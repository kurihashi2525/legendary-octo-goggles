<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【最終実装版】AI記者付きトーナメント表</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&family=Noto+Serif+JP:wght@700&display=swap" rel="stylesheet">
 <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Yuji+Syuku&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
/* styleタグ内の分かりやすい場所に追加 */

/* ▼▼▼ 勢力図分析アニメーション用のCSS（レイアウト修正版）▼▼▼ */
#analysis-stage {
    background: radial-gradient(ellipse at center, rgba(15, 23, 42, 1) 0%, rgba(0, 0, 0, 1) 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    padding: 2rem; /* 内側に余白を追加 */
}
.round-column {
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    height: 100%;
}
.analysis-matchup {
    margin: 10px 0;
    position: relative;
}
.analysis-team {
    padding: 4px 10px;
    background-color: rgba(0, 183, 255, 0.2);
    border: 1px solid rgba(0, 183, 255, 0.7);
    color: #e0f2fe;
    border-radius: 4px;
    font-weight: bold;
    font-size: 0.9rem;
    margin: 4px 0;
    transition: all 0.5s ease-in-out;
    opacity: 0;
    width: 150px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    /* ▼▼▼ 以下の2行を削除、またはコメントアウト ▼▼▼ */
    /* position: absolute; */
    /* ▲▲▲ */
}
.analysis-team.show {
    opacity: 1;
}
.analysis-team.highlight {
    background-color: rgba(255, 204, 0, 0.4);
    border-color: rgba(255, 204, 0, 1);
    color: white;
    transform: scale(1.1);
    box-shadow: 0 0 15px rgba(255, 204, 0, 0.7);
}

/* 勝ち上がり線のスタイル */
.matchup-connector {
    position: absolute;
    top: 50%;
    right: -20px;
    width: 20px;
    height: 2px;
    background-color: rgba(0, 183, 255, 0.5);
}
.round-connector {
    position: absolute;
    top: 25%;
    right: -30px;
    width: 2px;
    height: 50%;
    background-color: rgba(0, 183, 255, 0.5);
}
/* ▲▲▲ ここまで ▲▲▲ */

/* まとめサイトのロゴスタイル */
.matome-site-logo-container {
    position: relative;
    width: 80px; /* ロゴの幅 */
    height: 50px; /* ロゴの高さ */
    overflow: hidden;
    border-radius: 5px; /* 角を少し丸める */
    box-shadow: 0 2px 4px rgba(0,0,0,0.3); /* 影で立体感を出す */
}

.matome-site-logo-bg {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 画像をコンテナに合わせて表示 */
    position: absolute;
    top: 0;
    left: 0;
    filter: brightness(0.7) blur(1px); /* 少し暗く、ぼかして文字を読みやすく */
}

.matome-site-logo-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-weight: bold;
    font-size: 0.9rem; /* 文字サイズ調整 */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8); /* 文字の視認性を高める影 */
    white-space: nowrap; /* テキストの折り返しを防ぐ */
}

/* 新しいまとめサイトモーダルのためのスタイル */
/* スクロールバーのカスタマイズ (TailwindCSS JIT mode with plugins is better, but this is a quick fix) */
.scrollbar-thin {
    scrollbar-width: thin;
    scrollbar-color: #a0aec0 #edf2f7; /* thumb color track color */
}

.scrollbar-thin::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.scrollbar-thin::-webkit-scrollbar-thumb {
    background-color: #a0aec0; /* gray-400 */
    border-radius: 10px;
    border: 2px solid #edf2f7; /* gray-200 */
}

.scrollbar-thin::-webkit-scrollbar-track {
    background-color: #edf2f7; /* gray-200 */
    border-radius: 10px;
}

/* ヘッダーのロゴ画像とタイトルを縦方向に中央揃え */
#integrated-matome-modal .flex.justify-between.items-center img {
    vertical-align: middle;
}

/* タブボタンのアニメーション */
.matome-tab-btn {
    position: relative;
    z-index: 1;
    margin-right: -1px; /* タブ間の隙間をなくす */
    border: 1px solid #e2e8f0; /* gray-300 */
    border-bottom: none;
    background-color: #f7fafc; /* gray-50 */
}
.matome-tab-btn.active {
    background-color: #2563eb; /* blue-600 */
    color: white;
    border-color: #2563eb; /* active tab border color */
    border-bottom-color: transparent;
    z-index: 2;
}

/* 記事リンクのホバーエフェクト */
.matome-article-link p.font-bold:hover {
    color: #2563eb; /* blue-600 */
    text-decoration: underline;
}

/* BBSコメントのスタイル */
.bbs-comment {
    background-color: #ffffff;
    border: 1px solid #e2e8f0;
    padding: 1rem;
    border-radius: 0.5rem;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
}
.bbs-comment p.font-semibold {
    color: #4a5568; /* gray-700 */
    font-size: 0.875rem; /* text-sm */
    margin-bottom: 0.25rem;
}
.bbs-comment p.text-gray-800 {
    color: #2d3748; /* gray-800 */
    line-height: 1.5;
}

/* ▼▼▼ 新しいローダー用のCSS ▼▼▼ */
.loader {
    text-align: center;
    padding: 40px 20px;
    font-style: italic;
    color: #4b5563; /* gray-600 */
    font-size: 1.1rem;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 8px;
    margin: 1rem 0;
}

.loader .ellipsis span {
    opacity: 0;
    animation: pulse-ellipsis 1.4s infinite;
}
.loader .ellipsis span:nth-child(1) { animation-delay: 0s; }
.loader .ellipsis span:nth-child(2) { animation-delay: 0.2s; }
.loader .ellipsis span:nth-child(3) { animation-delay: 0.4s; }

@keyframes pulse-ellipsis {
    0% { opacity: 0.2; }
    50% { opacity: 1; }
    100% { opacity: 0.2; }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ 禍々しい雰囲気用のCSS ▼▼▼ */
.dread-mode-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(127, 29, 29, 0.5); /* 不気味な赤色のオーバーレイ */
    z-index: 199; /* 抽選会モーダルのすぐ下 */
    pointer-events: none;
    animation: fadeIn 0.5s forwards;
}

#lottery-pot.dread {
    background-color: #7f1d1d; /* red-900 */
    border-color: #fca5a5; /* red-300 */
    animation: pulse-dread 1s infinite;
}

@keyframes pulse-dread {
    0%, 100% {
        transform: scale(1.05);
        box-shadow: 0 0 15px 5px rgba(255, 100, 100, 0.7);
    }
    50% {
        transform: scale(1.1);
        box-shadow: 0 0 30px 15px rgba(255, 100, 100, 0.9);
    }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ 抽選会イベント用のCSS ▼▼▼ */
#drawn-team-container.fade-in-out {
    animation: fadeInOut 2.5s ease-in-out forwards;
}

@keyframes fadeInOut {
    0% { opacity: 0; transform: scale(0.8); }
    20%, 80% { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(0.8); }
}

.lottery-slot {
    border: 1px solid #d1d5db;
    background-color: #f3f4f6;
    padding: 4px 8px;
    font-size: 14px;
    font-weight: 500;
    border-radius: 4px;
    transition: all 0.3s ease-in-out;
}
.lottery-slot.filled {
    background-color: #fffbeb; /* amber-100 */
    border-color: #f59e0b; /* amber-500 */
    font-weight: 700;
    transform: scale(1.05);
}
.lottery-slot.highlight {
    background-color: #ef4444; /* red-500 */
    color: white;
    border-color: #b91c1c; /* red-700 */
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}
.animate-fade-in-up {
    animation: fadeInUp 0.5s ease-out forwards;
}
@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* Weather Effects */
.rain {
    position: absolute;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
}
.drop {
    position: absolute;
    bottom: 100%;
    width: 1px;
    height: 50px;
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.4));
    animation: drop 0.5s linear infinite;
}
@keyframes drop {
    to { transform: translateY(100vh); }
}

.sunshine {
    position: absolute;
    top: -50px;
    left: -50px;
    width: 100px;
    height: 100px;
    z-index: 2;
}
.sun {
    position: absolute;
    width: 100px;
    height: 100px;
    background: radial-gradient(circle, rgba(255,255,220,0.8) 0%, rgba(255,255,220,0) 60%);
    border-radius: 50%;
}
.sun-flare {
    position: absolute;
    width: 200px;
    height: 200px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    animation: flare 5s infinite;
}
@keyframes flare {
    0% { transform: scale(1); opacity: 0.1; }
    50% { transform: scale(1.2); opacity: 0.2; }
    100% { transform: scale(1); opacity: 0.1; }
}

/* Weather Control Buttons */
.weather-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.5);
    background-color: rgba(255, 255, 255, 0.2);
    font-size: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
}
.weather-btn:hover {
    background-color: rgba(255, 255, 255, 0.4);
    border-color: white;
}

/* ▼▼▼ このブロックを追加 ▼▼▼ */
        .subtitle-text {
            color: white;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
        }
        .setup-header {
            color: white !important; /* Tailwind CSSより優先させる */
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            border-bottom-color: rgba(255, 255, 255, 0.5) !important; /* 下線も白っぽくする */
        }
        /* ▲▲▲ ▲▲▲ */

/* ▼▼▼ このブロックを追加 ▼▼▼ */
     .main-title {
            font-family: 'Yuji Syuku', serif;
            font-size: 3rem; /* 少し大きくして迫力を出す */
            letter-spacing: 0.2em; /* 文字間を調整 */
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7);
            animation: fadeIn 2s ease-in-out; /* フェードインアニメーション */
        }

        .subtitle-text {
            color: white;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            animation: fadeIn 2.2s ease-in-out; /* アニメーションを追加 */
        }

        /* メインコンテンツエリアをガラスパネル風に */
        .setup-card {
            background-color: rgba(10, 10, 20, 0.65) !important; /* 半透明背景を優先 */
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px); /* 背景をぼかす（対応ブラウザのみ） */
            padding: 2.5rem !important; /* paddingを調整 */
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            animation: fadeIn 1.5s ease-in-out;
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .setup-header {
            color: white !important;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            border-bottom-color: rgba(255, 255, 255, 0.5) !important;
        }

        /* チーム一覧エリアを名簿風に */
        #teams-list {
            background-color: rgba(0, 0, 0, 0.2) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            color: #f0f0f0 !important;
            font-size: 0.9rem;
            line-height: 1.6;
            padding: 1.5rem !important;
        }

        /* ボタンエリアにアニメーションを追加 */
        #setup .mt-8 {
            animation: fadeIn 2.5s ease-in-out;
        }

        /* フェードイン用アニメーションの定義 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ このブロックを追加 ▼▼▼ */
#news-ticker-container {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    display: flex;
    align-items: center;
    z-index: 50; /* 他の要素より手前に */
    height: 30px;
    font-family: 'Noto Sans JP', sans-serif;
    border-top: 1px solid rgba(255, 255, 255, 0.3);
}
.ticker-label {
    background-color: #e53935; /* 赤色 */
    font-weight: bold;
    padding: 0 12px;
    height: 100%;
    display: flex;
    align-items: center;
    font-size: 0.9rem;
}
.ticker-content {
    flex-grow: 1;
    overflow: hidden; /* はみ出したテキストを隠す */
    padding-left: 1rem;
}
#ticker-text {
    white-space: nowrap; /* テキストを改行させない */
    /* アニメーション時間を少し長めに設定してゆっくり流す */
    animation: scroll-ticker 40s linear infinite;
}
@keyframes scroll-ticker {
    0% { transform: translateX(100%); }
    100% { transform: translateX(-100%); }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* 写実的な天候アニメーション用のスタイル */
   /* 写実的な天候アニメーション用のスタイル（★調査モード★） */
/* 背景画像 */
.ballpark-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* Layer 1 (Bottom) */
    /* ▼▼▼ This line is the only change ▼▼▼ */
    background-image: url('ballpark.jpg'); /* Use the local image */
    /* ▲▲▲ END OF CHANGE ▲▲▲ */
    background-size: cover;
    background-position: center;
    filter: blur(2px) brightness(0.7);
    animation: subtle-breathing 20s ease-in-out infinite;
}
/* 土埃のアニメーション用コンテナ */
#dust-container {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; /* クリックの邪魔をしない */
    z-index: 2; /* 階層2（中間） */
}
/* メインコンテンツのコンテナ */
#app-container {
    position: relative; /* z-indexを有効にするため */
    z-index: 3; /* 階層3（一番手前） */
}
@keyframes subtle-breathing {
    0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); }
}
.dust-particle {
    position: absolute; background-color: rgba(255, 255, 255, 0.5);
    border-radius: 50%; opacity: 0; animation: drift-up linear infinite;
}
@keyframes drift-up {
    0% { transform: translateY(100vh) translateX(var(--x-start)); opacity: 0; }
    10% { opacity: 1; } 90% { opacity: 1; }
    100% { transform: translateY(-100px) translateX(var(--x-end)); opacity: 0; }
}
/* Input field color-coding */
.result-hit { background-color: #eff6ff !important; color: #1d4ed8; } /* Blue for hits */
.result-out { background-color: #fee2e2 !important; color: #b91c1c; } /* Red for outs */
.result-on-base { background-color: #f0fdf4 !important; color: #15803d; } /* Green for walks, etc. */

.clickable-team-name {
    cursor: pointer;
    transition: color 0.2s;
}
.clickable-team-name:hover {
    color: #1d4ed8; /* blue-700 */
}
        body { 
    font-family: 'Inter', 'Noto Sans JP', sans-serif; 
}
.setup-card { 
    background-color: transparent; /* 背景を透明に */
    padding: 24px; 
    border-radius: 12px; 
    box-shadow: none; /* 影を削除 */
    margin-bottom: 24px;
}
.display-card {
    background-color: #fff; padding: 24px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); margin-bottom: 24px;
}
        #main-bracket-container { display: flex; justify-content: center; padding: 20px; font-size: 12px; overflow-x: auto; border: 1px solid #e5e7eb; background-color: #f9fafb; border-radius: 8px;}
        .bracket-half { display: flex; }
        .bracket-half.right { flex-direction: row-reverse; }
        .bracket-final { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0 10px; flex-shrink: 0; min-width: 60px; }
        .bracket-final .final-matchup { border: 2px solid #f59e0b; background-color: #fffbeb; border-radius: 6px; padding: 5px; margin-top: 10px; }
        .bracket-final .winner-box { font-weight: bold; color: #b45309; text-align: center; padding: 10px 20px; white-space: nowrap; font-size: 1.25rem; }
        .bracket-final .final-title { font-weight: 600; color: #4b5563; margin-bottom: 10px; writing-mode: vertical-rl; letter-spacing: 2px; }
        .round { display: flex; flex-direction: column; justify-content: space-around; flex-shrink: 0; width: 230px; padding: 0 10px; }
        .matchup { margin: 8px 0; position: relative; display: flex; flex-direction: column; justify-content: center; flex-grow: 1; }
        .team-slot { display: flex; align-items: center; background-color: #ffffff; border: 1px solid #e5e7eb; border-radius: 4px; margin-bottom: 4px; transition: background-color 0.3s; position: relative; }
        .team-slot:last-of-type { margin-bottom: 0; }
        .team-name { flex-grow: 1; padding: 6px 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .team-name .rank { font-weight: bold; margin-right: 4px; }
        .team-name .rank-A { color: #ef4444; }
        .team-name .rank-B { color: #f97316; }
        .team-name .rank-C { color: #eab308; }
        .team-name .rank-D { color: #3b82f6; }
        .team-name .rank-E { color: #6b7280; }
        .team-name.seed { font-weight: bold; color: #ca8a04; }
        .score-input { width: 40px; padding: 6px 4px; border-left: 1px solid #e5e7eb; text-align: center; background-color: #fff; }
        .win-btn { background-color: #d1d5db; color: #fff; border: none; padding: 6px 8px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; cursor: pointer; font-weight: bold; transition: background-color 0.2s; }
        .team-slot:not(.empty) .win-btn { background-color: #3b82f6; }
        .team-slot:not(.empty):hover .win-btn { background-color: #2563eb; }
        .team-slot.winner { background-color: #dbeafe; border-color: #93c5fd; font-weight: 600; }
        .team-slot.loser { background-color: #f3f4f6; opacity: 0.6; }
        .team-slot.empty .team-name { color: #9ca3af; }
        .team-slot.empty .score-input, .team-slot.empty .win-btn, .team-slot.empty .details-btn { display: none; }
        .matchup::after { content: ''; position: absolute; top: 50%; width: 10px; height: 2px; background-color: #cbd5e1; }
        .bracket-half.left .matchup::after { right: -10px; }
        .bracket-half.right .matchup::after { left: -10px; }
        .round.subsequent-round .matchup::before { content: ''; position: absolute; top: -8px; height: calc(100% + 16px); width: 2px; background-color: #cbd5e1; }
        .bracket-half.left .round.subsequent-round .matchup::before { right: -10px; }
        .bracket-half.right .round.subsequent-round .matchup::before { left: -10px; }
        .hidden { display: none; }
        .news-article { border-left: 4px solid #3b82f6; cursor: pointer; transition: background-color 0.2s; }
        #modal-bg { background-color: rgba(0,0,0,0.5); }
        .confirm-modal, .details-modal, .save-load-modal, .newspaper-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .confirm-modal-content, .details-modal-content, .save-load-modal-content, .newspaper-modal-content { background-color: white; padding: 24px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .details-modal-content { width: 95%; max-width: 1000px; max-height: 90vh; overflow-y: auto;}
        .save-load-modal-content { width: 95%; max-width: 500px; }
        .newspaper-modal-content { width: 95%; max-width: 800px; max-height: 95vh; overflow-y: auto; }
        .confirm-modal-content { text-align: center; }
        .loader { text-align: center; padding: 20px; font-style: italic; color: #6b7280; }
        .details-btn { background-color: #6b7280; color: white; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: auto; margin-right: 2px; }
        .details-btn:hover { background-color: #4b5563; }
        .matchup-footer { text-align: center; margin-top: 2px; display: flex; justify-content: center; align-items: center; gap: 4px;}
        .stats-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .stats-table th, .stats-table td { border: 1px solid #e5e7eb; padding: 4px 6px; text-align: center; }
        .stats-table th { background-color: #f3f4f6; }
        .stats-table input { width: 100%; border: none; text-align: center; background: transparent;}
        .stats-table input:focus { outline: 1px solid #3b82f6; }
        .modal-body-scroll { max-height: 70vh; overflow-y: auto; }
        #save-code-output { word-break: break-all; background-color: #f3f4f6; padding: 8px; border-radius: 4px; max-height: 200px; overflow-y: auto; user-select: all; }
        .bbs-comment { background-color: #ffffff; border: 1px solid #e5e7eb; padding: 8px 12px; border-radius: 8px; font-size: 14px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .match-summary-input { resize: none; height: 40px; }
        .article-error { background-color: #fee2e2; border-left: 4px solid #ef4444; color: #b91c1c; padding: 1rem; border-radius: 0.5rem; display: flex; justify-content: space-between; align-items: center; }
        .retry-btn { background-color: #ef4444; color: white; padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-weight: 600; cursor: pointer; }
        .retry-btn:hover { background-color: #dc2626; }
        .namco-news-item { cursor: pointer; transition: background-color 0.2s; }
        .namco-news-tag { background-color: #f97316; color: white; font-size: 0.75rem; padding: 2px 8px; border-radius: 9999px; margin-left: 8px; }
      
.region-map-scroll-container {
    display: flex;
    overflow-x: auto;
    padding-bottom: 16px; /* Space for the scrollbar */
    gap: 16px;
}
.region-column { 
    flex: 0 0 250px; /* Prevent cards from shrinking */
    background-color: #ffffff; 
    border: 1px solid #e5e7eb; 
    border-radius: 8px; 
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
}
.region-header { 
    padding: 12px 16px; 
    background-color: #f9fafb; 
    border-bottom: 1px solid #e5e7eb; 
}
.region-title { 
    font-weight: 700; 
    font-size: 1.1rem; 
    color: #1f2937; 
}
.region-stats { 
    font-size: 0.8rem; 
    color: #4b5563; 
    font-weight: 500;
}
.region-team-list { 
    list-style: none; 
    padding: 12px 16px; 
    margin: 0;
    flex-grow: 1; /* Allow list to fill space */
}
.region-team { 
    padding: 6px 0; 
    font-size: 0.9rem;
    border-bottom: 1px solid #f3f4f6;
}
.region-team:last-child {
    border-bottom: none;
}
.team-surviving { 
    font-weight: 500; 
    color: #1f2937; 
}
.team-eliminated { 
    color: #9ca3af; 
    text-decoration: line-through; 
}
         .scorebook-font {
            font-family: 'Yuji Syuku', serif;
        }
        .newspaper-container { font-family: 'Noto Serif JP', serif; padding: 2rem; background-color: #fdfdf8; }
        .newspaper-early { filter: grayscale(100%); border: 2px solid #333; }
        .newspaper-late { border: 2px solid #a10e25; }
        .newspaper-header { text-align: center; border-bottom: 4px double #333; padding-bottom: 0.5rem; margin-bottom: 1rem; }
        .newspaper-title { font-size: 1.2rem; font-weight: 700; }
        .newspaper-date { font-size: 0.8rem; }
        .newspaper-content { display: flex; gap: 1.5rem; }
        .newspaper-main-headline { writing-mode: vertical-rl; text-orientation: mixed; font-size: 2.5rem; font-weight: 700; letter-spacing: 0.2em; border-right: 2px solid #333; padding-right: 1rem; margin-right: 1rem; }
        .newspaper-late .newspaper-main-headline { color: #a10e25; border-right-color: #a10e25;}
        .newspaper-body-content { flex-grow: 1; }
        .newspaper-sub-headline { font-size: 1.5rem; font-weight: 700; margin-bottom: 1rem; border-bottom: 1px solid #666; padding-bottom: 0.5rem; }
        .newspaper-late .newspaper-sub-headline { color: #333; }
        .newspaper-text { font-family: 'Noto Sans JP', sans-serif; column-count: 3; column-gap: 1.5rem; text-align: justify; font-size: 0.9rem; line-height: 1.8; }
        .newspaper-early .newspaper-text { column-count: 2; }
        .newspaper-score-box { border: 2px solid #333; padding: 1rem; text-align: center; margin-top: 1rem; }
        .newspaper-score-box h3 { font-weight: 700; margin-bottom: 0.5rem; font-size: 1.1rem; }
        .newspaper-score-box .score { font-size: 2rem; font-weight: 700; }
        .newspaper-late .newspaper-score-box { background-color: #fff8f8; border-color: #a10e25; }
        .newspaper-image-placeholder { width: 100%; height: 200px; background-color: #e0e0e0; margin: 1rem 0; display: flex; align-items: center; justify-content: center; font-family: 'Noto Sans JP', sans-serif; color: #888; border: 1px dashed #aaa; }
        .rivalry-match .team-slot { border: 2px solid #ef4444 !important; background-color: #fff1f2; }
        .feud-match .team-slot { border: 2px solid #8b5cf6 !important; background-color: #f5f3ff; }
        .rivalry-match .team-slot.winner { background-color: #fecaca; }
        .feud-match .team-slot.winner { background-color: #ddd6fe; }
    
/* 詳細入力テーブル用のスタイル */
/* 詳細入力テーブル用のスタイル（最終版） */
.details-table { 
    border-collapse: collapse; 
    font-size: 12px; 
    
}
/* ▼▼▼ この新しいルールを追加 ▼▼▼ */
.details-table th {
    white-space: nowrap; /* ヘッダーの文字が折り返さないようにする */
}
/* ▲▲▲ ▲▲▲ */
.details-table td { 
    border: 1px solid #e5e7eb; 
    padding: 4px; 
    text-align: center; 
    vertical-align: middle; 
}
.details-table th { background-color: #f9fafb; font-weight: 600; }
.details-table input, .details-table select { width: 100%; border: none; text-align: center; background: transparent; font-size: 12px; }
.details-table input:focus, .details-table select:focus { outline: 1px solid #3b82f6; }

/* ★列幅設定★ */
/* イニングスコアテーブル */
#inning-score-table { table-layout: auto; width: auto; } /* スコアボードは自動幅 */
#inning-score-table .col-team { min-width: 120px; text-align: left; padding-left: 8px; }
#inning-score-table .col-inning-score { width: 40px; }
#inning-score-table .col-total { width: 50px; }
#inning-score-table .col-add-inning { width: 40px; }

/* 打撃成績テーブル */
/* ★列幅設定（min-widthで最低幅を保証）★ */
.batting-table .col-order { min-width: 40px; }
.batting-table .col-number { min-width: 60px; }
.batting-table .col-player { min-width: 120px; }
.batting-table .col-pos { min-width: 100px; }
.batting-table .col-sub-type { min-width: 80px; }
.batting-table .col-inning { min-width: 300px; }  /* ←お好みの幅に調整してください */
/* ▲▲▲ ▲▲▲ */
        .add-row-btn { background-color: #e5e7eb; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-top: 4px; }

        .add-row-btn:hover { background-color: #d1d5db; }　



　 </style>
</head>
<body class="p-4 md:p-8">
     <audio id="lottery-bgm" src="./bgm.mp3" loop preload="auto"></audio>
    <div class="ballpark-background"></div>
    <div id="dust-container"></div>
 <div id="rain-container" class="rain hidden"></div>
    <div id="sun-container" class="sunshine hidden">
        <div class="sun"></div>
        <div class="sun-flare"></div>
    </div>
    <div id="app-container" class="max-w-full mx-auto">
/div>

<div id="news-ticker-container">
    <div class="ticker-label">NEWS</div>
    <div class="ticker-content">
        <p id="ticker-text"></p>
    </div>
</div>

    <div id="weather-controls" class="fixed bottom-4 right-4 z-10">
        <div class="flex gap-2 p-2 bg-black bg-opacity-20 rounded-lg">
            <button id="unmute-btn" class="weather-btn">🔇</button>
            <button class="weather-btn" data-weather="sun">☀️</button>
            <button class="weather-btn" data-weather="rain">🌧️</button>
            <button class="weather-btn" data-weather="none">💨</button>
        </div>
    </div>
        
<div id="settings-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[200]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 class="text-xl font-bold">設定</h3>
            <button id="settings-modal-close-btn" class="text-gray-400 hover:text-gray-600">&times;</button>
        </div>
        <div class="space-y-4">
            <div class="flex items-center justify-between">
                <span class="font-semibold">試合記事の自動生成</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-article-generation" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
            </div>
            <div class="flex items-center justify-between">
                <span class="font-semibold">掲示板の自動生成</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-bbs-generation" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
            </div>
        </div>
    </div>
</div>



        <div class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white main-title">AI記者付きトーナメント表</h1>
            <p id="tournament-year-display" class="mt-2 subtitle-text">（最終実装版）</p>
        </div>

        <div id="setup" class="setup-card">
             <div class="w-full">
                 <h2 class="text-xl font-semibold mb-4 border-b pb-2 setup-header">参加チーム (64チーム)</h2>
                 <textarea id="teams-list" class="w-full h-96 p-3 border border-gray-300 rounded-lg" readonly></textarea>
             </div>
             <div class="mt-8 text-center">
                 <button id="resume-btn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-green-700 shadow-md mb-4 w-full md:w-auto">
                   再開（合い言葉入力）
                 </button>
                 <button id="generate-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 shadow-md w-full md:w-auto">
                     新しいトーナメントを開始
                 </button>
　　　　　　　　<button id="help-btn" class="bg-gray-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-gray-600 shadow-md mt-4 w-full md:w-auto">
    遊び方
</button>
 <button id="show-matome-site-btn" class="bg-orange-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-orange-600 shadow-md mt-4 w-full md:w-auto">
    📰 まとめサイトを見る
    </button>            
 </div>
        </div>




        <div id="tournament-display" class="hidden">
            <div id="autumn-regional-blocks-container" class="display-card hidden"></div>
            <div id="autumn-ranking-playoffs-container" class="display-card hidden"></div>
            <button id="skip-autumn-blocks-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 shadow-md hidden">地区ブロック予選をスキップ</button>
<button id="skip-autumn-ranking-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 shadow-md hidden">地区順位決定戦をスキップ</button>
<button id="skip-autumn-main-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 shadow-md hidden">県大会本戦をスキップ</button>
<button id="skip-spring-qualifiers-btn" class="bg-teal-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-600 shadow-md hidden">春季地区予選をスキップ</button>
<button id="skip-spring-round1-btn" class="bg-teal-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-600 shadow-md hidden">春季県大会1回戦をスキップ</button>
<button id="skip-spring-main-btn" class="bg-teal-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-600 shadow-md hidden">春季県大会2回戦以降をスキップ</button>


            <div id="autumn-controls" class="text-center my-4 hidden">
                <button id="start-ranking-playoffs-btn" class="bg-purple-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-purple-700 shadow-md hidden">
                    地区内順位決定戦へ進む
                </button>
                <button id="start-main-tournament-btn" class="bg-teal-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-teal-700 shadow-md hidden">
                    県大会本戦へ進む
                </button>

            </div>

            

<div id="region-map-section" class="display-card hidden scorebook-font">
                 <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">地区別 勝ち残り状況</h2>
                 <div id="region-map-container" class="w-full"></div>
            </div>
             <div id="namco-news-section" class="hidden display-card border-2 border-orange-400">
                 <h2 class="text-xl font-bold text-orange-600 mb-3 text-center">ナムコグループからのお知らせ</h2>
                 <div id="namco-news-content" class="space-y-2"></div>
             </div>
            <div class="flex justify-between items-start mb-4">
                <div>
                    <button id="generate-summary-btn" class="hidden bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 shadow-md">
                        ここまでの大会ハイライト記事を生成
                    </button>
                    <button id="next-tournament-btn" class="hidden bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 shadow-md">
                        次の大会へ進む
                    </button>
                </div>
               <div class="ml-auto">
                    <div class="flex items-center justify-end space-x-2">
                        <button id="skip-r1-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">1回戦スキップ</button>
                        <button id="skip-r2-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">2回戦スキップ</button>
                        <button id="skip-r3-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">3回戦スキップ</button>
<button id="skip-r4-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">準々決勝スキップ</button>
<button id="skip-r5-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">準決勝スキップ</button>
<button id="skip-final-btn" class="hidden bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 shadow-md">決勝スキップ</button>

                        <span id="save-feedback" class="text-gray-600 font-bold opacity-0 transition-opacity duration-500"></span>
<button id="show-matome-site-btn" class="bg-orange-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-600 shadow-md">
    📰 まとめ
    </button>
                        

   <button id="open-settings-btn" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 shadow-md">⚙️ 設定</button>
<button id="save-btn" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-700 shadow-md">セーブ</button>
                        <button id="reset-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 shadow-md">リセット</button>
                    </div>
                    <div id="skip-loader-container" class="h-6 text-right mt-1">
                         <span id="skip-loader" class="hidden text-sm text-gray-600 font-bold">試合を進行しています...</span>
                    </div>
                </div>
            </div>
            <div id="main-bracket-wrapper" class="display-card scorebook-font">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">トーナメント表</h2>
                <div class="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4 rounded-md text-sm">
                    <p><b>PCでの表示について:</b> トーナメント表の全体が表示されない場合は、表のエリア内でマウスのホイールを回しながら <b>Shiftキー</b> を押すか、表の下に表示されるスクロールバーを直接ドラッグすることで、左右にスクロールできます。</p>
                </div>
                <div id="main-bracket-container"></div>
            </div>
            <div id="news-section" class="display-card">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">注目ニュース</h2>
                <div id="news-articles" class="space-y-4">
                    <p class="text-gray-500 text-center">まだニュースはありません。</p>
                </div>
            </div>
             <div id="daiya-bbs-section" class="hidden display-card border-4 border-green-600">
                 <h2 id="daiya-bbs-title" class="text-2xl font-bold text-green-800 mb-4 text-center">【特設】代矢東 応援掲示板</h2>
                 <div id="daiya-bbs-comments" class="space-y-3">
                     <p class="text-gray-500 text-center">まだ反応はありません。</p>
                 </div>
             </div>
             <div id="bbs-section" class="display-card">
                 <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">掲示板の反応</h2>
<div class="mb-4 p-4 border rounded-lg bg-white">
    <form id="main-comment-form">
        <textarea id="main-comment-textarea" class="w-full p-2 border rounded" rows="2" placeholder="コメントを書き込む... (例: 今日の姫川はレベチだったわ！)" required></textarea>
        <div class="text-right mt-2">
            <button type="submit" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">投稿する</button>
        </div>
    </form>
</div>
                 <div id="bbs-comments" class="space-y-3">
                     <p class="text-gray-500 text-center">まだ反応はありません。</p>
                 </div>
             </div>
        </div>
    </div>

    <div id="news-modal" class="fixed inset-0 z-50 hidden items-center justify-center">
        <div id="modal-bg" class="absolute inset-0"></div>
        <div class="relative bg-white rounded-lg shadow-xl max-w-2xl w-full m-4">
            <div class="p-6 modal-body-scroll">
                <h3 id="modal-title" class="text-2xl font-bold text-gray-900"></h3>
                <div id="modal-meta" class="text-gray-400 text-sm mt-2 flex items-center gap-4"></div>
                <p id="modal-body" class="mt-4 text-gray-600 whitespace-pre-wrap"></p>
            </div>
            <button id="modal-close" class="absolute top-3 right-3 text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    
  
<div id="integrated-matome-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 hidden items-center justify-center z-[200]">
    <div class="bg-gray-100 p-2 md:p-4 rounded-lg shadow-xl w-full max-w-7xl max-h-[95vh] flex flex-col overflow-hidden">
        
        <div class="flex justify-between items-center mb-2 px-2 md:px-0">
            <h2 class="text-2xl md:text-3xl font-extrabold text-red-700 font-sans tracking-wide">
                <img src="koshien.jpg" alt="なんJスタジアム" class="h-10 md:h-12 inline-block mr-2">
                俺たちの甲子園速報＠なんJまとめ
            </h2>
            <button id="matome-modal-close-btn" class="text-gray-400 hover:text-gray-600">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>

        <div class="flex border-b border-gray-300 bg-white shadow-sm mb-3 text-sm md:text-base sticky top-0 z-10">
            <button class="matome-tab-btn active bg-blue-600 text-white py-2 px-4 rounded-t hover:bg-blue-700 transition-colors" data-tab="top">トップ</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="blog">このブログについて</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="twitter">Twitter</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="antenna">なんJアンテナ</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="baseball-mag">BaseBall MAG</button>
            </div>

        <div id="matome-content-area" class="flex-grow overflow-y-auto bg-gray-50 p-2 md:p-4 rounded-b-lg scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200">
            
            <div id="matome-tab-top" class="matome-tab-content grid grid-cols-1 md:grid-cols-3 gap-4 active">
                
                <div class="md:col-span-2 space-y-4">
                    <div class="bg-white p-4 rounded-lg shadow-md">
                        <h3 class="text-lg font-bold text-gray-800 border-b pb-2 mb-3">🔥 本日の注目記事</h3>
                        <div id="matome-articles-container" class="space-y-2">
                            <div class="loader text-center py-8">記事を読み込んでいます...</div>
                        </div>
                    </div>

                    <div class="bg-white p-4 rounded-lg shadow-md">
                        <h3 class="text-lg font-bold text-gray-800 border-b pb-2 mb-3">✅ まとめ</h3>
                        <ul class="list-none space-y-1">
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">野球部員(14)「甲子園は興味ない」</a></li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">DeNA・ジャクソン、衝撃のスリーランホームランｗｗｗｗｗｗ</a></li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">【画像】「下着ディズニー」パスｗｗｗｗｗｗｗｗｗ</a></li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">【悲報】レンチンで簡単に旨いポテチ味付けられるライフハックがヤバイ</a></li>
                        </ul>
                    </div>
                </div>
                
                <div class="space-y-4">
                    <div class="bg-white p-2 rounded-lg shadow-md text-center">
                        <h3 class="text-md font-bold text-gray-800 border-b pb-1 mb-2">他社から乗り換えで</h3>
                        <img src="sumaho.jpg" alt="広告" class="w-full h-auto rounded">
                        <p class="text-sm text-gray-600 mt-1">人気スマホ<span class="text-xl font-bold text-red-600">500</span>円！</p>
                        <p class="text-xs text-gray-500">2025/8/31まで</p>
                    </div>

                    <div class="bg-white p-4 rounded-lg shadow-md">
                        <h3 class="text-lg font-bold text-gray-800 border-b pb-2 mb-3">💡 なんJアンテナ</h3>
                        <ul class="list-none space-y-1 text-sm">
                            <li><a href="#" class="text-gray-700 hover:text-blue-600">なんJ PRIDE: 巨人岡本和真(28) .300 40本 100打点</a></li>
                            <li><a href="#" class="text-gray-700 hover:text-blue-600">MLB NEWS: 大谷翔平、本日も二刀流で大活躍</a></li>
                            <li><a href="#" class="text-gray-700 hover:text-blue-600">まとめヒストリア: 昔のなんJスレを振り返る</a></li>
                        </ul>
                    </div>
                    
                </div>
            </div>

            <div id="matome-tab-blog" class="matome-tab-content hidden p-4 bg-white rounded-lg shadow-md">
                <h3 class="text-xl font-bold">このブログについて</h3>
                <p class="mt-2 text-gray-700">当ブログ「俺たちの甲子園速報＠なんJまとめ」は、架空の高校野球トーナメントと現実世界のなんJネタを融合させた、唯一無二のまとめサイトです。</p>
                <p class="mt-2 text-gray-700">野球に関する話題を中心に、時事ネタや芸能ニュース、学歴コンプレックスから派生する議論まで、なんJで話題になった様々なスレッドを独自の視点でまとめています。</p>
                <p class="mt-2 text-gray-700">管理人「甲子園の申し子」が、日夜巡回し、ホットな情報をお届けします。</p>
            </div>
            <div id="matome-tab-twitter" class="matome-tab-content hidden p-4 bg-white rounded-lg shadow-md">
                <h3 class="text-xl font-bold">Twitter</h3>
                <p class="mt-2 text-gray-700">@koshien_nanjのアカウントで、日々熱い実況をしています！</p>
                <div class="mt-4 bg-gray-100 p-3 rounded">
                    <p class="font-bold">なんJまとめ速報 @koshien_nanj</p>
                    <p class="text-sm mt-1">今日の試合も熱すぎる！○○高校、まさかの逆転サヨナラ勝ちｗｗｗ #高校野球 #甲子園 <span class="text-blue-500">#なんJ</span></p>
                    <p class="text-xs text-gray-500 mt-2">1時間前</p>
                </div>
                <div class="mt-4 bg-gray-100 p-3 rounded">
                    <p class="font-bold">なんJまとめ速報 @koshien_nanj</p>
                    <p class="text-sm mt-1">【悲報】ワイの応援してた高校、初戦敗退…今年はもう終わりや… <span class="text-blue-500">#甲子園の夏</span></p>
                    <p class="text-xs text-gray-500 mt-2">3時間前</p>
                </div>
            </div>
            <div id="bbs-thread-display-area" class="hidden p-4 bg-white rounded-lg shadow-md flex flex-col h-full">
                <div class="flex justify-between items-center border-b pb-3 mb-4">
                    <h3 id="bbs-thread-title" class="text-xl md:text-2xl font-bold text-gray-800"></h3>
                    <button id="bbs-thread-back-btn" class="bg-blue-500 text-white font-bold py-1 px-3 rounded hover:bg-blue-600 text-sm">
                        一覧に戻る
                    </button>
                </div>
                <div id="bbs-thread-content" class="overflow-y-auto space-y-4 flex-grow">
                    <div class="loader text-center py-8">スレッドを読み込んでいます...</div>
                </div>
                <div class="mt-4 p-3 bg-gray-50 rounded-lg border-t text-sm text-gray-600">
                    <p>コメントは、AIによる自動生成です。特定の意見や人物を意図するものではありません。</p>
                </div>
            </div>

        </div>
    </div>
</div>

  <div id="confirm-modal" class="confirm-modal hidden">
        <div class="confirm-modal-content">
            <p id="confirm-modal-text" class="mb-4 text-lg"></p>
            <button id="confirm-ok" class="bg-red-600 text-white px-6 py-2 rounded-lg mr-2">はい</button>
            <button id="confirm-cancel" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">いいえ</button>
        </div>
    </div>

    <div id="details-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="details-modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-6xl max-h-[90vh] flex flex-col">
            <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">試合詳細入力</h3>
            <div id="details-modal-body" class="overflow-y-auto space-y-6 flex-grow">
                </div>
            <div class="mt-6 text-center border-t pt-4">
                <button id="details-save" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">この内容で保存</button>
                <button id="details-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
            </div>
        </div>
    </div>
    
    <div id="save-load-modal" class="save-load-modal hidden">
        <div class="save-load-modal-content">
            <div class="flex border-b">
                <button id="save-tab-btn" class="px-4 py-2 font-semibold border-b-2 border-blue-500">セーブ (合い言葉の発行)</button>
                <button id="load-tab-btn" class="px-4 py-2 text-gray-500">ロード (合い言葉の入力)</button>
            </div>
            <div id="save-tab-content" class="py-4">
                <p class="text-sm mb-2">現在の進行状況を保存するための「合い言葉」を発行します。下のボタンを押してください。</p>
                <button id="generate-save-code-btn" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700">合い言葉を発行</button>
                <div id="save-code-area" class="hidden mt-4">
                    <p class="text-sm font-bold text-green-600">合い言葉が発行されました。以下をコピーして安全な場所に保管してください。</p>
                    <div class="flex items-center mt-2">
                        <div id="save-code-output" class="flex-grow text-xs"></div>
                        <button id="copy-save-code-btn" class="ml-2 bg-gray-200 px-3 py-1 rounded text-xs font-semibold hover:bg-gray-300">コピー</button>
                    </div>
                    <p id="copy-feedback" class="text-xs text-green-600 mt-1 h-4"></p>
                </div>
            </div>
            <div id="load-tab-content" class="py-4 hidden">
                <p class="text-sm mb-2">保存した「合い言葉」を以下に貼り付けてください。</p>
                <textarea id="load-code-input" placeholder="合い言葉をここに貼り付け" class="w-full h-32 p-2 border rounded mb-2"></textarea>
                <button id="load-from-code-btn" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">このデータで再開する</button>
            </div>
             <div class="mt-4 text-right">
                 <button id="save-load-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
             </div>
        </div>
    </div>

    <div id="newspaper-modal" class="newspaper-modal hidden">
        <div class="newspaper-modal-content">
            <div id="newspaper-modal-body"></div>
            <div class="mt-4 text-center">
                <button id="newspaper-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
            </div>
        </div>
    </div>


<div id="feedback-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-[150]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記者への追加指示</h3>
        <div class="space-y-4">
            <div>
                <label for="feedback-include" class="block text-sm font-medium text-gray-700">✅ この要素を必ず含めてください</label>
                <textarea id="feedback-include" rows="4" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="例：殊勲打を放った〇〇選手のコメントを中心に。&#10;例：敗れた△△高校のエースの涙にも触れてほしい。"></textarea>
            </div>
            <div>
                <label for="feedback-exclude" class="block text-sm font-medium text-gray-700">❌ この要素・展開は避けてください</label>
                <textarea id="feedback-exclude" rows="3" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="例：監督の采配ミスという論調はもういい。&#10;例：ありきたりな「全員野球」という言葉は使わないで。"></textarea>
            </div>
        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="feedback-submit-btn" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">この指示で再生成</button>
            <button id="feedback-cancel-btn" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="review-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記事の最終確認・編集</h3>
        <div class="overflow-y-auto space-y-4 flex-grow">
            <div>
                <label for="review-title" class="block text-sm font-medium text-gray-700">タイトル</label>
                <input type="text" id="review-title" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div>
                <label for="review-body" class="block text-sm font-medium text-gray-700">本文</label>
                <textarea id="review-body" rows="15" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 whitespace-pre-wrap"></textarea>
            </div>
        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="review-save-btn" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">この記事で確定</button>
            <button id="review-cancel-btn" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="lottery-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 hidden items-center justify-center z-[200] font-sans">
    <div id="lottery-content" class="bg-white rounded-lg shadow-2xl w-full max-w-6xl h-[95vh] flex flex-col p-6">
        <h2 class="text-4xl font-bold text-center mb-4 scorebook-font text-gray-800 tracking-widest">夏の高校野球 組み合わせ抽選会</h2>
        <div id="lottery-stage" class="flex-grow bg-gray-800 rounded p-4 flex gap-4 overflow-hidden relative border-4 border-gray-600">
            <div class="w-1/3 flex flex-col items-center justify-between bg-gray-200 rounded-lg shadow-inner p-4">
                <div id="lottery-pot-container" class="w-full flex flex-col items-center">
                    <p id="pot-name" class="text-2xl font-bold text-gray-700 mb-2">Aシード</p>
                    <div id="lottery-pot" class="w-48 h-48 bg-red-800 border-4 border-yellow-400 text-white flex items-center justify-center text-5xl font-bold shadow-lg rounded-full cursor-pointer transition-transform duration-200 hover:scale-105">
                        抽選
                    </div>
                </div>
                <div id="drawn-team-container" class="w-full h-32 border-4 border-dashed border-gray-400 rounded-lg flex items-center justify-center opacity-0 bg-white">
                    <p id="drawn-team" class="text-4xl font-bold text-gray-800"></p>
                </div>
            </div>
            <div id="lottery-bracket" class="w-2/3 grid grid-cols-2 gap-x-4 h-full overflow-y-auto p-2 bg-gray-100 rounded-lg shadow-inner">
                <div id="lottery-bracket-left" class="space-y-1"></div>
                <div id="lottery-bracket-right" class="space-y-1"></div>
            </div>
        </div>
        <div class="h-32 flex flex-col justify-between pt-4">
            <div id="lottery-commentary" class="h-20 text-center text-2xl font-semibold text-gray-800 bg-yellow-100 border-2 border-yellow-300 rounded p-2 flex items-center justify-center">
                <p>静岡大会 抽選会へようこそ。主将は抽選箱をクリックしてクジを引いてください。</p>
            </div>
            <div id="lottery-controls" class="text-center">
    <button id="start-lottery-btn" class="bg-blue-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-blue-700">抽選を開始</button>
    <button id="skip-lottery-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 ml-4">スキップ</button>
</div>
        </div>
    </div>
</div>

<div id="analysis-modal" class="fixed inset-0 bg-black bg-opacity-90 hidden flex flex-col items-center justify-center z-[250] p-4 font-sans">
    <div class="w-full max-w-6xl h-full flex flex-col">
        <div class="flex-shrink-0 flex justify-between items-center mb-4">
            <div id="analysis-block-tabs" class="flex space-x-1 p-1 bg-gray-800 rounded-lg">
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="A">Aブロック</button>
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="B">Bブロック</button>
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="C">Cブロック</button>
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="D">Dブロック</button>
            </div>
            <button id="analysis-modal-close-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
        </div>
        
        <div id="analysis-stage" class="flex-grow bg-gray-900 rounded-lg relative overflow-hidden">
            </div>

        <div id="analysis-narration-box" class="flex-shrink-0 h-28 mt-4 bg-gray-800 border-t-2 border-cyan-500 rounded-b-lg p-4 overflow-y-auto">
            <p id="analysis-narration-text" class="text-white text-lg leading-relaxed whitespace-pre-wrap"></p>
        </div>
    </div>
</div>

<div id="interview-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-[300]">
    <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full p-6 m-4 animate-fade-in-up">
        <h3 class="text-2xl font-bold text-gray-900 mb-4 border-b pb-2">抽選会後 主将インタビュー</h3>
        <div id="interview-content" class="space-y-4 max-h-[60vh] overflow-y-auto"></div>
        <div class="text-center mt-6">
            <button id="close-interview-btn" class="bg-blue-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-blue-700">大会を始める</button>
        </div>
    </div>
</div>

<div id="help-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記者付きトーナメント表 取扱説明書</h3>
        <div class="overflow-y-auto space-y-6 flex-grow pr-4 text-gray-700">
            
            <div>
                <h4 class="font-bold text-lg text-blue-700 mb-2">はじめに：このゲームの目的</h4>
                <p class="text-sm">
                    このシミュレーターの目的は、単にトーナメントを勝ち進めることだけではありません。あなたの采配や入力した試合内容によって、AIが自動でリアルな「ニュース記事」や「掲示板の反応」を生成します。あなただけの、唯一無二の高校野球の物語を創り上げ、その歴史の目撃者となることが、このゲームの醍醐味です。
                </p>
            </div>

            <div>
                <h4 class="font-bold text-lg text-blue-700 mb-2">基本的な遊び方</h4>
                <ol class="list-decimal list-inside space-y-2 text-sm">
                    <li><strong>トーナメント開始:</strong> 「新しいトーナメントを開始」でゲームを始めます。最初の大会は夏の県大会です。</li>
                    <li><strong>スコア入力:</strong> トーナメント表の試合カードに、半角数字で最終スコアを入力します。</li>
                    <li><strong>勝者決定:</strong> スコアを入力したら、勝った方のチームの青い「▶」ボタンを押します。</li>
                    <li><strong>AIコンテンツ生成:</strong> 勝者が決まると、AIが自動で「ニュース記事」と「掲示板の反応」を生成します。</li>
                    <li><strong>繰り返し:</strong> 全ての試合でこれを繰り返し、優勝チームを決定してください。「セーブ」ボタンでいつでも進行状況を「合い言葉」として保存できます。</li>
                </ol>
            </div>
            
            <div>
                <h4 class="font-bold text-lg text-orange-700 mb-2">一年間の流れと各大会のルール</h4>
                <p class="text-sm mb-3">
                    この世界では、夏の大会が終わると新チームによる秋季大会、そして春季大会へと時間が流れます。それぞれの大会には独自のルールと目的があります。
                </p>
                <div class="space-y-4">
                    <div class="p-4 border rounded-lg bg-gray-50">
                        <h5 class="font-semibold text-gray-800">夏の大会 (メインイベント)</h5>
                        <p class="text-sm text-gray-600">3年生にとって最後の大会。64校による一発勝負のトーナメントで、優勝校は夏の甲子園に出場したとみなされ、AIがその全国での戦績をシミュレートします。</p>
                    </div>

                    <div class="p-4 border rounded-lg bg-gray-50">
                        <h5 class="font-semibold text-gray-800">秋の大会 (新チームの始まりと、春への道)</h5>
                        <p class="text-sm text-gray-600 mb-3">1,2年生の新チームで挑む最初の公式戦。この大会の最終成績が、次の春季大会のシード権を決定します。</p>
                        <pre class="text-xs bg-white p-3 rounded-md border overflow-x-auto">
秋季大会の流れ (東部・中部・西部地区)
----------------------------------------------------------------
[各地区20チーム] → [4ブロックに分割 (各5チーム)] → [ブロック予選]
                                |
                                |
              +-----------------+-----------------+
              | (各ブロック優勝4チーム)           | (各ブロック準優勝4チーム)
              ↓                                 ↓
[上位校トーナメント (1位-4位決定)]     [敗者復活トーナメント (5位決定)]
              |                                 |
              +-----------------+-----------------+
                                |
                                ↓
                      [各地区代表5チームが県大会へ] → [計16チームによる県大会本戦]

伊豆地区 (4チーム)
-------------------
[予選なし] → [直接、県大会本戦へ (1チーム)]
                        </pre>
                    </div>

                    <div class="p-4 border rounded-lg bg-gray-50">
                        <h5 class="font-semibold text-gray-800">春の大会 (夏のシード権をかけた戦い)</h5>
                        <p class="text-sm text-gray-600 mb-3">夏の大会の前哨戦。この大会の結果が、夏の大会のシード校を決定します。</p>
                        <pre class="text-xs bg-white p-3 rounded-md border overflow-x-auto">
春季大会の流れ
----------------------------------------------------------------
[秋季大会ベスト8 (シード校)] → [県大会2回戦から登場]
                                               |
                                               +--> [ベスト16による本戦]
                                               |
[それ以外の全チーム] → [地区予選] → [予選突破16チーム] → [県大会1回戦]
                        </pre>
                    </div>
                </div>
            </div>

            <div>
                <h4 class="font-bold text-lg text-green-700 mb-2">【重要】詳細入力：あなただけの物語を創る</h4>
                <p class="text-sm mb-3">
                    このシミュレーターの真価は「詳細入力」にあります。スコアだけでなく、試合内容を細かく入力することで、AIが生成する物語の解像度が劇的に向上します。
                </p>
                <ul class="list-disc list-inside space-y-2 text-sm bg-green-50 p-4 rounded-lg">
                    <li><strong>イニングスコア:</strong> 試合展開をAIに教えます。「初回に大量得点した試合」と「9回に逆転した試合」では、生成される記事の物語が全く異なります。</li>
                    <li><strong>個人成績:</strong> その試合の「ヒーロー」をAIに教えます。ここで入力された選手が、記事やハイライトの中心人物となります。</li>
                    <li><strong>選手交代（出場）:</strong> ドロップダウンから「代打」「代走」「守備」を選ぶことで、監督の采配の意図をAIが理解します。</li>
                    <li><strong>この回の主な出来事:</strong> 打席結果には現れないプレー（例：盗塁、盗塁死）を入力します。「鈴木 盗塁、佐藤 盗塁死」のように入力してください。</li>
                    <li><strong>試合の決め手:</strong> トーナメント表のテキストエリアです。ここに「エース〇〇、気迫の150球完投勝利」のように入力すると、AIは他のどの情報よりもこれを**最優先**し、記事全体のテーマにします。</li>
                </ul>
            </div>
            
            <div>
                <h4 class="font-bold text-lg text-red-700 mb-2">トラブルシューティング</h4>
                <ul class="list-disc list-inside space-y-2 text-sm">
                    <li><strong>エラーでクラッシュする場合:</strong> ほとんどの原因は、ブラウザに保存されている古いセーブデータと、最新のコードの間に矛盾が生じていることです。コード内の`TEAM_DATA`を編集した後は、**必ず「リセット」ボタンで古いセーブデータを完全に消去してから**「新しいトーナメントを開始」してください。</li>
                    <li><strong>AIの記事がおかしい/事実と違う:</strong> AIに渡す情報が不足しているか、AIが稀に混乱している可能性があります。まずは「確認・編集」画面で手修正をお試しください。それでも改善しない場合は、詳細入力でより多くの情報（特に敗者チームの打撃成績など）を与えてみてください。</li>
                </ul>
            </div>

        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="help-modal-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
        </div>
    </div>
</div>

<div id="team-status-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 id="status-modal-team-name" class="text-2xl font-bold text-gray-800"></h3>
            <button id="status-modal-close" class="text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="space-y-4">
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">最高戦績</h4>
                <p id="status-modal-best" class="text-lg text-amber-600 font-bold"></p>
            </div>
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">直近の成績</h4>
                <div id="status-modal-history" class="space-y-1 text-gray-700"></div>
            </div>
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">称号</h4>
                <div id="status-modal-traits" class="flex flex-wrap gap-2"></div>
            </div>
            
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">監督</h4>
                <div id="status-modal-coach" class="text-gray-700"></div>
            </div>
            </div>
    </div>
</div>
<script type="module">

const BATTING_RESULTS = {
    hits: ['安', '二塁打', '三塁打', '本塁打'],
    outs: ['三振', 'ゴロ', '飛', '直', '併殺'],
    walks: ['四球', '死球'],
    sacrifices: ['犠打', '犠飛', '犠失'], // ← ここに追加
    other: ['野選', 'エラー']
};
const DIRECTIONS = ['投', '捕', '一', '二', '三', '遊', '左', '中', '右'];
const RBIS = ['1点', '2点', '3点', '4点'];

    // --- ライバル関係と称号の定義 ---
    const RIVALRIES = [
        { teams: ["代矢東", "雷門南"], type: "公立の覇権争い" },
        { teams: ["283学園", "稲城実業"], type: "私立の王者対決" },
        { teams: ["765総合高校", "代矢東"], type: "新旧王者対決" },
        { teams: ["青道", "稲城実業"], type: "西東京ライバル対決" }
    ];
    const TITLES = {
        GIANT_KILLER: { id: 'giant_killer', name: 'ジャイアントキラー', desc: '格上の強豪校を倒した実績を持つ。' },
        REPECHAGE_KING: { id: 'repechage_king', name: '不屈の敗者復活組', desc: '敗者復活戦から這い上がってきた実績があり、非常に粘り強い。' },
        WALL_OF_TOKYO: { id: 'wall_of_tokyo', name: '西東京の壁', desc: '西東京地区に立ちはだかる絶対的強者。' } // 例
    };
const tournamentNameMap = { summer: '夏季大会', autumn: '秋季大会', spring: '春季大会' };

// ▼▼▼ このブロックをまるごと置き換える ▼▼▼
const SCANDAL_DEFINITIONS = [
    {
        id: 'overpractice',
        condition: (teamName) => ['A', 'B'].includes(calculateRank(teamName, tournamentState)),
        
        // 文字列から関数に変更
        rumorTitle: (teamName) => `【週刊熱闘】${teamName}に「違法練習」疑惑か？`,
        rumorBody: (teamName) => `強豪として知られる${teamName}だが、その強さの裏には、高校野球連盟が定める練習時間規定を大幅に超過するほどの猛練習があるというタレコミが本誌に寄せられた。深夜までバットの音が鳴り響くという近隣住民の証言もあり、今後の動向が注目される。`,
        
        consequences: {
            report: {
                // こちらも同様に関数に変更
                outcomeTitle: (teamName) => `【速報】${teamName}、練習規定違反で公式戦を辞退`,
                outcomeBody: (teamName) => `先日、週刊誌で報じられた${teamName}の練習時間規定違反問題で、高野連は調査の結果、違反の事実を認定。同校は事態を重く受け止め、今大会の残り試合を辞退することを発表した。`,
                applyEffect: (teamName, state) => {
        if (state.teamRecords[teamName]) {
            state.teamRecords[teamName].penalty = 'forfeit';
        }

        const currentMatch = findCurrentMatchForTeam(teamName, state);
        if (!currentMatch) return; // 該当する試合がなければ何もしない

        const opponent = currentMatch.team1 === teamName ? currentMatch.team2 : currentMatch.team1;

        // 相手がいない場合（シードなど）は、単に負け扱いにする
        if (!opponent) {
            currentMatch.winner = `(不戦敗)`;
            currentMatch.team1 = teamName;
            currentMatch.team2 = null;
            return;
        }

        // 不戦勝として試合結果を記録
        currentMatch.winner = opponent;
        currentMatch.summary = `${teamName}の不祥事による不戦勝`;

        if (currentMatch.team1 === opponent) {
            currentMatch.score1 = 'W'; // Win
            currentMatch.score2 = 'L'; // Lose
        } else {
            currentMatch.score1 = 'L';
            currentMatch.score2 = 'W';
        }

        // チーム記録を更新
        if(state.teamRecords[opponent]) state.teamRecords[opponent].wins++;
        if(state.teamRecords[teamName]) state.teamRecords[teamName].losses++;
        
        // 勝者を次のラウンドへ自動で進める
        advanceWinnerToNextRound(currentMatch, opponent, state);
    }
            },
            ignore: {
                outcomeTitle: (teamName) => `${teamName}の練習問題、高野連は「事実確認できず」`,
                outcomeBody: (teamName) => `先日、一部週刊誌で報じられた${teamName}の練習時間に関する疑惑に対し、高野連は「現時点で違反の事実は確認できなかった」と発表。噂は噂のまま、球児たちの夏は続く。`,
                applyEffect: (teamName, state) => { /* 何もしない */ }
            }
        }
    }
];
// ▲▲▲ ここまで置き換え ▲▲▲
    // --- DOM Elements ---
    const setupEl = document.getElementById('setup');
    const tournamentDisplayEl = document.getElementById('tournament-display');
    const teamsTextarea = document.getElementById('teams-list');
    const generateBtn = document.getElementById('generate-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const resetBtn = document.getElementById('reset-btn');
    const nextTournamentBtn = document.getElementById('next-tournament-btn');
    const saveBtn = document.getElementById('save-btn');
    const mainBracketContainer = document.getElementById('main-bracket-container');
    const mainBracketWrapper = document.getElementById('main-bracket-wrapper');
    const newsContainer = document.getElementById('news-articles');
    const bbsCommentsContainer = document.getElementById('bbs-comments');
    const daiyaBbsSection = document.getElementById('daiya-bbs-section');
    const daiyaBbsCommentsContainer = document.getElementById('daiya-bbs-comments');
    const namcoNewsSection = document.getElementById('namco-news-section');
    const namcoNewsContent = document.getElementById('namco-news-content');
    const tournamentYearDisplay = document.getElementById('tournament-year-display');
    const generateSummaryBtn = document.getElementById('generate-summary-btn');
    const skipR1Btn = document.getElementById('skip-r1-btn');
    const skipR2Btn = document.getElementById('skip-r2-btn');
    const skipR3Btn = document.getElementById('skip-r3-btn');

    const skipLoader = document.getElementById('skip-loader');
const skipR4Btn = document.getElementById('skip-r4-btn');
const skipR5Btn = document.getElementById('skip-r5-btn');
const skipFinalBtn = document.getElementById('skip-final-btn');
    // Autumn Tournament UI
    const autumnRegionalContainer = document.getElementById('autumn-regional-blocks-container');
    const autumnRankingContainer = document.getElementById('autumn-ranking-playoffs-container');
    const autumnControls = document.getElementById('autumn-controls');
    const startRankingPlayoffsBtn = document.getElementById('start-ranking-playoffs-btn');
    const startMainTournamentBtn = document.getElementById('start-main-tournament-btn');
// ▼▼▼ ここから3行追加 ▼▼▼
const skipAutumnBlocksBtn = document.getElementById('skip-autumn-blocks-btn');
const skipAutumnRankingBtn = document.getElementById('skip-autumn-ranking-btn');
const skipAutumnMainBtn = document.getElementById('skip-autumn-main-btn');
// ▲▲▲ ここまで追加 ▲▲▲
// ▼▼▼ ここから3行追加 ▼▼▼
const skipSpringQualifiersBtn = document.getElementById('skip-spring-qualifiers-btn');
const skipSpringRound1Btn = document.getElementById('skip-spring-round1-btn');
const skipSpringMainBtn = document.getElementById('skip-spring-main-btn');
// ▲▲▲ ここまで追加 ▲▲▲
    // Modals
    const newsModal = document.getElementById('news-modal');
    const modalBg = document.getElementById('modal-bg');
    const modalClose = document.getElementById('modal-close');
    const confirmModal = document.getElementById('confirm-modal');
    const detailsModal = document.getElementById('details-modal');
    const saveLoadModal = document.getElementById('save-load-modal');
    const saveTabBtn = document.getElementById('save-tab-btn');
    const loadTabBtn = document.getElementById('load-tab-btn');
    const saveTabContent = document.getElementById('save-tab-content');
    const loadTabContent = document.getElementById('load-tab-content');
    const generateSaveCodeBtn = document.getElementById('generate-save-code-btn');
    const loadFromCodeBtn = document.getElementById('load-from-code-btn');
    const saveLoadCloseBtn = document.getElementById('save-load-close');
    const copySaveCodeBtn = document.getElementById('copy-save-code-btn');
    const newspaperModal = document.getElementById('newspaper-modal');
    const newspaperModalBody = document.getElementById('newspaper-modal-body');
    const newspaperCloseBtn = document.getElementById('newspaper-close');

    
    // --- State Management ---
    let tournamentState = {};
    let currentMatchIdForDetails = null;
    let articleForRegeneration = null; 
    let soundEffects = {};
let currentBlock = 'A';
    const UNDERDOG_TEAMS = ["虎府島総合", "浜松特支", "川根", "伊豆総合", "湖西", "小山", "新居", "熱海", "伊豆中央", "島田", "島田工業", "裾野"];
    const POWERHOUSE_TEAMS = ["283学園", "常葉菊川", "静岡", "掛川西", "静岡商業", "聖隷クリストファー", "765総合高校"];
　　const POWERHOUSE_REVIVAL_TEAMS = ["浜松商業", "静清", "飛龍"];
　　const ONE_MAN_TEAMS = ["富士宮北"];

// ▼▼▼ このオブジェクトで、既存のSoundManagerを完全に置き換えてください ▼▼▼
// ▼▼▼ サウンド管理システム ▼▼▼
// ▼▼▼ サウンド管理システム（ローカルファイル対応・最終完成版）▼▼▼
// ▼▼▼ BGM管理に特化した新しいサウンドマネージャー ▼▼▼
// ▼▼▼ BGMの音量調整機能付きサウンドマネージャー ▼▼▼
const SoundManager = {
    bgm: null,
    isReady: false,
    volume: 0.07, // BGMの音量を設定 (0.0がミュート, 1.0が最大)

    init() {
        this.bgm = document.getElementById('lottery-bgm');
        
        const unlockAudio = () => {
            if (!this.isReady && this.bgm) {
                this.isReady = true;
                this.bgm.volume = this.volume; // 初期音量を設定
                this.bgm.play().catch(e => console.error("BGM unlock failed:", e));
                this.bgm.pause();
                console.log("BGM ready.");
            }
            document.body.removeEventListener('click', unlockAudio);
        };
        
        document.body.addEventListener('click', unlockAudio, { once: true });
    },

    startBgm() {
        if (this.isReady && this.bgm) {
            this.bgm.volume = this.volume; // 再生前に音量を設定
            this.bgm.currentTime = 0;
            this.bgm.play().catch(e => console.error("BGM play failed:", e));
        }
    },

    stopBgm() {
        if (this.bgm) {
            this.bgm.pause();
            this.bgm.currentTime = 0;
        }
    }
};
// ▲▲▲
// ▲▲▲
// ▲▲▲ ▲▲▲
// ▲▲▲

    // ▼▼▼ 100種類の日本の苗字リスト ▼▼▼
const JAPANESE_SURNAMES = [
    "佐藤", "鈴木", "高橋", "田中", "伊藤", "渡辺", "山本", "中村", "小林", "加藤",
    "吉田", "山田", "佐々木", "山口", "松本", "井上", "木村", "林", "斎藤", "清水",
    "山崎", "森", "池田", "橋本", "阿部", "石川", "山下", "中島", "石井", "小川",
    "前田", "岡田", "長谷川", "藤田", "後藤", "村上", "近藤", "坂本", "遠藤", "青木",
    "藤井", "西村", "三浦", "岡本", "松田", "中川", "中野", "原田", "小野", "田村",
    "竹内", "金子", "和田", "中山", "石田", "上田", "森田", "原", "柴田", "酒井",
    "工藤", "横山", "宮崎", "宮本", "内田", "高木", "安藤", "谷口", "大野", "丸山",
    "今井", "高田", "藤原", "武田", "松井", "杉山", "村田", "大塚", "千葉", "岩崎",
    "桜井", "野口", "松尾", "菊地", "野村", "新井", "渡部", "佐野", "安田", "宮田",
    "小島", "大西", "杉本", "市川", "古川", "久保", "川崎", "飯田", "中田", "堀"
];

// ▼▼▼ サウンド管理システム ▼▼▼

// ▲▲▲

// --- Team Master Data ---
    const TEAM_DATA = {
    "天竜": {
        name_yomi: "てんりゅう",
        region: "西部",
        type: "公立",
        deviation: 52,
        best: "県大会ベスト16",
        last: "県大会ベスト16",
        info: "創部3年目にしてベスト16入りを果たした期待の新興勢力。新任の志賀監督の下、挑戦者としてのびのびとプレーした昨年とは一転、今年は他校からのマークも厳しくなる。昨年の躍進がフロックでなかったことを証明できるか、真価が問われる夏となる。西部地域の学校からの甲子園での成績が乏しいため、突如現れた彗星に期待の声も多い。エースの三橋やリードオフマンの田島を筆頭に部員数は少ないながらも力のある選手も多い。チームとしての目標は昨年を超えるベスト8ではなく甲子園出場。西部地域の雄となるために、まずは今年、どこまで上位勢に食らいつけるかが正念場である。。",
        coach: { name: '志賀 剛', style: '育成上手', experience: '新任' }
    },
    "桐陽": {
        name_yomi: "とうよう",
        region: "東部",
        type: "私立",
        deviation: 32,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "元プロの元木監督を招聘し、強化に乗り出した新興私立。プロ流の厳しい練習はチーム内に軋轢も生んでいるが、個々の能力は飛躍的に向上しており、140km以上を計測する選手が6人もいるなど、そのポテンシャルは計り知れない。監督の指導方針がチームとして完全に噛み合った時、一気に大会の主役へ躍り出る可能性を秘めている。",
        coach: { name: '元木 大介', style: '積極打撃', experience: 'プロOB' }
    },
    "浜松商業": {
        name_yomi: "はままつしょうぎょう",
        region: "西部",
        type: "公立",
        deviation: 40,
        best: "甲子園優勝",
        last: "県大会2回戦",
        info: "30年前の甲子園優勝校として野球ファンの間では知名度のある高校。近年はナムコグループや新興私立の台頭により低迷しており、昔のような圧倒的な強さはないが、今もなお中堅レベルの実力校として虎視眈々と聖地を狙っている。輝かしい栄光を取り戻すべく、今大会での躍進に期待したいい。",
        coach: { name: '伊武 雅之', style: 'データ野球', experience: 'ベテラン' }
    },
    "初星学園": {
        name_yomi: "はつぼしがくえん",
        region: "中部",
        type: "私立",
        deviation: 58,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "全国で唯一アイドル科を持つ学校として知られている創立3年目のナムコグループ系列校。全国からアイドル科目当てに受験する人も多く、学校としての注目度も高い。男女比では学校の特色も相まって驚異の8割が女子である。創部3年目の野球部としての設備はナムコグループ系列ということもあり整っており、直近の練習試合ではホームランも複数飛び出すなど、選手のポテンシャルも低くはない。練習ではアイドル科の生徒との合同トレーニングを組むこともあり、違う学科であれど、お互いアスリートの視点でアドバイスを送りあうなど学校の特色を活かした練習メニューもある。野球部で目立った実績はないが、アイドル科ではなく「野球の初星」と呼ばれるように躍進してほしい",
        coach: { name: '石川 実', style: '育成上手', experience: '中堅' }
    },
    "浜松特支": {
        name_yomi: "はままつとくし",
        region: "中部",
        type: "公立",
        deviation: 45,
        best: "なし",
        last: "なし",
        info: "創部一年目、全員1年生。県内初の試みとして、特別支援学校に設立された野球部。視覚障害、聴覚障害、知的障害、肢体不自由、病弱・身体虚弱の子どもを対象とした特別支援学校は、全国におよそ1100校ある。その中で高野連に加盟し、単独チームとして公式戦に出場しているのは緑山特別支援学校だけだ。部員たちは、野球のルールを覚えることや、仲間と声を掛け合うこと、その一つ一つが大きな挑戦だ。北村監督は、野球の技術以前に、彼らが野球というスポーツを心から楽しみ、自分を表現する喜びを知ってもらうにはどうすれば良いのか、答えのない問いに日々向き合っている。しかし、春の練習試合で喫した『52-0』の大敗は、彼らから野球の楽しさを根こそぎ奪い去った。部室代わりの理科準備室には、彼らの野球ノートが置かれており、中を見ると「たのしくない」「こわい」といった文面が多く見受けられた。エラーをすれば下を向いて泣き出し、打席ではデッドボールを怖がって腰が引ける。そして、なにより知的障害を持った子が硬式野球を行うことについての安全性を問われる声が多々あった。北村監督は勝利ではなく『試合を成立させること』の絶望的な難しさに直面している。夏の目標は9回を戦い抜き、スコアボードに『0』以外の数字を灯すこと。それは甲子園出場よりも遥かに高く、そして切実な壁だ。",
        coach: { name: '北村 大輔', style: '全員野球', experience: '新任' }
    },
    "765総合高校": {
        name_yomi: "なむこそうごう",
        region: "中部",
        type: "私立",
        deviation: 55,
        best: "甲子園ベスト16",
        last: "県大会2回戦",
        info: "大手ナムコグループが母体となる、県内屈指の資金力と設備を誇る私立校。黒井監督の徹底した管理野球の下、個々の能力が高く、大崩れしない安定した戦いぶりが特徴。２年前には甲子園初出場も果たし、破竹の勢いでベスト16まで勝ち進み、一躍有名校となったのは記憶に新しいだろう。しかし昨年の夏は２回戦敗退、秋は初戦敗退、春も初戦敗退と苦しい時期が続いている。聖地を知るメンバーは今の3年生のみとなった今、逆襲を誓い再び甲子園を目指す。ノーシードではあるがその実力はシード校級であり今大会のダークホースと言っても過言ではないだろう",
        popularity: true,
        coach: { name: '黒井 崇男', style: '総合力', experience: 'ベテラン' }
    },
    "川根": {
        name_yomi: "かわね",
        region: "中部",
        type: "公立",
        deviation: 53,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "今年度限りでの閉校が決まっており、野球部にとってはこれが最後の夏となる。グラウンド脇では校舎の解体作業が進むという異例の環境だが、選手たちは動揺を見せず練習に打ち込む。監督・選手ともに大会終了後はそれぞれ別の道を歩むことになる。「母校の名を刻みたい」という想いは一つ。有終の美を飾るべく、チームの士気は非常に高い。",
        coach: { name: '鈴木 誠', style: '堅実', experience: 'ベテラン' }
    },
    "283学園": {
        name_yomi: "つばさがくえん",
        region: "西部",
        type: "私立",
        deviation: 60,
        best: "甲子園1回戦",
        last: "県優勝(甲子園初戦敗退)",
        info: "昨年度の県大会王者。エース白瀬、二刀流の姫川や十王、花海咲など１年次からのレギュラーメンバーを軸に投打のバランスが取れた強豪校。。しかし、初出場となった昨年の夏の甲子園では初戦の浦和学院戦に7-9で敗戦し涙を飲み、全国の壁を痛感した。新チームになってからは樋口や花海佑などの新戦力も台頭し、春の大会では圧倒的な戦いで優勝し、第１シードに君臨。名将・天井監督は、昨年の経験を糧に、県内連覇とその先の「全国での一勝」を見据える。王者としてのプレッシャーをはねのけ、再び頂点に立てるか注目が集まる。",
        popularity: true,
        coach: { name: '天井 努', style: 'ID野球', experience: '名将' }
    },
    "島田工業": {
        name_yomi: "しまだこうぎょう",
        region: "中部",
        type: "公立",
        deviation: 41,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "県内でも有数の工業高校で、部員の多くが技術職を目指している。実習などで練習時間が限られるハンデを、田中監督が叩き込む「根性野球」でカバー。最後まで諦めない粘り強さがチームの持ち味。スター選手は不在だが、一丸となった時の結束力は高く、強豪校にとってはやりにくい相手として知られる。。",
        coach: { name: '田中 鉄平', style: '根性野球', experience: 'ベテラン' }
    },
    "磐田南": {
        name_yomi: "いわたみなみ",
        region: "西部",
        type: "公立",
        deviation: 63,
        best: "甲子園出場",
        last: "初戦敗退",
        info: "全国トップクラスの進学校。野球は「文武両道」を掲げる課外活動の一環だが、その実力は侮れない。選手個々の野球IQが高く、データを駆使した緻密な戦術を得意とする。知性派集団が、夏のトーナメントに旋風を巻き起こす。余談だが、全国制覇の経験を持つサッカー部が応援に駆けつけることもあり、その独特の応援スタイルも名物となっている。ちなみにサッカー形式の野球応援が珍しいということで、これを目当てに試合に見に来るという隠れファンも多い。",
        coach: { name: '中田 譲二', style: '守備重視', experience: '中堅' }
    },
    "三島北": {
        name_yomi: "みしまきた",
        region: "東部",
        type: "公立",
        deviation: 55,
        best: "県大会ベスト8",
        last: "県大会ベスト8",
        info: "2年生エース左腕・榛名を擁する公立の実力校。max148キロの球速を持つ榛名の投球が試合の鍵を握るが、打線がエースを援護できるかが長年の課題。絶対的エースの存在に頼るだけでなく、チーム全体で得点を奪う総合力が試される。安定して上位に進出する力は十分に持っている。",
        coach: { name: '大川 透', style: '投手中心', experience: '中堅' }
    },
    "静岡": {
        name_yomi: "しずおか",
        region: "中部",
        type: "公立",
        deviation: 65,
        best: "甲子園3回戦",
        last: "県大会ベスト4",
        info: "創立93年、甲子園出場13回。そしてスポーツに力を入れながらも勉学でも優秀。その輝かしい歴史、実績は地元民のみならず県民の誇り、また憧れでもあり、老若男女問わず地元民に愛される伝統校である。近年は他校の私立やナムコグループとの選手獲得競争に一つ遅れをとっており、甲子園からは遠ざかっているが、歴史は厚く、私立並みの設備とOBからの厚い支援、そして、なによりも代矢東の試合がある際には球場に多くのOBが駆け付け、大応援団を結成し、相手を圧倒する。近年はナムコグループが県内を牛耳りかけているため、公立の希望の星としてメディアに取り上げられることも多い。県内を席巻するナムコグループへの『公立最後の砦』として、その存在は象徴的な意味を持ち始めた。名将・高島は伝統と現代野球の融合に腐心する。これは単なる高校野球ではない。地域の誇りと未来をかけた代理戦争なのだ。",
        popularity: true,
        coach: { name: '高島 礼', style: '伝統野球', experience: '名将' }
    },
    "飛龍": {
        name_yomi: "ひりゅう",
        region: "東部",
        type: "私立",
        deviation: 59,
        best: "甲子園2回戦",
        last: "初戦敗退",
        info: "かつては甲子園出場経験もある私立校だが、数年前に起きた不祥事の影響でチームは低迷。現在は若き林田監督と共に、失われた信頼を取り戻すべく再建の道を歩んでいる。地域への清掃活動などを通じて地道な努力を続けており、グラウンドでの結果で完全復活をアピールしたいところだ。。",
        coach: { name: '林田 健太郎', style: '機動力野球', experience: '期待の若手' }
    },
    "聖隷クリストファー": {
        name_yomi: "せいれいくりすとふぁー",
        region: "西部",
        type: "私立",
        deviation: 54,
        best: "県大会準優勝",
        last: "県大会ベスト8",
        info: "毎年優勝候補に挙げられる西部地区の雄。名将・片岡監督が築き上げた投手を中心とした堅守は全国レベルと評される。しかし、その堅実さゆえに打線が湿りがちで、トーナメント終盤で涙を飲む展開が続く。タレントは揃っており、悲願の甲子園出場に向けて、伝統の守備力に加えて得点力をどう向上させるか。長年の課題である「ベスト8の壁」を越えられるかが今大会の焦点となる。",
        popularity: true,
        coach: { name: '片岡 鉄心', style: '守備重視', experience: '名将' }
    },
    "裾野": {
        name_yomi: "すその",
        region: "東部",
        type: "公立",
        deviation: 48,
        best: "なし",
        last: "なし",
        info: "エースの茂野が中心となって創部された新しいチーム。部員のほとんどが高校から野球を始めた初心者であり、戦力としては未知数。茂野の圧倒的な個人技でどこまで勝ち上がれるかが注目される。チームとしての一体感が生まれれば、面白い存在になるかもしれない。",
        coach: { name: '茂野 吾郎', style: '超攻撃型', experience: '新任' }
    },
    "富士宮北": {
        name_yomi: "ふじのみやきた",
        region: "東部",
        type: "公立",
        deviation: 51,
        best: "甲子園出場",
        last: "初戦敗退",
        info: "プロ注目のmax158kmの本格派右腕・斎藤を擁する公立校。彼の存在により、例年以上の注目を集めている。佐々木監督はエースへの負担を考慮しつつ、チーム全体の底上げを図る。斎藤の快投はもちろん、彼を支える野手陣の奮起が、上位進出への鍵となる。",
        coach: { name: '佐々木 朗', style: '投手中心', experience: '中堅' }
    },
    "美城学園": {
        name_yomi: "みしろがくえん",
        region: "中部",
        type: "私立",
        deviation: 61,
        best: "県大会ベスト4",
        last: "県大会2回戦",
        info: "ナムコグループ系列校の草分け的存在。かつてはグループの中心だったが、近年は同じ系列の765総合や283学園に有力選手が集まり、苦戦を強いられている。三城監督の下、プライドをかけた戦いで古豪の意地を見せ、グループ内での序列を覆したいところだ。",
        coach: { name: '三城 常務', style: 'エリート野球', experience: 'ベテラン' }
    },
    "沼津高専": {
        name_yomi: "ぬまづこうせん",
        region: "東部",
        type: "公立",
        deviation: 78,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "全国トップクラスの偏差値を誇る超進学校。相手チームのデータを徹底的に分析し、確率に基づいた戦術を組み立てる「シンキング・ベースボール」が持ち味。身体能力では他校に劣る部分もあるが、その知性で補って余りある。セオリーの穴を突く戦い方は、どんな強豪にとっても脅威となる。。",
        coach: { name: '京大 一郎', style: 'データ野球', experience: '中堅' }
    },
    "三島南": {
        name_yomi: "みしまみなみ",
        region: "東部",
        type: "公立",
        deviation: 52,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "数年前に21世紀枠として甲子園に出場した経験を持つ。数年前ほどの力はないが、今年のチームは全員野球で相手に挑み、守備でリズムを作りながら、つなぐバッティングで得点する野球が特長。エースの吉田と主砲の打川を中心に、泥臭い野球でこの夏は下克上で甲子園まで勝ち上がる。",
        popularity: true,
        coach: { name: '吉田 輝夫', style: '全員野球', experience: 'ベテラン' }
    },
    "御殿場南": {
        name_yomi: "ごてんばみなみ",
        region: "東部",
        type: "公立",
        deviation: 54,
        best: "県大会ベスト16",
        last: "県大会ベスト16",
        info: "50年ぶりとなるベスト16に進出した昨年の躍進で、地元を大いに沸かせた公立校。データ分析を得意とする山内監督の指導の下、派手さはないが堅実な野球で勝ち上がった。周囲の「まぐれ」という声を覆し、自分たちの実力が本物であることを証明したい今大会は、真価を問われる重要な夏となる。。",
        coach: { name: '山内 浩司', style: '堅実', experience: '中堅' }
    },
    "掛川西": {
        name_yomi: "かけがわにし",
        region: "西部",
        type: "公立",
        deviation: 61,
        best: "甲子園2回戦",
        last: "県大会ベスト4",
        info: "静岡高校と並ぶスポーツが盛んな県内二大公立校。サッカー部などが全国的に有名なスポーツ強豪校であり、野球部も毎年安定して上位に進出する実力を持つが、あと一歩で甲子園に届かないシーズンが続く。名将・円堂監督が掲げる、常識にとらわれない大胆な采配は、多くのファンを魅了している。今年こそ他競技の輝かしい実績に追いつきたい。。",
        coach: { name: '円堂 守', style: '超次元野球', experience: '名将' }
    },
    "浜松市立": {
        name_yomi: "はままついちりつ",
        region: "西部",
        type: "公立",
        deviation: 55,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "毎年安定した力を持つ中堅公立校だが、トーナメント中盤で強豪校と当たり敗退することが多く、「壁」を越えられずにいる。この状況を打破すべく、ベテランの山口監督は今年は機動力野球に特化。塁に出れば積極的に次の塁を狙う、しつこい野球で番狂わせを狙う。。",
        coach: { name: '山口 一', style: '機動力野球', experience: 'ベテラン' }
    },
    "浜松学院": {
        name_yomi: "はままつがくいん",
        region: "西部",
        type: "私立",
        deviation: 52,
        best: "県大会ベスト16",
        last: "県大会ベスト16",
        info: "体育科のみで構成される通信制の私立校。全国から選手が集まり、寮生活を送りながら野球に打ち込んでいる。サッカー界で実績のある岡田監督が、競技の垣根を越えて指導にあたっており、その育成手腕に注目が集まる。独特の環境で育った選手たちが、チームとしてどう機能するかが鍵。",
        coach: { name: '岡田 武史', style: '育成上手', experience: 'ベテラン' }
    },
    "焼津水産": {
        name_yomi: "やいづすいさん",
        region: "中部",
        type: "公立",
        deviation: 44,
        best: "県大会ベスト16",
        last: "県大会2回戦",
        info: "港町に根ざした水産高校で、スタンドに翻る大漁旗がチームのシンボル。一昨年のベスト16進出という実績もあり、地元の期待は大きい。浜田監督が率いるチームは、チャンスでの集中打を得意とする攻撃的な野球が持ち味。昨年の不振を乗り越え、再び「大漁」を狙う。",
        coach: { name: '浜田 大吉', style: '積極打撃', experience: '中堅' }
    },
    "袋井": {
        name_yomi: "ふくろい",
        region: "中部",
        type: "公立",
        deviation: 59,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "県内有数のマンモス校で、毎年一定数の有望な新入生が入部する。突出したスター選手はいないものの、全部員のレベルが高く、総合力で勝負するチーム。ベテラン千葉監督の下、選手層の厚さを活かした多彩な戦術が強み。昨年の初戦敗退の雪辱を誓う。。",
        coach: { name: '千葉 繁', style: '総合力', experience: 'ベテラン' }
    },
    "浜松城北工業": {
        name_yomi: "はままつじょうほくこうぎょう",
        region: "西部",
        type: "公立",
        deviation: 46,
        best: "県大会ベスト4",
        last: "初戦敗退",
        info: "県大会ベスト4の経験もある公立校。元プロの金本監督が注入する、積極果敢なフルスイング野球がチームの代名詞。その攻撃的なスタイルは、時にラフプレーと批判されることもあるが、勝利への執念はどのチームよりも強い。昨年の初戦敗退から這い上がり、再び頂点を目指す。。",
        coach: { name: '金本 知憲', style: '積極打撃', experience: 'プロOB' }
    },
    "磐田東": {
        name_yomi: "いわたひがし",
        region: "西部",
        type: "私立",
        deviation: 50,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "轟監督の「打撃こそ正義」という哲学に基づき、練習の大部分を打撃練習に費やす超攻撃型チーム。その破壊力は県内トップクラスで、大量得点で試合をひっくり返す力を持つ。一方で、守備力に課題を残しており、試合展開が非常に不安定なのが特徴。観客を魅了する、スリリングな試合運びで勝ち上がりを狙う。。",
        coach: { name: '轟 雷蔵', style: '打撃偏重', experience: 'ベテラン' }
    },
    "静岡商業": {
        name_yomi: "しずおかしょうぎょう",
        region: "中部",
        type: "公立",
        deviation: 57,
        best: "甲子園優勝",
        last: "県大会ベスト8",
        info: "甲子園優勝経験もある伝統校で、毎年優勝候補の筆頭に挙げられる。エース成宮を筆頭とする投手力は全国屈指のレベルを誇る。昨年の大会では準々決勝で敗退しており、今年は王座奪還を目指す。名将・国友監督の下、投打に隙がなく、総合力は県内トップクラス。。",
        popularity: true,
        coach: { name: '国友 広重', style: '総合力', experience: '名将' }
    },
    "御殿場西": {
        name_yomi: "ごてんばにし",
        region: "東部",
        type: "私立",
        deviation: 56,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "トーナメント中盤の大きな壁として、毎年安定した力を見せる私立の実力校。ベテラン田崎監督が築き上げた堅実な野球は、どのチームにとってもやりにくい。一方で、近年はベスト8前後での敗退が続き、上位進出には課題も残る。強豪校にとっては厄介な「門番」から脱却し、頂点を狙えるかが問われる。。",
        coach: { name: '田崎 圭介', style: '堅実', experience: 'ベテラン' }
    },
    "誠恵": {
        name_yomi: "せいけい",
        region: "東部",
        type: "私立",
        deviation: 38,
        best: "甲子園出場",
        last: "初戦敗退",
        info: "かつては甲子園にも出場した古豪だが、近年は部員不足に悩み低迷している。勝利のためなら手段を選ばないベテラン影山監督の非情な采配は、物議を醸すことも少なくない。しかし、恵まれない戦力で勝ち上がるため、綺麗事だけでは済まされないというチームの現実も表している。。",
        coach: { name: '影山 秀路', style: 'ラフプレー', experience: 'ベテラン' }
    },
    "科学技術": {
        name_yomi: "かがくぎじゅつ",
        region: "中部",
        type: "私立",
        deviation: 55,
        best: "県大会ベスト4",
        last: "県大会ベスト16",
        info: "VRトレーニングやAIによるデータ解析など、最新技術を積極的に導入している新時代の私立校。その先進的な取り組みはメディアでも度々取り上げられ、知名度は高い。速水監督の下、科学的なアプローチで選手の能力を最大限に引き出す。データ野球が伝統的な強豪校にどこまで通用するのか、注目が集まる。。",
        coach: { name: '速水 奨', style: 'データ野球', experience: '中堅' }
    },
    "小山": {
        name_yomi: "おやま",
        region: "東部",
        type: "公立",
        deviation: 49,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "人口1万人の小さな町にある、全校生徒100人にも満たない小規模校。町の期待を一身に背負い、彼らはグラウンドに立つ。チャンス時に全校生徒と町民が一体となって踊る『小山舞踊』は、相手チームを呑み込む独特の雰囲気を生み出す。ベテラン猫田監督の下、体格では劣る選手たちが機動力で掻き回す。町全体の想いが、奇跡を起こすかもしれない。",
        coach: { name: '猫田 権蔵', style: '機動力野球', experience: 'ベテラン' }
    },
    "虎府島総合": {
        name_yomi: "こふとうそうごう",
        region: "西部",
        type: "公立",
        deviation: 47,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "本土から定期船で4時間。台風が来れば1週間は孤島と化す。それが虎府島だ。グラウンドは塩害で芝生がまだらに枯れ、雨が降れば沼地と化す。練習相手は漁の合間に集まる島の草野球チームの地元の方々。彼らから教わるのは『気合』と『潮の流れの読み方』だ。本土の他校の情報は、月に一度届く野球雑誌だけ。しかし、この絶望的なハンデが彼らの魂を鋼鉄に変えた。その逆境が「虎府島スピリッツ」と呼ばれる強靭な精神力とチームの結束を育んだ。試合の日には島民が大挙して応援に駆けつけるなど、地域との絆はどこよりも強い。噂によると島民の約半数にも及ぶらしい。もはやこれは単なるスポーツではない。島が、生きるために戦う物語だ。",
        coach: { name: '島袋 譲二', style: '全員野球', experience: 'ベテラン' }
    },
    "知徳": {
        name_yomi: "ちとく",
        region: "東部",
        type: "私立",
        deviation: 51,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "『力こそ全て』を校訓に掲げ、練習のほとんどをウエイトトレーニングに費やす脳筋集団。金剛監督の指導の下、全選手がベンチプレス100kg以上を誇るパワーは本物だ。しかし、その大味な野球は、栄養管理や科学的トレーニングを取り入れる強豪校の前に、いつもあと一歩で屈してきた。筋肉は裏切らない。その言葉を信じ、彼らは今日も鉄アレイを握る。",
        coach: { name: '金剛 毅', style: 'パワー野球', experience: '中堅' }
    },
    "静清": {
        name_yomi: "せいせい",
        region: "中部",
        type: "私立",
        deviation: 55,
        best: "甲子園優勝",
        last: "初戦敗退",
        info: "半世紀前に甲子園5連覇を達成した伝説的な古豪。近年は低迷が続くが、その名前は今も高校野球ファンに畏敬の念を抱かせている。かつての名将の血を引く犬飼監督が、伝統の堅守を復活させ、「帝国の再建」を目指す。古豪復活への道のりは険しいが、その一挙手一投足に注目が集まる。。",
        coach: { name: '犬飼 賢人', style: '守備重視', experience: '名将' }
    },
    "日大三島": {
        name_yomi: "にちだいみしま",
        region: "東部",
        type: "私立",
        deviation: 56,
        best: "甲子園出場",
        last: "県大会ベスト16",
        info: "2022年の春夏連続甲子園出場が記憶に新しい日大三島。昨秋は県大会3回戦で敗退し、気合を入れ直したところだ。指揮をとるのは永田裕治監督だ。報徳学園（兵庫）時代には全国制覇を含む、春夏通算18回の甲子園出場。2020年に日大三島に赴任すると、2022年には春夏連続で甲子園に導いた。今チームも百戦錬磨の名将から全員野球の大切さ、勝負に対する厳しさを学び、選手たちの顔つきが少しずつ変わってきた。名将の就任から4年が過ぎようとしている。。",
        coach: { name: '小和田 雅人', style: '堅実', experience: 'ベテラン' }
    },
    "浜松開誠館": {
        name_yomi: "はままつかいせいかん",
        region: "西部",
        type: "私立",
        deviation: 60,
        best: "県大会ベスト4",
        last: "県大会ベスト16",
        info: "「強豪キラー」として知られる、トーナメント屈指のダークホース。策士・豊臣監督が率いるチームは、相手チームの徹底的な分析に基づいた奇策を得意とする。その予測不能な戦いぶりは、格上の強豪校にとって大きな脅威。安定感に欠ける面もあるが、ひとたび波に乗れば一気に勝ち上がる力を持っている。。",
        coach: { name: '豊臣 秀幸', style: '奇策', experience: '策士' }
    },
    "東海大翔洋": {
        name_yomi: "とうかいだいしょうよう",
        region: "中部",
        type: "私立",
        deviation: 61,
        best: "県準優勝",
        last: "県大会ベスト16",
        info: "一昨年の夏はノーシードから県内強豪チームに勝利し準優勝。新しいスタイルで今夏こそ甲子園へ！勝利への執念を引き継ぐ現チームの特徴は「機動力」。前チームとはまた違ったスタイルに期待がかかる。機動力以外もレベルアップしている。投手は140キロ右腕の甘田圭澄（2年）が君臨。課題だった2番手も、1年生を中心に台頭しつつある。一方の攻撃力は7試合計90安打を叩き出した昨年のチームに比べて劣るが、機動力を使った野球を展開。チームナンバーワンの俊足・松下揮人（2年＝外野手）や岸川を筆頭に足の速い選手が多いのも追い風となっている。守りからリズムを作り、1点ずつ積み重ねていくニュースタイルが浸透してきた「タテジマ軍団」。2004年夏以来となる甲子園に向けて牙を研ぐ。。",
        coach: { name: '須田 幸雄', style: '総合力', experience: 'ベテラン' }
    },
    "283学園B": {
        name_yomi: "つばさがくえんB",
        region: "西部",
        type: "私立",
        deviation: 59,
        best: "なし",
        last: "なし",
        info: "王者・283学園の『二軍』。昨年の優勝により部員数が急激に増加した283学園。一時は100人も超えたため、それに伴い、異例の措置として設立されたBチーム。Aチームに上がれなかった選手で構成されているが、監督に就任した七草の手腕もあり、その実力は侮れない。「打倒Aチーム」を掲げ、ハングリー精神は本家以上。公式戦での兄弟対決が実現すれば、大きな注目を集めるだろう。県内からは同じ県内に同じ高校のチームの二つ目を作り大会に参加させるのは違反行為なのでは、という声が多く上がったが、県内はナムコグループが牛耳っているため、ごり押しで可決させた。",
        coach: { name: '七草 はづき', style: '育成上手', experience: '期待の若手' }
    },
    "伊豆伊東": {
        name_yomi: "いずいとう",
        region: "伊豆",
        type: "公立",
        deviation: 43,
        best: "県大会2回戦",
        last: "県大会2回戦",
        info: "数年前に共学化した元女子高で、野球部は創部まもない新しいチーム。学校側の全面的なバックアップを受け、期待の若手、伊集院監督が指導にあたる。全国レベルと名高い吹奏楽部の応援もチームの大きな武器。まだ発展途上だが、今後の成長が期待される注目株だ。。",
        coach: { name: '伊集院 隼人', style: '機動力野球', experience: '期待の若手' }
    },
    "富士東": {
        name_yomi: "ふじひがし",
        region: "東部",
        type: "公立",
        deviation: 63,
        best: "県大会2回戦",
        last: "県大会2回戦",
        info: "富士東は最上級生の奮起に注目だ。昨年は４人しかいない３年生全員が活躍を見せ、初戦で甲子園出場経験もある富士宮北を７―６で破った。一緒にプレーした岩田主将（３年）は「そういう上級生の姿を今年も後輩たちに見せたい」と意気込む。エースの眞山（３年）は、４日の招待試合で日大三島に１失点完投勝利。自信を胸に「チームを鼓舞する投球をしたい」と大舞台を見据える。。",
        coach: { name: '高橋 留美', style: '守備重視', experience: '中堅' }
    },
    "常葉菊川": {
        name_yomi: "とこはきくがわ",
        region: "西部",
        type: "私立",
        deviation: 55,
        best: "甲子園準優勝",
        last: "県準優勝",
        info: "織田監督が率いる、超攻撃的な野球を標榜する私立校。昨年の県大会では、その圧倒的な打撃力で準優勝に輝いた。守備に課題を残すものの、「点を取られたら取り返す」というスタイルは多くのファンを魅了している。今年もその破壊的な打線は健在で、頂点を目指す。。",
        coach: { name: '織田 信長', style: '超攻撃型', experience: 'ベテラン' }
    },
    "加藤学園": {
        name_yomi: "かとうがくえん",
        region: "東部",
        type: "私立",
        deviation: 62,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "投手陣は緩急をつける三浦、思い切りのいい山口らが主戦を争う。打線は長打力があるブランコ、中村ら中軸が信頼できる。石川、モーガンら上位が出て、得点機をつくりたい。下位打線の充実が鍵。守備は一年生の時から試合に出ている遊撃梶谷、昨年を経験した捕手鶴岡らセンターラインが軸。確実にアウトを取れる安定感が持ち味だ。",
        coach: { name: '渡辺 元智', style: '総合力', experience: '名将' }
    },
    "藤枝明誠": {
        name_yomi: "ふじえだめいせい",
        region: "西部",
        type: "私立",
        deviation: 60,
        best: "県大会準優勝",
        last: "県大会ベスト8",
        info: "「雑草軍団」として知られ、エリート校への強い対抗心とハングリー精神がチームの原動力。ベテラン猪狩監督の指導の下、個々の選手の能力は非常に高い。チームとして噛み合った時の爆発力は、優勝候補をも脅かす。近年着々と結果を出しており、今大会は春の大会で上位の成績を収めたことにより、シード校として君臨している。「革命」の時は近い。",
        coach: { name: '猪狩 茂', style: '投手中心', experience: 'ベテラン' }
    },
    "駿河総合": {
        name_yomi: "するがそうごう",
        region: "中部",
        type: "私立",
        deviation: 57,
        best: "県大会準優勝",
        last: "県大会2回戦",
        info: "2019年夏に初の県決勝進出を果たした駿河総合。昨夏の「2020年夏季静岡県高等学校野球大会結果」でもベスト4入り。悲願の甲子園が手の届く位置まできている。同校はチーム力が年々上昇すると同時に、上のカテゴリーで活躍する卒業生が増えている。2018年に社会人野球を経てOBの杉山一樹（福岡ソフトバンク）がプロ入り。最速157キロの剛速球を武器に今季はローテーションの一角として期待される。さらに、2019年のドラフトで指名された紅林弘太郎（オリックス）はプロ1年目から1軍戦に出場。将来の主軸候補として注目を集めている。期待の若手・藤崎監督が持ち込んだデータ野球を武器に、着実に力をつけている。相手の油断を突く情報戦を得意とし、下馬評を覆すポテンシャルは十分。校名とは裏腹に、冷静沈着な野球で番狂わせを狙う。。",
        coach: { name: '藤崎 詩織', style: 'データ野球', experience: '期待の若手' }
    },
    "静岡大成": {
        name_yomi: "しずおかたいせい",
        region: "中部",
        type: "私立",
        deviation: 49,
        best: "県大会ベスト16",
        last: "県大会2回戦",
        info: "突出した選手こそいないものの、堅実な守備と、出塁率を武器にしている。選手たちは限られた環境の中でも、年間を通して一生懸命に取り組んでいる。直近の練習試合では東海大翔洋にも勝利するなど実力は侮れない。今大会のダークホースになるかもしれない",
        coach: { name: '鰯水 等', style: '堅実', experience: '中堅' }
    },
    "浜松工業": {
        name_yomi: "はままつこうぎょう",
        region: "西部",
        type: "公立",
        deviation: 54,
        best: "甲子園ベスト8",
        last: "県大会2回戦",
        info: "約30年前に甲子園ベスト8に進出し、「浜工旋風」を巻き起こしたことで知られる。近年は低迷していたが、当時のエースだった青葉が監督に就任し、再建に乗り出した。かつての英雄の帰還に、OBや地元の期待も高まっている。新しい世代の選手たちと共に、再び聖地を目指す。。",
        coach: { name: '青葉 健司', style: '育成上手', experience: '期待の若手' }
    },
    "伊豆総合": {
        name_yomi: "いずそうごう",
        region: "東部",
        type: "公立",
        deviation: 43,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "エースは最速１３６キロの力のあるストレートで勝負する。打撃陣に派手さはないものの走塁や戦術に磨きをかけ、足りない長打力をカバーする。落ち着いた雰囲気で野球に取り組んでいる。尾島太郎監督の指導は、堅実な守備と確実なバントなどを重視するスタイル。派手さはないが、大崩れしない安定感がある。。",
        coach: { name: '尾島 太郎', style: '守備重視', experience: 'ベテラン' }
    },
    "富士宮西": {
        name_yomi: "ふじのみやにし",
        region: "東部",
        type: "公立",
        deviation: 58,
        best: "甲子園ベスト16",
        last: "初戦敗退",
        info: "約30年前に甲子園出場経験のある古豪。近年は私立校の台頭に押され、上位進出から遠ざかっている。OBや地元ファンの「復活を」という期待が、時に選手たちのプレッシャーになることも。ベテラン拳崎監督は、選手たちが気負わずに実力を発揮できる環境作りに努めている。",
        coach: { name: '拳崎 史郎', style: '積極打撃', experience: 'ベテラン' }
    },
    "富士市立": {
        name_yomi: "ふじいちりつ",
        region: "西部",
        type: "私立",
        deviation: 51,
        best: "県大会ベスト8",
        last: "県大会2回戦",
        info: "セイバーメトリクスをいち早く導入し、データに基づいた野球を徹底する私立校。赤嶺監督の采配は、選手のコンディションや相手との相性など、あらゆる情報を分析した上で決定される。その合理的なアプローチは、時に非情とも映るが、着実に結果を残している。",
        coach: { name: '赤嶺 譲二', style: 'データ野球', experience: '中堅' }
    },
    "オイスカ浜松国際": {
        name_yomi: "おいすかはままつこくさい",
        region: "西部",
        type: "私立",
        deviation: 49,
        best: "県大会ベスト4",
        last: "県大会2回戦",
        info: "県内を牛耳る巨大資本『ナムコグループ』に対抗すべく、地元の有志『オイスカグループ』が設立した異色の高校。潤沢な資金を持つナムコ系列校とは対照的に、彼らが持つのは反骨精神と結束力だけだ。「伝説」と称される桐生監督の指導は、技術よりも精神的な強さを重視する。その熱いプレースタイルと反骨精神は多くのファンを惹きつけており、大会の波乱要因として注目されている。",
        coach: { name: '桐生 一馬', style: '根性野球', experience: '伝説' }
    },
    "新居": {
        name_yomi: "あらい",
        region: "中部",
        type: "公立",
        deviation: 48,
        best: "県大会初戦敗退",
        last: "初戦敗退",
        info: "夏の大会、公式戦通算0勝32敗。それがこの学校の歴史の全てだ。長年公式戦での勝利から遠ざかっており、部員数も常にギリギリという厳しい状況が続く公立校。練習環境も恵まれているとは言えないが、選手たちは野球が好きだという純粋な気持ちで白球を追い続けている。チームの悲願は、まず「公式戦で一勝」を挙げること。その瞬間に向けて、ひたむきな努力を重ねる。",
        coach: { name: '田中 一郎', style: '堅実', experience: '中堅' }
    },
    "韮山": {
        name_yomi: "にらやま",
        region: "東部",
        type: "公立",
        deviation: 68,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "県のシンボル『伊豆山』の麓にある県内屈指の進学校。彼らの名物は、険しい山道を毎日駆け上がる地獄のトレーニングだ。それで鍛え上げられた強靭な足腰は、他校の脅威。ベテラン山路監督が率いる機動力野球は、一度出塁を許すと止まらない。山の民の誇りを胸に、グラウンドを嵐のように駆け巡る。",
        coach: { name: '山路 和弘', style: '機動力野球', experience: 'ベテラン' }
    },
    "静岡学園": {
        name_yomi: "しずおかがくえん",
        region: "中部",
        type: "私立",
        deviation: 61,
        best: "甲子園出場",
        last: "県大会ベスト16",
        info: "創部19年の新興勢力ながら、甲子園出場経験を持つ実力校。しかし更なる飛躍のため、学校は大きな賭けに出た。かつて帝王実業を甲子園5連覇に導いた伝説の名将・國村監督を招聘したのだ。規律を重んじるベテラン監督の下、才能ある選手たちがどう融合するのか、優勝候補の一角として大きな注目を集めている。。",
        coach: { name: '國村 隼', style: '総合力', experience: '名将' }
    },
    "市立沼津": {
        name_yomi: "いちりつぬまづ",
        region: "東部",
        type: "公立",
        deviation: 62,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "全国レベルの吹奏楽部が奏でる応援は『市沼サウンド』として有名。その美しくも力強い音圧は、相手チームの集中力を削ぎ、味方を鼓舞する。ベテラン猫又監督が率いるチームは、その応援をバックに、粘り強い守備でリズムを作る。派手な選手はいないが、繋ぐ意識は県内随一。音の魔術師たちが、静かに、しかし確実に相手を追い詰めていく。",
        coach: { name: '猫又 育史', style: '守備重視', experience: 'ベテラン' }
    },
    "沼津城北": {
        name_yomi: "ぬまづじょうほく",
        region: "東部",
        type: "公立",
        deviation: 55,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "生徒の自主性を重んじる自由な校風で知られる公立校。野球部も西垣監督の指導方針の下、選手たちが自ら練習メニューや戦術を考える「考える野球」を実践している。その型にはまらないプレースタイルは、時にセオリーを覆す大きな波乱を巻き起こす可能性を秘めている。",
        coach: { name: '西垣 奈々', style: '奇策', experience: '期待の若手' }
    },
    "下田": {
        name_yomi: "しもだ",
        region: "伊豆",
        type: "公立",
        deviation: 50,
        best: "県大会初戦敗退",
        last: "初戦敗退",
        info: "過疎化が進む静かな港の町。全校生徒80人、野球部員は奇跡的に集まったが、グラウンドには雑草が生い茂り、練習は紅白戦もできず、監督が打つボールをただ延々と追いかけるだけ。昨年、町で唯一のスポーツ用品店がシャッターを下ろし、今は破れたボールを自分たちで縫って使うしかない。町の大人たちは、彼らが野球をしていることすら知らないかもしれない。消えゆく町で、誰にも知られず消えていく野球部。彼らが夏の大会に出場するのは、勝利のためではない。自分たちが『下田高校野球部』として確かにここに存在したという、たった一つの証を夏の青空に刻み込むためだけの、あまりにも切ない戦いだ。",
        coach: { name: '水上 善次', style: '堅実', experience: '中堅' }
    },
    "湖西": {
        name_yomi: "こさい",
        region: "西部",
        type: "公立",
        deviation: 57,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "大会ごとに成績が大きく変動する、ムラッ気のあるチームとして知られる。上位進出経験もありポテンシャルは高いが、格下相手への取りこぼしも少なくない。ベテラン海野監督は、長年の課題である精神的な安定感をチームにもたらそうと指導。今大会で安定した戦いぶりを見せられるかが躍進の鍵となる。。",
        coach: { name: '海野 平', style: '機動力野球', experience: 'ベテラン' }
    },
    "熱海": {
        name_yomi: "あたみ",
        region: "伊豆",
        type: "公立",
        deviation: 46,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "創立70年を迎える地域の伝統校だが、近年は過疎化の波に飲まれ、活気を失いつつある。野球部の活躍は、町に残された数少ない希望だ。『俺たちが勝てば、町が元気になる』。その想いを胸に、選手たちはグラウンドに立つ。選手は全員が地元出身。育成に定評のある根本監督の下、郷土愛を力に変えて戦う。そのひたむきなプレーには、多くの地元ファンがついている。地元出身の選手たちが、愛する故郷に勝利を届ける。",
        coach: { name: '根本 陸夫', style: '育成上手', experience: 'ベテラン' }
    },
    "静岡東": {
        name_yomi: "しずおかひがし",
        region: "中部",
        type: "公立",
        deviation: 53,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "毎年投打にバランスの取れた好チームを編成するが、トーナメントの組み合わせに恵まれず、実力以上の結果を残せていない「悲運の公立校」。井上監督はどんな相手にも自分たちの野球を貫くことを選手に求める。今年こそ、厳しい組み合わせを乗り越えて上位進出を果たしたい。。",
        coach: { name: '井上 和彦', style: '総合力', experience: '中堅' }
    },
    "城南静岡": {
        name_yomi: "じょうなんしずおか",
        region: "中部",
        type: "公立",
        deviation: 59,
        best: "県大会ベスト4",
        last: "初戦敗退",
        info: "かつて県ベスト4の実績を持つ公立の実力校。昨年の初戦敗退の屈辱から、チームは「原点回帰」をテーマに伝統の積極打撃を徹底的に磨き直した。伊藤監督の下、古豪復活を目指すチームの士気は高い。ノーシードからの下剋上を狙う。。",
        coach: { name: '伊藤 健太郎', style: '積極打撃', experience: 'ベテラン' }
    },
    "浜松南": {
        name_yomi: "はままつみなみ",
        region: "西部",
        type: "公立",
        deviation: 56,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "近年、校舎が新築され、練習環境が大幅に改善された公立校。学校全体の期待が高まる中、期待の若手・高木監督がチームを率いる。まだ目立った実績はないが、最新の設備と新しいユニフォームで心機一転、新たな歴史を作るべく今大会に挑む。。",
        coach: { name: '高木 渉', style: '育成上手', experience: '期待の若手' }
    },
    "島田": {
        name_yomi: "しまだ",
        region: "中部",
        type: "公立",
        deviation: 53,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "大正8年創立という長い歴史を持つ伝統校だが、近年は部員不足から連合チームを組むなど、苦しい時期が続いている。今季から再び単独チームとして出場するが、戦力はまだ整っていない。まずは大会で一勝を挙げ、チームの新たな一歩を踏み出すことが目標となる。。",
        coach: { name: '島本 宏', style: '堅実', experience: '中堅' }
    },
    "伊豆中央": {
        name_yomi: "いずちゅうおう",
        region: "伊豆",
        type: "公立",
        deviation: 51,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "長年の部員不足から昨年まで連合チームとして出場していたが、今年から待望の単独出場を果たす。部員の多くが野球経験の浅い1年生で、チームはまだ発展途上。中田監督は、まずは公式戦で戦う経験を積ませ、チームの土台作りを進めている段階。今大会は未来への第一歩となる。。",
        coach: { name: '中田 島蔵', style: '全員野球', experience: '中堅' }
    }
};

    const DETAILED_TEAM_DATA = {
        "283学園": {
            summary: "夏の連覇の先に、聖地での勝利を目指す。昨年王者、守備の一体感と打線のつながりを強みに、試合ごとに成長。チームスローガンは『強』。個の技量に頼らず、一人ひとりの力を集めて戦う。",
            players: [
                { name: "姫川", year: 3, position: "ピッチャー", desc: "投打の中心。MAX151kmの直球とスプリット、高校通算42本塁打の怪物。" },
                { name: "花海咲", year: 3, position: "センター", desc: "1年夏からベンチ入りを果たしている、経験豊富な走攻守三拍子揃ったリードオフマン。攻守の要として監督からの信頼は厚い。" },
                { name: "鈴木", year: 2, position: "ファースト", desc: "芯で捉える技術を持つ打者。守備でも存在感。" },
                { name: "十王", year: 3, position: "ショート", desc: "鉄壁の守備を誇る名手。チャンスメイクも得意な打者。" },
                { name: "浅倉享", year: 2, position: "レフト", desc: "2年生ながら5番に座ることもあるクラッチヒッター。ポテンシャルが高い。" },
                { name: "樋口", year: 3, position: "サード", desc: "強肩強打のパワーヒッター。勝負強い打撃が光る。" },
                { name: "有栖川", year: 3, position: "キャッチャー", desc: "大舞台に強い主軸。変化球打ちの技術はチームトップクラス。" },
                { name: "芹沢", year: 2, position: "セカンド", desc: "小技と守備センスが光る二塁手。チャンスでの一打も。" },
                { name: "花海佑", year: 1, position: "ライト", desc: "1年生のスーパースター。兄・咲との連携も抜群。既に通算13本塁打。" },
                { name: "黛", year: 2, position: "ピッチャー", desc: "チーム最速の直球を持つ。春はメンバー外の悔しさをバネに復調を目指す。" },
                { name: "白瀬", year: 3, position: "ピッチャー", desc: "春の大会で完全試合を達成。伸び上がるストレートが武器。" }
            ]
        },
        "常葉菊川": {
            summary: "個々のレベルアップが結実し昨年は準優勝。個人成績の可視化と実力主義でチーム内の競争を活性化させ、初の甲子園を目指す。スローガンは『個々の能力重視』。",
            players: [
                { name: "沖田総司", year: 3, position: "ピッチャー", desc: "投打の大黒柱。MAX157kmの速球を持つ主砲。" },
                { name: "土方任三郎", year: 3, position: "キャッチャー", desc: "グラウンド上の監督。高いスローイング技術と高校通算28本塁打のパワーを持つ。" },
                { name: "宮本和佐", year: 3, position: "ファースト", desc: "力強い打撃と勝負強さが魅力の3番打者。" },
                { name: "柳生俊昌", year: 2, position: "セカンド", desc: "バッティングセンスに優れる2年生。落ち着いたプレーが光る。" },
                { name: "近藤春樹", year: 3, position: "サード", desc: "ガッツあふれるプレーでチームを引っ張る5番打者。高校通算46本塁打。" },
                { name: "坂本俊樹", year: 3, position: "ショート", desc: "走攻守三拍子揃った抜群の身体能力を持つショート。" },
                { name: "岡田克也", year: 3, position: "ライト", desc: "高校通算71本塁打を誇る絶対的な4番。恵まれた体格からの強打が武器。" },
                { name: "森晴継", year: 2, position: "センター", desc: "50m6秒フラットの俊足。攻守にわたり抜群の勝負強さを見せる。" },
                { name: "上泉誠", year: 3, position: "レフト", desc: "バランスと勝負強い打撃が武器。逆転劇のきっかけを作る。" },
                { name: "拝拓也", year: 3, position: "ピッチャー", desc: "巧みな投球術と強い精神力を持つ控え投手。MAX155km。" },
                { name: "疋田文也", year: 2, position: "ピッチャー", desc: "クレバーさと強気を兼ね備えた2年生投手。昨夏も登板経験あり。" }
            ]
        },
        "掛川西": {
            summary: "昨年ベスト4。選手の長所を活かす野球で、磨き上げた守備力とタイプの違う3年生投手3人の継投を武器に、2005年以来の夏の聖地を目指す。",
            players: [
                { name: "豪炎寺秀一", year: 3, position: "ピッチャー", desc: "最速158kmの直球と縦スライダーで打者を打ち取る絶対的エース。" },
                { name: "円堂憲作", year: 3, position: "キャッチャー", desc: "冷静なリードで多彩な投手陣を引っ張る扇の要。3番打者としても活躍。" },
                { name: "壁山英二郎", year: 3, position: "ファースト", desc: "190cmの長身を生かした守備と長打力が魅力。" },
                { name: "半田慎二", year: 3, position: "セカンド", desc: "小柄ながら攻守に堅実なプレーでチームに貢献。" },
                { name: "一ノ瀬拓郎", year: 3, position: "サード", desc: "チーム一の打球の速さを誇る2番打者。" },
                { name: "土門海斗", year: 3, position: "ショート", desc: "ミスの少ない堅実な守備で試合のリズムを作る内野の要。" },
                { name: "染岡竜吾", year: 3, position: "レフト", desc: "監督も絶大な信頼を寄せる大砲。気持ちの強さも魅力。" },
                { name: "風丸一郎", year: 3, position: "センター", desc: "サイクルヒット達成経験もあるリードオフマン。ミート力が格段にアップ。" },
                { name: "栗松鉄平", year: 2, position: "ライト", desc: "力強いスイングから放たれる長打が魅力の2年生。" },
                { name: "鬼道優斗", year: 3, position: "ピッチャー", desc: "キレのある縦スライダーと内角への直球が魅力の右腕。" },
                { name: "松野裕介", year: 2, position: "ピッチャー", desc: "MAX144kmのストレートとカットボールが武器の2年生。奪三振能力が高い。" }
            ]
        },
        "静岡": {
            summary: "投打の大黒柱を中心にダイナミックなベースボールを展開。攻めの姿勢を貫き、1999年以来の聖地を見据える伝統校。どこからでも得点できる打線が強み。",
            players: [
                { name: "渋谷卓", year: 3, position: "ピッチャー", desc: "常時150km超の速球を投げる本格派エース。" },
                { name: "片野坂晴人", year: 3, position: "キャッチャー", desc: "小柄ながら強肩強打の司令塔。盗塁阻止率は随一。" },
                { name: "郷野将暉", year: 3, position: "ファースト", desc: "高校通算63本塁打のプロ注目スラッガー。得点圏での勝負強さが光る。" },
                { name: "片倉郁弥", year: 3, position: "セカンド", desc: "俊足と広い守備範囲が武器の機動力内野手。" },
                { name: "島津成哉", year: 3, position: "サード", desc: "反応速度と強肩が武器の守備の要。広角に打ち分ける打撃も。" },
                { name: "藤原元輝", year: 3, position: "ショート", desc: "軽快なフットワークが光る守備職人。つなぎ役もこなす。" },
                { name: "倉科哲史", year: 3, position: "レフト", desc: "小柄ながら高い身体能力を持つ。クリーンアップの前を打つ。" },
                { name: "滝川文隆", year: 3, position: "センター", desc: "抜群の走力でセンターラインを統率するリードオフマン。" },
                { name: "川又良太", year: 3, position: "ライト", desc: "安定した打率を誇る右打者。正確な返球も魅力。" },
                { name: "六反田良弥", year: 3, position: "ピッチャー", desc: "最速152kmの剛腕。リリーフも先発もこなす万能型。" },
                { name: "鳥羽晴康", year: 3, position: "ピッチャー", desc: "左腕から多彩な変化球を投げるクローザー的存在。" }
            ]
        },
        "聖隷クリストファー": {
            summary: "昨年ベスト8。選手の長所を活かした攻撃力と堅守を武器に雪辱を期す。タイプの異なる3人の投手による継投が強み。",
            players: [
                { name: "沢村栄玲", year: 2, position: "ピッチャー", desc: "最速140kmの直球と多彩な変化球で三振を奪う次世代エース左腕。" },
                { name: "降谷暁", year: 3, position: "ピッチャー", desc: "長身から投げ下ろすスライダーとシュートが武器の大型右腕。" },
                { name: "御幸一也", year: 3, position: "キャッチャー", desc: "攻守にわたる高い野球センスを誇るプロ注目の司令塔。" },
                { name: "前園裕太", year: 2, position: "一塁手／外野手", desc: "高い打撃技術と強肩を持つ大型野手。" },
                { name: "小湊夏樹", year: 3, position: "二塁手", desc: "堅実な守備と巧みなバットコントロールが光る。" },
                { name: "金丸真也", year: 3, position: "三塁手", desc: "打球反応が速く、強肩が武器。中距離ヒッター。" },
                { name: "倉持実", year: 2, position: "ショート", desc: "俊敏な動きと華麗な守備が魅力の内野の要。" },
                { name: "結城大介", year: 3, position: "レフト", desc: "長打力を武器に快音を響かせる強打者。" },
                { name: "東条光希", year: 3, position: "センター", desc: "強肩と確実な捕球で外野を統率する守備職人。" },
                { name: "白洲浩司", year: 3, position: "ライト", desc: "打撃センスが光る左打者。冷静な状況判断が持ち味。" }
            ]
        },
        "三島北": {
            summary: "雪辱を期す知性派軍団。絶対的エース榛名を擁し、データを駆使した緻密な野球で昨夏の悔しさを晴らす。チームスローガンは『知は力なり』。",
            players: [
                { name: "榛名 元希", year: 3, position: "ピッチャー", desc: "最速140km後半の直球と高速スライダーで三振の山を築く絶対的エース。" },
                { name: "秋丸協平", year: 3, position: "キャッチャー", desc: "冷静沈着なリードでエース榛名を支える扇の要。" },
                { name: "大川 公彦", year: 3, position: "ファースト", desc: "チーム不動の4番。一振りで試合の流れを変えるパワーが魅力。" },
                { name: "福原 恭介", year: 3, position: "ショート", desc: "卓越したバットコントロールと選球眼を持つ1番打者。守備も堅実。" },
                { name: "町田誠", year: 3, position: "センター", desc: "走攻守三拍子揃ったアベレージヒッター。3番を担う。" }
            ]
        },
        "静岡商業": {
            summary: "王座奪還へ、揺るぎなき『王国』のプライド。昨年の雪辱に燃える絶対王者。投打にタレントを揃え、最強左腕・成宮を軸に再び全国の頂点を目指す。スローガンは『常勝』。",
            players: [
                { name: "成宮 鳴", year: 3, position: "ピッチャー", desc: "「キング」の異名を持つ世代最強左腕。MAX150km/hの直球と魔球チェンジアップを操る。" },
                { name: "神谷 カルロス 俊樹", year: 3, position: "センター", desc: "50m5秒台の俊足を誇る「チーター」。攻守に規格外の身体能力を見せる。" },
                { name: "白河 勝之", year: 3, position: "ショート", desc: "卓越した野球センスと華麗な守備が光る内野の司令塔。" },
                { name: "多田野 樹", year: 2, position: "キャッチャー", desc: "「キング」成宮の女房役を射止めた2年生捕手。冷静なリードが持ち味。" },
                { name: "山岡 陸", year: 3, position: "サード", desc: "稲実の新たな4番打者。勝負強いクラッチヒッター。高校通算61本。" }
            ]
        },
        "藤枝明誠": {
            summary: "史上最強の『黄金世代』。投打の柱・猪狩兄弟を擁し、個の力で世代の頂点を証明する。雑草軍団が狙うは完全優勝。スローガンは『実力主義』。",
            players: [
                { name: "猪狩 守", year: 3, position: "ピッチャー", desc: "「黄金世代」を率いるキャプテンにして絶対的エース。「ライジングキャノン」と呼ばれる剛速球が武器。" },
                { name: "猪狩 進", year: 2, position: "キャッチャー", desc: "兄・守とバッテリーを組む天才捕手。「球界の頭脳」と称されるリードと俊足が武器。" },
                { name: "三本松 一", year: 3, position: "ファースト", desc: "不動の4番。高校生離れしたパワーを誇る規格外の長距離砲。" },
                { name: "七井将暉", year: 3, position: "レフト", desc: "三本松と双璧をなす長距離砲。広角に打ち分ける技術と「バズーカ」強肩も。" },
                { name: "矢部 翔雄", year: 3, position: "センター", desc: "俊足が武器の外野手。意外な勝負強さも見せる。" }
            ]
        }
    };
    const INITIAL_TEAM_POOL = Object.keys(TEAM_DATA);

    // --- Utility & State Functions ---
   

 function shuffleArray(array) {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
    }
    
    function saveState() {
        try {
            localStorage.setItem('tournamentState', JSON.stringify(tournamentState));
        } catch (e) {
            console.error("進行状況の保存に失敗しました:", e);
            showAlert("進行状況の保存に失敗しました。ブラウザのストレージ容量が不足している可能性があります。");
        }
    }
    
    function uint8ArrayToBase64(bytes) {
        let binary = '';
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    function getRankFromHistoryString(historyString) {
        if (historyString.includes('優勝')) return 1;
        if (historyString.includes('準優勝')) return 2;
        if (historyString.includes('ベスト4')) return 4;
        if (historyString.includes('ベスト8')) return 8;
        if (historyString.includes('ベスト16')) return 16;
        if (historyString.includes('3回戦')) return 16;
        if (historyString.includes('2回戦')) return 32;
        if (historyString.includes('初戦敗退')) return 64;
        return 64;
    }

    function getRankString(rank) {
 // ★★★ このifブロックを関数の先頭に追加 ★★★
    if (rank <= -1) {
        for (const key in KOSHIEN_RESULTS) {
            if (KOSHIEN_RESULTS[key].rank === rank) {
                return KOSHIEN_RESULTS[key].label;
            }
        }
    }
    // ★★★ ここまで追加 ★★★
        if (rank === 1) return "優勝";
        if (rank === 2) return "準優勝";
        if (rank <= 4) return "ベスト4";
        if (rank <= 8) return "ベスト8";
        if (rank <= 16) return "ベスト16";
        if (rank <= 32) return "3回戦敗退";
        if (rank <= 64) return "2回戦敗退";
        return "初戦敗退";
    }
// --- Utility & State Functions --- などに追加

/**
 * Creates a subtle, realistic dust particle animation.
 */
function createDustEffect() {
    const container = document.getElementById('dust-container');
    if (!container) return;
    
    const particleCount = 20; // The number of dust particles

    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'dust-particle';
        
        const size = Math.random() * 3 + 1; // Particle size between 1px and 4px
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // Use CSS variables to randomize the start and end points of the animation
        particle.style.setProperty('--x-start', `${Math.random() * 100}vw`);
        particle.style.setProperty('--x-end', `${Math.random() * 100}vw`);
        
        particle.style.animationDuration = `${Math.random() * 20 + 10}s`; // Duration between 10s and 30s
        particle.style.animationDelay = `${Math.random() * 10}s`; // Stagger the start time
        
        container.appendChild(particle);
    }
}
/**
 * スコアボードの合計点を更新する
 */
/**
/**
 * スコアボードの合計点を更新する
 */
function updateTotalScores() {
    const table = document.getElementById('inning-score-table');
    if(!table) return;

    table.querySelectorAll('tbody tr').forEach(row => {
        const total = Array.from(row.querySelectorAll('input')).reduce((sum, input) => {
            const value = parseInt(input.value);
            return isNaN(value) ? sum : sum + value;
        }, 0);
        
        const totalCell = row.querySelector('.total-score');
        if (totalCell) {
            totalCell.textContent = total;
        }
    });
}
/**
 * 戦績レコードを読みやすい文字列に変換する
 */
function formatRecordToString(record) {
    if (!record) return "データなし";
    const year = record.year.toString().slice(-2);
    const tournamentNameMap = { summer: '夏', autumn: '秋', spring: '春' };
    const tournament = tournamentNameMap[record.tournament] || '';
    const rank = getRankString(record.rank);
    // ★★★ 以下の行を変更 ★★★
    const prefix = record.rank < 0 ? '' : '県大会'; // 甲子園成績の場合は「県大会」をつけない
    return `'${year} ${tournament}: ${prefix}${rank}`;
    // ★★★ ここまで変更 ★★★
}

// AI Content Generation & Helpers のセクションに追加

/**
 * チームの今大会の軌跡を要約する
 * (★試合ごとの記録を参照して、正確に猛打賞を判断する最終版)
 */
function getCurrentTournamentPerformance(teamName, currentMatchId) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) return "今大会初戦。";

    const path = [];
    const keyPerformances = new Set();
    const currentTournamentMatchIds = Object.keys(tournamentState.matches);

    for (const matchId of currentTournamentMatchIds) {
        if (matchId === currentMatchId) continue;
        const match = tournamentState.matches[matchId];
        
        if (match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            const opponent = match.team1 === teamName ? match.team2 : match.team1;
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 1;
            
            if (match.winner === teamName) {
                path.push(`${roundNum}回戦 vs ${opponent}`);
            }

            if (match.details) {
                const teamKey = match.team1 === teamName ? 'team1' : 'team2';
                
                // 投手の好投
                const pitchers = match.details.pitching?.[teamKey] || [];
                pitchers.forEach(p => {
                    if (p.name && p.result === 'W' && parseFloat(p.innings) >= 6) {
                        keyPerformances.add(`${p.name}が${roundNum}回戦で好投`);
                    }
                });

                // 保存された「試合ごとの成績」を参照して猛打賞を判断
                if (match.details.playerGameStats) {
                    const gameStats = match.details.playerGameStats[teamKey];
                    for (const playerName in gameStats) {
                        // この試合で3安打以上打っていたかをチェック
                        if (gameStats[playerName].h >= 3) {
                            keyPerformances.add(`${playerName}が${roundNum}回戦で猛打賞を記録`);
                        }
                    }
                }
            }
        }
    }
    
    let summary = "";
    if (path.length === 0) {
        return "今大会初戦。";
    } else {
        summary += `ここまでの勝ち上がり: ${path.join(' → ')}。`;
    }
    
    // 大会通算打率の分析
    const playerBattingStats = teamRecord.playerStats?.batting || {};
    for (const playerName in playerBattingStats) {
        const stats = playerBattingStats[playerName];
        if (stats.ab >= 5) { // 5打数以上の選手を対象
            const battingAverage = stats.h / stats.ab;
            if (battingAverage >= 0.4) {
                keyPerformances.add(`${playerName}が打率4割超えと絶好調`);
            } else if (battingAverage <= 0.2) {
                keyPerformances.add(`${playerName}が打率2割以下と不振`);
            }
        }
    }
    
    if (keyPerformances.size > 0) {
        summary += `今大会の主な活躍: ${Array.from(keyPerformances).join('、')}。`;
    }

    return summary;
}

// ▼▼▼ このブロックをまるごと追加 ▼▼▼

// ▼▼▼ この関数をまるごと追加 ▼▼▼
/**
 * 本格的なまとめサイトのHTMLを、現実と架空のニュースを融合させて生成する（エラー修正・ダミーデータ強化版）
 * @returns {Promise<string>} 生成されたHTML文字列
 */
/**
 * 本格的なまとめサイトのHTMLを、サーバーと通信して生成する（複数カテゴリ対応・最終版）
 * @returns {Promise<string>} 生成されたHTML文字列
 */
async function generateMatomeSiteHtml() {
    let articles = [];
    
    // --- 1. 強化されたサーバー機能に、現実のニュースをまとめてリクエスト ---
    try {
        const response = await fetch('/.netlify/functions/get-news');
        if (!response.ok) {
            throw new Error(`サーバーエラー: ${response.status}`);
        }
        const realNewsArticles = await response.json();
        articles.push(...realNewsArticles);

    } catch (e) {
        console.error("サーバーからのニュース取得に失敗しました:", e);
        articles.push({ headline: "【速報】ニュースサーバー、ダウン中", type: 'real', timestamp: Date.now(), category: 'システム' });
    }

    // --- 2. ゲーム内のニュースを取得 ---
    const gameNewsList = tournamentState.news || [];
    gameNewsList.filter(n => n.context && n.context.dbMatch).slice(-5).forEach(gameNews => {
        const { winnerName, loserName, dbMatch } = gameNews.context;
        const winnerRank = calculateRank(winnerName, tournamentState);
        const loserRank = calculateRank(loserName, tournamentState);
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        let gameTitle = `【高校野球】${winnerName}が${loserName}に勝利！`;

        if (rankValues[winnerRank] < rankValues[loserRank]) {
            gameTitle = `【超絶悲報】${loserName}(${loserRank}ランク)、格下の${winnerName}(${winnerRank}ランク)に負けるｗｗｗｗ`;
        } else if ((parseInt(dbMatch.score1) + parseInt(dbMatch.score2)) > 15) {
            gameTitle = `【乱打戦】${winnerName}vs${loserName}、とんでもない試合になる`;
        }
        
        articles.push({
            headline: gameTitle,
            type: 'game',
            matchId: dbMatch.id,
            timestamp: gameNews.timestamp,
            category: '高校野球'
        });
    });

    // --- 3. 全記事をタイムスタンプでソートしてHTMLを生成 ---
    articles.sort((a, b) => b.timestamp - a.timestamp);

    if (articles.length === 0) {
        return '<p class="text-center text-gray-500">まだ表示できるニュースがありません。</p>';
    }

    const categoryColors = {
        "高校野球": "bg-green-100 text-green-800",
        "スポーツ": "bg-blue-100 text-blue-800",
        "エンタメ": "bg-pink-100 text-pink-800",
        "国内": "bg-indigo-100 text-indigo-800",
        "国際": "bg-teal-100 text-teal-800",
        "経済": "bg-yellow-100 text-yellow-800",
        "IT": "bg-purple-100 text-purple-800",
        "科学": "bg-gray-200 text-gray-800",
        "主要": "bg-red-100 text-red-800",
    };

    return articles.map(article => {
        const time = new Date(article.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
        const commentCount = Math.floor(Math.random() * 800) + 50;
        const color = categoryColors[article.category] || "bg-gray-100 text-gray-800";

        // ▼▼▼ aタグのhref属性などを修正 ▼▼▼
        // ▼▼▼ このブロックが修正の核心です ▼▼▼
         // ▼▼▼ このブロックが修正の核心です ▼▼▼
        const linkHref = article.type === 'real' ? `href="${article.url}" target="_blank" rel="noopener noreferrer"` : 'href="javascript:void(0)"';
        const dataAttributes = `data-headline="${article.headline}" data-type="${article.type}" data-category="${article.category}" data-match-id="${article.matchId || ''}"`;

        return `
            <a ${linkHref} class="matome-article-link block p-3 rounded-lg hover:bg-gray-100 transition-colors" ${dataAttributes}>
                <div class="flex items-center text-xs text-gray-500">
                    <span class="font-bold py-0.5 px-2 rounded-full ${color}">${article.category}</span>
                    <span class="ml-auto">${time}</span>
                </div>
                <p class="font-bold text-gray-800 mt-2 text-base">${article.headline}</p>
                <div class="text-right text-xs text-gray-500 mt-1">コメント: ${commentCount} 💬</div>
            </a>
        `;
        // ▲▲▲
    }).join('');
}


/**
 * ゲーム内の試合結果に対する、なんJまとめサイト風のスレッドをAIに生成させる（★善戦評価ロジック・最終版）
 */
async function generateGameMatchBbsComments(matchContext) {
    // contextから必要な基本情報を取り出す
    const { winnerName, loserName, dbMatch, playerStatsText, playByPlayText, winnerJourney, loserJourney, nextOpponent, nextOpponentJourney, winnerLineupChanges, loserLineupChanges } = matchContext;
    const score = `${dbMatch.score1}-${dbMatch.score2}`;

    // ★★★ ここからが修正箇所 ★★★
    // この関数内で、プロンプトに必要な情報を改めて生成する
    const winnerData = TEAM_DATA[winnerName];
    const loserData = TEAM_DATA[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, tournamentState.teamRecords[winnerName]);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, tournamentState.teamRecords[loserName]);
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);

    // ★★★ ここからが修正箇所 ★★★
    // 次の対戦相手に関するテキストを、3つのパターンに応じて準備する
    let nextOpponentText = '次の相手は未定やな。'; // デフォルト (なんJ風の語尾)
    if (nextOpponent) {
        // パターン1: 対戦相手が決まっている場合
        if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            nextOpponentText = `次の${nextOpponent.roundName}の相手は${nextOpponent.opponentName}(ランク:${nextOpponent.opponentRank})か。`;
        }
        // パターン2: 対戦相手は未定だが、どの試合の勝者と当たるか分かっている場合
        else if (nextOpponent.decidingMatch) {
            const dm = nextOpponent.decidingMatch;
            nextOpponentText = `次の${nextOpponent.roundName}の相手は、${dm.team1}(${dm.rank1}ランク)と${dm.team2}(${dm.rank2}ランク)の勝者やな。`;
        }
    }
    const nextOpponentJourneyText = (nextOpponent && nextOpponentJourney)
        ? `ちなみに、その${nextOpponent.opponentName}のここまでの軌跡は「${nextOpponentJourney}」。`
        : '';
    // ★★★ 修正箇所はここまで ★★★

    // ★★★ 生データの説明を追加 ★★★
    let rawResultsDescription = '詳細な打席ごとのデータはありません。';
    if (matchContext.rawBattingResults) { // matchContextからrawBattingResultsを参照
        rawResultsDescription = `
### データ4：生の打席結果データ (イニングごとの全記録)
- 各チームの選手ごとに、イニングごとの打席結果が文字列配列で記録されています。
- 配列のインデックス+1がイニング数です (例: results[0] は1回の結果)。
- 1イニングに複数打席ある場合は「、」で区切られます。
- 1打席の結果は「打撃結果;走塁結果1,走塁結果2...」の形式です (例: "中安1点;田中 進塁 二塁へ,佐藤 生還")。
- team1 (${dbMatch.team1}): ${JSON.stringify(matchContext.rawBattingResults.team1)}
- team2 (${dbMatch.team2}): ${JSON.stringify(matchContext.rawBattingResults.team2)}`;
    }
    // ★★★ ここまで追加 ★★★


    const prompt = `あなたは、静岡県の高校野球を長年見続けている、なんJの玄人野球ファンです。あなたは特に「背番号」が持つ意味に詳しく、選手の背景を深く読み解きます。
以下の試合データを多角的に分析し、玄人たちのリアルな会話を35個前後生成してください。

### 参考情報：高校野球における背番号の意味
- **[#1]**: チームの絶対的エース投手。
- **[#2-9]**: 基本的にレギュラーの野手陣（正捕手、内野手、外野手）。
- **[#10], [#11]**: エースに次ぐ控え投手。
- **[#12]以降**: 控え選手。時に監督の秘蔵っ子や、期待の1・2年生が含まれる。

### データ1：前試合からのスタメン変更
- **${winnerName}**: ${winnerLineupChanges || '情報なし'}
- **${loserName}**: ${loserLineupChanges || '情報なし'}

### データ2：試合結果
- **勝利:** ${winnerName} (ランク: ${winnerRank})
- **敗北:** ${loserName} (ランク: ${loserRank})
- **スコア:** ${score}
- **ユーザーによる試合の決め手:** ${dbMatch.summary || '特になし'}

### チームの背景
- **${winnerName}**: ${winnerDynamicInfo}
- **${loserName}**: ${loserDynamicInfo}

### データ3：この試合の個人成績 (最終結果)
${playerStatsText || '詳細な個人成績データはありません。'}

${rawResultsDescription}

### 参考情報：トーナメント全体の状況
- **${winnerName}の軌跡**: ${winnerJourney || '今大会初戦'}
- **次の試合**: ${nextOpponentText} ${nextOpponentJourneyText}

### 指示
あなたは今、上記の全データを眺めながら、他のファンと会話しています。以下の指示に従って、リアルなコメントを生成してください。

1.  **【超重要：高度な分析】**
    「データ3：最終成績」と**「データ4：生の打席結果データ」**を比較し、最終成績が良い選手でもチャンスで凡退していないかなど、結果だけでは分からない深い分析コメントを生成してください。（例：「品川は4打数2安打やけど、データ4見たらチャンスで三振しとるからワイは評価せん」）

2.  **【善戦の評価】** ★★★この指示ブロックが新しい機能です★★★
    もし**ランクの低いチーム（敗北側）がランクの高いチーム（勝利側）相手に善戦（例：5点差以内での敗北、または生の打席結果データから読み取れる終盤までの接戦）**した場合、その健闘を称えるコメントを必ず含めてください。
    - 例：「負けはしたけど、格上相手によくやったわ」「〇〇（敗北校）は来年期待できるな」「まさかここまで苦戦するとは思わなかった」

3.  **【プレーへの言及】**
    **「データ4：生の打席結果データ」**から印象的なプレーを抜き出し、「〇回の△△のプレー（例：中安1点）は良かった/悪かった」といった、特定のプレーに言及するコメントを生成してください。

4.  **【次戦の展望】**
    「参考情報」を元に、次の対戦相手の強さや勝ち上がり方に触れ、「次は厳しい」「相手も苦戦しとるからワンチャンある」といった、次戦を予想する会話を生成してください。

5.  その他、なんJらしい煽り、称賛、達観したコメントなどを自由に織り交ぜてください。安価（>>）を使った会話も必ず含めてください。

6. ランク名をそのまま使うのではなく、eランクは無名校、dランクは挑戦校、cランクは中堅校、bランクは強豪校、Aランクは名門校と言い換えてください。

7. #は背番号と言い換えてください。(#1→背番号1)

### 出力形式【最重要】
解説や前置きは一切不要です。必ず以下のJSON形式"のみ"で出力してください。
{
  "threadTitle": "（生成したスレッドタイトル）",
  "comments": [
    {"personality": "1: 風吹けば名無し", "comment": "（スレ主のコメント）"},
    {"personality": "2: 風吹けば名無し", "comment": "（住民2のコメント）"}
  ]
}`;

    // AIへのリクエスト部分は変更なし
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const bbsJson = parseJsonFromText(rawText);
            if (bbsJson && bbsJson.threadTitle && Array.isArray(bbsJson.comments)) {
                return {
                    title: bbsJson.threadTitle,
                    comments: bbsJson.comments.map(c => ({
                        id: crypto.randomUUID(),
                        personality: c.personality,
                        text: c.comment,
                        timestamp: Date.now()
                    }))
                };
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI game match BBS generation failed:", error);
        return null;
    }
}

/**
 * 現実のニュースヘッドラインに対する、なんJ風の掲示板コメントをAIに生成させる
 * @param {string} headline - 現実のニュースの見出し
 * @param {string} category - ニュースのカテゴリ
 * @returns {Promise<Array|null>} コメントオブジェクトの配列
 */
async function generateRealNewsBbsComments(headline, category) {
    let personaPrompt = `あなたは、日本の匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは少し皮肉屋で、ネットスラングを多用し、あらゆる話題に短いコメントを書き込みます。`;
    let instructions = ``;
    switch (category) {
        case '政治': instructions = `政治ニュースに詳しい住民として、与党や野党を煽ったり、将来を悲観したり、達観したようなコメントをしてください。`; break;
        case '芸能': instructions = `芸能ニュースが大好きな野次馬として、「〇〇ロスだわ」「どうせすぐ別れる」といった、お祝いと嫉妬が入り混じったコメントをしてください。`; break;
        case '学歴': instructions = `学歴コンプレックスを持つ住民として、「F欄のワイ、高みの見物」「結局は学歴よりコミュ力」といった、自虐や持論を展開してください。`; break;
        default: instructions = `一般的な住民として、ニュースに反応してください。`; break;
    }
    
    const prompt = `${personaPrompt}

以下の【${category}】のニュースヘッドラインについて、**リアルタイムでスレッドが進行していくかのように**、自然な流れで**30〜35個**の掲示板の反応を生成してください。

### ニュースヘッドライン
${headline}

### スレッド進行の指示
1.  **序盤 (1〜5レス):** スレ主の投稿に対し、即座に食いつく第一陣の反応。「マジか」「草」「また〇〇か」といった短いコメントが中心。
2.  **中盤 (6〜15レス):** 少し冷静になった住民たちが、ニュースに対して様々な角度からコメントを始める。肯定、否定、煽り、全く関係ない脱線などを織り交ぜる。**「>>1」「>>5」のような安価（アンカー）を使って、他のコメントに返信するやり取りを必ず含めること。**
3.  **終盤 (16レス以降):** ある程度議論が出尽くした後の、まとめのようなコメントや、飽きてきた住民によるおふざけが始まる。
4.　**最終盤 (26レス以降):** スレも混沌としてきて、関係ない話題を持ってくる者や、勝手にコンプレックスを刺激され発狂するもの、ただの荒らしなどが湧き始め、グダグダになり解散する。


### 出力形式（JSON配列）
[
    {"personality": "1: 風吹けば名無し", "comment": "（スレ主のコメント）"},
    {"personality": "2: 風吹けば名無し", "comment": "（住民2のコメント）"},
    {"personality": "3: 風吹けば名無し", "comment": "（住民3のコメント）"},
    ...
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now()
                }));
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI real news BBS generation failed:", error);
        return null;
    }
}
// ▲▲▲ ここまで追加 ▲▲▲

// ▲▲▲ ここまで追加 ▲▲▲

/**
 * 指定されたチームが次に出場する、まだ終わっていない試合を探す
 * @param {string} teamName - 探したいチーム名
 * @param {object} state - 現在のtournamentState
 * @returns {object|null} - 見つかった試合オブジェクト、またはnull
 */
function findCurrentMatchForTeam(teamName, state) {
    const allMatches = { ...state.matches, ...(state.autumnData?.allMatches || {}), ...(state.springData?.allMatches || {}) };
    let earliestMatch = null;
    let minRound = Infinity;

    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (!match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 0;
            if (roundNum < minRound) {
                minRound = roundNum;
                earliestMatch = match;
            }
        }
    }
    return earliestMatch;
}



/**
 * トーナメントの勝者を次のラウンドに進める（processMatchWinから抜粋・改造）
 * @param {object} match - 終了した試合のオブジェクト
 * @param {string} winnerName - 勝者名
 * @param {object} state - 現在のtournamentState
 */
function advanceWinnerToNextRound(match, winnerName, state) {
    const matchId = match.id;
    const idParts = matchId.split('-');
    const side = idParts[0];

    if (side === 'F') return; // 決勝戦なら何もしない

    const roundStr = idParts[1];
    const roundNum = parseInt(roundStr.slice(1));
    
    // このロジックは夏季・春季県大会（16 or 64チーム）を想定
    if (state.teams && state.teams.length > 0) {
        const numTeamsInTournament = state.teams.length;
        const finalRound = Math.log2(numTeamsInTournament);

        if (roundNum < finalRound) {
            const matchNum = parseInt(idParts[2].slice(1));
            const nextRoundNum = roundNum + 1;
            let nextMatchId = (nextRoundNum === finalRound) ? 'F-R1-M1' : `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
            
            if (!state.matches[nextMatchId]) {
                state.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
            }
            let slot = (nextRoundNum === finalRound) ? (side === 'L' ? 1 : 2) : (matchNum % 2 !== 0 ? 1 : 2);
            state.matches[nextMatchId][`team${slot}`] = winnerName;
        }
    }
    // TODO: 秋季大会などの複雑な進行ロジックが必要な場合は、ここに追加する
}

// ▲▲▲ ここまで追加 ▲▲▲


/**
 * 密着ドキュメンタリーを開始し、序章の記事を生成する
 * @param {'underdog' | 'powerhouse'} type - ドキュメンタリーの種類
 * @param {string} teamName - 取材対象のチーム名
 */
async function startDocumentary(type, teamName) {
    tournamentState.documentary = { target: teamName, type: type };
    newsContainer.innerHTML = `<div class="loader">AI記者が「${teamName}」の特別ドキュメンタリー番組の制作を開始しました...</div>`;
    
    renderTournament(tournamentState); 

    const firstMatch = Object.values(tournamentState.matches).find(m => 
        m.id.includes('-R1-') && (m.team1 === teamName || m.team2 === teamName)
    );
    
    let matchDataForArticle = { 
        opponent: '不明', opponentRank: 'E', opponentRecord: '情報なし',
        toughestRival: '不明', toughestRivalRecord: '情報なし'
    };

    if (firstMatch) {
        const opponentName = firstMatch.team1 === teamName ? firstMatch.team2 : firstMatch.team1;
        matchDataForArticle.opponent = opponentName;
        matchDataForArticle.opponentRank = calculateRank(opponentName, tournamentState);
        
        // ▼▼▼ ここからが新しい処理 ▼▼▼
        // 相手の昨年の成績をTEAM_DATAから直接取得
        matchDataForArticle.opponentRecord = TEAM_DATA[opponentName]?.last || '情報なし';

        const teamIndex = tournamentState.teams.indexOf(teamName);
        const blockIndex = Math.floor(teamIndex / 16);
        const blockStart = blockIndex * 16;
        const blockEnd = blockStart + 16;
        const blockTeams = tournamentState.teams.slice(blockStart, blockEnd);
        
        let toughestRivalName = null;
        let highestRankValue = -1;
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };

        blockTeams.forEach(rivalName => {
            if (rivalName === teamName) return;
            const rivalRank = calculateRank(rivalName, tournamentState);
            if (rankValues[rivalRank] > highestRankValue) {
                highestRankValue = rankValues[rivalRank];
                toughestRivalName = rivalName;
            }
        });
        
        if (toughestRivalName) {
            matchDataForArticle.toughestRival = toughestRivalName;
            // 最強ライバルの昨年の成績もTEAM_DATAから直接取得
            matchDataForArticle.toughestRivalRecord = TEAM_DATA[toughestRivalName]?.last || '情報なし';
        }
        // ▲▲▲
    }
    
    const article = await generateDocumentaryArticle('intro', type, teamName, matchDataForArticle);
    
    // ▲▲▲

    if (article) {
        tournamentState.news.push(article);
    } else {
        // 失敗した場合、再生成に必要な情報を「context」として保存する
        tournamentState.news.push({
            title: "ドキュメンタリー記事生成エラー",
            body: `「${teamName}」のドキュメンタリー記事の生成に失敗しました。`,
            timestamp: Date.now(),
            error: true,
            // ★★★ ここからが重要 ★★★
            context: {
                isDocumentary: true, // ドキュメンタリーであるという目印
                type: type,
                teamName: teamName,
                matchData: matchDataForArticle
            }
            // ★★★ ここまで ★★★
        });
    }
    renderNews(tournamentState.news);
    saveState();
}


async function generateDocumentaryArticle(phase, type, teamName, matchData = null, userFeedback = null) {
    const teamMasterData = TEAM_DATA[teamName];
    let prompt = `あなたは、情熱的で人間ドラマを描くのが得意なドキュメンタリー番組の記者です。あなたは今、高校野球チーム「${teamName}」に密着取材しています。`;
    let title = "";

    let charactersPrompt = `### 主な登場人物\n- 監督: ${teamMasterData.coach.name} (${teamMasterData.coach.style})\n`;
    if (DETAILED_TEAM_DATA[teamName]) {
        const detailedData = DETAILED_TEAM_DATA[teamName];
        const keyPlayers = detailedData.players.map(p => `- ${p.name}(${p.year}年, ${p.position}): ${p.desc}`).join('\n');
        charactersPrompt += `### 注目選手\n${keyPlayers}\n`;
    }
    
    let feedbackPrompt = '';
    if (userFeedback) {
        if (userFeedback.include && userFeedback.include.trim() !== '') {
            feedbackPrompt += `\n- **【最重要指示】** 以下の要素を必ず記事の中心に据えて、最もドラマチックに描写してください：\n${userFeedback.include}\n`;
        }
        if (userFeedback.exclude && userFeedback.exclude.trim() !== '') {
            feedbackPrompt += `\n- **【厳禁事項】** 以下の要素や表現は、絶対に記事に含めないでください：\n${userFeedback.exclude}\n`;
        }
    }
    const finalFeedbackPrompt = `\n### ディレクターからの追加指示\n${feedbackPrompt || '特になし'}`;

    // ==================================================================
    // --- 1. 古豪復活チーム (powerhouse_revival) ---
    // ==================================================================
    if (type === 'powerhouse_revival') {
        switch (phase) {
            case 'intro':
                title = `『${teamName}、復活への序曲』`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 1) { // 格上
                        reactionPrompt = `
5.  **【試練の初戦】**
    初戦の相手が格上の「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちが「不足はない相手」「復活をアピールするには最高の相手だ」と闘志を燃やす。
6.  **【監督の『建前』と『本音』】**
    監督は**選手たちの前で**、「挑戦者として、失うものは何もない。全力でぶつかるぞ」という趣旨で語る。
    しかし記者の前では**二人きりで**、「本当の山場は**${matchData.toughestRival}**戦でしょう。彼らは昨年${matchData.toughestRivalRecord}。この初戦は、そこへ向けてチームがどれだけ成長できるかの試金石ですね」という趣旨で、冷静に先を見据える。`;
                    } else { // 同格か格下
                        reactionPrompt = `
5.  **【油断という名の敵】**
    初戦の相手が「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。「勝てる」という安堵の空気が選手たちの間に流れる。
6.  **【監督の『建前』と『本音』】**
    その空気を察した監督が**選手たちの前で**、「油断が一番の敵だ。俺たちはまだ何も成し遂げていない」という趣旨で厳しく一喝する。
    しかし、記者の前では**二人きりで**、「正直、ホッとしました。**${matchData.toughestRival}**（彼らは昨年${matchData.toughestRivalRecord}）と当たるまでに、いくつか試合をこなして練度を上げたかったので」という趣旨で、安堵の理由が戦略的なものであることを明かす。`;
                    }
                }
                prompt += `
### 取材テーマ
かつて黄金時代を築いた古豪「${teamName}」が、失われた栄光を取り戻すべく挑む夏を追う。過去、現在、そして未来が交錯する物語の序章を描いてください。
${charactersPrompt}
### 構成案
1.  **【埃をかぶった優勝旗】**: 部室に眠る色褪せた優勝旗やトロフィーの描写から始める。過去の栄光の重圧と、現在のチームが置かれた状況（${teamMasterData.info}）を対比させる。
2.  **【OBたちの熱き眼差し】**: 練習を厳しい目で見つめるOB会長に「俺たちの時代は…」という昔語りと、現在のチームへの歯がゆさ、そして心の底にある期待を語らせる。
3.  **【重圧を背負う主将】**: 主将に「このユニフォームを着て戦うことの意味」を問う。伝統の重みと、それを力に変えようとする彼の覚悟を描写する。
4.  **【監督の信念と現実】**: 監督に「古豪復活への道筋」をインタビューする。OBからのプレッシャーの中で、彼が信じる今の選手たちの可能性と、現在の課題について語らせる。
${reactionPrompt}
7.  **【新たな歴史へ】**: 主将の「俺たちは俺たちの野球で、新しい歴史を作るだけ」という言葉で、復活をかけた夏の始まりを力強く宣言して締めくくる。
### 描写のポイント
- 時間軸の意識: 「過去の栄光」「現在の葛藤」「未来への挑戦」を意識し、物語に深みを与えること。
- 建前と本音: 監督の二面性を描くことで、キャラクターのリアリティを追求すること。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、復活への第一歩』`;
                prompt += `
### 取材テーマ
古豪「${teamName}」が ${matchData.opponent} との試合に ${matchData.score} で勝利しました。「名門復活への狼煙」となるこの一勝の価値を、感動的に描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」を物語の中心に据え、その場面を最もドラマチックに描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、この勝利の価値をより高める。
3.  監督に「伝統の粘り強さが出せた」という趣旨のコメントをさせる。
4.  主将に、次戦への意気込みと共に「先輩たちが築いた歴史に、新たな1ページを刻みたい」と語らせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、夢、またも届かず』`;
                prompt += `
### 取材テーマ
古豪「${teamName}」の夏が終わりを告げた。復活を願った人々の期待と、それに応えられなかった選手たちの無念さを描いてください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにしてチームの夢を打ち砕いたかを詳細に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、敗北の文脈をより深く描写する。
3.  グラウンドに泣き崩れる選手たちと、彼らにかける言葉が見つからない監督の姿。
4.  「彼らの挑戦は終わった。しかし、〇〇（校名）の野球部の灯が消えることはない」と、未来への希望で締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } 
    // ==================================================================
    // --- 2. 絶対的エースチーム (one_man_team) ---
    // ==================================================================
    else if (type === 'one_man_team') {
        switch (phase) {
            case 'intro':
                title = `『${teamName}のエースと、8人の仲間たち』`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 2) { // 絶望的な格上
                        reactionPrompt = `
5.  **【試される『個』の力】**
    初戦の相手が格上の強豪「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。野手たちが動揺する中、エースだけが「相手が誰であろうと、俺がゼロに抑えるだけです」という趣旨のコメントで闘志を燃やす。
6.  **【監督の『建前』と『本音』】**
    監督は**選手たちの前で**、「最高の相手だ。我々には〇〇（エース名）がいる。彼を信じろ」という趣旨のコメントで、エースへの絶対的な信頼を口にする。
    しかし記者の前では**二人きりで**、「正直、最悪のクジです。彼（エース）の負担を考えれば、勝ち進んだ先の**${matchData.toughestRival}**（昨年${matchData.toughestRivalRecord}）戦まで、他の選手に経験を積ませたかった」という趣旨のコメントで、チーム全体の成長を願う本音を漏らす。`;
                    } else { // 同格か格下
                        reactionPrompt = `
5.  **【エース温存か、否か】**
    初戦の相手が「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちの間に「この相手なら、エース抜きでも勝てるのでは？」という慢心が生まれる。
6.  **【監督の『賭け』】**
    監督が**選手たちの前で**、「初戦、〇〇（エース名）は投げない。お前たちで勝ち上がってこい」という趣旨の、非情とも思える決断を下す。
    記者の前では**二人きりで**、「これは賭けです。でも、**${matchData.toughestRival}**（昨年${matchData.toughestRivalRecord}）と戦うことを見据えれば、ここで他の選手が覚醒しなければ未来はない」という趣旨のコメントで、エースの将来とチームの未来を想う本音を語らせる。`;
                    }
                }
                prompt += `
### 取材テーマ
プロ注目の絶対的エースを擁する「${teamName}」。天才の苦悩と、彼を支える「その他大勢」と呼ばれた仲間たちのプライドを描く。
${charactersPrompt}
### 構成案
1.  **【殺到する報道陣】**: 練習グラウンドに集まる、エースだけを狙う無数のカメラの描写から始める。
2.  **【エースの孤独なマウンド】**: エースにインタビュー。「チームを勝たせるのが自分の仕事」と語る彼の言葉の裏にある、重いプレッシャーを描写する。
3.  **【名もなき脇役たちの意地】**: メディアからは注目されない他の野手たちに焦点を当てる。「俺たちは、あいつの引き立て役じゃない」という、彼らの静かなプライドと葛藤を引き出す。
4.  **【監督の信念】**: 監督に「彼らはワンマンチームですか？」と問う。「世間はそう言うだろう。だが、本当の主役が誰なのかを私だけは知っている」という趣旨の意味深な言葉を語らせる。
${reactionPrompt}
7.  **【一つのチームとして】**: 野手の一人が「俺たちが、あいつを甲子園のマウンドに連れて行く」と力強く宣言し、物語を締めくくる。
### 必ず含めるべき要素
- **チームが抱える状況を描写すること: ${teamMasterData.info}**
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `エース快投！しかし、勝利の影に${teamName}の結束あり`;
                prompt += `
### 取材テーマ
「${teamName}」が勝利。メディアはエースの快投ばかりを報じるだろう。しかし、その裏にあった仲間たちのファインプレーやチームの結束こそが真の勝因だったことを、あなたの視点で深く描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにチームの結束力を象徴するプレーだったかを物語の中心に据える。
2.  エースの投球内容を簡潔に紹介しつつ、「しかし、この日の主役は彼だけではなかった」と続ける。
3.  そのプレーをした選手に「エースを助けるのが俺たちの仕事ですから」と、誇らしげに語らせる。
4.  エースに「今日の勝利は、俺一人の力じゃない。みんなが守ってくれたおかげです」と、初めて仲間に感謝の言葉を述べさせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `英雄、あまりに早すぎる敗退。${teamName}の夏、終わる`;
                prompt += `
### 取材テーマ
絶対的エースを擁しながら、「${teamName}」は敗れた。天才と仲間たちの、残酷で、しかし美しい夏の終わりを描いてください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにして絶対的エースを打ち崩したのか、その一瞬を詳細に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れることで、敗北の衝撃を際立たせる。
3.  マウンドで呆然とするエースと、彼に駆け寄り「お前のせいじゃない」と声をかける仲間たちの姿を描く。
4.  「彼らはワンマンチームではなかった。勝つ時も、負ける時も、彼らは一つのチームだった」と締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } 
    // ==================================================================
    // --- 3. 強豪校 (powerhouse) ---
    // ==================================================================
    else if (type === 'powerhouse') {
        switch (phase) {
            case 'intro':
                title = `『${teamName}、王者の告白』序章`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 0) { // 同格か格上
                        reactionPrompt = `
5.  **【試される王国】**
    初戦の相手がいきなり実力校「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちの間に走る緊張感を「歓迎すべき試練」として描写する。
6.  **【監督の『建前』と『本音』】**
    監督は**選手たちの前で**、「初戦から最高の相手だ。挑戦者を受ける覚悟はできている」という趣旨で、チームのプライドを煽る。
    しかし記者の前では**二人きりで**、「厳しい戦いになる。だが、このブロックの本命は我々と**${matchData.toughestRival}**。彼らは昨年${matchData.toughestRivalRecord}。倒すためには、どこかで通らなければいけない道だ」という趣旨で、厳しい本音を語らせる。`;
                    } else { // 格下
                        reactionPrompt = `
5.  **【王者の静寂】**
    初戦の相手が「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちは表情一つ変えず、淡々と次の練習の準備を始める。
6.  **【監督の『建前』と『本音』】**
    監督が**選手たちの前で**は「油断するな」という趣旨で引き締めつつ、記者の前では**二人きりで**、「初戦は問題ない。本当の勝負は**${matchData.toughestRival}**戦。彼らは昨年${matchData.toughestRivalRecord}の実力校だ。そこが事実上の決勝戦になるだろう」という趣旨で、先を見据えた分析を語らせる。`;
                    }
                }
                prompt += `
### 取材テーマ
絶対的王者「${teamName}」の栄光の裏に隠された苦悩と、常人には理解しがたいプレッシャーを描く。
${charactersPrompt}
### 構成案
1.  **【静寂のトロフィー室】**: 無数に並ぶ優勝トロフィーが放つ輝きと、「勝って当然」という重圧を描写する。
2.  **【Bグラウンドの陽炎】**: ベンチ入りできなかった3年生が、最後の夏にも関わらず、黙々と後輩へのサポートを務める。彼の「チームへの愛」と「諦め」の独白を引き出す。
3.  **【監督の非情な勝負論】**: 監督にインタビュー。「勝つためには、時に非情にならなければならない。それが王者であり続けるということだ」という彼の哲学を語らせる。
4.  **【主将の孤独な背中】**: スター選手揃いのチームを一つにまとめることの難しさと、「負けることが許されない」という王者ならではの孤独な覚悟を主将に語らせる。
${reactionPrompt}
7.  **【王者、出陣】**: 主将が「俺たちの目標は、県大会優勝じゃない。その先にある」と、全国の頂点だけを見据えていることを示唆して締めくくる。
### 必ず含めるべき要素
- **チームが抱える状況を描写すること: ${teamMasterData.info}**
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、王者の告白』第${matchData.round}章`;
                prompt += `
### 取材テーマ
「${teamName}」が勝利。しかし彼らにとってこの勝利は歓喜ではなく、「次へ進むための義務」でしかない。その独特の空気感をリアルに描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」を引用し、それが王者としての力の証明であったことを示す。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、勝利が順当であったことを描写する。
3.  試合後、安堵の表情を浮かべるも、決して喜びを爆発させない選手たちの姿。
4.  監督に「今日のプレーで満足せず、次を見据えている」という趣旨の、冷静なコメントをさせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、王者の告白』最終章`;
                prompt += `
### 取材テーマ
絶対的王者「${teamName}」の夏が終わった。王国の崩壊の瞬間と、選手たちの初めて見せる涙、そして重圧からの解放を感傷的に記録してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにして絶対王者の歯車を狂わせたのか、その瞬間を克明に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、この敗戦が歴史的な番狂わせであることを強調する。
3.  試合終了のサイレンが鳴り響く、球場の信じられないような静寂を描写する。
4.  これまで常に気丈に振る舞ってきた主将が、初めてグラウンドに泣き崩れる姿に焦点を当てる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } 
    // ==================================================================
    // --- 4. 逆境チーム (underdog) ---
    // ==================================================================
    else { 
        switch (phase) {
            case 'intro':
                title = `『${teamName}、魂の記録』序章`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 2) { // 絶望的な格上
                        reactionPrompt = `
3.  **【残酷な現実、そして監督の『建前』】**
    初戦の相手が格上の強豪「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。絶望と沈黙に包まれる選手たち。
    その重い空気の中、監督が**選手たちの前で**「これは試練だ。だが、歴史を創るチャンスでもある」という趣旨の力強い言葉でチームを奮い立たせる。
4.  **【監督室の『本音』】**
    記者が二人きりで監督に心境を聞くと、「いや、正直しんどいですよ…笑っちゃいましたもん、まさか〇〇（相手校名）と当たるなんて…」という趣旨の、人間味あふれる弱音や本音を漏らす。`;
                    } else if (rankDiff >= 1) { // 少し格上
                        reactionPrompt = `
3.  **【挑戦者たち】**
    初戦の相手が、格上の「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちが「不足はない相手」「一泡吹かせてやる」と闘志を燃やす。
4.  **【監督の戦略】**
    監督は**選手たちの前で**「良い顔つきになったな」と彼らの士気を高めつつ、記者の前では**二人きりで**、「正直、勝率は3割もないでしょう。でも、高校野球は何が起こるか分からない」という趣旨で、冷静な分析と本音を語る。`;
                    } else { // 同格か格下
                        reactionPrompt = `
3.  **【運命の初戦】**
    初戦の相手が実力の近い「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。「勝てる！」と少し浮足立つ選手たち。
4.  **【監督の『建前』と『本音』】**
    監督が**選手たちの前で**「油断が一番の敵だ」と厳しく一喝する一方、記者の前では**二人きりで**、「最高のクジを引きました。ここを勝てば、間違いなくチームは波に乗れる」という趣旨で、安堵とプレッシャーが入り混じった本音を語る。`;
                    }
                }
                prompt += `
### 取材テーマ
「${teamName}」が抱える困難な状況と、それでも夢を諦めない彼らの姿を描く。
${charactersPrompt}
### 構成案
1.  **【チームの現在地】**: 記者がチームの元を訪れる場面から始める。監督や選手にインタビューし、チームが抱える具体的なハンデ（例：${teamMasterData.info}）と、それに対する彼らの想いを明らかにする。
2.  **【地域との絆】**: チームを支える地元の人々（例：商店街の店主、OBなど）にも話を聞き、地域にとってこのチームがどのような存在であるかを描写する。
${reactionPrompt}
5.  **【決意表明】**: 最後に、主将が大会へ向かう決意を語り、締めくくる。
### 必ず含めるべき要素
- **チームが抱える状況を描写すること: ${teamMasterData.info}**
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、魂の記録』第${matchData.round}章`;
                prompt += `
### 取材テーマ
「${teamName}」が、奇跡的な勝利を収めた。この一勝が彼らにとってどれほど大きな意味を持つのか、感動的に描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」を、この試合で起きた奇跡の象徴として、最も感動的に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、この勝利がどれほどの金星であったかを伝える。
3.  勝利の瞬間、子供のように抱き合って泣く選手たちの姿を描写する。
4.  この勝利を見届けた地元の人々の、我が事のような喜びの声を加える。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、魂の記録』最終章`;
                prompt += `
### 取材テーマ
「${teamName}」の夏が終わった。夢破れた彼らの姿と、それでも確かに残ったものを描くドキュメンタリー最終章。
### 対戦相手「${teamName}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」に触れ、あと一歩及ばなかった彼らの奮闘を称える。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、「よくやった」「悔しい」といった感情を増幅させる。
3.  試合終了の瞬間、泣き崩れるも、やがて顔を上げ、相手にエールを送る選手たちの姿を描写する。
4.  3年生の引退と、彼らの想いが後輩たちへと受け継がれていくことを示唆して、物語を締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    }
    
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) return { ...article, timestamp: Date.now() };
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI documentary article generation failed:", error);
        return null;
    }
}

/**
 * Sets the weather effect for the background.
 * @param {'none' | 'rain' | 'sun'} weatherType - The type of weather to display.
 */
function setWeather(weatherType) {
    const rainContainer = document.getElementById('rain-container');
    const sunContainer = document.getElementById('sun-container');

    // Hide all weather effects first
    rainContainer.classList.add('hidden');
    sunContainer.classList.add('hidden');
    rainContainer.innerHTML = ''; // Clear old raindrops

    if (weatherType === 'rain') {
        rainContainer.classList.remove('hidden');
        // Create 100 raindrops
        for (let i = 0; i < 100; i++) {
            const drop = document.createElement('div');
            drop.className = 'drop';
            drop.style.left = Math.random() * 100 + 'vw';
            drop.style.animationDelay = Math.random() * 0.5 + 's';
            drop.style.animationDuration = Math.random() * 0.2 + 0.3 + 's';
            rainContainer.appendChild(drop);
        }
    } else if (weatherType === 'sun') {
        sunContainer.classList.remove('hidden');
    }
}

/**
 * 詳細入力モーダル内のチームデータ、またはチーム名自体を入れ替える
 * @param {string} matchId - 対象の試合ID
 */
function swapTeamDetails(matchId) {
    const match = findMatchById(matchId);
    if (!match) return;

    // 1. チーム名と、トーナメント表に表示されているスコアを入れ替える
    const tempTeam = match.team1;
    match.team1 = match.team2;
    match.team2 = tempTeam;

    const tempScore = match.score1;
    match.score1 = match.score2;
    match.score2 = tempScore;

    // 2. もし詳細データが入力済みなら、その中身も入れ替える
    if (match.details) {
        // 打撃データを入れ替え
        const tempBatting = match.details.batting.team1;
        match.details.batting.team1 = match.details.batting.team2;
        match.details.batting.team2 = tempBatting;

        // 投手データを入れ替え
        const tempPitching = match.details.pitching.team1;
        match.details.pitching.team1 = match.details.pitching.team2;
        match.details.pitching.team2 = tempPitching;
        
        // イニングスコアを入れ替え
        if (match.details.inningScore) {
            const tempInningScore = match.details.inningScore.team1;
            match.details.inningScore.team1 = match.details.inningScore.team2;
            match.details.inningScore.team2 = tempInningScore;
        }
    }

    // 3. 変更を保存し、画面を更新する
    saveState();
    renderTournament(tournamentState); // トーナメント表も更新
    openDetailsModal(matchId); // モーダルを再描画して変更を反映
}
/**
 * チームステータスモーダルを表示する
 */
function showTeamStatusModal(teamName) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) return;

    // モーダルの要素を取得
    const modal = document.getElementById('team-status-modal');
    const bestEl = document.getElementById('status-modal-best');
    const historyEl = document.getElementById('status-modal-history');
    const traitsEl = document.getElementById('status-modal-traits');
    // ↓↓↓ おそらく抜けていたのがこの一行です ↓↓↓
    const coachEl = document.getElementById('status-modal-coach'); 

    // チーム名を設定
    document.getElementById('status-modal-team-name').textContent = teamName;
    
    // 最高戦績を設定
    bestEl.textContent = teamRecord.best ? formatRecordToString(teamRecord.best) : 'まだありません';

    // 直近の成績を設定
    historyEl.innerHTML = '';
    if (teamRecord.history && teamRecord.history.length > 0) {
        teamRecord.history.slice(0, 2).forEach(rec => {
            const p = document.createElement('p');
            p.textContent = formatRecordToString(rec);
            historyEl.appendChild(p);
        });
    } else {
        historyEl.innerHTML = '<p>まだありません</p>';
    }

    // 称号を設定
    traitsEl.innerHTML = '';
    if (teamRecord.teamTraits && teamRecord.teamTraits.length > 0) {
        teamRecord.teamTraits.forEach(traitId => {
            const trait = TITLES[traitId];
            if (trait) {
                const span = document.createElement('span');
                span.className = 'bg-blue-100 text-blue-800 text-xs font-semibold px-2.5 py-0.5 rounded-full';
                span.textContent = trait.name;
                traitsEl.appendChild(span);
            }
        });
    } else {
        traitsEl.innerHTML = '<p class="text-gray-500 text-sm">なし</p>';
    }
    
    // 監督情報を設定
    const teamMasterData = TEAM_DATA[teamName];
    if (teamMasterData && teamMasterData.coach) {
        const coach = teamMasterData.coach;
        coachEl.textContent = `${coach.name} (${coach.experience} / ${coach.style})`;
    } else {
        coachEl.textContent = '情報なし';
    }
    
    // モーダルを表示
    modal.classList.remove('hidden');
}
    // --- Custom Alert/Confirm ---
    function showAlert(message) {
        alert(message);
    }

    function showConfirm(message) {
        return new Promise((resolve) => {
            const confirmOk = document.getElementById('confirm-ok');
            const confirmCancel = document.getElementById('confirm-cancel');
            document.getElementById('confirm-modal-text').textContent = message;
            confirmModal.classList.remove('hidden');

            const onOk = () => {
                confirmModal.classList.add('hidden');
                cleanup();
                resolve(true);
            };

            const onCancel = () => {
                confirmModal.classList.add('hidden');
                cleanup();
                resolve(false);
            };
            
            const cleanup = () => {
                confirmOk.removeEventListener('click', onOk);
                confirmCancel.removeEventListener('click', onCancel);
            };

            confirmOk.addEventListener('click', onOk);
            confirmCancel.addEventListener('click', onCancel);
        });
    }

// --- Utility & State Functions --- などに追加

// 甲子園での成績を定義（数字が小さいほど上位）
const KOSHIEN_RESULTS = {
    CHAMPION:       { rank: -1, label: '全国優勝' },
    RUNNER_UP:    { rank: -2, label: '全国準優勝' },
    BEST_4:         { rank: -4, label: '甲子園ベスト4' },
    BEST_8:         { rank: -8, label: '甲子園ベスト8' },
    BEST_16:        { rank: -16, label: '甲子園3回戦敗退' }, // ベスト16
    ROUND_2:        { rank: -32, label: '甲子園2回戦敗退' },
    ROUND_1:        { rank: -64, label: '甲子園初戦敗退' },
};

// チームのA～Eランクごとの、甲子園での成績確率（ウェイト方式）
const KOSHIEN_PROBABILITIES = {
    'A': [
        { result: 'CHAMPION', weight: 20 }, { result: 'RUNNER_UP', weight: 25 },
        { result: 'BEST_4', weight: 25 },   { result: 'BEST_8', weight: 15 },
        { result: 'BEST_16', weight: 10 },  { result: 'ROUND_2', weight: 4 },
        { result: 'ROUND_1', weight: 1 }
    ],
    'B': [
        { result: 'CHAMPION', weight: 5 },  { result: 'RUNNER_UP', weight: 10 },
        { result: 'BEST_4', weight: 20 },   { result: 'BEST_8', weight: 30 },
        { result: 'BEST_16', weight: 20 },  { result: 'ROUND_2', weight: 10 },
        { result: 'ROUND_1', weight: 5 }
    ],
    'C': [
        { result: 'CHAMPION', weight: 1 },  { result: 'RUNNER_UP', weight: 3 },
        { result: 'BEST_4', weight: 8 },    { result: 'BEST_8', weight: 20 },
        { result: 'BEST_16', weight: 30 },  { result: 'ROUND_2', weight: 28 },
        { result: 'ROUND_1', weight: 10 }
    ],
    'D': [
        { result: 'BEST_8', weight: 5 },    { result: 'BEST_16', weight: 15 },
        { result: 'ROUND_2', weight: 40 },  { result: 'ROUND_1', weight: 40 }
    ],
    'E': [
        { result: 'BEST_16', weight: 5 },   { result: 'ROUND_2', weight: 25 },
        { result: 'ROUND_1', weight: 70 }
    ],
};

/**
 * チームランクに基づき、甲子園での成績を確率で決定する
 * @param {string} teamRank - 'A'から'E'までのチームランク
 * @returns {string} - KOSHIEN_RESULTSのキー ('CHAMPION', 'BEST_8'など)
 */
function simulateKoshien(teamRank) {
    const probabilities = KOSHIEN_PROBABILITIES[teamRank] || KOSHIEN_PROBABILITIES['E'];
    const totalWeight = probabilities.reduce((sum, p) => sum + p.weight, 0);
    let random = Math.random() * totalWeight;

    for (const prob of probabilities) {
        if (random < prob.weight) {
            return prob.result;
        }
        random -= prob.weight;
    }
    return 'ROUND_1'; // フォールバック
}
    /**
     * 試合IDを元に、stateオブジェクトの深い階層から試合オブジェクトを検索して返す
     */
    function findMatchById(matchId) {
    // 通常のトーナメント表を検索
    if (tournamentState.matches && tournamentState.matches[matchId]) {
        return tournamentState.matches[matchId];
    }

    // 秋季大会の地区予選・順位決定戦を検索
    if (tournamentState.autumnData) {
        for (const region of ['東部', '中部', '西部', '伊豆']) { // 伊豆を追加
            const regionData = tournamentState.autumnData.regions[region];
            if (!regionData) continue;
            // ▼▼▼ このブロックが修正箇所 ▼▼▼
            if (regionData.blocks) { // 東部・中部・西部
                for (const block of regionData.blocks) {
                    if (block.matches[matchId]) return block.matches[matchId];
                }
            }
            if (regionData.izuBracket && regionData.izuBracket.matches[matchId]) { // 伊豆
                return regionData.izuBracket.matches[matchId];
            }
            // ▲▲▲
            if (regionData.champBracket && regionData.champBracket.matches[matchId]) {
                return regionData.champBracket.matches[matchId];
            }
            if (regionData.repechageBracket && regionData.repechageBracket.matches[matchId]) {
                return regionData.repechageBracket.matches[matchId];
            }
        }
    }
        
        // 春季大会の地区予選を検索
         if (tournamentState.springData) {
        for (const region of ['東部', '中部', '西部', '伊豆']) {
            const regionData = tournamentState.springData.regions[region];
            if (!regionData) continue;

            // ブロック代表決定戦を検索
            if (regionData.blocks) {
                for (const block of regionData.blocks) {
                    if (block.matches[matchId]) return block.matches[matchId];
                }
            }
            // 第5代表決定戦（敗者復活）を検索
            if (regionData.repechageBracket && regionData.repechageBracket.matches[matchId]) {
                return regionData.repechageBracket.matches[matchId];
            }
            // 伊豆地区予選を検索
            if (regionData.izuBracket && regionData.izuBracket.matches[matchId]) {
                return regionData.izuBracket.matches[matchId];
            }
        }
    }
    // ▲▲▲ ここまで修正 ▲▲▲
        return null; // どこにも見つからなかった場合
    }
// --- Team Rank Calculation ---
    function calculateRank(teamName, state) {
    if (!teamName) return ''; 

    const teamData = TEAM_DATA[teamName];
    
    // ▼▼▼ この安全装置を追加 ▼▼▼
    if (!teamData) {
        // もしTEAM_DATAにチームが見つからなければ、エラーを起こさずに
        // デフォルトのEランクを返して、この関数の処理を終了する
        return 'E'; 
    }
    // ▲▲▲ ▲▲▲

    // この行は、上記のチェックのおかげで安全に実行される
    let score = 0;
    score += teamData.deviation;

        if (teamData.best.includes('優勝')) score += 25;
        else if (teamData.best.includes('準優勝')) score += 20;
        else if (teamData.best.includes('ベスト4')) score += 15;
        else if (teamData.best.includes('ベスト8')) score += 10;
        else if (teamData.best.includes('出場')) score += 10;
        else if (teamData.best.includes('ベスト16')) score += 5;

        if (teamData.popularity) score += 5;

        if (state.teamRecords && state.teamRecords[teamName]) {
            const lastFinish = state.teamRecords[teamName].lastFinish;
            const rankMultiplier = 3.0; 
            if (lastFinish === 1) score += 30 * rankMultiplier; 
            else if (lastFinish === 2) score += 25 * rankMultiplier;
            else if (lastFinish <= 4) score += 20 * rankMultiplier;
            else if (lastFinish <= 8) score += 15 * rankMultiplier;
            else if (lastFinish <= 16) score += 5 * rankMultiplier;
            else if (lastFinish >= 64) score -= 5 * rankMultiplier;
        }
        
        if (score >= 85) return 'A';
        if (score >= 70) return 'B';
        if (score >= 55) return 'C';
        if (score >= 40) return 'D';
        return 'E';
    }
// --- Tournament Logic & Rendering ---

// ▼▼▼ この関数をまるごと追加してください ▼▼▼
/**
 * 指定されたブロックのアニメーションを再生する（トーナメント表示版）
 */
/**
 * 指定されたブロックのアニメーションを再生する（トーナメント表示版）
 */
async function playBlockAnimation(blockId) {
    // タブのアクティブ表示を更新
    document.querySelectorAll('.analysis-block-tab-btn').forEach(btn => {
        const isActive = btn.dataset.block === blockId;
        btn.classList.toggle('bg-cyan-500', isActive);
        btn.classList.toggle('text-white', isActive);
        btn.classList.toggle('bg-gray-700', !isActive);
        btn.classList.toggle('text-gray-400', !isActive);
    });

    const stage = document.getElementById('analysis-stage');
    const narrationTextEl = document.getElementById('analysis-narration-text');
    const analysisData = tournamentState.blockAnalysisData;

    if (!analysisData || !analysisData[blockId]) {
        stage.innerHTML = `<p class="text-center text-gray-500">分析データを読み込めませんでした。</p>`;
        narrationTextEl.textContent = '';
        return;
    }
    const narration = analysisData[blockId];
    
    // ... (以降のコードは変更ありません) ...
    const blockTeams = tournamentState.teams.slice(
        (blockId.charCodeAt(0) - 65) * 16, 
        (blockId.charCodeAt(0) - 64) * 16
    );

    stage.innerHTML = '';
    narrationTextEl.textContent = '';
    
    stage.innerHTML = `
        <div id="r1-col" class="round-column"></div>
        <div id="r2-col" class="round-column"></div>
        <div id="r3-col" class="round-column"></div>
        <div id="r4-col" class="round-column"></div>
    `;

    for(let i = 0; i < 8; i++) {
        const matchupEl = document.createElement('div');
        matchupEl.className = 'analysis-matchup';
        matchupEl.innerHTML = `
            <div class="analysis-team" data-team-name="${blockTeams[i*2]}">${blockTeams[i*2]}</div>
            <div class="analysis-team" data-team-name="${blockTeams[i*2+1]}">${blockTeams[i*2+1]}</div>
            <div class="matchup-connector"></div>
        `;
        stage.querySelector('#r1-col').appendChild(matchupEl);
    }
    
    for(let i = 0; i < 4; i++) { stage.querySelector('#r2-col').innerHTML += '<div class="analysis-matchup"><div class="analysis-team">???</div><div class="analysis-team">???</div><div class="matchup-connector"></div><div class="round-connector"></div></div>'; }
    for(let i = 0; i < 2; i++) { stage.querySelector('#r3-col').innerHTML += '<div class="analysis-matchup"><div class="analysis-team">???</div><div class="analysis-team">???</div><div class="matchup-connector"></div><div class="round-connector"></div></div>'; }
    stage.querySelector('#r4-col').innerHTML += '<div class="analysis-matchup"><div class="analysis-team">???</div></div>';

    await new Promise(r => setTimeout(r, 100));
    document.querySelectorAll('.analysis-team').forEach((el, i) => {
        setTimeout(() => el.classList.add('show'), i * 50);
    });

    for (let i = 0; i < narration.length; i++) {
        narrationTextEl.textContent += narration[i];
        await new Promise(r => setTimeout(r, 50));
    }
    
    blockTeams.forEach(team => {
        if (narration.includes(team)) {
            document.querySelectorAll(`.analysis-team[data-team-name="${team}"]`).forEach(el => {
                el.classList.add('highlight');
            });
        }
    });
}
// ▼▼▼ この関数をまるごと追加してください ▼▼▼
/**
 * AIに各ブロックの勢力図を分析させ、ナレーション原稿を生成させる（データ分析強化版）
 * @param {object} state - tournamentState
 * @returns {Promise<object|null>}
 */
/**
 * AIに各ブロックの勢力図を分析させ、ナレーション原稿を生成させる（ハイブリッド版・APIエラー対策済み）
 * @param {object} state - tournamentState
 * @returns {Promise<object|null>}
 */
async function generateBlockAnalysisArticle(state) {
    const { teams, seeds } = state;
    const blocks = { A: [], B: [], C: [], D: [] };
    teams.forEach((team, i) => {
        if (i < 16) blocks.A.push(team);
        else if (i < 32) blocks.B.push(team);
        else if (i < 48) blocks.C.push(team);
        else blocks.D.push(team);
    });

    const blockAnalysisData = {};
    for (const blockId in blocks) {
        const blockTeams = blocks[blockId];
        // ▼▼▼ ここからが新しい処理 ▼▼▼
        const teamDetails = blockTeams.map(teamName => {
            const rank = calculateRank(teamName, state);
            const isSeed = seeds.includes(teamName);
            // シード校か、A,Bランクの強豪校の場合のみ、詳細な情報を渡す
            if (isSeed || ['A', 'B'].includes(rank)) {
                const info = TEAM_DATA[teamName]?.info || '';
                return `${teamName}(${rank}${isSeed ? 'S' : ''})[背景: ${info}]`;
            } else {
                return `${teamName}(${rank})`;
            }
        }).join(', ');
        // ▲▲▲
        blockAnalysisData[blockId] = teamDetails;
    }

    const prompt = `あなたは高校野球の解説者です。以下の各ブロックのチームリストを分析し、それぞれの見どころを**150字程度**のナレーション原稿にまとめてください。

### 分析対象ブロック (チーム名とランク、Sはシード校、[]内は注目校の背景情報)
- **Aブロック:** ${blockAnalysisData.A}
- **Bブロック:** ${blockAnalysisData.B}
- **Cブロック:** ${blockAnalysisData.C}
- **Dブロック:** ${blockAnalysisData.D}

### 指示
- **物語を重視:** [背景]情報が提供されている注目校を中心に、そのチームが持つ物語や背景（例：古豪の復活、王者の苦悩）に触れながら解説してください。
- **簡潔に:** 全体のナレーションは150字程度に収めてください。
- 最も激戦区だと思われる「死のブロック」を特定してください。
- 4ブロック分、必ず全てのナレーションを生成してください。

### 出力形式 (JSON)
{
  "A": "（Aブロックのナレーション）",
  "B": "（Bブロックのナレーション）",
  "C": "（Cブロックのナレーション）",
  "D": "（Dブロックのナレーション）"
}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        return parseJsonFromText(result.candidates[0].content.parts[0].text);
    } catch (error) {
        console.error("AIブロック分析記事の生成に失敗:", error);
        return null;
    }
}
   /**
 * 新しいトーナ-メントを開始するメイン関数（大会移行バグ修正・最終完全版）
 */
async function createNewTournament(isNext = false, nextTournamentType = 'summer', predeterminedTeams = null) {
    setupEl.classList.add('hidden');
    tournamentDisplayEl.classList.remove('hidden');
    
    // 大会移行時に、前の大会のコントロールボタンを確実に非表示にする
    autumnControls.classList.add('hidden');
    startMainTournamentBtn.classList.add('hidden');
    startRankingPlayoffsBtn.classList.add('hidden');

    // --- 世代交代処理 ---
    if (isNext && tournamentState.teamRecords) {
        for (const teamName in tournamentState.teamRecords) {
            if (tournamentState.teamRecords.hasOwnProperty(teamName)) {
                const record = tournamentState.teamRecords[teamName];
                record.previousRank = record.lastFinish;
                record.wins = 0;
                record.losses = 0;
            }
        }
    }

    // --- 秋季大会の開始 ---
    if (nextTournamentType === 'autumn') {
        tournamentState.currentTournament = 'autumn';
        tournamentState.autumnPhase = 'regional_blocks';
        if (!isNext) {
            tournamentState.tournamentYear = 2025;
            tournamentState.settings = { enableArticleGeneration: true, enableBbsGeneration: true };
        }
        tournamentState.autumnData = {
            regions: {
                '東部': { blocks: [], blockWinners: [], blockRunnersUp: [], ranking: [], finalReps: [] },
                '中部': { blocks: [], blockWinners: [], blockRunnersUp: [], ranking: [], finalReps: [] },
                '西部': { blocks: [], blockWinners: [], blockRunnersUp: [], ranking: [], finalReps: [] },
                '伊豆': { izuBracket: null, finalReps: [] }
            }
        };
        Object.assign(tournamentState, {
            teams: [], matches: {}, news: [], seeds: [], bbsComments: [], daiyaBbsComments: [],
            tickerHeadlines: [], namcoNews: null, is16team: false, documentary: { target: null, type: null }
        });
        await setupAutumnRegionalBlocks();
        return;
    }
    // --- 春季大会の開始 ---
    else if (nextTournamentType === 'spring') {
        tournamentState.currentTournament = 'spring';
        tournamentState.autumnPhase = null;
        
        const allRankedTeams = Object.keys(tournamentState.teamRecords)
            .map(name => ({ name, rank: tournamentState.teamRecords[name].lastFinish }))
            .sort((a, b) => a.rank - b.rank);

        const seedTeams = allRankedTeams.slice(0, 8).map(t => t.name);
        const qualifierTeams = allRankedTeams.slice(8).map(t => t.name);

        tournamentState.springPhase = 'regional_qualifiers';
        tournamentState.springData = {
            seedTeams,
            qualifierTeams,
            regions: {
                '東部': { blocks: [], repechageBracket: null, finalReps: [] },
                '中部': { blocks: [], repechageBracket: null, finalReps: [] },
                '西部': { blocks: [], repechageBracket: null, finalReps: [] },
                '伊豆': { izuBracket: null, finalReps: [] }
            },
            allMatches: {}
        };
        await setupSpringRegionalQualifiers();

         if (tournamentState.senbatsuTeams && tournamentState.senbatsuTeams.length > 0) {
        for (const teamName of tournamentState.senbatsuTeams) {
            // チームの実力（ランク）を取得
            const teamRank = calculateRank(teamName, tournamentState);
            // ランクに基づき、甲子園での成績を確率的に決定
            const koshienResultKey = simulateKoshien(teamRank);
            const koshienResult = KOSHIEN_RESULTS[koshienResultKey];
            
            // チームの公式記録を更新
            const teamRecord = tournamentState.teamRecords[teamName];
            if (teamRecord) {
                teamRecord.lastFinish = koshienResult.rank; // 最終成績を甲子園のものに更新
                const newHistoryRecord = { 
                    year: tournamentState.tournamentYear, 
                    tournament: 'spring_koshien', // 春の甲子園という特別な記録
                    rank: koshienResult.rank 
                };
                teamRecord.history.unshift(newHistoryRecord);
                // これまでの最高成績より良ければ更新
                if (!teamRecord.best || newHistoryRecord.rank < teamRecord.best.rank) {
                    teamRecord.best = newHistoryRecord;
                }
            }
            
            // 結果を元にニュース記事をAIに生成させる
            const article = await generateKoshienSummaryArticle(teamName, koshienResult.label, 'spring');
            if (article) {
                tournamentState.news.push(article);
            }
        }
    }
    // ▲▲▲

    tournamentState.senbatsuTeams = [];
    return;
}    
    // --- 夏季大会の開始 ---
    mainBracketWrapper.classList.remove('hidden');
    tournamentState.is16team = false;
    tournamentState.currentTournament = 'summer';

    if (isNext) { // 春から夏への移行時
        tournamentState.tournamentYear++;
    }
    
    // 年度とチーム記録の初期化 (全くの初回プレイ時)
    if (!isNext) { 
        tournamentState.tournamentYear = 2025;
        tournamentState.teamRecords = {};
        const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
        historicalRanks.sort((a, b) => a.rank - b.rank);
        
        // 初回のみsettingsを初期化
        tournamentState.settings = {
            enableArticleGeneration: true,
            enableBbsGeneration: true
        };

        INITIAL_TEAM_POOL.forEach(t => {
            const historicalRank = historicalRanks.find(hr => hr.name === t);
            tournamentState.teamRecords[t] = { 
                wins: 0, losses: 0, best: null, history: [],
                lastFinish: historicalRank ? historicalRank.rank : 64, 
                previousRank: null,
                teamTraits: [], 
                previousStarters: null,
                roster: null,
            };
        });
    }
    
    let teams;
    let seeds = [];
    if (predeterminedTeams) {
        teams = predeterminedTeams;
        const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
        historicalRanks.sort((a, b) => a.rank - b.rank);
        seeds = historicalRanks.slice(0, 8).map(t => t.name);
    } else {
        if (isNext) {
            const lastTournamentTeams = Object.keys(tournamentState.teamRecords)
                .map(teamName => ({ name: teamName, ...tournamentState.teamRecords[teamName] }))
                .sort((a, b) => a.lastFinish - b.lastFinish);
            seeds = lastTournamentTeams.slice(0, 8).map(t => t.name);
        } else {
            const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
            historicalRanks.sort((a, b) => a.rank - b.rank);
            seeds = historicalRanks.slice(0, 8).map(t => t.name);
        }

        const nonSeeds = INITIAL_TEAM_POOL.filter(t => !seeds.includes(t));
        const shuffledNonSeeds = shuffleArray(nonSeeds);
        teams = Array(64).fill(null);
        const seedPositionsTemplate = [0, 32, 16, 48, 8, 40, 24, 56];
        const seedPlacements = {};
        seeds.forEach((seed, i) => { seedPlacements[seedPositionsTemplate[i]] = seed; });
        let nonSeedIndex = 0;
        for (let i = 0; i < 64; i++) {
            teams[i] = seedPlacements[i] ? seedPlacements[i] : shuffledNonSeeds[nonSeedIndex++];
        }
    }
    
    // トーナメントデータの作成
    tournamentState.teams = teams;
    tournamentState.matches = {};
    tournamentState.news = [];
    tournamentState.documentary = { target: null, type: null };
    tournamentState.activeScandal = null;
    tournamentState.seeds = seeds;
    tournamentState.bbsComments = [];
    tournamentState.daiyaBbsComments = [];
    tournamentState.tickerHeadlines = []; 
    tournamentState.rivalries = RIVALRIES;
    tournamentState.feuds = tournamentState.feuds || [];
    tournamentState.namcoNews = null;

    const round1Setup = teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    round1Setup.forEach((match, index) => {
        const side = index < 16 ? 'L' : 'R';
        const matchNum = index < 16 ? index + 1 : index - 15;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

    saveState();
    renderTournament(tournamentState);
    
    const currentTournamentName = tournamentNameMap[tournamentState.currentTournament];
    newsContainer.innerHTML = `<div class="loader">AI記者が${currentTournamentName}の勢力図を分析中...</div>`;
    bbsCommentsContainer.innerHTML = `<div class="loader">AIが組み合わせを分析中...</div>`;
    namcoNewsSection.classList.remove('hidden');
    namcoNewsContent.innerHTML = `<div class="loader">ナムコグループからのお知らせを確認中...</div>`;

    if (tournamentState.currentTournament === 'summer') {
        const analysisData = await generateBlockAnalysisArticle(tournamentState);
        if (analysisData) {
            tournamentState.blockAnalysisData = analysisData;
            const summaryArticle = {
                title: `${tournamentState.tournamentYear}年度 夏季大会、組み合わせ決定！`,
                body: `各ブロックの勢力図分析が完了しました。下のボタンから、未来的なアニメーションとAIによる解説をお楽しみください。`,
                timestamp: Date.now(),
                isAnalysisArticle: true
            };
            tournamentState.news.unshift(summaryArticle);
        }
    } else {
        // ★展望記事用の簡易contextを作成して渡す
    const previewContext = { matchId: 'preview' };
    const previewArticle = await generateNewsArticle(previewContext);
    if (previewArticle) tournamentState.news.unshift(previewArticle);
}    
    const [bracketComments, namcoNews] = await Promise.all([
        generateBracketReactionComments(tournamentState),
        generateNamcoNews(tournamentState, 'bracket')
    ]);

    if (bracketComments && bracketComments.length > 0) tournamentState.bbsComments.push(...bracketComments);
    if (namcoNews) tournamentState.namcoNews = namcoNews;

    renderNews(tournamentState.news);
    renderBbsComments(tournamentState.bbsComments);
    renderNamcoNews(tournamentState.namcoNews);
    saveState();
}


   /**
 * 大会終了時に、全チームの最終順位をteamRecordsに記録し、履歴を更新する
 */
function updateTournamentFinishRecords() {
    const { matches, teams } = tournamentState;
    if (!teams || teams.length === 0) return;

    const numTeams = teams.length;
    const finalRound = Math.log2(numTeams);

    // 最終順位を決定する
    const getRoundLosers = (round, side) => {
        const losers = [];
        const numMatches = (numTeams / 2) / Math.pow(2, round - 1);
        for (let m = 1; m <= numMatches; m++) {
            const match = matches[`${side}-R${round}-M${m}`];
            if (match && match.winner) {
                const loser = match.winner === match.team1 ? match.team2 : match.team1;
                if (loser) losers.push(loser);
            }
        }
        return losers;
    };

    const finalMatch = matches['F-R1-M1'];
    if (finalMatch && finalMatch.winner) {
        const winner = finalMatch.winner;
        const runnerUp = finalMatch.winner === finalMatch.team1 ? finalMatch.team2 : finalMatch.team1;
        if (tournamentState.teamRecords[winner]) tournamentState.teamRecords[winner].lastFinish = 1;
        if (tournamentState.teamRecords[runnerUp]) tournamentState.teamRecords[runnerUp].lastFinish = 2;
    }

    // 準決勝以前の敗退順位を記録
    for (let r = finalRound - 1; r >= 1; r--) {
        const finishRank = Math.pow(2, finalRound - r + 1);
        getRoundLosers(r, 'L').concat(getRoundLosers(r, 'R')).forEach(t => {
            if (t && tournamentState.teamRecords[t]) tournamentState.teamRecords[t].lastFinish = finishRank;
        });
    }

    // ★★★ ここからが戦績履歴と最高成績の更新処理 ★★★
    Object.keys(tournamentState.teamRecords).forEach(team => {
        const record = tournamentState.teamRecords[team];
        if(!record.lastFinish) return; // 試合に参加していない場合はスキップ

        // 今回の大会結果オブジェクトを作成
        const newHistoryRecord = {
            year: tournamentState.tournamentYear,
            tournament: tournamentState.currentTournament,
            rank: record.lastFinish
        };

        // 履歴の先頭に追加 (新しいものが常に一番上に来るように)
        if (!record.history) record.history = [];
        record.history.unshift(newHistoryRecord);

        // 最高成績を更新
        // (bestが未設定か、今回の成績の方が良い(rankの数字が小さい)場合に更新)
        if (!record.best || newHistoryRecord.rank < record.best.rank) {
            record.best = newHistoryRecord;
        }
    });
    // ★★★ ここまで ★★★
}

 /**
     * 現在のトーナメント状態に基づいてUI全体を再描画する
     * @param {object} data - 現在のtournamentState
     */
// 【修正対象1】
function renderTournament(data) {
        let tournamentNameString = tournamentNameMap[data.currentTournament] || '大会';

    // UI要素を一度すべて非表示に初期化
    mainBracketWrapper.classList.add('hidden');
    autumnRegionalContainer.classList.add('hidden');
    autumnRankingContainer.classList.add('hidden');
    autumnControls.classList.add('hidden');
    // 全ての秋季・春季スキップボタンを隠す
    [skipAutumnBlocksBtn, skipAutumnRankingBtn, skipAutumnMainBtn, skipSpringQualifiersBtn, skipSpringRound1Btn, skipSpringMainBtn, startRankingPlayoffsBtn, startMainTournamentBtn].forEach(btn => btn?.classList.add('hidden'));
    
    // --- 大会種別に応じて表示を切り替え ---
    if (data.currentTournament === 'spring') {
        autumnControls.classList.remove('hidden'); // 春季大会中もコントロール用の親コンテナは表示

        switch(data.springPhase) {
            case 'regional_qualifiers':
                tournamentNameString = '春季大会 地区予選';
                autumnRegionalContainer.classList.remove('hidden');
                renderSpringRegionalQualifiers();
                skipSpringQualifiersBtn.classList.remove('hidden'); // ★地区予選スキップボタンを表示
                checkSpringQualifiersComplete();
                break;
            case 'main_round1':
                tournamentNameString = '春季大会 県大会1回戦';
                mainBracketWrapper.classList.remove('hidden');
                renderMainBracket(data);
                skipSpringRound1Btn.classList.remove('hidden'); // ★県大会1回戦スキップボタンを表示
                break;
            case 'main_round2_onwards':
                tournamentNameString = '春季大会 県大会';
                mainBracketWrapper.classList.remove('hidden');
                renderMainBracket(data);
                skipSpringMainBtn.classList.remove('hidden'); // ★県大会2回戦以降スキップボタンを表示
                break;
        }
    } else if (data.currentTournament === 'autumn') {
        // ▼▼▼ ここからが修正箇所 ▼▼▼
        autumnControls.classList.remove('hidden'); // ★秋季大会中は、親コンテナを常に表示する

        switch(data.autumnPhase) {
            case 'regional_blocks':
                tournamentNameString = '秋季大会 地区ブロック予選';
                autumnRegionalContainer.classList.remove('hidden');
                renderAutumnRegionalBlocks();
                skipAutumnBlocksBtn.classList.remove('hidden'); // ★ブロック予選スキップボタンを表示
                checkAutumnRegionalBlocksComplete(); // 完了していれば進行ボタンも表示
                break;
            case 'regional_ranking':
                tournamentNameString = '秋季大会 地区 第5代表決定トーナメント';
                autumnRankingContainer.classList.remove('hidden');
                renderAutumnRankingTournaments();
                skipAutumnRankingBtn.classList.remove('hidden'); // ★順位決定戦スキップボタンを表示
                checkAutumnRankingTournamentsComplete(); // 完了していれば進行ボタンも表示
                break;
            case 'main':
                tournamentNameString = '秋季大会 県大会本戦';
                mainBracketWrapper.classList.remove('hidden');
                renderMainBracket(data);
                skipAutumnMainBtn.classList.remove('hidden'); // ★県大会本戦スキップボタンを表示
                break;
        }
        // ▲▲▲ 修正箇所ここまで ▲▲▲
    } else { // Summer
        mainBracketWrapper.classList.remove('hidden');
        renderMainBracket(data);
    }

    // --- 共通の描画処理 ---
    tournamentYearDisplay.textContent = `${data.tournamentYear}年度 ${tournamentNameString}`;
    renderRegionMap(data);
    renderNews(data.news || []);
    renderBbsComments(data.bbsComments || []);
    renderDaiyaBbsComments(data.daiyaBbsComments || []);
    renderNamcoNews(data.namcoNews);
    checkTournamentProgress(); // 夏大会のスキップボタン表示制御
    updateTicker();
}
/**
 * [秋季大会] 地区ブロック予選をスキップする
 */
async function skipAutumnRegionalBlocks() {
    skipAutumnBlocksBtn.disabled = true;
    skipAutumnBlocksBtn.textContent = '進行中...';

    // 全ての地区の全ブロックの試合を処理
    for (const region of ['東部', '中部', '西部', '伊豆']) {
        const regionData = tournamentState.autumnData.regions[region];
        
        const blocks = regionData.izuBracket ? [regionData.izuBracket] : regionData.blocks;

        for (const block of blocks) {
            // ブロック内の全試合IDを取得
            const matchIds = Object.keys(block.matches);
            for (const matchId of matchIds) {
                const match = block.matches[matchId];
                // チームがセットされていて、まだ勝者が決まっていない試合を処理
                if (match.team1 && match.team2 && !match.winner) {
                    const { team1, team2 } = match;
                    const rank1 = calculateRank(team1, tournamentState);
                    const rank2 = calculateRank(team2, tournamentState);
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    
                    const winnerName = (rankValues[rank1] >= rankValues[rank2]) ? team1 : team2;
                    const loserName = winnerName === team1 ? team2 : team1;

                    const [winnerScore, loserScore] = generateAutoScore(rank1, rank2);
                    match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
                    match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;
                    
                    // processMatchWinを呼び出して勝者を次に進める
                    await processMatchWin(matchId, winnerName);
                }
            }
        }
    }
    
    // 全て終わったら、自動で次のステージへ
    await setupAutumnRankingTournaments();
    skipAutumnBlocksBtn.disabled = false;
    skipAutumnBlocksBtn.textContent = '地区ブロック予選をスキップ';
}

/**
 * [秋季大会] 地区順位決定戦（敗者復活戦）をスキップする
 */
async function skipAutumnRankingTournaments() {
    skipAutumnRankingBtn.disabled = true;
    skipAutumnRankingBtn.textContent = '進行中...';

    for (const region of ['東部', '中部', '西部']) {
        const repBracket = tournamentState.autumnData.regions[region].repechageBracket;
        if (!repBracket) continue;
        
        const matchIds = Object.keys(repBracket.matches);
        for (const matchId of matchIds) {
            const match = repBracket.matches[matchId];
            if (match.team1 && match.team2 && !match.winner) {
                const { team1, team2 } = match;
                const rank1 = calculateRank(team1, tournamentState);
                const rank2 = calculateRank(team2, tournamentState);
                const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                
                const winnerName = (rankValues[rank1] >= rankValues[rank2]) ? team1 : team2;
                
                const [winnerScore, loserScore] = generateAutoScore(rank1, rank2);
                match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
                match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;

                await processMatchWin(matchId, winnerName);
            }
        }
    }

    // 自動で県大会本戦へ
    await setupAutumnMainTournament();
    skipAutumnRankingBtn.disabled = false;
    skipAutumnRankingBtn.textContent = '地区順位決定戦をスキップ';
}

/**
 * [秋季大会] 県大会本戦をスキップする
 */
async function skipAutumnMainTournament() {
    skipAutumnMainBtn.disabled = true;
    skipAutumnMainBtn.textContent = '進行中...';

    // 秋季県大会は16チームトーナメント（4ラウンド）
    await skipRound(1); // 1回戦 (ベスト8決定)
    await skipRound(2); // 準々決勝 (ベスト4決定)
    await skipRound(3); // 準決勝 (決勝進出決定)
    await skipFinal();  // 決勝

    skipAutumnMainBtn.disabled = false;
    skipAutumnMainBtn.textContent = '県大会本戦をスキップ';
}

/**
 * [春季大会] 地区予選をスキップする
 */
async function skipSpringQualifiers() {
    skipSpringQualifiersBtn.disabled = true;
    skipSpringQualifiersBtn.textContent = '進行中...';

    const allQualifierMatches = Object.values(tournamentState.springData.allMatches);

    // 予選の全試合をループ処理
    for (const match of allQualifierMatches) {
        // チームがまだセットされていない試合はスキップ
        if (!match.team1 || !match.team2 || match.winner) continue;
        
        const { team1, team2 } = match;
        const rank1 = calculateRank(team1, tournamentState);
        const rank2 = calculateRank(team2, tournamentState);
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        
        const winnerName = (rankValues[rank1] >= rankValues[rank2]) ? team1 : team2;
        
        const [winnerScore, loserScore] = generateAutoScore(rank1, rank2);
        match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
        match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;

        await processMatchWin(match.id, winnerName);
    }

    // 自動で県大会1回戦へ
    await setupSpringMainTournament_Round1();
    skipSpringQualifiersBtn.disabled = false;
    skipSpringQualifiersBtn.textContent = '春季地区予選をスキップ';
}

/**
 * [春季大会] 県大会1回戦をスキップする
 */
async function skipSpringMainRound1() {
    skipSpringRound1Btn.disabled = true;
    skipSpringRound1Btn.textContent = '進行中...';

    // 1回戦は8試合
    await skipRound(1); 
    
    // 自動で県大会2回戦へ
    await setupSpringMainTournament_Round2();
    skipSpringRound1Btn.disabled = false;
    skipSpringRound1Btn.textContent = '春季県大会1回戦をスキップ';
}

/**
 * [春季大会] 県大会2回戦以降をスキップする
 */
async function skipSpringMainTournament() {
    skipSpringMainBtn.disabled = true;
    skipSpringMainBtn.textContent = '進行中...';

    // 2回戦以降はベスト16トーナメントと同じ
    await skipRound(1); // 2回戦 (ベスト8決定)
    await skipRound(2); // 準々決勝 (ベスト4決定)
    await skipRound(3); // 準決勝 (決勝進出決定)
    await skipFinal();  // 決勝

    skipSpringMainBtn.disabled = false;
    skipSpringMainBtn.textContent = '春季県大会2回戦以降をスキップ';
}

    /**
     * メインのトーナメント表（64チームまたは16チーム）を描画する
     */
    function renderMainBracket(data) {
        if (!data.teams || data.teams.length === 0) {
             mainBracketContainer.innerHTML = '';
             return;
        };

        const { matches, teams, seeds } = data;
        const numTeams = teams.length;

        const bracketContentWrapper = document.createElement('div');
        bracketContentWrapper.className = 'flex flex-row';

        const leftBracketEl = document.createElement('div');
        leftBracketEl.className = 'bracket-half left';

        const rightBracketEl = document.createElement('div');
        rightBracketEl.className = 'bracket-half right';
        
        const finalRound = Math.log2(numTeams);
        const semiFinalRound = finalRound - 1;
        
        const leftChampion = data.matches[`L-R${semiFinalRound}-M1`]?.winner ?? null;
        const rightChampion = data.matches[`R-R${semiFinalRound}-M1`]?.winner ?? null;
        
        const finalMatch = data.matches['F-R1-M1'] || {};
        const finalTeam1 = finalMatch.team1 ?? leftChampion;
        const finalTeam2 = finalMatch.team2 ?? rightChampion;

        const finalEl = document.createElement('div');
        finalEl.className = 'bracket-final';
        finalEl.innerHTML = `<div class="final-title">決勝</div><div class="final-matchup" data-match-id="F-R1-M1">${createMatchHTML('F-R1-M1', finalTeam1, finalTeam2, finalMatch, seeds)}</div><div class="winner-box" id="tournament-winner">${finalMatch.winner ? `🏆 ${finalMatch.winner} 🏆` : '🏆'}</div>`;

        const round1Setup = teams.reduce((acc, team, i) => {
            if (i % 2 === 0) acc.push({ team1: team, team2: null });
            else acc[acc.length - 1].team2 = team;
            return acc;
        }, []);
        
        const leftHalfSetup = round1Setup.slice(0, round1Setup.length / 2);
        const rightHalfSetup = round1Setup.slice(round1Setup.length / 2);

        generateHalf(leftBracketEl, leftHalfSetup, 'L', matches, seeds);
        generateHalf(rightBracketEl, rightHalfSetup, 'R', matches, seeds);

        mainBracketContainer.innerHTML = '';
        bracketContentWrapper.append(leftBracketEl, finalEl, rightBracketEl);
        mainBracketContainer.appendChild(bracketContentWrapper);

        if (finalMatch.winner) {
            nextTournamentBtn.classList.remove('hidden');
        } else {
            nextTournamentBtn.classList.add('hidden');
        }
    }

    /**
     * トーナメント表の片側（レフトまたはライト）を描画するヘルパー関数
     */
    function generateHalf(containerEl, setup, side, allMatches, seeds) {
        containerEl.innerHTML = '';
        const numMatchesInFirstRound = setup.length;
        const numTeamsOnSide = numMatchesInFirstRound * 2;
        const numRounds = Math.log2(numTeamsOnSide);

        const roundNameMap = tournamentState.is16team
            ? { 1: "1回戦", 2: "準々決勝", 3: "準決勝" }
            : { 1: "1回戦", 2: "2回戦", 3: "3回戦", 4: "準々決勝", 5: "準決勝" };

        const roundElements = [];
        for (let i = 0; i < numRounds; i++) {
            const roundEl = document.createElement('div');
            roundEl.className = 'round';
            if (i > 0) roundEl.classList.add('subsequent-round');

            const roundTitle = document.createElement('h3');
            roundTitle.className = 'text-center font-bold mb-2';
            roundTitle.textContent = roundNameMap[i + 1] || `${i + 1}回戦`;
            roundEl.appendChild(roundTitle);

            containerEl.appendChild(roundEl);
            roundElements.push(roundEl);
        }

        setup.forEach((matchSetup, index) => {
            const matchId = `${side}-R1-M${index + 1}`;
            let dbMatch = allMatches[matchId] || {};
            roundElements[0].insertAdjacentHTML('beforeend', createMatchHTML(matchId, matchSetup.team1, matchSetup.team2, dbMatch, seeds));
        });

        for (let r = 2; r <= numRounds; r++) {
            const numMatchesInRound = numMatchesInFirstRound / Math.pow(2, r - 1);
            for (let m = 1; m <= numMatchesInRound; m++) {
                const matchId = `${side}-R${r}-M${m}`;
                const prevMatch1Id = `${side}-R${r - 1}-M${(m * 2) - 1}`;
                const prevMatch2Id = `${side}-R${r - 1}-M${m * 2}`;
                const team1 = allMatches[prevMatch1Id]?.winner || null;
                const team2 = allMatches[prevMatch2Id]?.winner || null;
                const dbMatch = allMatches[matchId] || {};
                roundElements[r - 1].insertAdjacentHTML('beforeend', createMatchHTML(matchId, team1, team2, dbMatch, seeds));
            }
        }
    }

    /**
     * 1試合分のHTMLを生成する
     */
    /**
 * 1試合分のHTMLを生成する（ドキュメンタリーボタン対応・エラー修正版）
 */
function createMatchHTML(matchId, team1, team2, dbMatch, seeds = []) {
    // ▼▼▼ 先に関数の定義をここ（関数の冒頭）に移動します ▼▼▼
    const createSpecialButtons = (teamName) => {
    if (!teamName || (tournamentState.documentary && tournamentState.documentary.target)) return '';
    
    let buttonHTML = '';
    // 逆境チーム用
    if (UNDERDOG_TEAMS.includes(teamName)) {
        buttonHTML += `<button class="underdog-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の逆境に密着取材する">📹</button>`;
    }
    // 通常の強豪校用
    if (POWERHOUSE_TEAMS.includes(teamName)) {
        buttonHTML += `<button class="powerhouse-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の王者の苦悩に密着取材する">👑</button>`;
    }
    // ▼▼▼ ここから追加 ▼▼▼
    // 古豪復活チーム用
    if (POWERHOUSE_REVIVAL_TEAMS.includes(teamName)) {
        buttonHTML += `<button class="powerhouse-revival-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の古豪復活に密着取材する">🏰</button>`;
    }
if (ONE_MAN_TEAMS.includes(teamName)) {
        buttonHTML += `<button class="one-man-team-doc-btn text-lg ml-2" data-team-name="${teamName}" title="絶対的エースとその仲間たちに密着取材する">🌟</button>`;
    }


        return buttonHTML;
    };
    // ▲▲▲ 関数の定義はここまで ▲▲▲

    const t1Empty = !team1;
    const t2Empty = !team2;

    let specialMatchClass = '';
    if (!t1Empty && !t2Empty) {
        const feud = tournamentState.feuds?.find(f => f.teams.includes(team1) && f.teams.includes(team2));
        if (feud) {
            specialMatchClass = 'feud-match';
        } else {
            const rivalry = tournamentState.rivalries?.find(r => r.teams.includes(team1) && r.teams.includes(team2));
            if (rivalry) {
                specialMatchClass = 'rivalry-match';
            }
        }
    }

    const rank1 = calculateRank(team1, tournamentState);
    const rank2 = calculateRank(team2, tournamentState);
    const rankColor = (rank) => {
        switch (rank) {
            case 'A': return 'rank-A';
            case 'B': return 'rank-B';
            case 'C': return 'rank-C';
            case 'D': return 'rank-D';
            case 'E': return 'rank-E';
            default: return '';
        }
    };

    const isMainBracketMatch = matchId.includes('-R');
    const roundStr = isMainBracketMatch ? matchId.split('-')[1] : '';
    const showDetailsButton = !t1Empty && !t2Empty;
    const isSeed1 = seeds.includes(team1);
    const isSeed2 = seeds.includes(team2);

    // HTMLテンプレート内の関数呼び出し名を修正
    const content = `
        <div class="team-slot ${t1Empty ? 'empty' : ''} ${dbMatch.winner === team1 && !t1Empty ? 'winner' : ''} ${dbMatch.winner && dbMatch.winner !== team1 && dbMatch.winner !== null ? 'loser' : ''}" data-team-name="${team1 || ''}">
            <span class="team-name clickable-team-name ${isSeed1 ? 'seed' : ''}" title="${team1 || ''}" data-team-name="${team1 || ''}">
                ${team1 ? `<span class="rank ${rankColor(rank1)}">[${rank1}]</span>` : ''}
                ${isSeed1 ? 'S ' : ''}${team1 || '---'}
            </span>
            ${createSpecialButtons(team1)} 
            <input type="text" class="score-input" value="${dbMatch.score1 ?? ''}" data-team-pos="1">
            <button class="win-btn">▶</button>
        </div>
        <div class="team-slot ${t2Empty ? 'empty' : ''} ${dbMatch.winner === team2 && !t2Empty ? 'winner' : ''} ${dbMatch.winner && dbMatch.winner !== team2 && dbMatch.winner !== null ? 'loser' : ''}" data-team-name="${team2 || ''}">
            <span class="team-name clickable-team-name ${isSeed2 ? 'seed' : ''}" title="${team2 || ''}" data-team-name="${team2 || ''}">
                ${team2 ? `<span class="rank ${rankColor(rank2)}">[${rank2}]</span>` : ''}
                ${isSeed2 ? 'S ' : ''}${team2 || '---'}
            </span>
            ${createSpecialButtons(team2)}
            <input type="text" class="score-input" value="${dbMatch.score2 ?? ''}" data-team-pos="2">
            <button class="win-btn">▶</button>
        </div>
        <div class="match-summary-container ${!t1Empty && !t2Empty ? '' : 'hidden'}">
            <textarea class="match-summary-input w-full text-xs p-1 mt-1 border rounded" data-match-id="${matchId}" placeholder="試合の決め手（任意）">${dbMatch.summary || ''}</textarea>
        </div>
    `;

    const footer = showDetailsButton ?
        `<div class="matchup-footer">
            <button class="details-btn" data-match-id="${matchId}">詳細入力</button>
            <button class="quick-sim-btn text-lg" data-match-id="${matchId}" title="このスコアでおまかせ入力">🎲</button>
        </div>` :
        '';

    return `<div class="matchup ${specialMatchClass}" data-match-id="${matchId}">${content}${footer}</div>`;
}

    
/**
 * UIの各種コンテンツエリア（ニュース）を描画する（全機能対応・最終版）
 */
function renderNews(news) {
    if (!news || news.length === 0) {
        newsContainer.innerHTML = `<p class="text-gray-500 text-center">まだニュースはありません。</p>`;
        return;
    }
    newsContainer.innerHTML = '';
    
    news.slice().reverse().forEach((article, reversedIndex) => {
        const articleEl = document.createElement('div');
        const originalIndex = news.length - 1 - reversedIndex;

        if (article.isScandalRumor) {
            articleEl.className = 'bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg shadow';
            articleEl.innerHTML = `
                <h3 class="font-bold">${article.title}</h3>
                <p class="text-sm mt-2">${article.body}</p>
                <div class="mt-4 border-t pt-3 text-center">
                    <p class="text-sm font-bold mb-2">あなたはこの疑惑をどうしますか？</p>
                    <button class="report-scandal-btn bg-red-600 text-white px-4 py-1 rounded text-sm hover:bg-red-700">大会運営に報告する</button>
                    <button class="ignore-scandal-btn bg-gray-500 text-white px-4 py-1 rounded text-sm hover:bg-gray-600 ml-2">見て見ぬふりをする</button>
                </div>
            `;
        } else if (article.error) {
            articleEl.className = 'article-error';
            const regenerateButtonHTML = article.context ? `<button class="regenerate-btn" data-index="${originalIndex}">再生成</button>` : '';
            articleEl.innerHTML = `<span>${article.title}</span>${regenerateButtonHTML}`;
        } else {
            articleEl.className = 'bg-white p-4 rounded-lg shadow';
            let buttonsHTML = '';

            if (article.isAnalysisArticle) {
                buttonsHTML = `<button class="text-sm bg-cyan-500 text-white font-bold px-4 py-2 rounded hover:bg-cyan-600 view-analysis-btn">勢力図をアニメーションで見る</button>`;
            } else {
                const regenerateButtonHTML = article.context ? `<button class="text-sm bg-yellow-100 text-yellow-800 px-3 py-1 rounded hover:bg-yellow-200 ml-2 regenerate-btn" data-index="${originalIndex}">再生成</button>` : '';
                const newspaperButtonHTML = article.isNewspaper ? `<button class="text-sm bg-red-100 text-red-700 px-3 py-1 rounded hover:bg-red-200 ml-2 newspaper-view-btn" data-index="${originalIndex}">新聞を読む</button>` : '';
                buttonsHTML = `
                    <button class="text-sm bg-gray-200 px-3 py-1 rounded hover:bg-gray-300 news-article-btn" data-index="${originalIndex}">本文</button>
                    ${newspaperButtonHTML}
                    ${regenerateButtonHTML}
                `;
            }

            articleEl.innerHTML = `
                <div class="flex justify-between items-center">
                    <div>
                        <h3 class="font-bold text-lg text-blue-600">${article.title}</h3>
                        <p class="text-xs text-gray-400 mt-1">${new Date(article.timestamp).toLocaleDateString('ja-JP')}</p>
                    </div>
                    <div class="flex items-center space-x-2">
                        ${buttonsHTML}
                    </div>
                </div>
            `;
        }
        newsContainer.appendChild(articleEl);
    });
}
    

function renderBbsComments(comments) {
    if (!comments || comments.length === 0) {
        bbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">まだ反応はありません。</p>`;
        return;
    }
    bbsCommentsContainer.innerHTML = '';
    
    comments.slice().reverse().forEach((comment, index) => {
        // ▼▼▼ THIS IS THE NEW LOGIC ▼▼▼
        // Check if the comment object is an error message
        if (comment.error) {
            const errorEl = document.createElement('div');
            errorEl.className = 'article-error'; // Reuse the article error style
            // The original index is needed for the retry function
            const originalIndex = comments.length - 1 - index;
            errorEl.innerHTML = `
                <span>${comment.title}</span>
                <button class="retry-bbs-btn" data-index="${originalIndex}">再生成</button>
            `;
            bbsCommentsContainer.appendChild(errorEl);
        } 
        // ▲▲▲ ▲▲▲
        else {
            // If it's a normal comment, render it as before
            renderCommentThread(comment, bbsCommentsContainer, 'general');
        }
    });
}

    function renderDaiyaBbsComments(comments) {
        if (!comments || comments.length === 0) {
            daiyaBbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">まだ反応はありません。</p>`;
            return;
        }
        daiyaBbsCommentsContainer.innerHTML = '';
        comments.slice().reverse().forEach(comment => {
            renderCommentThread(comment, daiyaBbsCommentsContainer, 'daiya');
        });
    }

    function renderNamcoNews(news) {
        if (!news) {
            namcoNewsSection.classList.add('hidden');
            return;
        }
        namcoNewsSection.classList.remove('hidden');
        namcoNewsContent.innerHTML = '';
        const newsItem = document.createElement('div');
        newsItem.className = 'namco-news-item p-2 hover:bg-orange-50 rounded';
        newsItem.innerHTML = `<p class="font-semibold text-gray-700">${news.title}<span class="namco-news-tag">野球部</span></p>`;
        newsItem.addEventListener('click', () => {
            document.getElementById('modal-title').textContent = news.title;
            document.getElementById('modal-body').textContent = news.body;
            document.getElementById('modal-meta').innerHTML = `<p>${new Date(news.timestamp).toLocaleDateString('ja-JP')}</p><p class="font-bold text-gray-500">野球部</p>`;
            newsModal.classList.remove('hidden');
            newsModal.classList.add('flex');
        });
        namcoNewsContent.appendChild(newsItem);
    }

    function renderCommentThread(comment, container, bbsType) {
        const threadContainer = document.createElement('div');
        if (container.id === `replies-to-${comment.id}` || (container.id.includes('bbs-comments') && container.children.length > 0)) {
            threadContainer.className = 'ml-4 border-l-2 pl-4 mt-2';
        } else {
            threadContainer.className = 'mt-2';
        }

        const personalityClass = comment.personality === 'あなた' ? 'text-blue-600 font-bold' : 'text-gray-600';
        const commentEl = document.createElement('div');
        commentEl.className = 'bbs-comment';
        commentEl.innerHTML = `
            <div class="flex justify-between items-center">
                <p class="font-semibold ${personalityClass} text-sm">${comment.personality || '名無しさん'}</p>
                <button class="reply-btn text-xs text-blue-500 hover:underline" data-comment-id="${comment.id}" data-bbs-type="${bbsType}">返信する</button>
            </div>
            <p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>
            <p class="text-xs text-gray-400 text-right">${new Date(comment.timestamp).toLocaleString('ja-JP')}</p>
            <div id="reply-form-container-${comment.id}" class="hidden mt-2">
                <form class="reply-form" data-comment-id="${comment.id}" data-bbs-type="${bbsType}">
                    <textarea class="w-full p-2 border rounded text-sm" placeholder="返信を入力..." required></textarea>
                    <button type="submit" class="mt-1 bg-blue-500 text-white px-3 py-1 text-xs rounded hover:bg-blue-600">送信</button>
                </form>
            </div>
        `;
        threadContainer.appendChild(commentEl);

        const repliesContainer = document.createElement('div');
        repliesContainer.id = `replies-to-${comment.id}`;
        threadContainer.appendChild(repliesContainer);

        container.appendChild(threadContainer);

        if (comment.replies && comment.replies.length > 0) {
            comment.replies.slice().reverse().forEach(reply => {
                renderCommentThread(reply, repliesContainer, bbsType);
            });
        }
    }

    /**
 * Renders the regional survival status with a new card-based, scrollable layout.
 */
function renderRegionMap(data) {
    const regionMapSection = document.getElementById('region-map-section');
    const finalMatch = data.matches['F-R1-M1'];
    if ((!data.matches || Object.keys(data.matches).length === 0) && !finalMatch) {
        regionMapSection.classList.add('hidden');
        return;
    }
    regionMapSection.classList.remove('hidden');

    const container = document.getElementById('region-map-container');
    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    INITIAL_TEAM_POOL.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region && teamsByRegion[region]) {
            teamsByRegion[region].push(teamName);
        }
    });

    const eliminatedTeams = new Set();
    const allMatches = { ...data.matches, ...(data.autumnData?.allMatches || {}) };

    Object.values(allMatches).filter(match => match.winner).forEach(match => {
        const loser = match.team1 === match.winner ? match.team2 : match.team1;
        if (loser) eliminatedTeams.add(loser);
    });

    if (finalMatch?.winner) {
        const tournamentWinner = finalMatch.winner;
        eliminatedTeams.forEach(team => {
            if (team === tournamentWinner) eliminatedTeams.delete(team);
        });
    }
    
    let html = '<div class="region-map-scroll-container">'; // New scroll container
    for (const region in teamsByRegion) {
        const teams = teamsByRegion[region];
        if (teams.length === 0) continue;
        
        const survivingCount = teams.filter(team => !eliminatedTeams.has(team)).length;

        html += `
        <div class="region-column">
            <div class="region-header">
                <h3 class="region-title">${region}地区</h3>
                <p class="region-stats">${survivingCount} / ${teams.length} チーム生存</p>
            </div>
            <ul class="region-team-list">
                ${teams.sort((a, b) => { // Sort teams to put survivors at the top
                    const aElim = eliminatedTeams.has(a);
                    const bElim = eliminatedTeams.has(b);
                    if (aElim === bElim) return a.localeCompare(b, 'ja');
                    return aElim ? 1 : -1;
                }).map(team => `
                    <li class="region-team ${eliminatedTeams.has(team) ? 'team-eliminated' : 'team-surviving'}">
                        ${team}
                    </li>
                `).join('')}
            </ul>
        </div>
        `;
    }
    html += '</div>';
    container.innerHTML = html;
}
    
    /**
     * スキップボタンの表示・非表示を制御する
     */
    function checkTournamentProgress() {
    // ボタン要素の取得
    const skipR1Btn = document.getElementById('skip-r1-btn');
    const skipR2Btn = document.getElementById('skip-r2-btn');
    const skipR3Btn = document.getElementById('skip-r3-btn');
    const skipR4Btn = document.getElementById('skip-r4-btn');
    const skipR5Btn = document.getElementById('skip-r5-btn');
    const skipFinalBtn = document.getElementById('skip-final-btn');
    const generateSummaryBtn = document.getElementById('generate-summary-btn');

    // 夏の大会以外では、全てのスキップボタンを非表示にする
    if (tournamentState.is16team || !tournamentState.matches || Object.keys(tournamentState.matches).length === 0 || tournamentState.currentTournament !== 'summer') {
        [skipR1Btn, skipR2Btn, skipR3Btn, skipR4Btn, skipR5Btn, skipFinalBtn, generateSummaryBtn].forEach(btn => btn?.classList.add('hidden'));
        return;
    }

    const matchIds = Object.keys(tournamentState.matches);

    // ▼▼▼ ここが修正されたヘルパー関数 ▼▼▼
    const getRoundStatus = (roundNumber) => {
        // 現在の試合データから、そのラウンドでプレイ済みの試合数を数える
        const played = matchIds.filter(id => id.includes(`-R${roundNumber}-M`) && tournamentState.matches[id]?.winner).length;
        
        // ★変更点：総試合数は、常に64チームトーナメントとして計算する
        const total = 64 / Math.pow(2, roundNumber);
        
        return { total, played };
    };
    // ▲▲▲ 修正ここまで ▲▲▲

    const r1 = getRoundStatus(1);
    const r2 = getRoundStatus(2);
    const r3 = getRoundStatus(3);
    const r4 = getRoundStatus(4); // 準々決勝
    const r5 = getRoundStatus(5); // 準決勝
    const finalMatch = tournamentState.matches['F-R1-M1'];

    // この表示/非表示の切り替えロジックは、getRoundStatusが修正されたことで正常に動作するようになります
    skipR1Btn.classList.toggle('hidden', r1.played > 0);
    skipR2Btn.classList.toggle('hidden', !(r1.played === r1.total && r2.played === 0));
    skipR3Btn.classList.toggle('hidden', !(r2.played === r2.total && r3.played === 0));
    skipR4Btn.classList.toggle('hidden', !(r3.played === r3.total && r4.played === 0));
    skipR5Btn.classList.toggle('hidden', !(r4.played === r4.total && r5.played === 0));
    skipFinalBtn.classList.toggle('hidden', !(r5.played === r5.total && (!finalMatch || !finalMatch.winner)));

    const summaryGenerated = tournamentState.news.some(n => n.summaryType === 'best8');
    generateSummaryBtn.classList.toggle('hidden', !(r3.played === r3.total && r4.played === 0 && !summaryGenerated));
}
/**
 * 決勝戦を自動でスキップする
 */
async function skipFinal() {
    const finalMatch = tournamentState.matches['F-R1-M1'];
    if (!finalMatch || !finalMatch.team1 || !finalMatch.team2 || finalMatch.winner) return;

    const btn = document.getElementById('skip-final-btn');
    if(btn) btn.disabled = true;
    
    const { team1, team2 } = finalMatch;
    const rank1 = calculateRank(team1, tournamentState);
    const rank2 = calculateRank(team2, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    
    let winnerName, loserName;
    // ランク差が2以上ある場合、95%の確率でランク上位が勝利
    const upsetChance = Math.abs(rankValues[rank1] - rankValues[rank2]) >= 2 ? 0.05 : 0.45;

    if (Math.random() < upsetChance) { // 番狂わせ
        winnerName = rankValues[rank1] < rankValues[rank2] ? team1 : team2;
    } else { // 順当
        winnerName = rankValues[rank1] >= rankValues[rank2] ? team1 : team2;
    }
    loserName = winnerName === team1 ? team2 : team1;

    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const [winnerScore, loserScore] = generateAutoScore(winnerRank, loserRank);

    finalMatch.score1 = (finalMatch.team1 === winnerName) ? winnerScore : loserScore;
    finalMatch.score2 = (finalMatch.team2 === winnerName) ? winnerScore : loserScore;

    await processMatchWin('F-R1-M1', winnerName);

    if(btn) btn.classList.add('hidden');
}

    function checkBest8Decided(){} // checkTournamentProgressに統合
// --- 試合詳細モーダル関連の関数（高機能版） ---

   /**
     * 【修正版】新しい試合詳細モーダルを開き、各種テーブルを生成する
     */
    /**
     * イニングスコアのテーブルHTMLを生成する
     */
    /**
 * イニングスコアのテーブルHTMLを生成する（★列幅クラスを適用した最終版）
 */
/**
/**
 * イニングスコアのテーブルHTMLを生成する（0点表示バグ修正版）
 * @param {string} team1Name - チーム1の名前
 * @param {string} team2Name - チーム2の名前
 * @param {object} details - 試合の詳細データ
 * @returns {string} - 生成されたHTML
 */
function createInningScoreTable(team1Name, team2Name, details) {
    const inningData = details.inningScore || { team1: [], team2: [] };
    const numInnings = (inningData.team1 && inningData.team1.length > 0) ? inningData.team1.length : 9;
    
    let header = '';
    for (let i = 1; i <= numInnings; i++) {
        header += `<th class="col-inning-score">${i}</th>`;
    }

    const createRow = (teamKey, teamName) => {
        let cells = '';
        for (let i = 0; i < numInnings; i++) {
            // ▼▼▼【重要修正】ここがバグの原因でした▼▼▼
            // 保存された値が0の場合でも、''（空文字）ではなく0と表示されるように修正
            const scoreValue = inningData[teamKey]?.[i] ?? ''; // nullかundefinedの場合のみ''にする
            cells += `<td class="col-inning-score"><input type="number" value="${scoreValue}"></td>`;
            // ▲▲▲
        }
        return `<tr>
                    <th class="col-team text-left font-semibold pl-2">${teamName}</th>
                    ${cells}
                    <td class="total-score col-total"></td>
                </tr>`;
    };

    return `
        <div class="mb-6 overflow-x-auto">
            <h4 class="font-bold mb-2">イニングスコア</h4>
            <table class="details-table" id="inning-score-table">
                <thead>
                    <tr>
                        <th class="col-team">チーム</th>${header}<th class="col-total">計</th><th class="col-add-inning"><button id="add-inning-score-btn" class="text-xs font-bold">+</button></th>
                    </tr>
                </thead>
                <tbody>${createRow('team1', team1Name)}${createRow('team2', team2Name)}</tbody>
            </table>
        </div>`;
}
/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する（全ての機能を含む最終版）
 */
/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する（★常時縦並びレイアウト対応版）
 */
// 【完成版】openDetailsModal
/**
 * Opens the detailed input modal with the corrected vertical layout.
 */
/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する（★レイアウト問題を完全修正した最終版）
 */
/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する（★データ初期化の欠陥を修正した最終版）
 */
function openDetailsModal(matchId) {
    currentMatchIdForDetails = matchId;
    const match = findMatchById(matchId);
    if (!match) {
        console.error(`[openDetailsModal] エラー: ID ${matchId} の試合が見つかりません。`);
        return;
    }

    console.log("--- [モーダル表示 開始] ---", { matchId: matchId, 既存データ: match.details });

    let details = JSON.parse(JSON.stringify(match.details || {}));
    
    const numInnings = Math.max(9, ...Object.values(tournamentState.matches)
        .filter(m => m.details?.inningScore?.team1)
        .map(m => m.details.inningScore.team1.length));

    console.log(`[モーダル表示] 現在の最大イニング数を ${numInnings} と判断しました。`);

    // データ構造の初期化
    details.inningScore = details.inningScore || { team1: [], team2: [] };
    details.batting = details.batting || { team1: [], team2: [] };
    details.pitching = details.pitching || { team1: [], team2: [] };
    details.inningEvents = details.inningEvents || { team1: [], team2: [] };
    details.positionChanges = details.positionChanges || [];
    
    // 配列の長さを現在のイニング数に合わせる
    for(const teamKey of ['team1', 'team2']) {
        if (!details.inningEvents[teamKey]) details.inningEvents[teamKey] = [];
        while (details.inningScore[teamKey].length < numInnings) details.inningScore[teamKey].push('');
        while (details.inningEvents[teamKey].length < numInnings) details.inningEvents[teamKey].push('');
        if (details.batting[teamKey]) {
            details.batting[teamKey].forEach(player => {
                if (!player.results) player.results = [];
                while (player.results.length < numInnings) player.results.push('');
            });
        }
    }
    console.log("[モーダル表示] 表示用に準備したデータ:", JSON.parse(JSON.stringify(details)));


    // もし試合データが空で、かつチームの選手名簿(roster)が存在すれば、それを読み込む
    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (details.batting[teamKey].length === 0 && teamRecord && teamRecord.roster) {
            details.batting[teamKey] = teamRecord.roster.map(p => ({ ...p, results: Array(numInnings).fill('') }));
        }
    }
    
    const detailsBody = document.getElementById('details-modal-body');
    detailsBody.innerHTML = `
        <div class="space-y-4">
            ${createInningScoreTable(match.team1, match.team2, details)}
            <div class="text-center py-2 border-t border-b">
                <button id="swap-teams-btn" data-match-id="${matchId}" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded">先攻・後攻を入れ替え</button>
            </div>
            <div class="space-y-4">
                <h4 class="font-bold text-lg">${match.team1} 打撃成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPlayerBattingTable(match.team1, 'team1', details)}</div>
                <h4 class="font-bold text-lg mt-4">${match.team2} 打撃成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPlayerBattingTable(match.team2, 'team2', details)}</div>
            </div>
            <div class="space-y-4 mt-4">
                <h4 class="font-bold text-lg">${match.team1} 投手成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPitchingStatsTable('team1', details)}</div>
                 <h4 class="font-bold text-lg mt-4">${match.team2} 投手成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPitchingStatsTable('team2', details)}</div>
            </div>
        </div>
    `;

    detailsModal.classList.remove('hidden');
    updateTotalScores();
}
 

/**
 * 投手成績のテーブルHTMLを生成する
 * @param {string} teamKey - 'team1' または 'team2'
 * @param {object} details - 試合の詳細データ
 * @returns {string} - 生成されたHTML
 */
function createPitchingStatsTable(teamKey, details) {
    const pitchingData = details.pitching[teamKey] || [];
    let bodyRows = pitchingData.map((player, index) => `
        <tr data-pitcher-index="${index}">
            <td>
                <select>
                    <option value="" ${!player.result ? 'selected' : ''}>-</option>
                    <option value="W" ${player.result === 'W' ? 'selected' : ''}>○</option>
                    <option value="L" ${player.result === 'L' ? 'selected' : ''}>●</option>
                    <option value="S" ${player.result === 'S' ? 'selected' : ''}>S</option>
                    <option value="H" ${player.result === 'H' ? 'selected' : ''}>H</option>
                </select>
            </td>
            <td><input type="text" value="${player.name || ''}"></td>
            <td><input type="text" value="${player.innings || ''}"></td>
            <td><input type="number" value="${player.battersFaced || ''}"></td>
            <td><input type="number" value="${player.pitches || ''}"></td>
            <td><input type="number" value="${player.hits || ''}"></td>
            <td><input type="number" value="${player.strikeouts || ''}"></td>
            <td><input type="number" value="${player.walks || ''}"></td>
            <td><input type="number" value="${player.runs || ''}"></td>
            <td><input type="number" value="${player.earnedRuns || ''}"></td>
        </tr>
    `).join('');

    // もし投手が一人もいなければ、空の行を1つ追加しておく
    if (pitchingData.length === 0) {
        bodyRows = `
            <tr data-pitcher-index="0">
                <td><select><option value="" selected>-</option><option value="W">○</option><option value="L">●</option><option value="S">S</option><option value="H">H</option></select></td>
                <td><input type="text" value=""></td><td><input type="text" value=""></td><td><input type="number" value=""></td>
                <td><input type="number" value=""></td><td><input type="number" value=""></td><td><input type="number" value=""></td>
                <td><input type="number" value=""></td><td><input type="number" value=""></td><td><input type="number" value=""></td>
            </tr>
        `;
    }

    return `
        <div class="overflow-x-auto">
            <table class="details-table" id="pitching-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="w-12">勝敗</th><th class="col-player">選手名</th><th class="col-stat">回数</th>
                        <th class="col-stat">打者</th><th class="col-stat">球数</th><th class="col-stat">被安打</th>
                        <th class="col-stat">奪三振</th><th class="col-stat">与四球</th><th class="col-stat">失点</th>
                        <th class="col-stat">自責点</th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            <button class="add-row-btn text-xs mt-2" data-table-id="pitching-table-${teamKey}">+ 投手を追加</button>
        </div>
    `;
}

// ★★★ この関数を丸ごと置き換えてください ★★★
/**
 * 個人別打席結果のテーブルHTMLを生成する（交代選手表示バグ修正・最終版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（スタメン・交代選手の分離を修正した最終版）
 */
/**
 * Creates the batting stats table, with all dropdowns correctly implemented.
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（★列幅クラスを適用した最終版）
 */
// 【完成版】createPlayerBattingTable
/**
 * 個人別打席結果のテーブルHTMLを生成する（複数走者入力UI対応の最終版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（打者・走者入力分離の最終完成版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（複数打席ロジック統合版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（複数打席ロジック統合・最終版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（司令塔として再設計した最終版）
 */
function createPlayerBattingTable(teamName, teamKey, details) {
    const battingData = details.batting[teamKey] || [];
    const numInnings = details.inningScore?.[teamKey]?.length || 9;
    const playersOnField = battingData.filter(p => p.name);

    let numberOptions = '<option value=""></option>';
    for (let i = 1; i <= 20; i++) { numberOptions += `<option value="${i}">${i}</option>`; }
    const posOptions = ['投', '捕', '一', '二', '三', '遊', '左', '中', '右'].map(p => `<option value="${p}">${p}</option>`).join('');
    
    let inningsHeader = '';
    for (let i = 1; i <= numInnings; i++) {
        inningsHeader += `<th class="col-inning">${i}</th>`;
    }

    let bodyRows = '';

    for (let i = 1; i <= 9; i++) {
        let starterData = battingData.find(p => p.order && parseInt(p.order) === i) || { order: i, results: Array(numInnings).fill('') };
        if (!starterData.results) starterData.results = Array(numInnings).fill('');

        const starterNumberSelect = `<select class="player-number w-full bg-transparent">${numberOptions.replace(`value="${starterData.number}"`, `value="${starterData.number}" selected`)}</select>`;
        const starterPosSelect = `<select class="player-pos w-full bg-transparent"><option value=""></option>${posOptions.replace(`value="${starterData.pos}"`, `value="${starterData.pos}" selected`)}</select>`;
        
        let resultInputs = '';
        for (let j = 0; j < numInnings; j++) {
            const resultString = starterData.results[j] || '';
            const atBats = (resultString && resultString.split('、').length > 0) ? resultString.split('、') : [''];
            
            const atBatBlocksHTML = atBats.map(atBatString => 
                createBattingResultDropdowns(playersOnField, atBatString)
            ).join('');

            resultInputs += `
                <td class="col-inning batting-result-cell align-top p-1">
                    ${atBatBlocksHTML}
                    <button class="add-at-bat-btn text-xs mt-2 bg-blue-100 px-2 py-1 rounded hover:bg-blue-200 w-full font-semibold">＋ 2打席目を追加</button>
                </td>
            `;
        }
        bodyRows += `
            <tr data-order="${starterData.order}">
                <td class="col-order">${i}</td><td class="col-number">${starterNumberSelect}</td>
                <td class="col-player"><input type="text" class="player-name" value="${starterData.name || ''}"></td>
                <td class="col-pos flex items-center justify-between">${starterPosSelect}<button class="text-xs bg-gray-200 px-1 ml-1 rounded pos-change-btn" data-player-name="${starterData.name || ''}" data-team-key="${teamKey}">変更</button></td>
                <td class="col-sub-type"></td>${resultInputs}
            </tr>
        `;
        
        const substitutes = battingData.filter(p => p.order && p.order.toString().startsWith(`${i}-sub`));
        substitutes.forEach(subData => {
            if (!subData.results) subData.results = Array(numInnings).fill('');
            const subNumberSelect = `<select class="player-number w-full bg-transparent">${numberOptions.replace(`value="${subData.number}"`, `value="${subData.number}" selected`)}</select>`;
            const subPosSelect = `<select class="player-pos w-full bg-transparent"><option value=""></option>${posOptions.replace(`value="${subData.pos}"`, `value="${subData.pos}" selected`)}</select>`;
            
            let subResultInputs = '';
            for (let j = 0; j < numInnings; j++) {
                const resultString = subData.results[j] || '';
                const atBats = (resultString && resultString.split('、').length > 0) ? resultString.split('、') : [''];
                const atBatBlocksHTML = atBats.map(atBatString => 
                    createBattingResultDropdowns(playersOnField, atBatString)
                ).join('');
                subResultInputs += `
                    <td class="col-inning batting-result-cell align-top p-1">
                        ${atBatBlocksHTML}
                        <button class="add-at-bat-btn text-xs mt-2 bg-blue-100 px-2 py-1 rounded hover:bg-blue-200 w-full font-semibold">＋ 2打席目を追加</button>
                    </td>
                `;
            }
            
            bodyRows += `
                <tr data-order="${subData.order}">
                    <td class="col-order"></td><td class="col-number">${subNumberSelect}</td>
                    <td class="col-player pl-4"><input type="text" class="player-name" value="${subData.name || ''}"></td>
                    <td class="col-pos flex items-center justify-between">${subPosSelect}<button class="text-xs bg-gray-200 px-1 ml-1 rounded pos-change-btn" data-player-name="${subData.name || ''}" data-team-key="${teamKey}">変更</button></td>
                    <td class="col-sub-type">
                        <select class="sub-type-select w-full bg-transparent">
                            <option value="" ${!subData.sub_type ? 'selected' : ''}>-</option>
                            <option value="PH" ${subData.sub_type === 'PH' ? 'selected' : ''}>代打</option>
                            <option value="PR" ${subData.sub_type === 'PR' ? 'selected' : ''}>代走</option>
                            <option value="DEF" ${subData.sub_type === 'DEF' ? 'selected' : ''}>守備</option>
                            <option value="PITCHER" ${subData.sub_type === 'PITCHER' ? 'selected' : ''}>投手</option>
                        </select>
                    </td>
                    ${subResultInputs}
                </tr>
            `;
        });
    }

    return `
        <div class="overflow-x-auto">
            <table class="details-table batting-table" id="batting-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="col-order">打順</th><th class="col-number">#</th><th class="col-player">選手名</th>
                        <th class="col-pos">守備</th><th class="col-sub-type">出場</th>${inningsHeader}
                        <th class="w-10"><button class="add-inning-btn text-xs" data-team-key="${teamKey}">+ 回</button></th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            <button class="add-substitute-btn text-xs mt-2" data-team-key="${teamKey}">+ 交代選手を追加</button>
        </div>
    `;
}
    /**
 * 詳細データを保存し、通算成績を更新する
 * (★先攻後攻を入れ替えた場合にも対応した最終版)
 */
/**
 * 詳細データを保存し、通算成績を更新する（全ての機能を網羅した最終完成版）
 */
/**
 * 詳細データを保存し、通算成績を更新する（省略箇所を全て復元した最終完成版）
 */
/**
 * 詳細データを保存し、通算成績を更新する（データ構造の矛盾を解消した最終完成版）
 */
/**
 * 詳細データを保存し、通算成績を更新する（データ構造の矛盾を解消した最終完成版）
 */
function saveDetailedStats() {
    if (!currentMatchIdForDetails) return;
    const match = findMatchById(currentMatchIdForDetails);
    if (!match) return;

    // --- 1. 古い成績を一度リセット ---
    if (match.details && match.details.playerGameStats) {
        for (const teamKey of ['team1', 'team2']) {
            const teamName = match[teamKey];
            const teamRecord = tournamentState.teamRecords[teamName];
            if (!teamRecord || !teamRecord.playerStats) continue;

            const previousBattingStats = match.details.playerGameStats[teamKey];
            if (previousBattingStats) {
                for (const playerName in previousBattingStats) {
                    const careerStats = teamRecord.playerStats.batting[playerName];
                    const prevGameStats = previousBattingStats[playerName];
                    if (careerStats && prevGameStats) {
                        if(prevGameStats.played) careerStats.games = (careerStats.games || 1) - 1;
                        careerStats.pa -= prevGameStats.pa || 0;
                        careerStats.ab -= prevGameStats.ab || 0;
                        careerStats.h -= prevGameStats.h || 0;
                        careerStats.hr -= prevGameStats.hr || 0;
                        careerStats.rbi -= prevGameStats.rbi || 0;
                    }
                }
            }
            const previousPitchingStats = match.details.pitching?.[teamKey];
            if (previousPitchingStats) {
                previousPitchingStats.forEach(prevGameStats => {
                    const playerName = prevGameStats.name;
                    const careerStats = teamRecord.playerStats.pitching[playerName];
                    if (careerStats && prevGameStats && parseFloat(prevGameStats.innings) > 0) {
                        careerStats.games = (careerStats.games || 1) - 1;
                        if (prevGameStats.result === 'W') careerStats.w--;
                        if (prevGameStats.result === 'L') careerStats.l--;
                        careerStats.ip -= parseFloat(prevGameStats.innings || 0);
                        careerStats.so -= parseInt(prevGameStats.strikeouts || 0);
                        careerStats.er -= parseInt(prevGameStats.earnedRuns || 0);
                    }
                });
            }
        }
    }

    // --- 2. 新しい詳細データオブジェクトを作成 ---
    const details = { 
        inningScore: { team1: [], team2: [] }, 
        batting: { team1: [], team2: [] }, 
        pitching: { team1: [], team2: [] }, 
        playerGameStats: { team1: {}, team2: {} },
        positionChanges: match.details?.positionChanges || []
    };
    
    // --- 3. 画面から入力された値を読み取り、成績を再計算・加算 ---
    const scoreTable = document.getElementById('inning-score-table');
    if (scoreTable) {
        const rows = scoreTable.querySelectorAll('tbody tr');
        const team1Row = Array.from(rows).find(row => row.querySelector('th')?.textContent.trim() === match.team1);
        const team2Row = Array.from(rows).find(row => row.querySelector('th')?.textContent.trim() === match.team2);
        if (team1Row) details.inningScore.team1 = Array.from(team1Row.querySelectorAll('input')).map(input => parseInt(input.value) || 0);
        if (team2Row) details.inningScore.team2 = Array.from(team2Row.querySelectorAll('input')).map(input => parseInt(input.value) || 0);
    }
    match.score1 = details.inningScore.team1.reduce((sum, score) => sum + score, 0);
    match.score2 = details.inningScore.team2.reduce((sum, score) => sum + score, 0);

    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord) continue;
        if (!teamRecord.playerStats) teamRecord.playerStats = { batting: {}, pitching: {} };

        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (battingTable) {
            battingTable.querySelectorAll('tbody tr').forEach(row => {
                const nameInput = row.querySelector('.player-name');
                if (nameInput && nameInput.value.trim() !== '') {
                    
                    const resultCells = Array.from(row.querySelectorAll('td.col-inning'));
                    const results = resultCells.map(cell => {
                        const atBatBlocks = Array.from(cell.querySelectorAll('.at-bat-block'));
                        
                        const atBatsString = atBatBlocks.map(block => {
                            const container = block.querySelector('.batting-result-container');
                            if (!container) return ''; 

                            const resultType = container.querySelector('.result-type').value;
                            const direction = container.querySelector('.result-direction').value;
                            const rbi = container.querySelector('.result-rbi').value;
                            const runnerPlay = container.querySelector('.result-runner-play').value;
                            const batterPlay = [direction, resultType, rbi, runnerPlay].filter(Boolean).join('');
                            
                            // ▼▼▼【重要修正】区切り文字を「、」から「,」に変更▼▼▼
                            const runnerPlays = Array.from(block.querySelectorAll('.runner-play-input')).map(rpContainer => {
                                const name = rpContainer.querySelector('.runner-name').value;
                                const play = rpContainer.querySelector('.runner-play').value;
                                const base = rpContainer.querySelector('.runner-base').value;
                                if (!name || !play) return '';
                                return [name, play, base].filter(Boolean).join(' ');
                            }).filter(Boolean).join(',');
                            // ▲▲▲
                            
                            return [batterPlay, runnerPlays].filter(Boolean).join(';');
                        }).join('、');

                        return atBatsString;
                    });
                    
                    const playerData = {
                        order: row.dataset.order, name: nameInput.value.trim(),
                        number: row.querySelector('.player-number').value,
                        pos: row.querySelector('.player-pos').value,
                        sub_type: row.querySelector('.sub-type-select') ? row.querySelector('.sub-type-select').value : null,
                        results: results
                    };
                    details.batting[teamKey].push(playerData);
                    
                    const playerName = playerData.name;
                    if (!teamRecord.playerStats.batting[playerName]) {
                        teamRecord.playerStats.batting[playerName] = { games: 0, pa: 0, ab: 0, h: 0, hr: 0, rbi: 0 };
                    }
                    const careerStats = teamRecord.playerStats.batting[playerName];
                    const gameStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, played: false };

                    playerData.results.forEach(inningResultString => {
                        if (!inningResultString) return;
                        inningResultString.split('、').forEach(atBatString => {
                            if (!atBatString) return;
                            const [batterPlay] = atBatString.split(';');
                            if (!batterPlay) return;
                            
                            gameStats.played = true;
                            gameStats.pa++;
                            if (!batterPlay.includes('四球') && !batterPlay.includes('死球') && !batterPlay.includes('犠')) gameStats.ab++;
                            
                            const isHitWord = ['安', '二塁打', '三塁打', '本塁打'].some(w => batterPlay.includes(w));
                            if (isHitWord) gameStats.h++;
                            if (batterPlay.includes('本')) gameStats.hr++;
                            if (batterPlay.includes('点')) {
                                const rbiMatch = batterPlay.match(/(\d+)点/);
                                gameStats.rbi += rbiMatch ? parseInt(rbiMatch[1]) : 1;
                            }
                        });
                    });

                    if(gameStats.played) careerStats.games++;
                    careerStats.pa += gameStats.pa;
                    careerStats.ab += gameStats.ab;
                    careerStats.h += gameStats.h;
                    careerStats.hr += gameStats.hr;
                    careerStats.rbi += gameStats.rbi;
                    
                    details.playerGameStats[teamKey][playerName] = gameStats;
                }
            });
        }
        const pitchingTable = document.getElementById(`pitching-table-${teamKey}`);
        if (pitchingTable) {
            pitchingTable.querySelectorAll('tbody tr').forEach(row => {
                const inputs = row.querySelectorAll('input');
                const select = row.querySelector('select');
                if (inputs[0] && inputs[0].value.trim() !== '') {
                    const pitcherData = {
                        result: select.value, name: inputs[0].value.trim(), innings: inputs[1].value,
                        battersFaced: inputs[2].value, pitches: inputs[3].value, hits: inputs[4].value,
                        strikeouts: inputs[5].value, walks: inputs[6].value, runs: inputs[7].value,
                        earnedRuns: inputs[8].value,
                    };
                    details.pitching[teamKey].push(pitcherData);

                    const pitcherName = pitcherData.name;
                    if (!teamRecord.playerStats.pitching[pitcherName]) {
                        teamRecord.playerStats.pitching[pitcherName] = { games: 0, w: 0, l: 0, ip: 0, so: 0, er: 0 };
                    }
                    const careerStats = teamRecord.playerStats.pitching[pitcherName];
                    if (parseFloat(pitcherData.innings) > 0) {
                        careerStats.games = (careerStats.games || 0) + 1;
                        if (pitcherData.result === 'W') careerStats.w++;
                        if (pitcherData.result === 'L') careerStats.l--;
                        careerStats.ip += parseFloat(pitcherData.innings) || 0;
                        careerStats.so += parseInt(pitcherData.strikeouts) || 0;
                        careerStats.er += parseInt(pitcherData.earnedRuns) || 0;
                    }
                }
            });
        }
    }

    match.details = details;
    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord) continue;
        const battingData = details.batting[teamKey];
        if (battingData && battingData.length > 0) {
            teamRecord.roster = battingData
                .filter(p => p.order && !p.order.toString().includes('sub'))
                .map(p => ({ order: p.order, number: p.number, name: p.name, pos: p.pos }));
        }
    }

    saveState();
    detailsModal.classList.add('hidden');
    renderTournament(tournamentState);
    alert('詳細を保存しました。');
}
/**
     * 【修正版】スキップ機能関連
     */
    function generateAutoScore(rankWinner, rankLoser) {
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        const diff = rankValues[rankWinner] - rankValues[rankLoser];
        let winnerScore, loserScore;

        if (diff >= 3) { // 大差
            winnerScore = 7 + Math.floor(Math.random() * 4);
            loserScore = Math.floor(Math.random() * 3);
        } else if (diff >= 2) { // 中差
            winnerScore = 5 + Math.floor(Math.random() * 3);
            loserScore = Math.max(0, winnerScore - (3 + Math.floor(Math.random() * 2)));
        } else if (diff >= 1) { // 小差
            winnerScore = 3 + Math.floor(Math.random() * 4);
            loserScore = Math.max(0, winnerScore - (1 + Math.floor(Math.random() * 2)));
        } else { // 同ランク
            winnerScore = 2 + Math.floor(Math.random() * 5);
            loserScore = winnerScore - 1;
        }
        return [winnerScore, loserScore];
    }

    /**
     * 【修正版】ラウンドを自動でスキップする
     */
    async function skipRound(roundNumber) {
        const btnId = `skip-r${roundNumber}-btn`;
        const btn = document.getElementById(btnId);
        if (btn) btn.disabled = true;

        const matchIds = [];
        const numMatchesInRoundSide = (tournamentState.teams.length / 2) / Math.pow(2, roundNumber - 1);

        ['L', 'R'].forEach(side => {
            for (let i = 1; i <= numMatchesInRoundSide; i++) {
                matchIds.push(`${side}-R${roundNumber}-M${i}`);
            }
        });

        const results = []; // このラウンドの結果を格納する配列

        // ステップ1：ラウンドの全試合の勝敗を決定
        for (const matchId of matchIds) {
            const match = tournamentState.matches[matchId];
            if (!match || match.winner || !match.team1 || !match.team2) continue;

            const { team1, team2 } = match;
            const rank1 = calculateRank(team1, tournamentState);
            const rank2 = calculateRank(team2, tournamentState);
            const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
            let winnerName, loserName;
            
            const upsetChance = 0.15 - (Math.abs(rankValues[rank1] - rankValues[rank2]) * 0.03);

            if (Math.random() < upsetChance) { // 番狂わせ
                winnerName = rankValues[rank1] < rankValues[rank2] ? team1 : team2;
            } else { // 順当
                winnerName = rankValues[rank1] >= rankValues[rank2] ? team1 : team2;
            }
            loserName = winnerName === team1 ? team2 : team1;
            
            const winnerRank = calculateRank(winnerName, tournamentState);
            const loserRank = calculateRank(loserName, tournamentState);

            const [winnerScore, loserScore] = generateAutoScore(winnerRank, loserRank);
            match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
            match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;
            match.winner = winnerName;
            
            if (tournamentState.teamRecords[winnerName]) tournamentState.teamRecords[winnerName].wins++;
            if (tournamentState.teamRecords[loserName]) tournamentState.teamRecords[loserName].losses++;
            
            // ダイジェスト記事用に結果を保存
            results.push({ winnerName, loserName, winnerScore, loserScore, rankDiff: Math.abs(rankValues[rank1] - rankValues[rank2]) });
        }
        
        // ステップ2：勝者を次のラウンドに進める
        const nextRoundNum = roundNumber + 1;
        const numTeams = tournamentState.teams.length;
        const finalRound = Math.log2(numTeams);

        if (nextRoundNum <= finalRound) {
            const numMatchesInNextRoundSide = numTeams / 2 / Math.pow(2, nextRoundNum - 1);
            for (const side of ['L', 'R']) {
                if (nextRoundNum < finalRound) {
                    for (let m = 1; m <= numMatchesInNextRoundSide; m++) {
                        const prevMatch1Id = `${side}-R${roundNumber}-M${(m * 2) - 1}`;
                        const prevMatch2Id = `${side}-R${roundNumber}-M${m * 2}`;
                        const winner1 = tournamentState.matches[prevMatch1Id]?.winner;
                        const winner2 = tournamentState.matches[prevMatch2Id]?.winner;
                        const nextMatchId = `${side}-R${nextRoundNum}-M${m}`;
                        
                        if (!tournamentState.matches[nextMatchId]) {
                            tournamentState.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
                        }
                        tournamentState.matches[nextMatchId].team1 = winner1;
                        tournamentState.matches[nextMatchId].team2 = winner2;
                    }
                } else { // 決勝戦への進出処理
                    const finalMatchId = 'F-R1-M1';
                    if (!tournamentState.matches[finalMatchId]) {
                         tournamentState.matches[finalMatchId] = { id: finalMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
                    }
                    const semiFinalWinner = tournamentState.matches[`${side}-R${roundNumber}-M1`]?.winner;
                    if (side === 'L') tournamentState.matches[finalMatchId].team1 = semiFinalWinner;
                    if (side === 'R') tournamentState.matches[finalMatchId].team2 = semiFinalWinner;
                }
            }
        }
        
        // ステップ3：UIの更新とダイジェスト記事の生成
        renderTournament(tournamentState);
        newsContainer.innerHTML = `<div class="loader">AI記者が${roundNumber}回戦のダイジェスト記事を執筆中...</div>`;

        const summaryArticle = await generateSkipRoundSummaryArticle(roundNumber, results);
        if (summaryArticle) {
            tournamentState.news.push(summaryArticle);
        }
        
        renderNews(tournamentState.news);
        saveState();
        if (btn) btn.classList.add('hidden');
    }
// --- NEW Autumn Tournament System ---

    /**
 * [秋季大会 ステージ1] 地区ブロック予選を開始する（伊豆地区追加・最終版）
 */
/**
 * [秋季大会 ステージ1] 地区ブロック予選を開始する（伊豆地区追加・最終版）
 */
async function setupAutumnRegionalBlocks() {
    tournamentState.autumnPhase = 'regional_blocks';
    
    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    INITIAL_TEAM_POOL.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region) teamsByRegion[region].push(teamName);
    });

    // 主要3地区のブロック分け
    ['東部', '中部', '西部'].forEach(region => {
        let regionalTeams = shuffleArray(teamsByRegion[region]);
        const blocks = [];
        for (let i = 0; i < 4; i++) { // 4ブロック作成
            const blockTeams = regionalTeams.splice(0, 5); // 5チームずつ
            if (blockTeams.length === 0) continue;

            const blockId = `${region}-B${i+1}`;
            
            const playInMatchId = `${blockId}-R0-M1`;
            const semi1Id = `${blockId}-R1-M1`;
            const semi2Id = `${blockId}-R1-M2`;
            const finalId = `${blockId}-R2-M1`;

            const matches = {
                [playInMatchId]: { id: playInMatchId, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '', summary: '' },
                [semi1Id]: { id: semi1Id, team1: null, team2: blockTeams[2], winner: null, score1: '', score2: '', summary: '' },
                [semi2Id]: { id: semi2Id, team1: blockTeams[3], team2: blockTeams[4], winner: null, score1: '', score2: '', summary: '' },
                [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '', summary: '' }
            };
            blocks.push({ id: blockId, teams: blockTeams, matches });
        }
        tournamentState.autumnData.regions[region].blocks = blocks;
    });

    // 伊豆地区の4チームトーナメントを作成
    const izuTeams = shuffleArray(teamsByRegion['伊豆']);
    const izuBracketId = '伊豆-AUTUMN';
    const izuMatches = {
        [`${izuBracketId}-R1-M1`]: { id: `${izuBracketId}-R1-M1`, team1: izuTeams[0], team2: izuTeams[1], winner: null, score1: '', score2: '' },
        [`${izuBracketId}-R1-M2`]: { id: `${izuBracketId}-R1-M2`, team1: izuTeams[2], team2: izuTeams[3], winner: null, score1: '', score2: '' },
        [`${izuBracketId}-R2-M1`]: { id: `${izuBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' } // 決勝
    };
    tournamentState.autumnData.regions['伊豆'].izuBracket = {
        id: izuBracketId,
        teams: izuTeams,
        matches: izuMatches
    };

    renderTournament(tournamentState);
    saveState();
}
   
/**
 * [秋季大会 ステージ1 UI] 地区ブロック予選を描画する（伊豆地区追加・最終版）
 */
function renderAutumnRegionalBlocks() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">秋季大会 地区予選</h2>`;
    html += '<div class="space-y-8">';

    // 東部・中部・西部の描画
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.blocks) continue;

        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">${region}地区 (5枠)</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    ${regionData.blocks.map(block => `
                        <div class="p-3 border rounded-lg bg-gray-50">
                            <h4 class="font-bold text-center mb-2">ブロック ${block.id.split('-')[1]}</h4>
                            ${create5TeamBlockHTML(block)}
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    // 伊豆地区の描画
    const izuData = tournamentState.autumnData.regions['伊豆'];
    if (izuData && izuData.izuBracket) {
        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">伊豆地区 (1枠)</h3>
                <div class="flex justify-center">
                    ${create4TeamBlockHTML(izuData.izuBracket)}
                </div>
            </div>
        `;
    }

    html += '</div>';
    autumnRegionalContainer.innerHTML = html;
    checkAutumnRegionalBlocksComplete();
}

    /**
     * 5チーム構成のブロックトーナメントHTMLを生成する
     * @param {object} blockData - 対象ブロックのデータ
     */
    // 【修正対象2】
function create5TeamBlockHTML(blockData) {
    const { id, matches } = blockData;
    const playIn = matches[`${id}-R0-M1`];
    const semi1 = matches[`${id}-R1-M1`];
    const semi2 = matches[`${id}-R1-M2`];
    const final = matches[`${id}-R2-M1`];

    // 試合の進行状況を更新
    semi1.team1 = playIn.winner;
    final.team1 = semi1.winner;
    final.team2 = semi2.winner;

    return `
        <div class="flex items-center justify-center space-x-2 text-xs">
            <div class="flex flex-col justify-around h-full space-y-4">
                <div class="w-40">${createMatchHTML(playIn.id, playIn.team1, playIn.team2, playIn, [])}</div>
                <div class="w-40">${createMatchHTML(semi2.id, semi2.team1, semi2.team2, semi2, [])}</div>
            </div>
            <div class="flex flex-col justify-center h-full w-40">
                ${createMatchHTML(semi1.id, semi1.team1, semi1.team2, semi1, [])}
            </div>
            <div class="flex flex-col justify-center h-full w-40">
                ${createMatchHTML(final.id, final.team1, final.team2, final, [])}
            </div>
        </div>
    `;
}

    /**
     * [秋季大会 ステージ2] 地区内順位決定戦を開始する
     */
    async function setupAutumnRankingTournaments() {
    tournamentState.autumnPhase = 'regional_ranking';

    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        
        // 重要な変更：上位校トーナメントは廃止し、敗者復活戦のみを行う
        regionData.champBracket = null; // 不要になったのでクリア

        // ブロック準優勝したチームで、第5代表決定トーナメントを組む
        const repechageBracketId = `${region}-REP`;
        const repTeams = shuffleArray(regionData.blockRunnersUp);
        regionData.repechageBracket = {
            id: repechageBracketId,
            teams: repTeams,
            matches: {
                [`${repechageBracketId}-R1-M1`]: { id: `${repechageBracketId}-R1-M1`, team1: repTeams[0], team2: repTeams[1], winner: null, score1: '', score2: '', summary: '' },
                [`${repechageBracketId}-R1-M2`]: { id: `${repechageBracketId}-R1-M2`, team1: repTeams[2], team2: repTeams[3], winner: null, score1: '', score2: '', summary: '' },
                [`${repechageBracketId}-R2-M1`]: { id: `${repechageBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '', summary: '' } // 5位決定戦
            }
        };
    }
    
    renderTournament(tournamentState);
    saveState();
}
    /**
     * [秋季大会 ステージ2 UI] 地区内順位決定戦を描画する
     */
   // 【修正対象3】
function renderAutumnRankingTournaments() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">秋季大会 地区 第5代表決定トーナメント</h2>`;
    html += '<div class="space-y-8">';
    
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.repechageBracket) continue;

        const rep = regionData.repechageBracket;
        
        const repSemi1 = rep.matches[`${rep.id}-R1-M1`];
        const repSemi2 = rep.matches[`${rep.id}-R1-M2`];
        rep.matches[`${rep.id}-R2-M1`].team1 = repSemi1.winner;
        rep.matches[`${rep.id}-R2-M1`].team2 = repSemi2.winner;
        
        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">${region}地区</h3>
                <div class="flex items-center justify-center space-x-4">
                    <div class="space-y-4">
                        ${createMatchHTML(repSemi1.id, repSemi1.team1, repSemi1.team2, repSemi1, [])}
                        
                        ${createMatchHTML(repSemi2.id, repSemi2.team1, repSemi2.team2, repSemi2, [])}
                        </div>
                    <div>
                        <p class="text-center font-semibold">代表決定戦</p>
                        ${createMatchHTML(rep.matches[`${rep.id}-R2-M1`].id, rep.matches[`${rep.id}-R2-M1`].team1, rep.matches[`${rep.id}-R2-M1`].team2, rep.matches[`${rep.id}-R2-M1`], [])}
                    </div>
                </div>
            </div>
        `;
    }
    html += '</div>';
    autumnRankingContainer.innerHTML = html;
    checkAutumnRankingTournamentsComplete();
}
    /**
     * [秋季大会 ステージ3] 県大会本戦を開始する
     */
   // 【修正対象4】
/**
 * [秋季大会 ステージ3] 県大会本戦を開始する（組み合わせロジックを修正した完全版）
 */
async function setupAutumnMainTournament() {
    tournamentState.autumnPhase = 'main';
    tournamentState.is16team = true;

    // --- 代表チームのリストを作成 ---
    const finalReps = [];
    // 1. 伊豆地区の代表
    const izuWinner = tournamentState.autumnData.regions['伊豆'].finalReps[0];
    if (izuWinner) finalReps.push(izuWinner.team);

    // 2. 主要3地区の代表
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        // 2-1. ブロック優勝した4チーム
        finalReps.push(...regionData.blockWinners);
        // 2-2. 敗者復活戦を勝ち上がった1チーム
        const repFinal = regionData.repechageBracket.matches[`${region}-REP-R2-M1`];
        if (repFinal.winner) {
            finalReps.push(repFinal.winner);
        }
    }

    // --- トーナメントデータを作成 ---
    tournamentState.teams = shuffleArray(finalReps); // 16チームをシャッフル
    tournamentState.matches = {};
    tournamentState.seeds = []; //秋季県大会はシードなし

    const round1Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    round1Setup.forEach((match, index) => {
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

    renderTournament(tournamentState);
    saveState();

    // --- 記事生成などの後続処理 (変更なし) ---
    const currentTournamentName = "秋季県大会本戦";
    newsContainer.innerHTML = `<div class="loader">AI記者が${currentTournamentName}の展望記事を執筆中...</div>`;
    bbsCommentsContainer.innerHTML = `<div class="loader">AIが組み合わせを分析中...</div>`;

    const [previewArticle, bracketComments] = await Promise.all([
        generateNewsArticle({ matchId: 'preview' }), // ★簡易contextを渡す
    generateBracketReactionComments(tournamentState)
]);
    if (previewArticle) tournamentState.news.unshift(previewArticle);
    if (bracketComments && bracketComments.length > 0) tournamentState.bbsComments.push(...bracketComments);
    
    renderNews(tournamentState.news);
    renderBbsComments(tournamentState.bbsComments);
    saveState();
}
    /**
     * 秋季地区ブロック予選がすべて終了したかチェックする
     */
    function checkAutumnRegionalBlocksComplete() {
    let allBlocksFinished = true;
    // 東部・中部・西部のチェック
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.blocks || regionData.blocks.length === 0) {
            allBlocksFinished = false; break;
        }
        for (const block of regionData.blocks) {
            const finalMatch = block.matches[`${block.id}-R2-M1`];
            if (!finalMatch.winner) {
                allBlocksFinished = false; break;
            }
        }
        if (!allBlocksFinished) break;
    }

    // ▼▼▼ このブロックが修正箇所 ▼▼▼
    // 伊豆地区のチェック
    if (allBlocksFinished) {
        const izuData = tournamentState.autumnData.regions['伊豆'];
        if (!izuData.izuBracket || !izuData.izuBracket.matches[`伊豆-AUTUMN-R2-M1`].winner) {
            allBlocksFinished = false;
        }
    }
    // ▲▲▲

    if (allBlocksFinished) {
        autumnControls.classList.remove('hidden');
        startRankingPlayoffsBtn.classList.remove('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startRankingPlayoffsBtn.classList.add('hidden');
    }
}

    /**
     * 秋季地区内順位決定戦がすべて終了したかチェックする
     */
    /**
     * 【修正版】秋季地区内順位決定戦がすべて終了したかチェックする
     */
    function checkAutumnRankingTournamentsComplete() {
    let allRankingsFinished = true;
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.repechageBracket) {
            allRankingsFinished = false;
            break;
        }

        const repechageFinal = regionData.repechageBracket.matches[`${region}-REP-R2-M1`]; // 5位決定戦

        // 敗者復活戦の決勝がすべて終わっているかチェック
        if (!repechageFinal.winner) {
            allRankingsFinished = false;
            break;
        }
    }
    
    if (allRankingsFinished) {
        autumnControls.classList.remove('hidden');
        startRankingPlayoffsBtn.classList.add('hidden');
        startMainTournamentBtn.classList.remove('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startMainTournamentBtn.classList.add('hidden');
    }
}
// --- NEW Spring Tournament System ---

/**
 * [春季大会 ステージ1] 地区予選を開始する（3校トーナメント対応・最終版）
 */
async function setupSpringRegionalQualifiers() {
    tournamentState.springPhase = 'regional_qualifiers';
    const { qualifierTeams } = tournamentState.springData;

    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    qualifierTeams.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region && teamsByRegion[region]) {
            teamsByRegion[region].push(teamName);
        }
    });
    
    // 東部・中部・西部地区の予選設定
    for (const region of ['東部', '中部', '西部']) {
        let regionalTeams = shuffleArray(teamsByRegion[region]);
        const blockCount = 4;
        const regionBlocks = [];
        
        for (let i = 0; i < blockCount; i++) {
            const blockTeams = regionalTeams.splice(0, Math.ceil(regionalTeams.length / (blockCount - i)));
            if(blockTeams.length === 0) continue;
            
            const blockId = `${region}-SB${i+1}`; // Spring Block
            const blockMatches = {};
            
            // チーム数に応じてトーナメント形式を決定
            if (blockTeams.length <= 4) { // 4チーム以下
                const semi1Id = `${blockId}-R1-M1`;
                const semi2Id = `${blockId}-R1-M2`;
                const finalId = `${blockId}-R2-M1`;
                Object.assign(blockMatches, {
                    [semi1Id]: { id: semi1Id, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '' },
                    [semi2Id]: { id: semi2Id, team1: blockTeams[2] || null, team2: blockTeams[3] || null, winner: null, score1: '', score2: '' },
                    [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '' }
                });
            } else { // 5チーム
                 const playInMatchId = `${blockId}-R0-M1`;
                 const semi1Id = `${blockId}-R1-M1`;
                 const semi2Id = `${blockId}-R1-M2`;
                 const finalId = `${blockId}-R2-M1`;
                 Object.assign(blockMatches, {
                    [playInMatchId]: { id: playInMatchId, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '' },
                    [semi1Id]: { id: semi1Id, team1: null, team2: blockTeams[2], winner: null, score1: '', score2: '' },
                    [semi2Id]: { id: semi2Id, team1: blockTeams[3], team2: blockTeams[4], winner: null, score1: '', score2: '' },
                    [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '' }
                 });
            }
            regionBlocks.push({ id: blockId, teams: blockTeams, matches: blockMatches });
            Object.assign(tournamentState.springData.allMatches, blockMatches);
        }
        tournamentState.springData.regions[region].blocks = regionBlocks;

        // 第5代表決定トーナメントの器を準備
        const repBracketId = `${region}-SREP`;
        tournamentState.springData.regions[region].repechageBracket = {
            id: repBracketId,
            teams: [], // ブロック準優勝校がここに入る
            matches: {
                [`${repBracketId}-R1-M1`]: { id: `${repBracketId}-R1-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' },
                [`${repBracketId}-R1-M2`]: { id: `${repBracketId}-R1-M2`, team1: null, team2: null, winner: null, score1: '', score2: '' },
                [`${repBracketId}-R2-M1`]: { id: `${repBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' }
            }
        };
        Object.assign(tournamentState.springData.allMatches, tournamentState.springData.regions[region].repechageBracket.matches);
    }
    
    // 伊豆地区の予選設定
    const izuTeams = shuffleArray(teamsByRegion['伊豆']);
    const izuBracketId = '伊豆-SIZU'; // IDを'SIZU'に変更
    const izuBracket = { id: izuBracketId, teams: izuTeams, matches: {} };

    if (izuTeams.length === 3) {
        // --- 3校トーナメントの場合 ---
        const semiId = `${izuBracketId}-R1-M1`;
        const finalId = `${izuBracketId}-R2-M1`;
        // 1チームが不戦勝（bye）で決勝へ
        Object.assign(izuBracket.matches, {
            [semiId]: { id: semiId, team1: izuTeams[0], team2: izuTeams[1], winner: null, score1: '', score2: '' },
            [finalId]: { id: finalId, team1: null, team2: izuTeams[2], winner: null, score1: '', score2: '' }
        });
    } else if (izuTeams.length >= 2) {
        // --- 4校（または2校）トーナメントの場合 ---
        const semi1Id = `${izuBracketId}-R1-M1`;
        const semi2Id = `${izuBracketId}-R1-M2`;
        const finalId = `${izuBracketId}-R2-M1`;
        Object.assign(izuBracket.matches, {
            [semi1Id]: { id: semi1Id, team1: izuTeams[0], team2: izuTeams[1], winner: null, score1: '', score2: '' },
            [semi2Id]: { id: semi2Id, team1: izuTeams[2] || null, team2: izuTeams[3] || null, winner: null, score1: '', score2: '' },
            [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '' }
        });
    }
    tournamentState.springData.regions['伊豆'].izuBracket = izuBracket;
    Object.assign(tournamentState.springData.allMatches, izuBracket.matches);

    renderTournament(tournamentState);
    saveState();
}

/**
 * [春季大会 ステージ1 UI] 地区予選を描画する
 */
function renderSpringRegionalQualifiers() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">春季大会 地区予選</h2>`;
    html += '<div class="space-y-8">';

    // 東部・中部・西部
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.springData.regions[region];
        if (!regionData.blocks) continue;

        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-green-700">${region}地区 (5枠)</h3>
                <h4 class="font-bold text-center text-lg mb-2">代表決定ブロック</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    ${regionData.blocks.map(block => `
                        <div class="p-3 border rounded-lg bg-gray-50">
                            <h4 class="font-bold text-center mb-2">ブロック ${block.id.split('-')[1].slice(1)}</h4>
                            ${block.teams.length <= 4 ? create4TeamBlockHTML(block) : create5TeamBlockHTML(block)}
                        </div>
                    `).join('')}
                </div>
                <h4 class="font-bold text-center text-lg mb-2">第5代表決定トーナメント</h4>
                <div class="flex justify-center">
                   ${create4TeamBlockHTML(regionData.repechageBracket, true)}
                </div>
            </div>
        `;
    }

    // 伊豆
    const izuData = tournamentState.springData.regions['伊豆'];
    if (izuData.izuBracket) {
        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-green-700">伊豆地区 (1枠)</h3>
                <div class="flex justify-center">
                    ${create4TeamBlockHTML(izuData.izuBracket)}
                </div>
            </div>
        `;
    }
    
    html += '</div>';
    autumnRegionalContainer.innerHTML = html; // 秋のコンテナを流用
    checkSpringQualifiersComplete();
}

/**
 * 4チーム構成のブロックトーナメントHTMLを生成する
 */
function create4TeamBlockHTML(blockData, isRepechage = false) {
    if (!blockData || !blockData.matches) return '<div></div>';
    const { id, matches } = blockData;
    const semi1 = matches[`${id}-R1-M1`];
    const semi2 = matches[`${id}-R1-M2`];
    const final = matches[`${id}-R2-M1`];
    if (!semi1 || !semi2 || !final) return '<div></div>';

    // 試合の進行状況を更新
    final.team1 = semi1.winner;
    final.team2 = semi2.winner;

    const placeholder = isRepechage ? 'ブロック準優勝校' : '---';

    return `
        <div class="flex items-center justify-center space-x-2 text-xs">
            <div class="space-y-4 w-40">
                ${createMatchHTML(semi1.id, semi1.team1 || placeholder, semi1.team2 || placeholder, semi1, [])}
                ${createMatchHTML(semi2.id, semi2.team1 || placeholder, semi2.team2 || placeholder, semi2, [])}
            </div>
            <div class="w-40">
                ${createMatchHTML(final.id, final.team1, final.team2, final, [])}
            </div>
        </div>
    `;
}

/**
 * 春季地区予選がすべて終了したかチェックする
 */
function checkSpringQualifiersComplete() {
    let allFinished = true;
    for (const match of Object.values(tournamentState.springData.allMatches)) {
        // チームがセットされていて、まだ勝者が決まっていない試合があるか
        if (match.team1 && match.team2 && !match.winner) {
            allFinished = false;
            break;
        }
    }

    if (allFinished) {
        autumnControls.classList.remove('hidden');
        startMainTournamentBtn.classList.remove('hidden'); // 県大会へ進むボタン
        startRankingPlayoffsBtn.classList.add('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startMainTournamentBtn.classList.add('hidden');
    }
}/**
 * [春季大会 ステージ2-1] 県大会本戦1回戦を開始する
 */
async function setupSpringMainTournament_Round1() {
    tournamentState.springPhase = 'main_round1';
    
    // 各地区の代表校をfinalRepsから集計
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.springData.regions[region];
        // ブロック優勝校
        regionData.blocks.forEach(block => {
            const finalMatch = block.matches[`${block.id}-R2-M1`] || block.matches[`${block.id}-R1-M1`]; // 2,3チームブロック対応
            if(finalMatch && finalMatch.winner) regionData.finalReps.push(finalMatch.winner);
        });
        // 第5代表
        const repFinal = regionData.repechageBracket.matches[`${regionData.repechageBracket.id}-R2-M1`];
        if (repFinal.winner) regionData.finalReps.push(repFinal.winner);
    }
    const izuFinal = tournamentState.springData.regions['伊豆'].izuBracket.matches[`伊豆-SIZU-R2-M1`];
    if (izuFinal.winner) tournamentState.springData.regions['伊豆'].finalReps.push(izuFinal.winner);

    const qualifiedTeams = Object.values(tournamentState.springData.regions).flatMap(r => r.finalReps);
    
    // 予選敗退チームの成績を記録
    tournamentState.springData.qualifierTeams.forEach(team => {
        if (!qualifiedTeams.includes(team)) {
            tournamentState.teamRecords[team].lastFinish = 64; // 予選敗退
        }
    });

    tournamentState.teams = shuffleArray(qualifiedTeams); // 予選突破16校で1回戦
    tournamentState.matches = {};
    tournamentState.is16team = true; // 16チームトーナメントとして描画
    tournamentState.seeds = []; // 1回戦はシードなし

    const round1Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    round1Setup.forEach((match, index) => {
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

    renderTournament(tournamentState);
    saveState();
    
    // 展望記事などを生成...
    newsContainer.innerHTML = `<div class="loader">AI記者が県大会1回戦の展望記事を執筆中...</div>`;
    // ★展望記事用の簡易contextを作成して渡す
    const previewContext = { matchId: 'preview' };
    const previewArticle = await generateNewsArticle(previewContext);
    if (previewArticle) tournamentState.news.unshift(previewArticle);

    renderNews(tournamentState.news);
    saveState();
}

/**
 * [春季大会 ステージ2-2] 県大会本戦2回戦を開始する
 */
async function setupSpringMainTournament_Round2() {
    tournamentState.springPhase = 'main_round2_onwards';
    
    const round1Winners = [];
    Object.values(tournamentState.matches).forEach(match => {
        if(match.id.includes('-R1-') && match.winner) {
            round1Winners.push(match.winner);
        }
    });

    const seedTeams = tournamentState.springData.seedTeams;
    const shuffledSeeds = shuffleArray(seedTeams);
    const shuffledWinners = shuffleArray(round1Winners);

    // 2回戦の組み合わせを作成 (シード vs 1回戦勝者)
    let newTeamsForRound2 = [];
    for (let i = 0; i < 8; i++) {
        newTeamsForRound2.push(shuffledSeeds[i]);
        newTeamsForRound2.push(shuffledWinners[i]);
    }
    newTeamsForRound2 = shuffleArray(newTeamsForRound2); // 組み合わせをシャッフル

    tournamentState.teams = newTeamsForRound2;
    tournamentState.matches = {};
    tournamentState.is16team = true;
    tournamentState.seeds = seedTeams; // 2回戦からシード校として表示

    const round2Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    // R1として試合IDを生成するが、これは大会の「2回戦」にあたる
    round2Setup.forEach((match, index) => {
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });
    
    // 敗退チームの成績を記録
    Object.values(tournamentState.teamRecords).forEach(record => {
        if (record.lastFinish > 16 && record.lastFinish <=32) record.lastFinish = 32; // 1回戦敗退はベスト32扱い
    });
    
    renderTournament(tournamentState);
    saveState();

    // 2回戦の展望記事を生成
    newsContainer.innerHTML = `<div class="loader">AI記者が県大会2回戦の展望記事を執筆中...</div>`;
    // ★展望記事用の簡易contextを作成して渡す
    const previewContext = { matchId: 'preview' };
    const previewArticle = await generateNewsArticle(previewContext);
    if (previewArticle) tournamentState.news.unshift(previewArticle);
    if(previewArticle) 
        tournamentState.news.unshift(previewArticle);
    

    renderNews(tournamentState.news);
    saveState();
}


// --- AI Content Generation & Helpers (Part A: Main Generators) ---

/**
 * 試合の全情報を集約した「matchContext」オブジェクトを生成する司令塔（★生の打席結果を渡すように修正）
 * @param {string} matchId - 対象の試合ID
 * @param {string} winnerName - 勝者名
 * @returns {object} - AIに渡すための全ての情報が詰まったオブジェクト
 */
function createMatchContext(matchId, winnerName) {
    const dbMatch = findMatchById(matchId);
    if (!dbMatch) return null;

    const loserName = dbMatch.team1 === winnerName ? dbMatch.team2 : dbMatch.team1;
    const nextOpponentInfo = findNextOpponent(winnerName, matchId);
    let nextOpponentJourney = null;
    if (nextOpponentInfo && nextOpponentInfo.opponentName && !['（未定）', '優勝'].includes(nextOpponentInfo.opponentName)) {
        nextOpponentJourney = getCurrentTournamentPerformance(nextOpponentInfo.opponentName, matchId);
    }

    const { highlights, keyPlayerNames } = createHighlightsText(dbMatch, winnerName);

    // ★★★ ここからが変更点 ★★★
    // generatePlayByPlayTextの呼び出しを削除
    // const playByPlayText = dbMatch.details ? generatePlayByPlayText(dbMatch) : null;

    // 生の打席結果データを抽出
    let rawBattingResults = null;
    if (dbMatch.details && dbMatch.details.batting) {
        rawBattingResults = {
            team1: dbMatch.details.batting.team1?.map(p => ({ name: p.name, order: p.order, results: p.results })),
            team2: dbMatch.details.batting.team2?.map(p => ({ name: p.name, order: p.order, results: p.results }))
        };
    }
    // ★★★ 変更点はここまで ★★★

    const context = {
        winnerName,
        loserName,
        dbMatch,
        matchId,
        winnerData: TEAM_DATA[winnerName],
        loserData: TEAM_DATA[loserName],
        winnerDetailedData: DETAILED_TEAM_DATA[winnerName],
        loserDetailedData: DETAILED_TEAM_DATA[loserName],
        playerStatsText: dbMatch.details ? formatPlayerStatsForPrompt(dbMatch) : null,
                rawBattingResults: rawBattingResults, // ← 新しく追加
        winnerJourney: getCurrentTournamentPerformance(winnerName, matchId),
        loserJourney: getCurrentTournamentPerformance(loserName, matchId),
        winnerLineupChanges: dbMatch.details ? analyzeLineupChanges(winnerName, dbMatch) : "比較データなし",
        loserLineupChanges: dbMatch.details ? analyzeLineupChanges(loserName, dbMatch) : "比較データなし",
        nextOpponent: nextOpponentInfo,
        nextOpponentJourney: nextOpponentJourney,
        highlights: highlights,
        keyPlayerNames: keyPlayerNames
    };
    return context;
}

/**
 * 前試合と今試合のスタメンを比較し、変更点を要約する
 * @param {string} teamName - 分析対象のチーム名
 * @param {object} dbMatch - 現在の試合オブジェクト
 * @returns {string} - 変更点をまとめた短いテキスト
 */
function analyzeLineupChanges(teamName, dbMatch) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord || !teamRecord.previousStarters) {
        return "今大会初戦のため、比較なし。";
    }

    const teamKey = dbMatch.team1 === teamName ? 'team1' : 'team2';
    const previousStarters = teamRecord.previousStarters;
    const currentStarters = dbMatch.details.batting[teamKey].filter(p => p.order && !p.order.toString().includes('sub'));

    if (previousStarters.length === 0 || currentStarters.length === 0) return "比較データなし。";
    
    let changes = [];
    const prevPlayerMap = new Map(previousStarters.map(p => [p.name, p]));
    const currentPlayerMap = new Map(currentStarters.map(p => [p.name, p]));

    // 1. スタメンから外れた選手を検出
    for (const prevPlayer of previousStarters) {
        if (!currentPlayerMap.has(prevPlayer.name)) {
            changes.push(`${prevPlayer.order}番の${prevPlayer.name}がスタメン落ち`);
        }
    }

    // 2. 新しくスタメンに入った選手や、打順が変わった選手を検出
    for (const currPlayer of currentStarters) {
        const prevPlayer = prevPlayerMap.get(currPlayer.name);
        if (!prevPlayer) {
            changes.push(`${currPlayer.order}番に${currPlayer.name}が新しくスタメン入り`);
        } else {
            if (currPlayer.order !== prevPlayer.order) {
                changes.push(`${currPlayer.name}が${prevPlayer.order}番から${currPlayer.order}番に打順変更`);
            }
        }
    }
    
    if (changes.length === 0) {
        return "前試合からスタメン変更なし。";
    }
    
    // AIに渡す情報が多すぎないよう、主な変更点に絞る
    return `主な変更点: ${changes.slice(0, 3).join('、')}。`;
}

/**
 * 打席結果の文字列を、シミュレーションで使える日本語とデータに変換する
 */
function translatePlay(atBatString) {
    if (!atBatString) return { description: "記録なし", type: "none", out: false, base: 0 };
    
    const s = atBatString;
    if (s.includes('本塁打')) return { description: `ホームラン`, type: "hr", out: false, base: 4 };
    if (s.includes('三塁打')) return { description: `三塁打`, type: "triple", out: false, base: 3 };
    if (s.includes('二塁打')) return { description: `二塁打`, type: "double", out: false, base: 2 };
    if (s.includes('安')) return { description: `ヒット`, type: "single", out: false, base: 1 };
    
    if (s.includes('四球') || s.includes('死球')) return { description: `四死球`, type: "walk", out: false, base: 1 };
    if (s.includes('エラー') || s.includes('野選') || s.includes('犠失')) return { description: `エラー/野選`, type: "error", out: false, base: 1 };

    if (s.includes('犠飛')) return { description: `犠牲フライ`, type: "sac_fly", out: true, base: 0 };
    if (s.includes('犠打')) return { description: `犠牲バント`, type: "sac_bunt", out: true, base: 0 };
    if (s.includes('併殺')) return { description: `併殺打`, type: "dp", out: true, base: 0 }; // 2アウトは別途処理

    if (s.includes('三振')) return { description: `三振`, type: "so", out: true, base: 0 };
    if (s.includes('ゴロ')) return { description: `ゴロ`, type: "go", out: true, base: 0 };
    if (s.includes('飛')) return { description: `フライ`, type: "fo", out: true, base: 0 };
    if (s.includes('直')) return { description: `ライナー`, type: "lo", out: true, base: 0 };
    
    return { description: `その他`, type: "other", out: false, base: 0 };
}

/**
 * 1イニング分の試合経過をシミュレートし、テキストを生成する
 */
function processHalfInning(dbMatch, teamKey, inningIndex, batterIndices) {
    let halfInningText = "";
    let outs = 0;
    let bases = [null, null, null]; // [1B, 2B, 3B]
    
    const battingOrder = dbMatch.details.batting[teamKey].filter(p => p.name).sort((a,b) => a.order - b.order);
    if (battingOrder.length === 0) return "";
    
    let batterIndex = batterIndices[teamKey];
    let atBatsInInning = 0;

    while (outs < 3) {
        const batter = battingOrder[batterIndex];
        const resultString = batter.results[inningIndex] || "";
        const atBatsForPlayer = resultString.split('、');

        // このイニングでこの打者がまだ打席に立っていない場合はループを抜ける
        if (atBatsForPlayer.length <= atBatsInInning) break; 
        
        const currentAtBatString = atBatsForPlayer[atBatsInInning];
        if(!currentAtBatString) break;

        const play = translatePlay(currentAtBatString);
        
        // 1. 打席結果をテキストに追加
        halfInningText += `${batter.order}番 ${batter.name} (${batter.pos}): ${play.description}\n`;

        // 2. アウトカウントを更新
        if(play.out) outs++;
        if(play.type === 'dp') outs++; // 併殺打

        if (outs >= 3) {
            halfInningText += `  → ${outs}アウト\n`;
            batterIndex = (batterIndex + 1) % battingOrder.length;
            break;
        }
        
        // 3. ランナーを進塁させる（簡易ロジック）
        const newBases = [null, null, null];
        let batterOnBase = false;

        // まずランナーを進める (3塁から)
        if (bases[2]) { // 3塁ランナー
            if (play.base >= 1 || play.type === 'sac_fly' || play.type === 'walk') newBases[2] = null; // 生還
            else newBases[2] = bases[2];
        }
        if (bases[1]) { // 2塁ランナー
            if (play.base >= 2) newBases[1] = null; // 生還
            else if (play.base === 1 || play.type === 'sac_bunt') newBases[2] = bases[1];
            else newBases[1] = bases[1];
        }
        if (bases[0]) { // 1塁ランナー
            if (play.base >= 3) newBases[0] = null; // 生還
            else if (play.base === 2) newBases[2] = bases[0];
            else if (play.base === 1 || play.type === 'sac_bunt' || play.type === 'walk') newBases[1] = bases[0];
            else newBases[0] = bases[0];
        }
        
        // 打者走者を塁に出す
        if (!play.out && play.base > 0) {
            newBases[play.base - 1] = batter.name;
        }

        bases = newBases;
        
        // 4. 現在の状況をテキストに追加
        const runners = [];
        if(bases[0]) runners.push("1塁");
        if(bases[1]) runners.push("2塁");
        if(bases[2]) runners.push("3塁");
        const runnerText = runners.length > 0 ? `ランナー${runners.join(', ')}` : "ランナーなし";
        halfInningText += `  → ${outs}アウト, ${runnerText}\n`;
        
        batterIndex = (batterIndex + 1) % battingOrder.length;
        atBatsInInning++;
    }

    batterIndices[teamKey] = batterIndex; // 次のイニングの先頭打者を記憶
    
    if (outs < 3) {
      halfInningText += `(${outs}アウトでイニング終了)\n`;
    }
    
    halfInningText += "チェンジ\n";
    return halfInningText;
}

/**
 * 全イニングの試合経過テキストを生成するマスター関数
 */
function generatePlayByPlayText(dbMatch) {
    if (!dbMatch || !dbMatch.details) return "詳細な試合データがありません。";

    let playByPlay = "";
    const numInnings = dbMatch.details.inningScore?.team1?.length || 9;
    // 各チームの次の先頭打者を記録するオブジェクト
    let batterIndices = { team1: 0, team2: 0 };

    for (let i = 0; i < numInnings; i++) {
        // 表の攻撃
        playByPlay += `\n【${i + 1}回表】${dbMatch.team1}の攻撃\n`;
        playByPlay += processHalfInning(dbMatch, 'team1', i, batterIndices);
        
        // サヨナラゲームの判定
        if (i >= 8) { // 9回表以降
            const score1 = (dbMatch.details.inningScore.team1 || []).slice(0, i + 1).reduce((a, b) => a + (b || 0), 0);
            const score2 = (dbMatch.details.inningScore.team2 || []).slice(0, i + 1).reduce((a, b) => a + (b || 0), 0);
            if (dbMatch.team2 === dbMatch.winner && score2 > score1) {
                 break;
            }
        }

        // 裏の攻撃
        playByPlay += `\n【${i + 1}回裏】${dbMatch.team2}の攻撃\n`;
        playByPlay += processHalfInning(dbMatch, 'team2', i, batterIndices);
    }

    playByPlay += "\n--- 試合終了 ---\n";
    return playByPlay;
}

/**
 * Finds a specific team's final result in the tournament.
 */
function getTeamFateSummary(teamName) {
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            if (match.winner !== teamName) {
                const opponent = match.winner;
                const score1 = match.team1 === teamName ? match.score1 : match.score2;
                const score2 = match.team1 === teamName ? match.score2 : match.score1;
                const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 1;
                return `${roundNum}回戦で${opponent}に${score1}-${score2}で敗退した。`;
            }
        }
    }
    
    // Check if the team is still in the tournament
    const isStillIn = Object.values(allMatches).some(match => !match.winner && (match.team1 === teamName || match.team2 === teamName));
    if(isStillIn) {
        return "まだ勝ち残っている。";
    }

    return "（今大会には出場していないか、情報がありません）";
}
   



/**
 * チームの紹介文を動的に生成する最終進化版。
 * TEAM_DATAの固定情報に、最新の成績情報を付け加える。
 * @param {string} teamName - チーム名
 * @param {object} teamData - TEAM_DATAから取得したそのチームの基本情報
 * @param {object} teamRecord - tournamentState.teamRecordsから取得したそのチームの成績記録
 * @returns {string} - 生成された最新の紹介文
 */
function generateDynamicTeamInfo(teamName, teamData, teamRecord) {
// ▼▼▼ この安全装置が、今後のあなたを助けます ▼▼▼
    if (!teamData) {
        // コンソールに、どのチーム名で失敗したかを出力
        console.error(`TEAM_DATAにチーム「${teamName}」が見つかりません。名前のタイプミスがないか確認してください。`);
        // 記事にはエラーメッセージを表示
        return `${teamName}のチーム情報が見つかりませんでした。`;
    }
    // ▲▲▲ ▲▲▲    
// teamData.info が基本の紹介文となる
    const baseInfo = teamData.info || `${teamName}の情報は不明です。`;

    // チームの成績記録がまだない（＝1年目の途中など）場合は、基本情報だけを返す
    if (!teamRecord || !teamRecord.history || teamRecord.history.length === 0) {
        return baseInfo;
    }

    const history = teamRecord.history;

    // --- ここからが追加情報の生成 ---
    let additionalNarrative = []; // 追加情報を入れる配列

    // 創部年数を計算 (2年目以降に意味を持つ情報)
    if (history.length > 0) {
        const establishedYear = history[history.length - 1].year;
        const yearsPassed = tournamentState.tournamentYear - establishedYear + 1;
        // 1年目の最初の大会では表示しないように、2年目以降の情報として扱う
        if (yearsPassed > 1) {
            additionalNarrative.push(`創部${yearsPassed}年目。`);
        }
    }
    
    // 昨年の成績を追加
    const lastFinishLabel = teamRecord.last?.label;
    if (lastFinishLabel && lastFinishLabel !== 'なし') {
        additionalNarrative.push(`昨年は${lastFinishLabel}。`);
    }

    // 過去最高成績を追加
    const bestFinishLabel = teamRecord.best?.label;
    if (bestFinishLabel && bestFinishLabel !== 'なし') {
        additionalNarrative.push(`過去最高は${bestFinishLabel}。`);
    }

    // 称号（Traits）を追加
    const traitDescriptions = {
        'GIANT_KILLER': '「ジャイアントキラー」の異名を持つ。',
        'REPECHAGE_KING': '「敗者復活の王」として知られる。',
    };
    if (teamRecord.teamTraits && teamRecord.teamTraits.length > 0) {
        teamRecord.teamTraits.forEach(traitId => {
            if (traitDescriptions[traitId]) {
                additionalNarrative.push(traitDescriptions[traitId]);
            }
        });
    }

    // --- 最終的な紹介文の組み立て ---
    // もし追加情報が何か一つでもあれば、基本情報に付け加える
    if (additionalNarrative.length > 0) {
        // 例：「（基本情報）。加えて、創部2年目。昨年は県大会2回戦。」のようになる
        return `${baseInfo} ${additionalNarrative.join(' ')}`;
    } 
    // 追加情報がなければ、基本情報だけを返す
    else {
        return baseInfo;
    }
}

 
/**
 * 選手の出場形式コードを、記事で使える自然な日本語に変換する（翻訳機）
 * @param {object} player - 選手のデータオブジェクト
 * @returns {string} - 出場形式を説明する文章
 */
function getSubstitutionDescription(player) {
    // 交代選手でない（スタメン）場合は "スタメン出場" とする
    if (!player.sub_type) {
        return 'スタメン出場';
    }

    // sub_typeの値に応じて、返す文章を切り替える
    switch (player.sub_type) {
        case 'PH':
            return '代打で出場';
        case 'PR':
            return '代走で出場';
        case 'DEF':
            return '守備固めで出場';
        // ▼▼▼ ADD THIS CASE ▼▼▼
        case 'PITCHER': return 'リリーフとして登板';
        // ▲▲▲ END OF ADDITION ▲▲▲
        default:
            return '途中出場'; // 何らかの理由でsub_typeが上記以外の場合
    }
}

/**
 * 試合の個人成績をAIプロンプト用のテキスト形式（★背番号付きボックススコア）にフォーマットする
 * @param {object} dbMatch - 試合オブジェクト
 * @returns {string} - フォーマットされたテキスト
 */
function formatPlayerStatsForPrompt(dbMatch) {
    if (!dbMatch || !dbMatch.details || !dbMatch.details.playerGameStats) {
        return '詳細な個人成績データはありません。';
    }

    const { details, winner } = dbMatch;

    const formatTeamStats = (teamKey) => {
        const teamName = dbMatch[teamKey];
        const isWinner = teamName === winner;
        const battingOrder = details.batting?.[teamKey] || [];
        const gameStats = details.playerGameStats?.[teamKey] || {};
        const pitchingData = details.pitching?.[teamKey] || [];

        let output = `\n**${teamName} (${isWinner ? '勝者' : '敗者'})**\n`;

        const sortedBatters = battingOrder.sort((a, b) => {
            const orderA = parseFloat(a.order.replace('-sub', '.'));
            const orderB = parseFloat(b.order.replace('-sub', '.'));
            return orderA - orderB;
        });

        sortedBatters.forEach(player => {
            if (!player.name) return;
            const stats = gameStats[player.name];
            if (!stats || !stats.played) return; 

            const orderDisplay = player.order.includes('sub') ? `  - ${player.sub_type || '代'}` : `${player.order}.`;
            // ★ここを変更: 選手名の前に背番号を追加
            const playerIdentifier = `[#${player.number}] ${player.name}`; 
            const statsLine = `${stats.ab}打数${stats.h}安打 ${stats.rbi}打点` + (stats.hr > 0 ? ` ${stats.hr}本塁打` : '');
            
            output += `${orderDisplay} ${playerIdentifier} (${player.pos}): ${statsLine}\n`;
        });
        
        pitchingData.forEach(pitcher => {
            if (!pitcher.name || !pitcher.innings) return;
            // ★ここも変更: 投手名の前に背番号を追加 (打撃データから背番号を検索)
            const pitcherData = sortedBatters.find(b => b.name === pitcher.name);
            const pitcherIdentifier = pitcherData ? `[#${pitcherData.number}] ${pitcher.name}` : pitcher.name;
            output += `- 投手: ${pitcherIdentifier} (${pitcher.innings}回 ${pitcher.runs}失点 ${pitcher.strikeouts}奪三振 ${pitcher.walks}四死球)\n`;
        });

        return output;
    };

    return formatTeamStats('team1') + formatTeamStats('team2');
}
/**
 * 試合の詳細データから、AIプロンプト用の個人成績ハイライトを生成する（★投手分析強化版）
 * @param {object} dbMatch - 試合オブジェクト
 * @returns {string} - "勝者・〇〇: 鈴木(4安打), 投手・田中(9回1失点, HQS達成). // 敗者・△△: ..."
 */
function extractKeyPerformances(dbMatch) {
    if (!dbMatch || !dbMatch.details || !dbMatch.details.playerGameStats) {
        return '詳細な個人成績データはありません。';
    }

    const { details, winner } = dbMatch;
    const winnerName = winner;
    const loserName = dbMatch.team1 === winner ? dbMatch.team2 : dbMatch.team1;

    const winnerKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
    const loserKey = dbMatch.team1 === loserName ? 'team1' : 'team2';

    const formatTeamPerformances = (teamKey) => {
        const teamName = dbMatch[teamKey];
        const performances = [];
        
        // 打撃成績の分析 (変更なし)
        const battingStats = details.playerGameStats?.[teamKey] || {};
        for (const playerName in battingStats) {
            const stats = battingStats[playerName];
            const playerHighlights = [];
            if (stats.h >= 3) playerHighlights.push(`${stats.h}安打`);
            if (stats.hr > 0) playerHighlights.push(`${stats.hr}本塁打`);
            if (stats.rbi >= 3) playerHighlights.push(`${stats.rbi}打点`);

            if (playerHighlights.length > 0) {
                const battingData = details.batting[teamKey].find(p => p.name === playerName);
                const order = battingData ? `${battingData.order}番` : '';
                performances.push(`${order}${playerName}(${playerHighlights.join(', ')})`);
            }
        }

        // ★★★ ここからが強化された投手分析ロジック ★★★
        const pitchingData = details.pitching?.[teamKey] || [];
        const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
        const opponentBattingData = details.batting?.[opponentTeamKey] || [];

        pitchingData.forEach(pitcher => {
            if (!pitcher.name) return;
            const pitcherHighlights = [];

            // 1. 基本的な投球結果を分析
            const innings = parseFloat(pitcher.innings || 0);
            const runs = parseInt(pitcher.runs || 0);
            const earnedRuns = parseInt(pitcher.earnedRuns || 0);
            const strikeouts = parseInt(pitcher.strikeouts || 0);
            const walks = parseInt(pitcher.walks || 0);
            const pitches = parseInt(pitcher.pitches || 0);

            // 従来の分析
            if (pitcher.result === 'W') {
                 if (innings >= 9 && earnedRuns === 0) pitcherHighlights.push('完封勝利');
                 else if (innings >= 9) pitcherHighlights.push('完投勝利');
            }
            if (strikeouts >= 10) pitcherHighlights.push(`${strikeouts}奪三振`);
            if (pitcher.result === 'L' && runs >= 5) pitcherHighlights.push(`${runs}失点炎上`);

            // 2. 新しい詳細分析
            if (pitches > 120) pitcherHighlights.push(`${pitches}球の熱投`);
            if (walks >= 5) pitcherHighlights.push(`与四球${walks}と制球難`);

            // 3. イニングごとの内容分析（主に先発投手を対象）
            if (innings >= 6 && opponentBattingData.length > 0) {
                let walksByInning = Array(9).fill(0);
                for (let i = 0; i < 9; i++) {
                    opponentBattingData.forEach(batter => {
                        const result = batter.results[i] || '';
                        if (result.includes('四球') || result.includes('死球')) {
                            walksByInning[i]++;
                        }
                    });
                }

                const earlyInningWalks = walksByInning.slice(0, 5).reduce((a, b) => a + b, 0);
                const lateInningWalks = walksByInning.slice(5, 9).reduce((a, b) => a + b, 0);

                if (lateInningWalks > earlyInningWalks && lateInningWalks >= 3) {
                    pitcherHighlights.push('終盤に制球を乱した');
                } else if (innings >= 7 && earnedRuns <= 2 && pitcher.result !== 'L') {
                    // 良い内容だった場合の評価
                    pitcherHighlights.push('試合を作った'); 
                }
            }
            
            if (pitcherHighlights.length > 0) {
                performances.push(`投手・${pitcher.name}(${pitcherHighlights.join(', ')})`);
            }
        });
        // ★★★ 投手分析ロジックはここまで ★★★

        return performances.length > 0 ? `${teamName}: ${performances.join(', ')}` : '';
    };

    const winnerPerf = formatTeamPerformances(winnerKey);
    const loserPerf = formatTeamPerformances(loserKey);

    return [winnerPerf, loserPerf].filter(Boolean).join(' // ');
}
/**
 * AI記者にニュース記事を執筆させるメイン関数（フィードバック機能付き・最終完全版）
 * @param {string|null} winnerName - 勝者名
 * @param {string|null} loserName - 敗者名
 * @param {object} dbMatch - 試合データ
 * @param {string} matchId - 試合ID
 * @param {object} winnerData - 勝者チームのマスターデータ
 * @param {object} loserData - 敗者チームのマスターデータ
 * @param {object} winnerDetailedData - 勝者チームの詳細選手データ
 * @param {object} loserDetailedData - 敗者チームの詳細選手データ
 * @param {Array} highlightsText - 試合のハイライト
 * @param {Array} keyPlayerNames - 注目選手名
 * @param {object|null} userFeedback - ユーザーからの追加指示
 * @returns {Promise<object|null>}
 */
async function generateNewsArticle(matchContext, userFeedback = null) {
    // --- 1. contextから必要な情報を取り出す ---
    const { 
        winnerName, loserName, dbMatch, matchId,
        winnerData, loserData, winnerDetailedData, loserDetailedData, 
        winnerLineupChanges, loserLineupChanges, 
        winnerJourney, loserJourney,
        nextOpponent // ★★★ 次の対戦相手の情報をここで受け取ります ★★★
    } = matchContext || {};
    
 let prompt = '';
    // --- 1. 大会展望記事の生成ロジック ---
    if (matchId === 'preview') {
        let prompt;
        const { tournamentYear, seeds, teams, matches, currentTournament, is16team, autumnData } = tournamentState;
        const tournamentName = tournamentNameMap[currentTournament] || '大会';

        // --- 1A. 秋季大会の展望 ---
        if (is16team) { 
            const reps = autumnData;
            const repText = Object.entries(reps.regions).map(([region, data]) => {
                if (!data.finalReps || data.finalReps.length === 0) return null;
                if (region === '伊豆') return `- ${region} (1校): ${data.finalReps[0].team}`;
                const repNames = data.finalReps.sort((a,b) => a.rank - b.rank).map(r => `${r.team}(${r.rank}位)`);
                return `- ${region} (${data.finalReps.length}校): ${repNames.join(', ')}`;
            }).filter(Boolean).join('\n');
            
            const matchups = [];
            for(let i=0; i<teams.length; i+=2) {
                matchups.push(`- ${teams[i]} vs ${teams[i+1]}`);
            }

            prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。野球以外の話題(プログラミング等)には一切触れないでください。
間もなく開幕する「${tournamentYear}年度 秋季大会 県大会本戦」の展望記事を作成してください。
### 大会のポイント
- 秋季大会は新チームで挑む最初の県大会であり、来春のセンバツ出場を占う重要な大会です。
- 地区予選を勝ち上がった順位に応じてポット分けされ、1回戦は同地区対決が避けられるなど、独特の組み合わせが特徴です。
### 県大会出場校一覧 (地区順位順)
${repText}
### 県大会1回戦の組み合わせ
${matchups.join('\n')}
### 執筆指示
- 最も厳しいブロック、いわゆる「死のブロック」はどこか指摘してください。
- 地区1位校と下位ポットの強豪校が当たる、注目の1回戦カードをいくつか挙げてください。
- 地区間のレベル差や、新チームの仕上がりについて分析的な視点で記述してください。
### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
        } 
        // --- 1B. 春季大会の展望 ---
        else if (currentTournament === 'spring') {
            const qualifierWinners = teams.filter(team => !seeds.includes(team));
            const round1Matchups = Object.values(matches)
                .filter(match => match.id.includes('-R1-'))
                .map(match => `- ${match.team1} vs ${match.team2}`);

            const allPromisingSchools = [...seeds, ...qualifierWinners];
            let notablePlayersText = '';
            const notablePlayers = allPromisingSchools.filter(team => DETAILED_TEAM_DATA[team]);
            if (notablePlayers.length > 0) {
                notablePlayersText += '### 今大会の注目選手\n';
                notablePlayers.forEach(team => {
                    const players = DETAILED_TEAM_DATA[team].players.slice(0, 2);
                    notablePlayersText += `- **${team}**: ${players.map(p => `${p.name}(${p.year}年)`).join(', ')}\n`;
                });
            }

            prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。野球以外の話題(プログラミング等)には一切触れないでください。
間もなく開幕する「${tournamentYear}年度 ${tournamentName}」の展望記事を作成してください。
### 大会の見どころ
- 今大会は、秋季大会ベスト8の強豪【シード校】と、厳しい地区予選を勝ち抜いた【予選突破校】が覇を競います。
- 1回戦は予選突破校同士が対戦し、勝ち上がったチームが2回戦でシード校に挑むという、下剋上も期待される注目の形式です。
### シード校 (2回戦から登場)
${seeds.join(', ')}
### 地区予選突破校 (1回戦から登場)
${qualifierWinners.join(', ')}
### 1回戦の注目カード
${round1Matchups.slice(0, 4).join('\n')}
${notablePlayersText}
### 執筆指示
- 予選突破校の中から、シード校を脅かす存在となりそうな「ダークホース」を2～3校挙げてください。
- どのシード校が最も厳しいブロックに入ったか、逆に最も楽なブロックはどこかを分析してください。
- 記事の本文で「注目選手」に言及し、彼らの活躍が大会の鍵を握ることを示唆してください。
- 夏の大会を占う重要な大会として、各チームの仕上がり具合を分析する視点で記述してください。
### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
        } 
        // --- 1C. 夏季大会の展望 ---
        else { 
            const isPromising = (teamName) => {
                const rank = calculateRank(teamName, tournamentState);
                return ['A', 'B'].includes(rank) || seeds.includes(teamName) || TEAM_DATA[teamName].popularity;
            };

            const blockAnalyses = [];
            const numBlocks = 4;
            const blockSize = 16;
            for (let i = 0; i < numBlocks; i++) {
                const blockName = String.fromCharCode(65 + i);
                const start = i * blockSize;
                const end = (i + 1) * blockSize;
                const blockTeams = teams.slice(start, end);
                if (blockTeams.length === 0) continue;
                const promisingInBlock = blockTeams.filter(isPromising);
                blockAnalyses.push(`- ${blockName}ブロック (${blockTeams.length}校): ${promisingInBlock.join(', ')}`);
            }
            const blockAnalysis = blockAnalyses.join('\n');
            
            let notablePlayersText = '';
            const promisingSchools = teams.filter(isPromising);
            const notablePlayers = promisingSchools.filter(team => DETAILED_TEAM_DATA[team]);
            if (notablePlayers.length > 0) {
                notablePlayersText += '### 今大会の注目選手\n';
                notablePlayers.forEach(team => {
                    const players = DETAILED_TEAM_DATA[team].players.slice(0, 2);
                    notablePlayersText += `- **${team}**: ${players.map(p => `${p.name}(${p.year}年)`).join(', ')}\n`;
                });
            }

            prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。野球以外の話題(プログラミング等)には一切触れないでください。
間もなく開幕する「${tournamentYear}年度 ${tournamentName}」の展望記事を作成してください。
### 大会の見どころ
- 3年生にとっては最後の夏であり、甲子園出場をかけた最も熱い戦いです。
- 春の大会の結果などからシード校が決定されていますが、ノーシードの実力校も多く、波乱が予想されます。
### シード校
${seeds.join(', ')}
### 各ブロックの有力校
${blockAnalysis}
${notablePlayersText}
### 執筆指示
- 最も厳しいブロック、いわゆる「死のブロック」はどこか指摘し、その理由を分析してください。
- 有力校が少ない「恵まれたブロック」に入ったチームにも言及してください。
- 「注目選手」を記事に登場させ、彼らが大会の鍵を握る存在であることを示唆してください。
- ノーシードの実力校の中から、大会の「ダークホース」となりそうなチームを挙げてみてください。
### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
        }

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
                if (article) return { ...article, timestamp: Date.now() };
            }
            throw new Error("AI preview response format error.");
        } catch (error) {
            console.error("AI preview article generation failed:", error);
            return { title: "展望記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true, errorId: `preview-${Date.now()}` };
        }
}


    // --- 2. 試合後記事の生成ロジック ---

    // --- 準備フェーズ ---
    const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
    const loserRankDesc = getRankDescription(calculateRank(loserName, tournamentState));
    const winnerRecord = tournamentState.teamRecords[winnerName];
    const loserRecord = tournamentState.teamRecords[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, winnerRecord);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, loserRecord);
　　
    const winnerCoach = winnerData.coach;
    const loserCoach = loserData.coach;
    const battingFirstTeam = dbMatch.team1;
    const battingSecondTeam = dbMatch.team2;
    const winnerPrevRankStr = winnerRecord?.previousRank ? ` (前大会: ${getRankString(winnerRecord.previousRank)})` : '';
    const loserPrevRankStr = loserRecord?.previousRank ? ` (前大会: ${getRankString(loserRecord.previousRank)})` : '';
    const winnerTitles = winnerRecord?.teamTraits?.map(tId => Object.values(TITLES).find(t => t.id === tId)?.name).join(', ') || '';
    const loserTitles = loserRecord?.teamTraits?.map(tId => Object.values(TITLES).find(t => t.id === tId)?.name).join(', ') || '';
    let currentTournamentName = tournamentNameMap[tournamentState.currentTournament] || '大会';

    let roundAchievement = '';
    let seedingImplication = '';
    let specialNarrativeContext = '';
    if (tournamentState.currentTournament === 'autumn') {
        const phase = tournamentState.autumnPhase;
        if (matchId.includes('-')) {
            const [region, bracketType, roundStr] = matchId.split('-');
            const roundNum = parseInt(roundStr?.slice(1));
            if (phase === 'regional_blocks') {
                currentTournamentName = `秋季大会 ${region}地区ブロック予選`;
                if (roundNum === 2) roundAchievement = 'ブロック優勝';
            } else if (phase === 'regional_ranking') {
                currentTournamentName = `秋季大会 ${region}地区内順位決定戦`;
                if (bracketType === 'CHAMP' && roundNum === 2) {
                    roundAchievement = dbMatch.type === 'final' ? '地区1位通過' : '地区3位通過';
                } else if (bracketType === 'REP' && roundNum === 2) {
                    roundAchievement = '第5代表（敗者復活）';
                }
            } else if (phase === 'main') {
                currentTournamentName = '秋季大会 県大会本戦';
                const roundNumMain = parseInt(matchId.split('-')[1].slice(1));
                if (roundNumMain === 1) {
                    roundAchievement = '県大会初戦突破（ベスト8進出）';
                    seedingImplication = 'この勝利で、来季の春季大会のシード権獲得を確実なものとした。';
                    const winnerRank = calculateRank(winnerName, tournamentState);
                    if (winnerData.type === '公立' && (winnerRank === 'D' || winnerRank === 'E')) {
                        specialNarrativeContext = `### 【物語のハイライト】\n県大会出場だけでも快挙だった公立校「${winnerName}」が、初戦を突破し【来春のシード権】まで獲得しました！これは二重の奇跡です。この「シンデレラ・ストーリーの最高潮」をテーマに、歴史的快挙として記事を執筆してください。`;
                    }
                } else if (roundNumMain === 2) roundAchievement = '準々決勝突破(ベスト4進出)';
                else if (roundNumMain === 3) roundAchievement = '準決勝突破(決勝進出)';
            }
        }
    } else if (matchId.includes('-R')) {
        const roundNum = parseInt(matchId.split('-')[1].slice(1));
        const finalRound = tournamentState.is16team ? 4 : 6;
        if (roundNum === finalRound) roundAchievement = (tournamentState.currentTournament === 'summer') ? '甲子園出場決定！' : '優勝！';
        else if (roundNum === finalRound - 1) roundAchievement = '準決勝突破(決勝進出)';
        else if (roundNum === finalRound - 2) roundAchievement = '準々決勝突破(ベスト4進出)';
        else if (roundNum === finalRound - 3) {
            roundAchievement = '3回戦突破(ベスト8進出)';
            if (tournamentState.currentTournament === 'spring') {
                seedingImplication = 'この勝利で、夏の選手権大会のシード権獲得を確実なものとした。';
            }
        } else if (roundNum === 2) roundAchievement = '2回戦突破';
        else if (roundNum === 1) roundAchievement = '初戦突破';
    }
    
    

    // --- 詳細データがある場合 (Aルート) ---
    

    // --- 詳細データがある場合 (Aルート) ---
    if (dbMatch.details) {
        // --- 準備フェーズ ---
        const { highlights, keyPlayerNames } = createHighlightsText(dbMatch, winnerName);
        const factListText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
        
        const winnerKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
        const winnerPlayersInGame = new Set(
            (dbMatch.details.batting?.[winnerKey] || []).map(p => p.name)
            .concat((dbMatch.details.pitching?.[winnerKey] || []).map(p => p.name))
        );
        const winnerKeyPlayers = keyPlayerNames.filter(name => winnerPlayersInGame.has(name));
        const loserKeyPlayers = keyPlayerNames.filter(name => !winnerPlayersInGame.has(name));

        const formatPlayerList = (playerNames, teamName, detailedTeamData) => {
            if (playerNames.length === 0) return '特になし';
            return playerNames.map(playerName => {
                const detailedInfo = detailedTeamData?.players.find(p => p.name === playerName);
                return detailedInfo ? `- **${detailedInfo.name} (${detailedInfo.year}年・${detailedInfo.position})**: ${detailedInfo.desc}` : `- **${playerName}**`;
            }).join('\n');
        };
        const winnerPlayersPrompt = formatPlayerList(winnerKeyPlayers, winnerName, winnerDetailedData);
        const loserPlayersPrompt = formatPlayerList(loserKeyPlayers, loserName, loserDetailedData);
        
        // ★★★ ここが重要：関数内部での分析は不要になり、渡された情報をそのまま使う ★★★
        const lineupChangesText = `- ${winnerName}: ${winnerLineupChanges}\n- ${loserName}: ${loserLineupChanges}`;
        
        const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, tournamentState.teamRecords[winnerName]);
        const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, tournamentState.teamRecords[loserName]);
        const winnerCoach = winnerData.coach;
        const loserCoach = loserData.coach;

        // 1. 次の対戦相手に関するテキストを、3つのパターンに応じて準備する
        let nextOpponentText = '次の対戦相手は未定。'; // デフォルト
        if (nextOpponent) {
            // パターン1: 対戦相手が決まっている場合
            if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
                nextOpponentText = `次の${nextOpponent.roundName}では、${nextOpponent.opponentName}(${nextOpponent.opponentRank}ランク)と対戦する。`;
            } 
            // パターン2: 対戦相手は未定だが、どの試合の勝者と当たるか分かっている場合
            else if (nextOpponent.decidingMatch) {
                const dm = nextOpponent.decidingMatch;
                nextOpponentText = `次の${nextOpponent.roundName}では、${dm.team1}(${dm.rank1}ランク)と${dm.team2}(${dm.rank2}ランク)の勝者と対戦する。`;
            }
            // パターン3: それ以外の未定の場合 (この場合はデフォルトのまま)
        }
        // ★★★ 修正箇所はここまで ★★★

        prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。
あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。
---
### **参考情報：高校野球における背番号の意味**
- **[#1]**: チームの絶対的エース投手。その投球がチームの運命を左右する。
- **[#2-9]**: 基本的にレギュラーの野手陣。一桁番号はチームの中心選手である証。
- **[#10], [#11]**: エースに次ぐ控え投手。
- **[#12]以降**: ベンチ入りした控え選手。時に監督の秘蔵っ子や、期待の1・2年生が含まれるサプライズ枠。
---
---
### **【最重要】この記事の唯一の事実情報源**
${factListText}
---
### **参考情報：補足**
- **前試合からのスタメン変更**:
${lineupChangesText}
- **ユーザーによる試合の決め手**: ${dbMatch.summary || 'なし'}
---
### **参考情報：チームと選手のプロフィール**
- **${winnerName}**: ${winnerDynamicInfo}
- **今大会の軌跡**: ${winnerJourney}
  - **監督**: ${winnerCoach ? `${winnerCoach.name} (${winnerCoach.style})` : '情報なし'}
  - **主な選手プロフィール**:\n${winnerPlayersPrompt}
- **${loserName}**: ${loserDynamicInfo}
  - **今大会の軌跡**: ${loserJourney}
  - **監督**: ${loserCoach ? `${loserCoach.name} (${loserCoach.style})` : '情報なし'}
  - **主な選手プロフィール**:\n${loserPlayersPrompt}
---
### **執筆指示**
1.  「事実リスト」を厳密に基に、試合の物語を再構築してください。
2.  **【監督の采配】**: 「スタメン変更」があった場合、その采配が試合にどう影響したかに触れること。
3.  **【物語の連続性】**: 「今大会の軌跡」情報を参考に、これまでの戦いと繋がりのある物語を描写すること。
4.  試合後の両チーム監督のコメントを、試合内容やチームの背景を反映させて生成すること。
5.  **【次戦への展望】**: 記事の最後に、次の対戦相手（${nextOpponentText}）に簡潔に触れ、今後の戦いへの展望を記述して締めくくること。
6.  **【背番号の意味を反映】**: 記事中で選手に言及する際、その選手の背番号が持つ意味を考慮し、物語に深みを与えてください。
---
### 編集長からの追加指示
${(userFeedback && userFeedback.include) ? `- **【最重要指示】** ${userFeedback.include}\n` : ''}
${(userFeedback && userFeedback.exclude) ? `- **【厳禁事項】** ${userFeedback.exclude}\n` : '特になし'}
---
### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;

    } 
    // --- 詳細データがない場合 (Bルート) ---
    else {
        // (こちらのルートは元々シンプルなので、大きな変更はありません)
        const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
        const loserRankDesc = getRankDescription(calculateRank(loserName, tournamentState));
        const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
        const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
        prompt = `あなたは、高校野球専門のAI記者です。
以下の試合結果に基づき、簡潔で分かりやすいニュース記事を作成してください。
### 試合情報
- **勝利チーム**: ${winnerName} (${winnerRankDesc})
- **敗北チーム**: ${loserName} (${loserRankDesc})
- **スコア**: ${winnerScore} - ${loserScore}
- **ユーザーによる試合の決め手**: ${dbMatch.summary || 'なし'}
### 執筆指示
- もし「ユーザーによる試合の決め手」に記述があれば、それを中心に記事を構成してください。
- 試合結果を客観的に伝えてください。
- 記事のタイトルと本文をJSON形式で出力してください。`;
    }

    // --- AIへのリクエスト ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                const isNewspaperWorthy = (dbMatch.details && (tournamentState.currentTournament !== 'autumn' || tournamentState.autumnPhase === 'main'));
                const newspaperHtml = isNewspaperWorthy ? createNewspaperHtml(article, { winnerName, loserName, dbMatch, matchId }) : null;
                return { ...article, isNewspaper: isNewspaperWorthy, timestamp: Date.now(), newspaperHtml };
            }
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI記事の生成に失敗しました:", error);
        return { 
            title: "記事生成エラー", body: "AI記者との通信に失敗しました。", 
            timestamp: Date.now(), error: true, errorId: matchId,
            context: matchContext // ★再生成のためにcontext全体を保存
        };
    }
}
/**
     * AIにスキップしたラウンドのダイジェスト記事を生成させる
     */
    async function generateSkipRoundSummaryArticle(roundNumber, results) {
        // 最も番狂わせが大きかった試合を1つ選出
        const biggestUpset = results.filter(r => r.rankDiff >= 2).sort((a,b) => b.rankDiff - a.rankDiff)[0];
        
        let highlightText = "シード校や有力校が順当に勝ち進みました。";
        if (biggestUpset) {
            highlightText = `最大の波乱は${biggestUpset.winnerName}が強豪${biggestUpset.loserName}を${biggestUpset.winnerScore}-${biggestUpset.loserScore}で破った一戦でした。`;
        }

        const prompt = `あなたは高校野球専門のAI記者です。
現在、${tournamentState.tournamentYear}年度${tournamentNameMap[tournamentState.currentTournament]}が進行中です。
${roundNumber}回戦の全試合が終了しました。以下のハイライトを元に、簡潔なダイジェスト記事を生成してください。

### ${roundNumber}回戦ハイライト
- ${highlightText}
- 次のラウンドでは、勝ち上がった猛者たちによる更なる激戦が期待されます。

### 執筆指示
- 上記のハイライトを自然な文章にまとめてください。
- タイトルは「${roundNumber}回戦が終了！波乱は起きるか？」のように、次への期待感を煽るものにしてください。

### 出力形式
JSON形式で出力してください: {"title": "記事のタイトル", "body": "記事の本文"}`;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
                if (article) return { ...article, timestamp: Date.now() };
            }
            throw new Error("AI summary response format error.");
        } catch (error) {
            console.error("AI summary article generation failed:", error);
            return { title: "ダイジェスト記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true, errorId: `skip-summary-${roundNumber}` };
        }
    }

/**
 * AIに掲示板のコメントを生成させるメイン関数（★context共有方式に統一した最終版）
 * @param {object} matchContext - 試合の全コンテキストデータ
 * @returns {Promise<Array|null>} 生成されたコメントオブジェクトの配列
 */
async function generateBbsComments(matchContext) {
    // --- 1. 受け取った「取材ファイル(matchContext)」から必要な情報を取り出す ---
    const { 
        winnerName, loserName, dbMatch, matchId, 
        winnerData, loserData
    } = matchContext;
    
    // --- 2. AIへの指示を作成するために必要な情報を準備する ---
    const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
    const loserRankDesc = getRankDescription(calculateRank(loserName, tournamentState));
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, tournamentState.teamRecords[winnerName]);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, tournamentState.teamRecords[loserName]);
    let specialNarrativeContext = '';
    
    if (tournamentState.currentTournament === 'autumn' && tournamentState.autumnPhase === 'main' && matchId.includes('-R1-')) {
        const winnerRank = calculateRank(winnerName, tournamentState);
        if (winnerData.type === '公立' && (winnerRank === 'D' || winnerRank === 'E')) {
            specialNarrativeContext = `### 【掲示板の話題】\n衝撃！無名の公立「${winnerName}」が県大会初戦を勝ち、【来春のシード権獲得】だ！この快進撃に驚きと嫉妬のコメントを生成せよ。`;
        }
    }

    let prompt = '';

    // --- 3. 記事の方向性を決定し、AIへの指示書(プロンプト)を作成する ---
    if (dbMatch.details) {
        // 詳細データがある場合 (Aルート)
        const { highlights } = createHighlightsText(dbMatch, winnerName);
        const highlightsText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
        
        prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下の試合結果と詳細なハイライトに基づき、各キャラクターになりきって、辛辣でリアルな短いコメントを5つ生成してください。
### 試合情報
- 勝利チーム: ${winnerName} (${winnerRankDesc})
- 敗北チーム: ${loserName} (${loserRankDesc})
- スコア: ${winnerScore} - ${loserScore}
- ユーザーが語る試合の決め手: ${dbMatch.summary || '特になし'}
### 試合の主なハイライト
${highlightsText}
### チームの背景
- **${winnerName}**: ${winnerDynamicInfo}
- **${loserName}**: ${loserDynamicInfo}
${specialNarrativeContext}
### あなたがなりきるべきキャラクターと指示
- **熱狂的な勝者チームのOB**: 「試合のハイライト」で活躍した自チームの選手を熱烈に称賛してください。
- **上から目線の野球解説者**: 「試合のハイライト」のプレーを玄人っぽく分析してください。
- **アンチ**: 「試合のハイライト」で活躍した相手選手を「まぐれだ」と貶してください。
- **ライバル校のファン**: 「試合のハイライト」の選手を自チームの選手と比較してください。
- **単なる野球好き**: 「試合のハイライト」で最も印象的だったプレーの感想を述べてください。
### 出力形式
【最重要】必ず以下のJSON配列形式"のみ"で出力してください。
[ {"personality": "（キャラクター名）", "comment": "（生成したコメント）"} ]`;
    } else {
        // 詳細データがない場合 (Bルート)
        prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下の試合結果について、それぞれのキャラクターになりきって、辛辣でリアルな短いコメントを5つ生成してください。
### 試合情報
- 勝利チーム: ${winnerName} (${winnerRankDesc})
- 敗北チーム: ${loserName} (${loserRankDesc})
- スコア: ${winnerScore} - ${loserScore}
- ユーザーが語る試合の決め手: ${dbMatch.summary || '特になし'}
### チームの背景
- **${winnerName}**: ${winnerDynamicInfo}
- **${loserName}**: ${loserDynamicInfo}
${specialNarrativeContext}
### あなたがなりきるべきキャラクターと指示
- **熱狂的な勝者チームのOB**: 勝利を喜び、チームの伝統や背景に触れてコメントしてください。
- **上から目線の野球解説者**: 順当な結果か、意外な結果かを分析してください。
- **アンチ**: 負けたチームや、スコアが僅差だったチームを批判してください。
- **ライバル校のファン**: 試合結果を見て、自チームとの力関係を測るようなコメントをしてください。
- **単なる野球好き**: スコアを見て、接戦だったか、一方的だったかなどの感想を述べてください。
### 出力形式
【最重要】必ず以下のJSON配列形式"のみ"で出力してください。
[ {"personality": "（キャラクター名）", "comment": "（生成したコメント）"} ]`;
    }

    // --- 4. AIへリクエストを送信し、結果を整形して返す ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AIからの応答が、正しい配列形式ではありません。");
    } catch (error) {
        console.error("AI掲示板コメントの生成に失敗しました:", error);
        return [{
            id: `error-${matchId}-bbs`,
            error: true,
            title: `掲示板コメント生成エラー`,
            context: matchContext // ★エラー時に再生成できるよう、context全体を保存
        }];
    }
}
/**
     * AIに代矢東応援掲示板のコメントを生成させる
     */
    async function generateDaiyaBbsComments(winnerName, loserName, dbMatch, nextOpponentInfo) {
        const isDaiyaWinner = winnerName === '静岡';
        const opponentName = isDaiyaWinner ? loserName : winnerName;
        const opponentRank = calculateRank(opponentName, tournamentState);
        const resultContext = isDaiyaWinner ? '勝利' : '敗北';
        const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
        const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;
        const score = `${winnerScore} - ${loserScore}`;
        
        const prompt = `あなたは、静岡の古豪「静岡」高校野球部の熱狂的なファンです。あなたは野球に非常に詳しく、常に冷静に試合を分析し、どうすればチームが甲子園に行けるかを考えています。
以下の試合結果について、あなたらしいコメントを5つ生成してください。

### 試合情報
- 試合結果: 静岡の${resultContext}
- 対戦相手: ${opponentName} (${getRankDescription(opponentRank)})
- スコア: ${score}

### あなたのキャラクターと指示
- あなたは生粋の野球好きで、静岡のファンが集う特設掲示板の常連です。
- **もし代矢東が勝利した場合:**
  - 喜びつつも、冷静に勝因を分析してください（例：「今日の勝因は継投のタイミングだな」「あの場面のスクイズは見事だった」）。
  - すぐに次の対戦相手に目を向け、どうすれば勝てるかの戦略を語ってください（例：「次は〇〇か…キーマンは相手の3番打者だ。徹底的にインコースを攻めるべき」）。
  - 決して浮かれず、常に甲子園への道を冷静に見据えてください。
- **もし代矢東が敗北した場合:**
  - 非常に落胆し、性格の悪さを露呈してください。
  - 敗因を厳しく追及してください（例：「なぜあの場面でピッチャーを変えなかったんだ」「監督の采配ミスだろ」）。
  - 「【悲報】静岡、今年も甲子園いけず…」のような、絶望的なスレッドタイトルを必ず一つ生成してください。
  - 来年に向けての不安や、チームの課題を辛辣に指摘してください。

### 出力形式
必ず以下のJSON配列形式で出力してください。
[
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"}
]`;
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const commentsJson = parseJsonFromText(rawText);
                if (Array.isArray(commentsJson)) {
                    return commentsJson.map(c => ({
                        id: crypto.randomUUID(),
                        personality: c.personality,
                        text: c.comment,
                        timestamp: Date.now(),
                        replies: []
                    }));
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("代矢東 掲示板コメントの生成に失敗しました:", error);
            return [];
        }
    }

   /**
 * AIに組み合わせ決定時の掲示板の反応を生成させる
 * ★★★ 春・夏・秋の大会進行度に応じて指示を切り替える完成版 ★★★
 */
async function generateBracketReactionComments(state) {
    const { teams, seeds } = state;
    // チーム数が少ない場合はコメントを生成しない
    if (teams.length < 8) return []; 

    let analysis = ''; // 組み合わせ分析を入れる変数
    let commentDirections = ''; // AIへの指示を入れる変数

    // --- 1. 秋季大会の処理 ---
    if (state.currentTournament === 'autumn' && state.autumnPhase === 'main') {
        const pots = { 1: [], 2: [], 3: [], 4: [], 5: [] };
        state.teams.forEach(team => {
            for (const region of ['東部', '中部', '西部', '伊豆']) {
                const rep = state.autumnData.regions[region].finalReps.find(r => r.team === team);
                if (rep) {
                    pots[rep.rank].push(`${team}(${region}${rep.rank}位)`);
                    break;
                }
            }
        });
        
        analysis = `秋季県大会の組み合わせが決定！
- ポット1(地区1位): ${pots[1].join(', ')}
- ポット2(地区2位): ${pots[2].join(', ')}
- ポット3(地区3位): ${pots[3].join(', ')}
- ポット4(地区4位): ${pots[4].join(', ')}
- ポット5(敗者復活): ${pots[5].join(', ')}`;

        commentDirections = `
- 「地区1位と敗者復活組がいきなり当たるのか！」「地区間のレベル差が試されるな」といったポット制や地区対決に関する反応。
- ポット1の強豪校がどこに入るか、そのブロックの他のチームへの同情。
- 自分の応援するチームがどのポットから、どのブロックに入ったかに対する一喜一憂。`;

    // --- 2. 春季大会の処理 ---
    } else if (state.currentTournament === 'spring') {
        
        // --- 2A. 地区予選 ---
        if (state.springPhase === 'regional_qualifiers') {
            analysis = `春季地区予選の組み合わせが決定！県大会本戦への出場権16枠をかけた戦いが始まる。`;
            commentDirections = `
- 「うちの地区、激戦区すぎだろ…」「県大会出るの大変だな」といった、地区予選の厳しさに関するコメント。
- シード校以外の有力校がどの地区にいるかについての言及。「〇〇と△△が同じ地区とかマジかよ」など。
- 無名校にとってはチャンスであることへの期待や感想。`;
        } 
        // --- 2B. 県大会1回戦 ---
        else if (state.springPhase === 'main_round1') {
            analysis = `春季県大会1回戦、予選を勝ち上がった16校の組み合わせが決定！シード校への挑戦権を掴むのはどこだ。`;
            commentDirections = `
- 「予選突破組同士の潰し合いか、面白いな」「ここ勝てばシード校とやれるのか」といった、1回戦ならではの反応。
- 地区予選を勝ち上がってきた勢いのあるチームへの注目。「予選で〇〇を倒した△△、どこまで行くか楽しみ」など。
- どのチームがシード校を脅かす存在になりそうかという予想。`;
        } 
        // --- 2C. 県大会2回戦 (シード校登場) ---
        else if (state.springPhase === 'main_round2') {
            const numBlocks = Math.ceil(teams.length / 16);
            let blockAnalyses = [];
            for(let i=0; i<numBlocks; i++){
                const blockName = String.fromCharCode(65+i);
                const blockTeams = teams.slice(i*16, (i+1)*16);
                if(blockTeams.length === 0) continue;
                const isStrong = (team) => seeds.includes(team) || DETAILED_TEAM_DATA[team] || TEAM_DATA[team].popularity;
                const strongTeams = blockTeams.filter(isStrong);
                blockAnalyses.push(`- ${blockName}ブロック: 有力校 ${strongTeams.length}チーム (${strongTeams.join(', ')})`);
            }
            analysis = `春季県大会2回戦、シード校と予選突破校の組み合わせが決定！\n${blockAnalyses.join('\n')}`;
            commentDirections = `
- 「シード校 vs 予選突破組」という構図への期待感。「〇〇（シード校）といきなり当たるとかクジ運なさすぎだろ」など。
- 有力校が固まった「死のブロック」への反応。「Aブロック、事実上の決勝戦じゃねえか」など。
- シード校が順当に勝つか、予選を勝ち上がったチームが「ジャイキリ」を起こすかという予想。`;
        }

    // --- 3. 夏季大会 (および上記以外のケース) の処理 ---
    } else {
        const numBlocks = Math.ceil(teams.length / 16);
        let blockAnalyses = [];
        for(let i=0; i<numBlocks; i++){
            const blockName = String.fromCharCode(65+i);
            const blockTeams = teams.slice(i*16, (i+1)*16);
            if(blockTeams.length === 0) continue;
            const isStrong = (team) => seeds.includes(team) || DETAILED_TEAM_DATA[team] || TEAM_DATA[team].popularity || TEAM_DATA[team].best.includes('甲子園');
            const strongTeams = blockTeams.filter(isStrong);
            blockAnalyses.push(`- ${blockName}ブロック: 有力校 ${strongTeams.length}チーム (${strongTeams.join(', ')})`);
        }
        analysis = `夏の選手権、組み合わせが決定！\n${blockAnalyses.join('\n')}`;
        commentDirections = `
- 「ここのブロックやばすぎる」「死のブロックだな」といった、有力校が固まったブロックへの反応。
- 「〇〇は決勝までフリーパスかよ」といった、有力校が少ないブロックへの反応。
- 自分の応援するチームが厳しいブロックに入ったことへの絶望や、楽なブロックに入ったことへの期待。
- 3年生最後の夏、という文脈でのドラマへの期待。`;
    }

    // --- プロンプトの組み立て ---
    const prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下のトーナメントの組み合わせ分析を読んで、ファンらしいリアルな短いコメントを5～7個生成してください。

### 組み合わせ分析
${analysis}

### コメントの方向性
${commentDirections}

### 出力形式
必ず以下のJSON配列形式で出力してください。
[
  {"personality": "匿名ファン", "comment": "（コメント本文）"},
  {"personality": "野球通", "comment": "（コメント本文）"},
  {"personality": "悲観的なファン", "comment": "（コメント本文）"}
]`;

    // --- AIへのリクエストと結果の処理 ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI組み合わせ反応コメントの生成に失敗しました:", error);
        return [];
    }
}
    
/**
 * Takes a user's comment and generates multiple AI fan replies to it.
 */
/**
 * Generates multiple AI fan replies to a user's top-level comment,
 * using the same advanced logic as the in-thread reply function.
 */
/**
 * ユーザーのコメント一つに対して、複数のAIファンからの返信を一度に生成する
 * (★チームの敗退状況も認識する最終版)
 */
async function generateMultipleReplies(userCommentText) {
    const conversationHistory = `あなた: 「${userCommentText}」`;

    // --- AIに与える「知識」の部分を作成（完全版） ---
    const mentionedTeams = new Set();
    const mentionedPlayers = new Set(); // ★言及された選手名を保存するSet

    INITIAL_TEAM_POOL.forEach(team => {
        if (userCommentText.includes(team)) {
            mentionedTeams.add(team);
            // チーム名が言及されたら、そのチームの全選手を潜在的な調査対象とする
            const detailedData = DETAILED_TEAM_DATA[team];
            if (detailedData) {
                detailedData.players.forEach(p => mentionedPlayers.add({name: p.name, team: team}));
            }
        } else {
            // チーム名がなくても、選手名単体で言及されている場合
            const detailedData = DETAILED_TEAM_DATA[team];
            if(detailedData) {
                detailedData.players.forEach(p => {
                    if (userCommentText.includes(p.name)) {
                        mentionedPlayers.add({name: p.name, team: team});
                    }
                });
            }
        }
    });

    let teamInfoPromptPart = '### 参考情報：関連チームと選手の状況\n';
    
    // チーム全体の状況
    mentionedTeams.forEach(teamName => {
        const teamData = TEAM_DATA[teamName];
        const teamRecord = tournamentState.teamRecords[teamName];
        const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord);
        const fate = getTeamFateSummary(teamName);
        teamInfoPromptPart += `- **${teamName}**: ${dynamicInfo} (今大会の状況: ${fate})\n`;
    });

    // 言及された全選手の個人成績
    if (mentionedPlayers.size > 0) {
        teamInfoPromptPart += `\n- **主な選手の今大会成績**:\n`;
        mentionedPlayers.forEach(playerInfo => {
            const statsSummary = getPlayerTournamentStatsSummary(playerInfo.name, playerInfo.team);
            if (statsSummary) {
                teamInfoPromptPart += `  - ${statsSummary}\n`;
            }
        });
    }

    // --- プロンプト作成 ---
    const prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
ユーザー「あなた」の投稿した以下のコメントに対し、4人の異なるキャラクターとして返信してください。
### **ユーザーのコメント**: 「${userCommentText}」
### **現在の大会状況**: ${getTournamentStatusSummary()}
${teamInfoPromptPart}
### **指示**:
- 各キャラクターの返信は、必ずユーザーのコメント内容に直接関連していること。
- **【重要】**: あなたの知識である「参考情報」を最大限に活用し、具体的なチーム状況や選手成績に触れながら、的確な返信をすること。
- **【注意】**: まだ大会序盤である（例：2試合しか終わっていない）ことを考慮し、「本塁打が少ない」といった早計な批判は避けること。
---
---### **ステップ4：出力形式**
【最重要】必ず以下のJSON配列形式"のみ"で出力すること。
[
    {"personality": "熱狂的なファン", "comment": "（コメント本文）"},
    {"personality": "上から目線の解説者", "comment": "（コメント本文）"},
    {"personality": "アンチ", "comment": "（コメント本文）"},
    {"personality": "ライバル校のファン", "comment": "（コメント本文）"}
]`;
    
    // --- 4. Call AI and Process Response ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI multi-reply generation failed:", error);
        return [];
    }
}

/**
     * AIにナムコグループからのお知らせを生成させる
     */
    async function generateNamcoNews(state, type, matchData = null) {
        const namcoSchools = ["初星学園", "765総合高校", "283学園", "美城学園", "283学園B"];
        let prompt = '';

        if (type === 'bracket') {
            const participatingSchools = state.teams.filter(t => namcoSchools.includes(t));
            if(participatingSchools.length === 0) return null;

            const matchups = participatingSchools.map(school => {
                const schoolIndex = state.teams.indexOf(school);
                if (schoolIndex === -1) return null;
                const opponentIndex = schoolIndex % 2 === 0 ? schoolIndex + 1 : schoolIndex - 1;
                const opponentName = state.teams[opponentIndex];
                return `- ${school} の初戦は ${opponentName} と対戦します。`;
            }).filter(item => item !== null).join('\n');

            prompt = `あなたはナムコグループの広報担当者です。
夏の高校野球選手権大会の組み合わせが決定しました。
以下の情報に基づき、グループの公式サイトに掲載する、プロフェッショナルで丁寧な「お知らせ」記事を生成してください。

### 各校の初戦の組み合わせ
${matchups}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）組み合わせ決定のお知らせ」とする。
- 本文では、抽選会が行われたことと、上記の組み合わせが決定したことを報告してください。
- 最後に、系列校野球部への応援をお願いする言葉で締めくくる。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}`;
        } else if (type === 'matchResult') {
            const { winnerName, loserName, dbMatch } = matchData;
            const isCivilWar = (winnerName === '283学園' && loserName === '283学園B') || (winnerName === '283学園B' && loserName === '283学園');

            if (isCivilWar) {
                // ... (省略)
            } else {
                const namcoTeam = namcoSchools.includes(winnerName) ? winnerName : loserName;
                const opponent = namcoSchools.includes(winnerName) ? loserName : winnerName;
                const result = namcoSchools.includes(winnerName) ? '勝利' : '敗北';
                const score = namcoSchools.includes(winnerName) ? `${dbMatch.score1}-${dbMatch.score2}` : `${dbMatch.score2}-${dbMatch.score1}`;

                prompt = `あなたはナムコグループの広報担当者です。
本日行われた、夏の高校野球選手権大会の試合結果について、公式サイトに掲載する「お知らせ」記事を生成してください。

### 試合情報
- 系列校: ${namcoTeam}
- 対戦相手: ${opponent}
- 結果: ${namcoTeam}の${result}
- スコア: ${score}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）試合結果のお知らせ」とする。
- 本文では、まず試合が行われたことと、結果を簡潔に報告する。
- **もし勝利した場合:**
  - 応援への感謝を述べ、次の試合への意気込みを語る（例：「次戦もチーム一丸となって勝利を目指します」）。
- **もし敗北した場合:**
  - 選手たちの健闘を称え、応援への感謝を深く述べる（例：「皆様の熱い声援が、選手の力となりました。心より感謝申し上げます」）。
  - 新チームでの再起を誓う言葉で締めくくる。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}`;
            }
        }

        if (!prompt) return null;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const newsJson = parseJsonFromText(rawText);
                if (newsJson) {
                    return { ...newsJson, timestamp: Date.now() };
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("ナムコニュースの生成に失敗しました:", error);
            return null;
        }
    }
/**
     * AIにスポーツ新聞の一面を生成させる
     */
    /**
     * AIが生成した新聞データからHTMLを生成する
     */
    function createNewspaperHtml(articleData, matchData) {
        const { winnerName, loserName, dbMatch, matchId } = matchData;
        const idParts = matchId.split('-');
        const roundNum = idParts[0] === 'F' ? Math.log2(tournamentState.teams.length) : parseInt(idParts[1].slice(1));

        const isLateRound = roundNum >= 4;
        const containerClass = isLateRound ? 'newspaper-late' : 'newspaper-early';
        const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
        const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;

        return `
            <div class="newspaper-container ${containerClass}">
                <div class="newspaper-header">
                    <h2 class="newspaper-title">熱闘高校野球</h2>
                    <p class="newspaper-date">${new Date(articleData.timestamp).toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                </div>
                <div class="newspaper-content">
                    <h1 class="newspaper-main-headline">${winnerName.slice(0, 4)}</h1>
                    <div class="newspaper-body-content">
                        <h2 class="newspaper-sub-headline">${articleData.title}</h2>
                        ${isLateRound ? '<div class="newspaper-image-placeholder">[試合の様子の写真]</div>' : ''}
                        <p class="newspaper-text">${articleData.body.replace(/\\n/g, '\n')}</p>
                        <div class="newspaper-score-box">
                            <h3>最終スコア</h3>
                            <p class="score">${winnerName} ${winnerScore} - ${loserScore} ${loserName}</p>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
async function generateSportsNewspaper(roundNumber) {
        const numTeams = tournamentState.is16team ? 16 : 64;
        const finalRound = Math.log2(numTeams);

        const roundNameMap = {
            [finalRound]: '決勝',
            [finalRound-1]: '準決勝',
            [finalRound-2]: '準々決勝',
            [finalRound-3]: '3回戦'
        };

        const roundName = roundNameMap[roundNumber];
        if (!roundName) return null;

        const matchIdsInRound = Object.keys(tournamentState.matches).filter(id => 
            (id.includes(`-R${roundNumber}-`)) || (roundNumber === finalRound && id.includes('F-R1-'))
        );
        const results = matchIdsInRound.map(id => tournamentState.matches[id]);

        const resultsText = results.map(match => {
            const winnerRank = getRankDescription(calculateRank(match.winner, tournamentState));
            const loser = match.team1 === match.winner ? match.team2 : match.team1;
            const loserRank = getRankDescription(calculateRank(loser, tournamentState));
            const winnerScore = match.team1 === match.winner ? match.score1 : match.score2;
            const loserScore = match.team1 === match.winner ? match.score2 : match.score1;
            return `${winnerRank}・${match.winner}が${loserRank}・${loser}に ${winnerScore}-${loserScore} で勝利。`;
        }).join('\n');

        const prompt = `あなたは、読者の購買意欲を掻き立てるのが得意な、日本のスポーツ新聞の編集長です。
現在、高校野球の${tournamentState.tournamentYear}年度大会が進行中です。${roundName}の全試合が終了しました。
以下の試合結果を基に、最も衝撃的でドラマチックな出来事を一つ選び出し、それに対応する新聞の一面を飾るテキストを生成してください。

### ${roundName} 全試合結果
${resultsText}

### あなたが作成するテキスト
以下の4つの要素を、JSON形式で出力してください。
1.  **mainHeadline**: 最も重要な結果を伝える、短く、衝撃的で、扇情的な大見出し。（例：「怪物散る！」「王者、盤石の決勝へ」）
2.  **subHeadline**: mainHeadlineを補足する、少し詳しい小見出し。
3.  **photoCaption**: その日のハイライトシーンを切り取った架空の写真に対する、情景が目に浮かぶようなキャプション。（例：「あと一歩及ばず、マウンドに崩れ落ちる〇〇高校のエース△△」）
4.  **otherResults**: その他の注目すべき結果を2つ、簡潔にまとめたもの。

### 出力形式
{"mainHeadline": "...", "subHeadline": "...", "photoCaption": "...", "otherResults": ["...", "..."]}`;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const newspaperData = parseJsonFromText(rawText);
                if (newspaperData) return newspaperData;
            }
            throw new Error("AI newspaper response format error.");
        } catch (error) {
            console.error("AI newspaper generation failed:", error);
            return null;
        }
    }

    /**
     * ラウンド終了時に新聞発行などのイベントを処理する
     */
    async function handleRoundCompletion(roundNumber) {
        const numTeams = tournamentState.is16team ? 16 : 64;
        const finalRound = Math.log2(numTeams);
        const significantRounds = [finalRound, finalRound - 1, finalRound - 2, finalRound - 3].filter(r => r > 0);
        if (!significantRounds.includes(roundNumber)) return;

        const alreadyExists = tournamentState.news.some(n => n.roundNumber === roundNumber && n.isNewspaper);
        if (alreadyExists) return;

        const newspaperData = await generateSportsNewspaper(roundNumber);
        if (newspaperData) {
            const roundNameMap = { 3: '3回戦', 4: '準々決勝', 5: '準決勝', 6: '決勝' };
            const roundName = tournamentState.is16team ? {1: '1回戦', 2: '準々決勝', 3: '準決勝', 4: '決勝'}[roundNumber] : roundNameMap[roundNumber];

            tournamentState.news.push({
                title: `【熱闘新聞】${roundName}特集号が発行されました！`,
                body: newspaperData.subHeadline,
                timestamp: Date.now(),
                isNewspaper: true,
                roundNumber: roundNumber,
                newspaperData: newspaperData
            });
            renderNews(tournamentState.news);
            saveState();
        }
    }

    /**
     * 新聞モーダルを描画する
     */
    function renderNewspaperModal(newspaperData) {
        const { mainHeadline, subHeadline, photoCaption, otherResults, imageUrl } = newspaperData;
        
        const imageHtml = imageUrl 
            ? `<img src="${imageUrl}" alt="${photoCaption}" class="w-full h-auto my-4 border">` 
            : `<div class="newspaper-image-placeholder my-4"><p class="text-sm p-4">${photoCaption}</p></div>`;

        newspaperModalBody.innerHTML = `
            <div class="newspaper-container newspaper-late">
                <div class="newspaper-header">
                    <h2 class="newspaper-title">熱闘スポーツ</h2>
                    <p class="newspaper-date">${new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                </div>
                <div class="newspaper-content">
                    <h1 class="newspaper-main-headline">${mainHeadline}</h1>
                    <div class="newspaper-body-content">
                        <h2 class="newspaper-sub-headline">${subHeadline}</h2>
                        ${imageHtml}
                        <div class="newspaper-score-box">
                            <h3>その他の主な結果</h3>
                            ${otherResults.map(r => `<p>${r}</p>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
 * AIに掲示板の返信を生成させる（最終版）
 * 最新のデータ構造と、脱線防止を強化したプロンプトを使用する
 */
/**
 * AIに掲示板の返信を生成させる（最新の環境に適合した最終版）
 */
async function generateBbsReply(parentCommentId, userReplyText, bbsType, aiPersona, context) {
    const commentSource = bbsType === 'general' ? tournamentState.bbsComments : tournamentState.daiyaBbsComments;
    const parentComment = findCommentById(commentSource, parentCommentId);
    if (!parentComment) return null;

    // --- 1. AIに渡すための「文脈」を収集する ---
    const userReplyObject = { id: 'temp_user_reply', personality: 'あなた', text: userReplyText, replies: [] };
    parentComment.replies.push(userReplyObject);
    const conversationHistory = formatConversationHistory(commentSource, 'temp_user_reply');
    parentComment.replies.pop();

    const mentionedTeams = new Set();
    conversationHistory.split('\n').forEach(line => {
        INITIAL_TEAM_POOL.forEach(team => {
            if (line.includes(team)) {
                mentionedTeams.add(team);
            }
        });
    });

    // --- 2. AIに与える「知識」の部分を作成する ---
    let teamInfoPromptPart = '';
    if (mentionedTeams.size > 0) {
        teamInfoPromptPart = '### 関連チームの背景情報\n';
        mentionedTeams.forEach(teamName => {
            const teamData = TEAM_DATA[teamName];
            const teamRecord = tournamentState.teamRecords[teamName];
            // ★最新のアナウンサー関数を活用
            const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord);
            teamInfoPromptPart += `- **${teamName}**: ${dynamicInfo}\n`;
        });
    }

    // --- 3. 最終的なプロンプトを組み立てる（★脱線防止策を適用） ---
    const prompt = `あなたは、匿名掲示板のキャラクター「${aiPersona}」です。あなたは今、他のユーザーと日本の高校野球について会話しています。
あなたの唯一の仕事は、会話の流れとあなたの知識に基づき、キャラクターになりきって自然な返信をすることです。野球以外の話題には絶対に触れないでください。
---
### **ステップ1：現在の会話状況を理解する**
- **これまでの会話の流れ**:
${conversationHistory}
- **あなたのキャラクター**: ${aiPersona}
- **現在の大会状況**: ${context.tournamentSummary}
---
### **ステップ2：関連情報を思い出す**
${teamInfoPromptPart}
---
### **ステップ3：返信する**
上記のステップ1と2の情報を元に、会話の最後の発言「${userReplyText}」に対して、あなたのキャラクターとして最も自然で的を射た返信を生成してください。
- **指示**:
  - 必ず相手の発言に直接応答することから始めること。
  - 応答の根拠として、ステップ2の「関連情報」を自然な形で会話に含めること。
  - 相手が話していない無関係なチームや試合の情報を一方的に解説しないこと。
---
### **ステップ4：出力形式**
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"comment": "（あなたの返信本文）"}`;
    
    // --- 4. AIを呼び出し、結果を処理する ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const replyJson = parseJsonFromText(rawText);
            if (replyJson && replyJson.comment) {
                return {
                    id: crypto.randomUUID(),
                    personality: aiPersona,
                    text: replyJson.comment,
                    timestamp: Date.now(),
                    replies: []
                };
            }
        }
        throw new Error("AIの応答形式が不正です。");
    } catch (error) {
        console.error("AI返信コメントの生成に失敗しました:", error);
        return null;
    }
}
/**
     * AIからの応答テキストからJSONオブジェクトを安全に抽出する
     */
    function parseJsonFromText(text) {
        try {
            const cleanedText = text.replace(/```json/g, '').replace(/```/g, '').trim();
            const jsonMatch = cleanedText.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch (e) {
            console.error("Failed to parse JSON from text:", text, e);
        }
        return null;
    }

    /**
     * リトライ機能付きでバックエンドAPI(Netlify Function)を呼び出す
     */
    async function fetchWithRetry(payload, maxRetries = 3) {
        const functionUrl = '/.netlify/functions/generateApiContent'; // Netlify Functionのエンドポイント
        let lastError;

        for (let i = 0; i < maxRetries; i++) {
            try {
                const response = await fetch(functionUrl, {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    return response;
                }
                
                if (response.status >= 400 && response.status < 500 && response.status !== 429) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error}`);
                }

                lastError = new Error(`API Error: ${response.status}`);
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));

            } catch (error) {
                lastError = error;
                const delay = Math.pow(2, i) * 1000;
                if (i < maxRetries - 1) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        throw lastError;
    }

    /**
     * チームランク（A～E）から説明的な文字列を取得する
     */
    function getRankDescription(rank) {
        switch(rank) {
            case 'A': return '名門校';
            case 'B': return '強豪校';
            case 'C': return '中堅校';
            case 'D': return '発展途上のチーム';
            case 'E': return '挑戦者';
            default: return '実力不明';
        }
    }
    
    /**
 * Generates a team's tournament path history, compatible with all tournament types.
 */
function getTournamentPath(teamName, startingMatchId) {
    if (!teamName) return "（不明）";
    const path = [];
    
    // Combine all matches from all tournaments into one list
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    // Determine the current round number to analyze up to that point
    const idParts = startingMatchId.split('-');
    if (idParts.length < 3) return '（地区予選突破）'; // Not a main tournament match
    let currentRoundNum = parseInt(idParts[1].slice(1));

    // Loop from the first round up to the current round
    for (let r = 1; r < currentRoundNum; r++) {
        // Find the match the team won in that round
        const matchInRound = Object.values(allMatches).find(match =>
            match.id && 
            match.id.includes(`-R${r}-`) && // Belongs to the correct round
            match.winner === teamName
        );

        if (matchInRound) {
            const opponent = matchInRound.team1 === teamName ? matchInRound.team2 : matchInRound.team1;
            const winnerScore = matchInRound.team1 === teamName ? matchInRound.score1 : matchInRound.score2;
            const loserScore = matchInRound.team1 === teamName ? matchInRound.score2 : matchInRound.score1;
            path.push(`${r}回戦 vs ${opponent} (${winnerScore}-${loserScore})`);
        }
    }

    return path.length > 0 ? path.join(' → ') : '（今大会初戦）';
}
    /**
     * AIプロンプト用に、チームの次の対戦相手情報を生成する
     */
    /**
 * Generates the next opponent info, compatible with all tournament structures.
 */
function getNextOpponentInfoForPrompt(teamName) {
    // Combine all matches from all tournaments into one list
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    let latestMatch = null;
    let maxRound = -1;

    // Find the most recent game this team played in
    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (match.team1 === teamName || match.team2 === teamName) {
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 0;
            if (roundNum > maxRound) {
                maxRound = roundNum;
                latestMatch = match;
            }
        }
    }

    if (!latestMatch) return "（まだ試合なし）";
    if (latestMatch.winner !== teamName) return "（この試合で敗退）";
    
    // Find the next game this team is in
    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        
        // Look for a future game where this team is slotted but the opponent is not yet decided
        if ((match.team1 === teamName && !match.team2) || (match.team2 === teamName && !match.tran1)) {
             return "（次の対戦相手は未定）";
        }
        
        // Look for a future game where the opponent is known
        if (match.team1 === teamName && match.team2 && !match.winner) {
             return `次の対戦相手は${match.team2}です。`;
        }
        if (match.team2 === teamName && match.team1 && !match.winner) {
            return `次の対戦相手は${match.team1}です。`;
        }
    }

    return "（優勝、または次のステージへ）";
}
    /**
     * AIプロンプト用に、掲示板の会話履歴をフォーマットする
     */
    function formatConversationHistory(comments, targetId) {
        let history = [];
        function findPath(currentComments, currentPath) {
            for(const comment of currentComments) {
                const newPath = [...currentPath, comment];
                if(comment.id === targetId) {
                    history = newPath;
                    return true;
                }
                if(comment.replies && findPath(comment.replies, newPath)) {
                    return true;
                }
            }
            return false;
        }
        findPath(comments, []);
        return history.map(c => `${c.personality}:「${c.text}」`).join('\n');
    }

    /**
     * AIプロンプト用に、現在の大会状況の要約を生成する
     */
    function getTournamentStatusSummary() {
        if (tournamentState.currentTournament === 'autumn') {
            return `現在、${tournamentState.tournamentYear}年度 秋季大会が進行中です。フェーズ: ${tournamentState.autumnPhase}`;
        }
        
        const finalMatch = tournamentState.matches['F-R1-M1'];
        if (finalMatch?.winner) return `${finalMatch.winner}が優勝しました。`;
        if (finalMatch?.team1 && finalMatch.team2) return `決勝戦の組み合わせは ${finalMatch.team1} vs ${finalMatch.team2} です。`;
        
        const numRounds = Math.log2(tournamentState.teams.length);
        for (let r = numRounds - 1; r >= 1; r--) {
            const roundIds = Object.keys(tournamentState.matches).filter(id => id.includes(`-R${r}-`));
            if (roundIds.some(id => tournamentState.matches[id]?.team1 && tournamentState.matches[id]?.team2)) {
                 const roundNameMap = { 5: "準決勝", 4: "準々決勝", 3: "3回戦", 2: "2回戦", 1: "1回戦"};
                 return `現在、${roundNameMap[r] || r + '回戦'}が進行中です。`;
            }
        }
        return '大会はまもなく開始されます。';
    }

    /**
     * IDを元に、入れ子構造のコメントデータから特定のコメントを見つけ出す
     */
    function findCommentById(comments, id) {
        for (const comment of comments) {
            if (comment.id === id) return comment;
            if (comment.replies && comment.replies.length > 0) {
                const found = findCommentById(comment.replies, id);
                if (found) return found;
            }
        }
        return null;
    }
/**
 * AIに甲子園（または東海大会）の結果を総括する記事を生成させる
 */
async function generateKoshienSummaryArticle(teamName, resultLabel, type) {
    let context, titleInstruction;

    if (type === 'summer') {
        context = `夏の甲子園、全国の頂点を目指した${teamName}の戦いが終わりました。`;
        titleInstruction = `「${teamName}、聖地での戦いの軌跡」のような、夏の終わりを感じさせる感動的なタイトルにしてください。`;
    } else if (type === 'spring') {
        context = `選抜高校野球大会に出場した${teamName}の最終結果が確定しました。`;
        titleInstruction = `「${teamName}、春の聖地に爪痕」のように、来たる夏への期待を感じさせるタイトルにしてください。`;
    } else { // tokai
        context = `秋季東海大会で、静岡県代表の${teamName}が見事な戦いを見せました。`;
        titleInstruction = `「${teamName}、センバツ当確！」のように、速報らしく、喜びが伝わるタイトルにしてください。`;
    }

    const prompt = `あなたは、情熱的な高校野球専門のAI記者です。
以下の情報に基づき、読者の心を打つような総括記事を生成してください。

### 大会結果
- チーム: ${teamName}
- 最終成績: ${resultLabel}
- 文脈: ${context}

### 執筆指示
- ${titleInstruction}
- チームのこれまでの努力や、県大会での戦いぶりを称え、今回の結果が持つ意味をドラマチックに描写してください。
- 最後に、選手たちへの賛辞や、今後のチームへの期待を述べて締めくくってください。

### 出力形式
JSON形式で出力してください: {"title": "記事のタイトル", "body": "記事の本文"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) return { ...article, timestamp: Date.now() };
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI甲子園記事の生成に失敗しました:", error);
        return { title: "記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true };
    }
}
// --- Match Processing & Event Listeners ---

/**
 * 延長イニングを全ての関連テーブルに追加する
 */
function addExtraInning() {
    // --- 1. イニングスコアのテーブルを更新 ---
    const scoreTable = document.getElementById('inning-score-table');
    if (scoreTable) {
        const headerRow = scoreTable.querySelector('thead tr');
        // 現在の最終イニング番号を取得し、1を足す
        const lastInningHeader = headerRow.children[headerRow.children.length - 3];
        const newInningNum = parseInt(lastInningHeader.textContent) + 1;

        // 新しいヘッダーを追加
        const newTh = document.createElement('th');
        newTh.className = 'w-10';
        newTh.textContent = newInningNum;
        headerRow.insertBefore(newTh, headerRow.children[headerRow.children.length - 2]);

        // 各チームの行に新しい入力欄を追加
        scoreTable.querySelectorAll('tbody tr').forEach(row => {
            const newTd = document.createElement('td');
            newTd.innerHTML = `<input type="text" value="">`;
            row.insertBefore(newTd, row.children[row.children.length - 1]);
        });
    }

    // --- 2. 両チームの打撃成績テーブルを更新 ---
    for (const teamKey of ['team1', 'team2']) {
        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (!battingTable) continue;

        // ヘッダーを更新
        const headerRow = battingTable.querySelector('thead tr');
        const lastInningHeader = headerRow.lastElementChild.previousElementSibling;
        const newInningNum = parseInt(lastInningHeader.textContent) + 1;
        const newTh = document.createElement('th');
        newTh.className = 'col-inning';
        newTh.textContent = newInningNum;
        headerRow.insertBefore(newTh, headerRow.lastElementChild);

        // 全ての選手行（スタメン・交代）に新しい入力欄を追加
        battingTable.querySelectorAll('tbody tr').forEach(row => {
            const newTd = document.createElement('td');
            newTd.innerHTML = `<input type="text" placeholder="-">`;
            row.appendChild(newTd);
        });

        // イニング出来事入力欄のcolspanを更新し、新しい入力欄を追加
        const tfoot = battingTable.querySelector('tfoot');
        if (tfoot) {
            const targetCell = tfoot.querySelector('td[colspan]');
            const currentNumInnings = parseInt(targetCell.getAttribute('colspan')) - 1;
            targetCell.setAttribute('colspan', currentNumInnings + 2);

            const newEventTd = document.createElement('td');
            newEventTd.className = 'border-t-2';
            newEventTd.innerHTML = `<input type="text" class="inning-events-input w-full text-left px-1 text-xs" data-team-key="${teamKey}" data-inning-index="${newInningNum - 1}" placeholder="例: 鈴木 盗塁">`;
            
            const eventRow = tfoot.querySelector('tr');
            eventRow.insertBefore(newEventTd, eventRow.lastElementChild);
        }
    }
}

/**
 * ニュースティッカーの表示を更新する
 */
function updateTicker() {
    const tickerContainer = document.querySelector('.ticker-content');
    const oldTickerText = document.getElementById('ticker-text');
    if (!tickerContainer || !oldTickerText) return;

    let headlines = tournamentState.tickerHeadlines || [];
    
    // 表示するヘッドラインがなければ、デフォルトのものを表示
    if (headlines.length === 0) {
        const defaultHeadlines = [
            "昨年度王者・283学園、連覇に向け盤石の仕上がり", "公立の雄・代矢東、悲願の甲子園へ『今年こそ』",
            "プロ注目右腕、大船渡・斎藤擁する布陣に死角なしか", "ノーシードからの下剋上なるか。ダークホース・豊中學園に注目",
            "新設校・緑山、初めての夏へ。全員野球で挑む", "765総合高校、2年前の栄光再び。聖地を知るメンバーがチームを牽引"
        ];
        headlines = new Array(5).fill(defaultHeadlines).flat().sort(() => Math.random() - 0.5);
    }

    const newTextContent = headlines.join('　／／　');
    
    // アニメーションをリセットするために要素を再生成
    const newTickerText = oldTickerText.cloneNode(false);
    newTickerText.textContent = newTextContent;
    oldTickerText.remove();
    tickerContainer.appendChild(newTickerText);
}

/**
 * 試合結果からニュースティッカー用の短いヘッドラインを生成する
 * @param {object} matchData - 試合のデータオブジェクト
 * @returns {string | null} - 生成されたヘッドラインの文字列、またはnull
 */
function generateTickerHeadline(matchData) {
    const { winnerName, loserName, score1, score2 } = matchData;
    const winnerScore = Math.max(parseInt(score1), parseInt(score2));
    const loserScore = Math.min(parseInt(score1), parseInt(score2));
    const scoreDiff = winnerScore - loserScore;

    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    const rankDiff = rankValues[winnerRank] - rankValues[loserRank];

    // パターン1：大番狂わせ（ジャイアントキリング）
    if (rankDiff <= -2) {
        return `【波乱】${getRankDescription(loserRank)}・${loserName}が初戦で散る！ ${winnerName}が金星挙げる`;
    }
    // パターン2：接戦
    if (scoreDiff <= 2 && rankDiff <= 1 && rankDiff >= -1) {
        return `手に汗握る接戦！ ${winnerName}が${loserName}を${winnerScore}-${loserScore}で振り切る`;
    }
    // パターン3：圧勝
    if (scoreDiff >= 8 && rankDiff >= 2) {
        return `王者・${winnerName}、盤石の試合運びで${loserName}を圧倒。${winnerScore}対${loserScore}でコールド勝ち級の快勝`;
    }
    // パターン4：ライバル対決
    const rivalry = RIVALRIES.find(r => r.teams.includes(winnerName) && r.teams.includes(loserName));
    if (rivalry) {
        return `因縁の${rivalry.type}は${winnerName}に軍配！ ${loserName}を下す`;
    }
    // デフォルト
    return `${winnerName}が${loserName}を下し、次のラウンドへ駒を進める`;
}

/**
 * 試合の詳細データから「事実オブジェクトの配列」と活躍選手リストを返す（★打順の巡りを完全再現する最終版）
 * @param {object} dbMatch - 試合のデータオブジェクト
 * @param {string} winnerName - 勝者名
 * @returns {{highlights: Array, keyPlayerNames: Array}}
 */
function createHighlightsText(dbMatch, winnerName) {
    if (!dbMatch.details) {
        return { highlights: [], keyPlayerNames: [] };
    }

    // --- 内部ヘルパー関数：打席結果を日本語に翻訳 ---
    const translateResult = (res, playerInfo, eventType) => {
        if (!res) return null;
        let description = `${playerInfo}が`;
        const rbiMatch = res.match(/(\d+)点/);
        const rbiText = rbiMatch ? (parseInt(rbiMatch[1]) > 1 ? `${rbiMatch[1]}点` : '') : '';
        if (res.includes('本塁打')) description = `${playerInfo}が${eventType}となる${rbiText}本塁打を放った`;
        else if (res.includes('三塁打')) description = `${playerInfo}が${eventType}となる${rbiText}三塁打を放った`;
        else if (res.includes('二塁打')) description = `${playerInfo}が${eventType}となる${rbiText}二塁打を放った`;
        else if (res.includes('安')) description = `${playerInfo}が${eventType}となる${rbiText}ヒットを放った`;
        else if (res.includes('犠飛')) description = `${playerInfo}が犠牲フライで${eventType}となる${rbiText || '1'}点を挙げた`;
        else if (res.includes('犠失')) description = `${playerInfo}が犠牲バントエラーで出塁した`;
        else if (res.includes('ゴロ') && res.includes('点')) description = `${playerInfo}の内野ゴロの間に${eventType}となる${rbiText || '1'}点を挙げた`;
        else if ((res.includes('エラー') || res.includes('失')) && res.includes('点')) description = `相手エラーの間に${eventType}となる${rbiText || '1'}点を記録した`;
        else if (res.includes('犠打')) description = `${playerInfo}が送りバントを決めた`;
        else if (res.includes('四球')) description = `${playerInfo}が四球を選んだ`;
        else if (res.includes('死球')) description = `${playerInfo}が死球で出塁した`;
        else if (res.includes('エラー')) description = `${playerInfo}がエラーで出塁した`;
        else if (res.includes('野選')) description = `${playerInfo}が野選で出塁した`;
        else if (res.includes('三振')) description = `${playerInfo}が三振に倒れた`;
        else if (res.includes('併殺')) description = `${playerInfo}が併殺打に倒れた`;
        else if (res.includes('ゴロ')) description = `${playerInfo}が内野ゴロに倒れた`;
        else if (res.includes('飛')) description = `${playerInfo}が外野フライに倒れた`;
        else if (res.includes('直')) description = `${playerInfo}がライナーに倒れた`;
        else return null;
        return description.replace(/1点/g, '');
    };
    
    const highlights = [];
    const keyPlayerNames = new Set();
    const winningTeamKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
    const losingTeamKey = winningTeamKey === 'team1' ? 'team2' : 'team1';
    const numInnings = dbMatch.details.inningScore?.team1?.length || 9;

    let hasScored = false;
    let isReversed = false;
    let scores = { team1: 0, team2: 0 };
let batterIndices = { team1: 0, team2: 0 };
    
// --- 1. イニングごとのプレーを、正しい打順で解析 ---
    for (let i = 0; i < numInnings; i++) {
        for (const teamKey of ['team1', 'team2']) {
            const teamName = dbMatch[teamKey];
            const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
            const allBattingData = dbMatch.details.batting?.[teamKey] || [];
            if (allBattingData.length === 0) continue;

            const sortedBattingOrder = allBattingData.sort((a,b) => parseFloat(a.order.replace('-sub','.')) - parseFloat(b.order.replace('-sub','.')));
            
            // A. この半イニングに発生した全てのプレーを一旦収集する
            let playsInHalfInning = [];
            sortedBattingOrder.forEach(player => {
                const resultString = player.results?.[i];
                if (resultString) {
                    resultString.split('、').forEach(atBatString => {
                        if(atBatString) {
                            playsInHalfInning.push({ player, atBatString });
                        }
                    });
                }
            });

            if (playsInHalfInning.length === 0) continue;

            // B.「次の打者」を基準に、プレーを時系列順に並べ替える
            const startingBatterOrder = sortedBattingOrder[batterIndices[teamKey]].order;
            playsInHalfInning.sort((a, b) => {
                const orderA = parseFloat(a.player.order.replace('-sub','.'));
                const orderB = parseFloat(b.player.order.replace('-sub','.'));
                const startOrder = parseFloat(startingBatterOrder.replace('-sub','.'));
                
                const adjustedOrderA = orderA >= startOrder ? orderA : orderA + 100;
                const adjustedOrderB = orderB >= startOrder ? orderB : orderB + 100;

                return adjustedOrderA - adjustedOrderB;
            });

            // C. 並べ替えた正しい順序で、ハイライトを生成する
            playsInHalfInning.forEach(play => {
                const { player, atBatString } = play;
                const [batterPlay, runnerPlaysString] = atBatString.split(';');
                const playerInfo = `${player.name}(${player.order.includes('sub') ? '交代' : player.order + '番'})`;
                
                if (batterPlay && batterPlay.trim() !== '') {
                    if (batterPlay.includes('点') || batterPlay.toLowerCase().includes('hr') || batterPlay.includes('本')) {
                        const prevTotalScore = scores[teamKey];
                        const rbiMatch = batterPlay.match(/(\d+)点/);
                        let addedScore = rbiMatch ? parseInt(rbiMatch[1]) : (batterPlay.includes('点') ? 1 : 0);
                        if (batterPlay.includes('本')) addedScore = Math.max(1, addedScore);
                        scores[teamKey] += addedScore;

                        let eventType = '追加点';
                        if (!hasScored) { eventType = '先制'; hasScored = true; }
                        else if (teamKey === winningTeamKey && prevTotalScore <= scores[opponentTeamKey] && scores[teamKey] > scores[opponentTeamKey] && !isReversed) { eventType = '逆転'; isReversed = true; }
                        
                        const description = translateResult(batterPlay, playerInfo, eventType);
                        if (description) {
                            highlights.push({ inning: i + 1, team: teamName, player: player.name, description });
                            keyPlayerNames.add(player.name);
                        }
                    } else {
                        const description = translateResult(batterPlay, playerInfo, '');
                        if (description) {
                            highlights.push({ inning: i + 1, team: teamName, player: player.name, description: description.replace(/がとなる/g, 'が') });
                            keyPlayerNames.add(player.name);
                        }
                    }
                }
                
                if (runnerPlaysString) {
                    runnerPlaysString.split(',').forEach(runnerPlay => {
                        if (!runnerPlay) return;
                        const runnerPlayParts = runnerPlay.trim().split(' ');
                        if (runnerPlayParts.length < 2) return;
                        const runnerName = runnerPlayParts[0];
                        const play = runnerPlayParts[1];
                        const detail = runnerPlayParts.slice(2).join(' ') || '';
                        let description = `${runnerName}が`;

                        if (play === '盗塁') description += `盗塁を成功させ${detail}！`;
                        else if (play === 'タッチアップ') description += `タッチアップから${detail}！`;
                        else if (play === '生還' || (play === '進塁' && detail.includes('生還'))) description += `好走塁でホームイン！`;
                        else if (play.includes('死') || play.includes('アウト')) description += `走塁ミスでアウトになった`;
                        else if (play === '進塁') description += `進塁し${detail}。`;
                        
                        highlights.push({ type: 'baserunning', inning: i + 1, team: teamName, player: runnerName, description: description });
                        keyPlayerNames.add(runnerName);
                    });
                }
            });

            // D. この回の最終打者を記録し、次のイニングの先頭打者を更新する
            if (playsInHalfInning.length > 0) {
                const lastBatter = playsInHalfInning[playsInHalfInning.length - 1].player;
                const lastBatterOrder = parseFloat(lastBatter.order.replace('-sub','.'));
                const lastBatterIndexInLineup = sortedBattingOrder.findIndex(p => parseFloat(p.order.replace('-sub','.')) === lastBatterOrder);
                batterIndices[teamKey] = (lastBatterIndexInLineup + 1) % sortedBattingOrder.length;
            }
        }
    }
    // --- 2. 試合全体の個別要素を分析 ---
    const loserName = dbMatch[losingTeamKey];
    const losingPitchers = dbMatch.details.pitching?.[losingTeamKey] || [];
    if (losingPitchers.length === 1) {
        const ace = losingPitchers[0];
        if (ace.result === 'L' && parseFloat(ace.innings) >= 8 && parseInt(ace.earnedRuns) <= 2) {
             highlights.push({ type: 'tough_loss', team: loserName, player: ace.name, description: `${ace.name}投手は${ace.innings}回を${ace.earnedRuns}失点と好投したが、打線の援護に恵まれなかった` });
             keyPlayerNames.add(ace.name);
        }
    }

    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const teamBatting = dbMatch.details.batting?.[teamKey] || [];
        const substitutes = teamBatting.filter(p => p.sub_type);

        substitutes.forEach(subPlayer => {
            for (let i = 0; i < numInnings; i++) {
                const resultInInning = subPlayer.results[i];
                if (resultInInning) {
                    if (subPlayer.sub_type === 'PH' && (resultInInning.includes('安') || resultInInning.includes('本') || resultInInning.includes('二') || resultInInning.includes('三'))) {
                        const subDescription = getSubstitutionDescription(subPlayer);
                        highlights.push({ type: 'substitute_hit', inning: i + 1, team: teamName, player: subPlayer.name, description: `${subDescription}し、起用に応えるヒットを放った` });
                        keyPlayerNames.add(subPlayer.name);
                    }
                    if (subPlayer.sub_type === 'PITCHER') {
                         highlights.push({ type: 'pitching_change', inning: i + 1, team: teamName, player: subPlayer.name, description: `リリーフとしてマウンドに上がった` });
                         keyPlayerNames.add(subPlayer.name);
                    }
                    break; 
                }
            }
        });
    }
    
    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const pitchingData = dbMatch.details.pitching?.[teamKey] || [];
        if (!pitchingData) continue;

        pitchingData.forEach((pitcher) => {
            if (!pitcher.name) return;
            const innings = parseFloat(pitcher.innings || 0);
            const runs = parseInt(pitcher.runs || 0);
            const strikeouts = parseInt(pitcher.strikeouts || 0);
            if (pitcher.result === 'W' && runs === 0 && innings >= 7) {
                highlights.push({ type: 'pitching_feat', team: teamName, player: pitcher.name, description: '圧巻の投球で完封勝利' });
                keyPlayerNames.add(pitcher.name);
            } else if (strikeouts >= 10) {
                highlights.push({ type: 'pitching_feat', team: teamName, player: pitcher.name, description: `${strikeouts}奪三振の快投` });
                keyPlayerNames.add(pitcher.name);
            }
        });
    }

    if (dbMatch.details.pitching) {
        for (const teamKey of ['team1', 'team2']) {
            const teamName = dbMatch[teamKey];
            const pitchingData = dbMatch.details.pitching[teamKey] || [];
            if (pitchingData.length > 1) {
                const pitcherNames = pitchingData.map(p => `${p.name}(${p.innings}回)`);
                highlights.push({ type: 'pitching_relay', team: teamName, description: `投手リレーは ${pitcherNames.join(' → ')} だった` });
            }
        }
    }

    // --- 3. 試合全体の物語性を分析し、総括ハイライトを生成 ---
    let summaryHighlight = null;
    const winnerScore = parseInt(dbMatch[winningTeamKey === 'team1' ? 'score1' : 'score2']);
    const loserScore = parseInt(dbMatch[losingTeamKey === 'team1' ? 'score1' : 'score2']);
    const totalRuns = winnerScore + loserScore;
    const winnerBatting = dbMatch.details.batting?.[winningTeamKey] || [];
    const loserBatting = dbMatch.details.batting?.[losingTeamKey] || [];
    const winnerPitching = dbMatch.details.pitching?.[winningTeamKey] || [];
    const countHits = (battingData) => battingData.reduce((sum, p) => sum + (p.results?.reduce((inningSum, res) => inningSum + (res && (res.includes('安') || res.includes('塁打')) ? 1 : 0), 0) || 0), 0);
    const winnerHits = countHits(winnerBatting);
    const totalHits = winnerHits + countHits(loserBatting);
    const inningScores = dbMatch.details.inningScore;
    let scoreAfter6th = { team1: 0, team2: 0 };
    for(let i = 0; i < numInnings; i++) {
        if (i < 6) {
             scoreAfter6th.team1 += parseInt(inningScores?.team1[i] || 0);
             scoreAfter6th.team2 += parseInt(inningScores?.team2[i] || 0);
        }
    }
    const winnerScoreAfter6th = scoreAfter6th[winningTeamKey];
    const loserScoreAfter6th = scoreAfter6th[losingTeamKey];
    const lastInning = numInnings - 1;
    const lastInningScore = parseInt(inningScores?.[winningTeamKey][lastInning] || 0);
    
    if (lastInning >= 8 && lastInningScore > 0 && scores[losingTeamKey] < scores[winningTeamKey]) {
        summaryHighlight = { type: 'summary', description: `劇的なサヨナラ勝ちで、${winnerName}が熱戦に終止符を打った` };
    } else if (winnerScoreAfter6th < loserScoreAfter6th && numInnings >= 7) {
        summaryHighlight = { type: 'summary', description: `${winnerName}が終盤に試合をひっくり返す、劇的な逆転勝利となった` };
    } else if (totalRuns <= 5 && totalHits <= 12) {
        summaryHighlight = { type: 'summary', description: `両チームの投手が好投し、1点を争う緊迫した投手戦となった` };
    } else if (totalRuns >= 13 && totalHits >= 20) {
        summaryHighlight = { type: 'summary', description: `両チーム合わせて${totalHits}安打${totalRuns}得点が乱れ飛ぶ、壮絶な乱打戦となった` };
    } else if (winnerScore - loserScore >= 7) {
        summaryHighlight = { type: 'summary', description: `${winnerName}が投打に圧倒し、一方的な試合展開で勝利を収めた` };
    }
    
    if (summaryHighlight) {
        highlights.unshift(summaryHighlight);
    }
    
    return { highlights: highlights, keyPlayerNames: Array.from(keyPlayerNames) };
}
/**
 * 3連携の打撃結果プルダウンメニューのHTMLを生成する
 */
/**
 * 3連携の打撃結果プルダウンメニューのHTMLを生成する（保存値の再現機能付き）
 */
/**
 * 3連携の打撃結果プルダウンメニューのHTMLを生成する（★データ属性を追加した最終版）
 */
/**
 * 3連携の打撃結果プルダウンメニューのHTMLを生成する（打者一巡対応版）
 */
/**
 * 3連携の打席結果プルダウンメニューのHTMLを生成する（シンプルな3連バージョン・完全版）
 */
/**
 * 3連携の打席結果プルダウンと、それに付随する走塁入力欄のHTMLを生成する（参照エラー修正版）
/**
 * 1打席分の入力ブロックHTMLを生成する（役割を単機能化した最終版）
 * @param {Array<object>} playersOnField - 現在出場中の選手リスト
 * @param {string} atBatString - 1打席分の保存済み文字列 (例: "中安1点好走塁;田中 進塁 二塁へ")
 * @returns {string} - 生成されたHTML
 */
/**
 * 1打席分の入力ブロックHTMLを生成する（役割を単機能化した最終版）
 */
function createBattingResultDropdowns(playersOnField, atBatString = '') {
    const [batterPlay, runnerPlaysString] = (atBatString || '').split(';');
    
    let selectedResult = '', selectedDirection = '', selectedRbi = '', selectedRunnerPlay = '';
    let tempResult = (batterPlay || '').trim();

    if (tempResult) {
        const rbiMatch = tempResult.match(/(\d+点)/);
        if (rbiMatch) {
            selectedRbi = rbiMatch[0];
            tempResult = tempResult.replace(selectedRbi, '').trim();
        }
        if (tempResult.includes('好走塁')) {
            selectedRunnerPlay = '好走塁';
            tempResult = tempResult.replace('好走塁', '').trim();
        }
        const allResultTypes = [ ...BATTING_RESULTS.hits, ...BATTING_RESULTS.outs, ...BATTING_RESULTS.walks, ...BATTING_RESULTS.sacrifices, ...BATTING_RESULTS.other ];
        for (const type of allResultTypes) {
            if (tempResult.includes(type)) {
                selectedResult = type;
                tempResult = tempResult.replace(type, '').trim();
                break;
            }
        }
        if (tempResult.length > 0 && DIRECTIONS.includes(tempResult)) {
            selectedDirection = tempResult;
        }
    }

    const resultOptions = [ ...BATTING_RESULTS.hits, ...BATTING_RESULTS.outs, ...BATTING_RESULTS.walks, ...BATTING_RESULTS.sacrifices, ...BATTING_RESULTS.other ]
        .map(r => `<option value="${r}" ${selectedResult === r ? 'selected' : ''}>${r}</option>`).join('');
    const directionOptions = DIRECTIONS.map(d => `<option value="${d}" ${selectedDirection === d ? 'selected' : ''}>${d}</option>`).join('');
    const rbiOptions = RBIS.map(r => `<option value="${r}" ${selectedRbi === r ? 'selected' : ''}>${r}</option>`).join('');
    const runnerPlayOptions = ['好走塁'].map(r => `<option value="${r}" ${selectedRunnerPlay === r ? 'selected' : ''}>${r}</option>`).join('');

    return `
        <div class="at-bat-block border-t border-dashed pt-2 mt-2 first:mt-0 first:pt-0 first:border-t-0">
            <div class="flex items-center gap-1 batting-result-container mb-1">
                <div class="flex-grow flex gap-1">
                    <select class="batting-result-part w-[28%] text-xs p-1 border rounded result-type"><option value="">-結果-</option>${resultOptions}</select>
                    <select class="batting-result-part w-[22%] text-xs p-1 border rounded result-direction"><option value="">-方向-</option>${directionOptions}</select>
                    <select class="batting-result-part w-[22%] text-xs p-1 border rounded result-rbi"><option value="">-打点-</option>${rbiOptions}</select>
                    <select class="batting-result-part w-[28%] text-xs p-1 border rounded result-runner-play bg-yellow-50"><option value="">-打者走塁-</option>${runnerPlayOptions}</select>
                </div>
            </div>
            ${createRunnerInputsHTML(playersOnField, runnerPlaysString)}
        </div>
    `;
}

/**
 * トーナメント表をたどり、次の対戦相手の情報を特定する（★タイプミスを修正した最終版）
 * @param {string} teamName - チーム名
 * @param {string} currentMatchId - そのチームが勝利した現在の試合ID
 * @returns {object|null} - 次の対戦相手に関する詳細情報
 */
function findNextOpponent(teamName, currentMatchId) {
    const allMatches = tournamentState.matches;
    // ★★★ ここが修正箇所： allMessages -> allMatches に修正 ★★★
    if (!allMatches || !allMatches[currentMatchId]) return null;

    const idParts = currentMatchId.split('-');
    const side = idParts[0];

    if (side === 'F') {
        return { opponentName: '優勝', roundName: '大会終了' };
    }

    const roundNum = parseInt(idParts[1].slice(1));
    const matchNum = parseInt(idParts[2].slice(1));
    const numTeams = tournamentState.teams.length;
    const finalRound = Math.log2(numTeams);

    let nextMatchId, roundName;
    if (roundNum === finalRound - 1) {
        nextMatchId = 'F-R1-M1';
        roundName = '決勝';
    } else if (roundNum < finalRound - 1) {
        const nextRoundNum = roundNum + 1;
        nextMatchId = `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
        const roundNameMap = { [finalRound - 1]: "準決勝", [finalRound - 2]: "準々決勝" };
        roundName = roundNameMap[nextRoundNum] || `${nextRoundNum}回戦`;
    } else {
        return null;
    }

    const nextMatch = allMatches[nextMatchId];
    if (!nextMatch) return null;

    let opponentName = null;
    if (nextMatch.team1 && nextMatch.team1 !== teamName) opponentName = nextMatch.team1;
    else if (nextMatch.team2 && nextMatch.team2 !== teamName) opponentName = nextMatch.team2;

    if (opponentName) {
        return {
            opponentName: opponentName,
            opponentRank: calculateRank(opponentName, tournamentState),
            roundName: roundName
        };
    } else {
        // 相手が未定の場合、その相手を決める試合を探しに行く
        const feederMatchNumber = matchNum % 2 === 1 ? matchNum + 1 : matchNum - 1;
        const feederMatchId = `${side}-R${roundNum}-M${feederMatchNumber}`;
        const feederMatch = allMatches[feederMatchId];

        if (feederMatch && feederMatch.team1 && feederMatch.team2) {
            return {
                opponentName: '（未定）',
                roundName: roundName,
                decidingMatch: {
                    team1: feederMatch.team1,
                    rank1: calculateRank(feederMatch.team1, tournamentState),
                    team2: feederMatch.team2,
                    rank2: calculateRank(feederMatch.team2, tournamentState)
                }
            };
        }
        
        return { opponentName: '（未定）', opponentRank: '?', roundName: roundName };
    }
}

/**
 * 複数走者に対応した走塁入力欄のHTMLを生成する
 * @param {Array<object>} playersOnField - 現在出場中の選手リスト
 * @param {string} currentResult - 保存済みの打席結果文字列
 * @returns {string} - 生成されたHTML
 */
/**
 * 複数走者に対応した走塁入力欄のHTMLを生成する（区切り文字バグ修正版）
 */
function createRunnerInputsHTML(playersOnField, runnerPlaysString = '') {
    const baserunningPlays = ['盗塁', '盗塁死', 'タッチアップ', '進塁', '生還', '走塁死', '牽制死', '挟殺プレーでアウト'];
    const bases = ['一塁へ', '二塁へ', '三塁へ', '本塁へ(生還)'];
    
    // ▼▼▼【重要修正】区切り文字を「、」から「,」に変更▼▼▼
    const runnerEvents = runnerPlaysString ? runnerPlaysString.split(',') : [];
    // ▲▲▲

    let html = '<div class="runner-plays-container space-y-1 mt-1">';
    
    runnerEvents.forEach(event => {
        const parts = event.trim().split(' ');
        const name = parts[0] || '';
        const play = parts[1] || '';
        const base = parts.slice(2).join(' ') || '';
        
        const nameOptions = playersOnField.map(p => `<option value="${p.name}" ${p.name === name ? 'selected' : ''}>${p.name}</option>`).join('');
        const playOptions = baserunningPlays.map(p => `<option value="${p}" ${p === play ? 'selected' : ''}>${p}</option>`).join('');
        const baseOptions = bases.map(b => `<option value="${b}" ${b === base ? 'selected' : ''}>${b}</option>`).join('');

        html += `
            <div class="runner-play-input flex gap-1 items-center mt-1">
                <select class="runner-name w-1/3 text-xs p-1 border rounded"><option value="">-誰が-</option>${nameOptions}</select>
                <select class="runner-play w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-何をした-</option>${playOptions}</select>
                <select class="runner-base w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-どこへ-</option>${baseOptions}</select>
                <button class="remove-runner-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </div>
        `;
    });

    html += '</div>';
    html += '<button class="add-runner-play-btn text-xs mt-1 bg-gray-200 px-2 py-0.5 rounded hover:bg-gray-300">+ 走者プレーを追加</button>';
    return html;
}

/**
 * 選手の大会通算成績を、AIプロンプト用の短い文章に要約する
 * @param {string} playerName - 選手名
 * @param {string} teamName - チーム名
 * @returns {string | null} - "姫川: 打率.500, 3本塁打, 10打点" のような要約文。成績がなければnull。
 */
function getPlayerTournamentStatsSummary(playerName, teamName) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord || !teamRecord.playerStats) return null;

    const battingStats = teamRecord.playerStats.batting[playerName];
    const pitchingStats = teamRecord.playerStats.pitching[playerName];
    
    let summaries = [];

    if (battingStats && battingStats.ab > 0) {
        const avg = (battingStats.h / battingStats.ab).toFixed(3);
        summaries.push(`打率${avg}, ${battingStats.hr}本塁打, ${battingStats.rbi}打点`);
    }

    if (pitchingStats && pitchingStats.ip > 0) {
        const era = pitchingStats.er > 0 ? ((pitchingStats.er * 9) / pitchingStats.ip).toFixed(2) : "0.00";
        summaries.push(`${pitchingStats.w}勝${pitchingStats.l}敗, 防御率${era}, ${pitchingStats.so}奪三振`);
    }

    if (summaries.length > 0) {
        return `${playerName}: ${summaries.join(' / ')}`;
    }
    
    return null;
}

/**
 * Analyzes the results of a half-inning, counts outs, and updates the UI (colors and disabled state).
 */
function updateInningState(teamKey, inningIndex) {
    const battingTable = document.getElementById(`batting-table-${teamKey}`);
    if (!battingTable) return;

    let outCount = 0;
    
    // --- 1. Analyze Batting Results ---
    battingTable.querySelectorAll('tbody tr').forEach(row => {
        const resultCell = row.children[5 + inningIndex];
        if (!resultCell) return;
        
        const atBatContainers = resultCell.querySelectorAll('.batting-result-container');
        atBatContainers.forEach(container => {
            const resultTypeSelect = container.querySelector('.result-type');
            const resultText = resultTypeSelect.value;
            
            // Count outs
            if (BATTING_RESULTS.outs.includes(resultText)) {
                outCount += (resultText === '併殺') ? 2 : 1;
            }

            // Color-code the dropdowns
            const dropdowns = container.querySelectorAll('select');
            dropdowns.forEach(dd => dd.classList.remove('result-hit', 'result-out', 'result-on-base'));

            if (BATTING_RESULTS.hits.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-hit'));
            } else if (BATTING_RESULTS.walks.includes(resultText) || BATTING_RESULTS.other.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-on-base'));
            } else if (BATTING_RESULTS.outs.includes(resultText) || BATTING_RESULTS.sacrifices.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-out'));
            }
        });
    });

    // --- 2. Count Outs from "Inning Events" (Baserunning) ---
    const eventsInput = document.querySelector(`.inning-events-input[data-team-key="${teamKey}"][data-inning-index="${inningIndex}"]`);
    if (eventsInput && eventsInput.value) {
        const events = eventsInput.value.split('、');
        events.forEach(event => {
            if (event.includes('盗塁死') || event.includes('走塁死')) {
                outCount++;
            }
        });
    }

    // --- 3. Lock the Inning if 3 Outs are Reached ---
    const isLocked = outCount >= 3;
    battingTable.querySelectorAll('tbody tr').forEach(row => {
        const resultCell = row.children[5 + inningIndex];
        if (!resultCell) return;
        
        const dropdowns = resultCell.querySelectorAll('.batting-result-container select');
        const addButtons = resultCell.querySelectorAll('.add-at-bat-btn');
        
        dropdowns.forEach(dd => {
            dd.disabled = isLocked;
            if (isLocked) dd.classList.add('bg-gray-100');
        });
        addButtons.forEach(btn => {
            btn.disabled = isLocked;
            if (isLocked) btn.style.visibility = 'hidden';
        });
    });
     if (eventsInput) {
        eventsInput.disabled = isLocked;
        if (isLocked) eventsInput.classList.add('bg-gray-100');
     }
}

/**
 * 生成された記事と元の「事実リスト」を比較し、内容が矛盾していないかAIに確認させる
 * @param {object} article - AI記者が生成した記事オブジェクト
 * @param {Array} facts - createHighlightsTextから生成された元の事実オブジェクトの配列
 * @returns {boolean} - 矛盾がなければtrue、あればfalseを返す
 */
/**
 * 生成された記事と元の「事実リスト」を比較し、内容が矛盾していないかAIに確認させる
 */
async function factCheckArticle(article, facts) {
    // ▼▼▼ この安全装置がクラッシュを防ぎます ▼▼▼
    if (!article || !article.body) {
        console.error("事実確認エラー: 記事データ、または記事の本文がありません。");
        return false; // 不完全な記事は「矛盾あり」とみなして処理を中断
    }
    // ▲▲▲

    const factListText = facts.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');

    const prompt = `あなたは厳格なファクトチェッカーです。以下の【事実リスト】と【記事】を比較し、記事に事実と異なる記述がないか判定してください。
### 事実リスト
${factListText}
### 記事
**タイトル:** ${article.title}
**本文:** ${article.body.replace(/\\n/g, '\n')}
### 指示
記事の内容が、事実リストと**著しく矛盾している場合のみ「いいえ」**と答えてください。表現の僅かな違いは許容します。あなたの答えは「はい」か「いいえ」の二文字だけでお願いします。`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const aiResponse = result.candidates[0].content.parts[0].text.trim();
            console.log("事実確認AIの応答:", aiResponse);
            return aiResponse.includes('はい');
        }
        return false;
    } catch (error) {
        console.error("事実確認AIの呼び出しに失敗しました:", error);
        return false;
    }
}

/**
     * 試合の勝者を処理する中心的関数。
     * 状態を更新し、次の試合を準備し、AIコンテンツ生成をトリガーする。
     */
    // 【修正対象5】
/**
     * 【修正版】試合の勝者を処理する中心的関数
     */
    /**
 * 試合の勝者を処理する中心的関数（全ての機能を統合した最終完成版）
 */
/**
 * 試合の勝者を処理する中心的関数（全てのロジックを統合した最終完成版）
 */
/**
 * 試合の勝者を処理する中心的関数（全機能統合・実行順序修正の最終版）
 */
async function processMatchWin(matchId, winnerName) {
    // --- 1. 試合データの特定と基本情報の設定 ---
    let dbMatch = findMatchById(matchId);
    if (!dbMatch || !dbMatch.team1 || !dbMatch.team2 || dbMatch.winner) return;
    
    const loserName = dbMatch.team1 === winnerName ? dbMatch.team2 : dbMatch.team1;
    dbMatch.winner = winnerName;
    
    const matchEl = document.querySelector(`.matchup[data-match-id="${matchId}"]`);
    if (matchEl) {
        const score1El = matchEl.querySelector('[data-team-pos="1"]');
        const score2El = matchEl.querySelector('[data-team-pos="2"]');
        if (score1El && score2El && score1El.value !== '' && score2El.value !== '') {
            dbMatch.score1 = score1El.value;
            dbMatch.score2 = score2El.value;
        }
        dbMatch.summary = matchEl.querySelector('.match-summary-input')?.value || '';
    }

    // --- 2. 試合後のデータ更新（ティッカー、称号、スタメン記録など） ---
    const newHeadline = generateTickerHeadline({ winnerName, loserName, score1: dbMatch.score1, score2: dbMatch.score2 });
    if (newHeadline) {
        tournamentState.tickerHeadlines.unshift(newHeadline);
        if (tournamentState.tickerHeadlines.length > 20) tournamentState.tickerHeadlines.pop();
        updateTicker();
    }
    
    if (dbMatch.details && dbMatch.details.batting) {
        const winnerTeamKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
        if (tournamentState.teamRecords[winnerName] && dbMatch.details.batting[winnerTeamKey]) {
            tournamentState.teamRecords[winnerName].previousStarters = dbMatch.details.batting[winnerTeamKey].filter(p => p.order && !p.order.toString().includes('sub')).map(p => ({ order: p.order, name: p.name, pos: p.pos }));
        }
        const loserTeamKey = dbMatch.team1 === loserName ? 'team1' : 'team2';
        if (tournamentState.teamRecords[loserName] && dbMatch.details.batting[loserTeamKey]) {
            tournamentState.teamRecords[loserName].previousStarters = dbMatch.details.batting[loserTeamKey].filter(p => p.order && !p.order.toString().includes('sub')).map(p => ({ order: p.order, name: p.name, pos: p.pos }));
        }
    }
    
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    if ((rankValues[loserRank] - rankValues[winnerRank]) >= 2) {
        const winnerRecord = tournamentState.teamRecords[winnerName];
        if (winnerRecord && !winnerRecord.teamTraits.includes('giant_killer')) {
            winnerRecord.teamTraits.push('giant_killer');
        }
    }

    // --- 3. AIコンテンツ生成の準備と実行 ---
    // --- 3. AIコンテンツ生成の準備と実行 ---
const matchContext = createMatchContext(matchId, winnerName);
if (!matchContext) {
    console.error("AIコンテンツ生成に必要なmatchContextの作成に失敗しました。");
    return; // AI処理を中断
}

let articlePromise = Promise.resolve(null);
let commentsPromise = Promise.resolve(null);

    if (tournamentState.settings.enableArticleGeneration) {
        newsContainer.innerHTML = `<div class="loader">AI記者が記事を執筆中...</div>`;
        const documentary = tournamentState.documentary;
        
        if (documentary && documentary.target && (documentary.target === winnerName || documentary.target === loserName)) {
            const isWin = documentary.target === winnerName;
            const opponentName = isWin ? loserName : winnerName;
            const opponentData = isWin ? loserData : winnerData; // 対戦相手のTEAM_DATAを取得

            const matchInfoForArticle = { 
                round: matchId.includes('-R') ? parseInt(matchId.split('-R')[1].split('-')[0]) : 1,
                opponent: opponentName,
                score: isWin ? `${dbMatch.score1}-${dbMatch.score2}` : `${dbMatch.score2}-${dbMatch.score1}`,
                highlights: highlightsText,
                summary: dbMatch.summary,
                opponentInfo: opponentData.info // ★★★ 対戦相手の背景情報を追加 ★★★
            };
            
            articlePromise = generateDocumentaryArticle(isWin ? 'win' : 'lose', documentary.type, documentary.target, matchInfoForArticle);
            
            if (!isWin) tournamentState.documentary = { target: null, type: null };
        } else {
        // ★呼び出し方を他のAIと統一し、matchContextをそのまま渡す★
        articlePromise = generateNewsArticle(matchContext);
            }
    }

    if (tournamentState.settings.enableBbsGeneration) {
    bbsCommentsContainer.innerHTML = `<div class="loader">AIが掲示板を監視中...</div>`;
    // ★matchContextを渡すだけのシンプルな呼び出しに修正
    commentsPromise = generateBbsComments(matchContext);
}    
    // --- 4. トーナメント進行ロジック ---
    if (tournamentState.currentTournament === 'autumn' && tournamentState.autumnPhase !== 'main') {
        const [region, bracketId, roundStr, matchStr] = matchId.split('-');
        if (bracketId.startsWith('B')) {
            const block = tournamentState.autumnData.regions[region].blocks.find(b => b.id === `${region}-${bracketId}`);
            const roundNum = parseInt(roundStr.slice(1));
            const matchNum = parseInt(matchStr.slice(1));
            if (roundNum === 0) block.matches[`${block.id}-R1-M1`].team1 = winnerName;
            else if (roundNum === 1) {
                const finalMatch = block.matches[`${block.id}-R2-M1`];
                if (matchNum === 1) finalMatch.team1 = winnerName; else finalMatch.team2 = winnerName;
            } else if (roundNum === 2) {
                tournamentState.autumnData.regions[region].blockWinners.push(winnerName);
                tournamentState.autumnData.regions[region].blockRunnersUp.push(loserName);
            }
        } else if (bracketId === 'AUTUMN') {
            const izuBracket = tournamentState.autumnData.regions['伊豆'].izuBracket;
            const roundNum = parseInt(roundStr.slice(1));
            const matchNum = parseInt(matchStr.slice(1));
            if (roundNum === 1) {
                const finalMatch = izuBracket.matches[`${izuBracket.id}-R2-M1`];
                if (matchNum === 1) finalMatch.team1 = winnerName; else finalMatch.team2 = winnerName;
            } else if (roundNum === 2) {
                tournamentState.autumnData.regions['伊豆'].finalReps.push({ team: winnerName, rank: 1 });
            }
        }
    } else if (tournamentState.currentTournament === 'autumn' && tournamentState.autumnPhase === 'regional_ranking') {
        // ▼▼▼ ここからが修正されたロジック ▼▼▼
        const [region, bracketId, roundStr, matchStr] = matchId.split('-');
        const roundNum = parseInt(roundStr.slice(1));
        const matchNum = parseInt(matchStr.slice(1));
        const isChamp = bracketId === 'CHAMP';
        const bracket = isChamp ? tournamentState.autumnData.regions[region].champBracket : tournamentState.autumnData.regions[region].repechageBracket;

        if (roundNum === 1) { // 準決勝
            const finalMatch = bracket.matches[`${bracket.id}-R2-M1`];
            if (matchNum === 1) finalMatch.team1 = winnerName; else finalMatch.team2 = winnerName;
            if (isChamp) {
                const thirdMatch = bracket.matches[`${bracket.id}-R2-M2`];
                if (matchNum === 1) thirdMatch.team1 = loserName; else thirdMatch.team2 = loserName;
            }
        } else if (roundNum === 2) { // 決勝 or 順位決定戦
            if (isChamp) {
                // `dbMatch.type` に頼らず、matchNum で判断する
                if (matchNum === 1) { // 1位決定戦 (M1)
                    tournamentState.autumnData.regions[region].finalReps.push({ team: winnerName, rank: 1 }, { team: loserName, rank: 2 });
                } else { // 3位決定戦 (M2)
                    tournamentState.autumnData.regions[region].finalReps.push({ team: winnerName, rank: 3 }, { team: loserName, rank: 4 });
                }
            } else { // 敗者復活トーナメント決勝 (5位決定戦)
                tournamentState.autumnData.regions[region].finalReps.push({ team: winnerName, rank: 5 });
            }
        }
        // ▲▲▲ 修正ロジックここまで ▲▲▲  

 } else if (tournamentState.currentTournament === 'spring' && tournamentState.springPhase === 'regional_qualifiers') {
        const [region, bracketType] = matchId.split('-');
        if (bracketType.startsWith('SB')) {
            const block = tournamentState.springData.regions[region].blocks.find(b => b.id === `${region}-${bracketType}`);
            if (matchId.includes('-R1-') || matchId.includes('-R0-')) {
                const finalMatchKey = Object.keys(block.matches).find(k => k.includes('-R2-'));
                if (finalMatchKey) {
                    const finalMatch = block.matches[finalMatchKey];
                    if (matchId.endsWith('M1')) finalMatch.team1 = winnerName; else finalMatch.team2 = winnerName;
                }
            } else {
                const repBracket = tournamentState.springData.regions[region].repechageBracket;
                repBracket.teams.push(loserName);
                if (repBracket.teams.length === 1) repBracket.matches[`${repBracket.id}-R1-M1`].team1 = loserName;
                if (repBracket.teams.length === 2) repBracket.matches[`${repBracket.id}-R1-M1`].team2 = loserName;
                if (repBracket.teams.length === 3) repBracket.matches[`${repBracket.id}-R1-M2`].team1 = loserName;
                if (repBracket.teams.length === 4) repBracket.matches[`${repBracket.id}-R1-M2`].team2 = loserName;
            }
        } else if (bracketType.startsWith('SREP')) {
            const finalMatch = tournamentState.springData.regions[region].repechageBracket.matches[`${region}-SREP-R2-M1`];
            if (matchId.endsWith('M1')) finalMatch.team1 = winnerName; if (matchId.endsWith('M2')) finalMatch.team2 = winnerName;
        } else if (bracketType.startsWith('SIZU')) {
            const izuBracket = tournamentState.springData.regions['伊豆'].izuBracket;
            const finalMatch = izuBracket.matches[`${izuBracket.id}-R2-M1`];
            if (izuBracket.teams.length === 3 && matchId.includes('-R1-')) {
                finalMatch.team1 = winnerName;
            } else if (matchId.endsWith('M1')) {
                finalMatch.team1 = winnerName;
            } else if (matchId.endsWith('M2')) {
                finalMatch.team2 = winnerName;
            }
        }
    } else { 
        if(tournamentState.teamRecords[winnerName]) tournamentState.teamRecords[winnerName].wins++;
        if(tournamentState.teamRecords[loserName]) tournamentState.teamRecords[loserName].losses++;
        const idParts = matchId.split('-');
        const side = idParts[0];
        if (side !== 'F') {
            const roundNum = parseInt(idParts[1].slice(1));
            const numTeamsInTournament = tournamentState.teams.length;
            const finalRound = Math.log2(numTeamsInTournament);
            if (roundNum < finalRound) {
                const matchNum = parseInt(idParts[2].slice(1));
                const nextRoundNum = roundNum + 1;
                let nextMatchId = (nextRoundNum === finalRound) ? 'F-R1-M1' : `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
                if (!tournamentState.matches[nextMatchId]) {
                    tournamentState.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
                }
                let slot = (nextRoundNum === finalRound) ? (side === 'L' ? 1 : 2) : (matchNum % 2 !== 0 ? 1 : 2);
                tournamentState.matches[nextMatchId][`team${slot}`] = winnerName;
            }
        } else {
            updateTournamentFinishRecords();
            if (tournamentState.currentTournament === 'summer') {
                const winnerRecord = tournamentState.teamRecords[winnerName];
                const winnerRank = calculateRank(winnerName, tournamentState);
                const koshienResultKey = simulateKoshien(winnerRank);
                const koshienResult = KOSHIEN_RESULTS[koshienResultKey];
                winnerRecord.lastFinish = koshienResult.rank;
                const newHistoryRecord = { year: tournamentState.tournamentYear, tournament: 'summer', rank: koshienResult.rank };
                winnerRecord.history.unshift(newHistoryRecord);
                if (!winnerRecord.best || newHistoryRecord.rank < winnerRecord.best.rank) {
                    winnerRecord.best = newHistoryRecord;
                }
                const article = await generateKoshienSummaryArticle(winnerName, koshienResult.label, 'summer');
                if(article) tournamentState.news.push(article);
            }
            if (tournamentState.currentTournament === 'autumn') {
                tournamentState.senbatsuTeams = [];
                const finalists = [winnerName, loserName];
                for (const teamName of finalists) {
                    if (Math.random() < 0.70) { 
                        tournamentState.senbatsuTeams.push(teamName);
                        const article = await generateKoshienSummaryArticle(teamName, 'センバツ出場決定', 'tokai');
                        if(article) tournamentState.news.push(article);
                    }
                }
            }
        }
    }
    
    // --- 5. AIコンテンツの処理と最終的な画面更新 ---
const [article, newComments] = await Promise.all([articlePromise, commentsPromise]);

if (newComments) {
    tournamentState.bbsComments.push(...newComments);
}
if (article) {
    if (!article.error) {
        article.context = matchContext;
    }
    // ★★★ ここが修正点：matchContextからハイライト情報を取り出して渡す ★★★
    const isVerified = await factCheckArticle(article, matchContext.highlights);
    
    if (isVerified) {
        showArticleReviewModal(article);
    } else {
        const errorArticle = {
            title: "記事生成エラー（事実矛盾の可能性）",
            body: "AI記者が生成した記事に、元の試合データとの矛盾が含まれている可能性があります。",
            timestamp: Date.now(),
            error: true,
            errorId: matchId, 
            context: matchContext
        };
        tournamentState.news.push(errorArticle);
    }
}
    
    if (!tournamentState.activeScandal && Math.random() < 0.1) {
        triggerScandalEvent(winnerName, loserName);
    }
    
    renderTournament(tournamentState);
    saveState();

    if (tournamentState.currentTournament === 'spring' && tournamentState.springPhase === 'main_round1') {
        const round1Matches = Object.values(tournamentState.matches).filter(m => m.id.includes('-R1-'));
        if (round1Matches.length === 8 && round1Matches.every(m => m.winner)) {
            const confirmed = await showConfirm("1回戦がすべて終了しました。シード校が登場する2回戦に進みますか？");
            if (confirmed) {
                await setupSpringMainTournament_Round2();
            }
        }
    }
}

// ▼▼▼ この関数をまるごと追加 ▼▼▼
/**
 * スキャンダルイベントを発生させる
 * @param {string} winnerName 
 * @param {string} loserName 
 */
function triggerScandalEvent(winnerName, loserName) {
    const potentialTargets = [winnerName, loserName];
    const eligibleScandals = [];

    for (const team of potentialTargets) {
        for (const scandal of SCANDAL_DEFINITIONS) {
            if (scandal.condition(team)) {
                eligibleScandals.push({ team, scandal });
            }
        }
    }

    if (eligibleScandals.length > 0) {
        const selected = eligibleScandals[Math.floor(Math.random() * eligibleScandals.length)];
        
        tournamentState.activeScandal = {
            teamName: selected.team,
            scandalId: selected.scandal.id
        };

        // ▼▼▼ この部分を修正 ▼▼▼
        const rumorArticle = {
            title: selected.scandal.rumorTitle(selected.team), // 関数として呼び出し、teamNameを渡す
            body: selected.scandal.rumorBody(selected.team),   // 関数として呼び出し、teamNameを渡す
            timestamp: Date.now(),
            isScandalRumor: true
        };
        // ▲▲▲ ここまで修正 ▲▲▲

        tournamentState.news.push(rumorArticle);
        renderNews(tournamentState.news);
        saveState();
    }
}
// ▲▲▲ ここまで追加 ▲▲▲

// --- 編集モーダル用のグローバル変数 ---
let articleForReview = null; // レビュー中の記事データを一時的に保持する

/**
 * AIが生成した記事を確認・編集するためのモーダルを表示する
 * @param {object} article - AIが生成した記事オブジェクト
 */
function showArticleReviewModal(article) {
    articleForReview = article; // 記事データを一時保存

    document.getElementById('review-title').value = article.title;
    document.getElementById('review-body').value = article.body.replace(/\\n/g, '\n');
    
    document.getElementById('review-modal').classList.remove('hidden');
}

/**
 * 編集モーダルを閉じる
 */
function closeReviewModal() {
    articleForReview = null;
    document.getElementById('review-modal').classList.add('hidden');
}

// --- 遊び方説明書モーダルのイベントリスナー ---
    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('help-modal');
    const helpModalClose = document.getElementById('help-modal-close');

    helpBtn.addEventListener('click', () => {
        helpModal.classList.remove('hidden');
    });
    helpModalClose.addEventListener('click', () => {
        helpModal.classList.add('hidden');
    }); 


// ▼▼▼ 抽選会イベント関連の関数群 ▼▼▼

const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

/**
 * 効果音を読み込む
 */
async function loadSoundEffects() {
    try {
        const drumroll = new Audio("https://actions.google.com/sounds/v1/sports/drum_roll_long.ogg");
        const cheer = new Audio("https://actions.google.com/sounds/v1/crowds/battle_crowd_cheer_med.ogg");
        const gasp = new Audio("https://actions.google.com/sounds/v1/human_sounds/gasp.ogg");
        soundEffects = { drumroll, cheer, gasp };
    } catch (e) {
        console.error("効果音の読み込みに失敗しました:", e);
    }
}

/**
 * 抽選会イベントを開始する
 */
/**
 * 抽選会イベントを開始する（BGM再生機能付き・完全版）
 */
async function startLotteryEvent() {
    const lotteryModal = document.getElementById('lottery-modal');
    lotteryModal.classList.remove('hidden');
    lotteryModal.classList.add('flex');

    // 抽選順を決める（トーナメントの組み合わせの元）
    const seeds = INITIAL_TEAM_POOL.map(teamName => ({
        name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last)
    })).sort((a, b) => a.rank - b.rank).slice(0, 8).map(t => t.name);
    
    const nonSeeds = INITIAL_TEAM_POOL.filter(t => !seeds.includes(t));
    const lotteryOrder = [...seeds, ...shuffleArray(nonSeeds)];

    // 簡易トーナメント表を作成
    const leftBracket = document.getElementById('lottery-bracket-left');
    const rightBracket = document.getElementById('lottery-bracket-right');
    leftBracket.innerHTML = '';
    rightBracket.innerHTML = '';
    for(let i=0; i<64; i++){
        const slot = document.createElement('div');
        slot.className = 'lottery-slot';
        slot.dataset.index = i;
        slot.innerHTML = `<span>${i+1}.</span> <span class="team-name-placeholder">---</span>`;
        document.getElementById(i < 32 ? 'lottery-bracket-left' : 'lottery-bracket-right').appendChild(slot);
    }

    // ボタンのイベントリスナーを設定
    document.getElementById('start-lottery-btn').onclick = () => runLotteryAnimation(lotteryOrder, seeds);
    
    document.getElementById('skip-lottery-btn').onclick = () => {
        lotteryModal.classList.add('hidden');
        SoundManager.stopBgm(); // スキップ時もBGMを停止
        createNewTournament(false, 'summer');
    };

    // BGM再生開始
    SoundManager.startBgm();
}
/**
 * 抽選会のアニメーションを実行する（強豪校の禍々しい雰囲気演出付き・完全版）
 * @param {Array<string>} lotteryOrder - シード校と、シャッフル済みのノーシード校を含む全チームの配列
 * @param {Array<string>} seeds - シード校8チームの配列
 */
/**
 * 抽選会のアニメーションを実行する（サウンドマネージャー対応の最終完成版）
 */
async function runLotteryAnimation(lotteryOrder, seeds) {
    // --- 1. 初期設定 ---
    document.getElementById('lottery-pot').onclick = null;
    document.getElementById('skip-lottery-btn').style.display = 'none';

    const commentaryEl = document.getElementById('lottery-commentary').querySelector('p');
    const drawnTeamContainer = document.getElementById('drawn-team-container');
    const drawnTeamEl = document.getElementById('drawn-team');
    const potEl = document.getElementById('lottery-pot');
    const potNameEl = document.getElementById('pot-name');
    
    const teamPositions = Array(64).fill(null);
    const seedPositionsTemplate = [0, 32, 16, 48, 8, 40, 24, 56];
    let availableSeedSlots = [...seedPositionsTemplate];
    let availableNonSeedSlots = Array.from({length: 64}, (_, i) => i).filter(p => !availableSeedSlots.includes(p));
    
    const blockDeathAnnounced = { A: false, B: false, C: false, D: false };

    // --- 内部ヘルパー関数：安全に音声を再生する ---
    const playSound = (id) => {
        const soundElement = document.getElementById(id);
        if (soundElement) {
            soundElement.currentTime = 0;
            soundElement.play().catch(e => console.warn(`Audio play failed for ${id}:`, e));
        }
    };
    
    const isStrongRank = (team) => ['S', 'A'].includes(calculateRank(team, {}));

    const checkDeathBlock = (position) => {
        const blockName = position < 16 ? 'A' : position < 32 ? 'B' : position < 48 ? 'C' : 'D';
        const startIdx = position < 16 ? 0 : position < 32 ? 16 : position < 48 ? 32 : 48;
        if (blockDeathAnnounced[blockName]) return false;
        const teamsInBlock = teamPositions.slice(startIdx, startIdx + 16);
        const strongTeamsCount = teamsInBlock.filter(team => team && isStrongRank(team)).length;
        if (strongTeamsCount >= 3) {
            commentaryEl.textContent = `これは...！ ${blockName}ブロックは有力校が集中する「死のブロック」になりました！`;
            blockDeathAnnounced[blockName] = true;
            playSound('sound-gasp');
            return true;
        }
        return false;
    };

    // --- 2. 抽選会フェーズ1：シード校の配置 ---
    potNameEl.textContent = "シード校";
    for (const teamName of seeds) {
        let dreadBg = null;
        if (isStrongRank(teamName)) {
            dreadBg = document.createElement('div');
            dreadBg.className = 'dread-mode-bg';
            document.body.appendChild(dreadBg);
            potEl.classList.add('dread');
            commentaryEl.textContent = `会場が静まり返る... 次は ${teamName} です...`;
            await sleep(2500);
        }

        commentaryEl.textContent = `${teamName}がクジを引きます...`;
        playSound('sound-drumroll');
        await sleep(1500);

        drawnTeamEl.textContent = teamName;
        drawnTeamContainer.classList.add('fade-in-out');

        const slotIndex = Math.floor(Math.random() * availableSeedSlots.length);
        const position = availableSeedSlots.splice(slotIndex, 1)[0];
        teamPositions[position] = teamName;

        await sleep(1250);

        const targetSlot = document.querySelector(`.lottery-slot[data-index="${position}"]`);
        targetSlot.querySelector('.team-name-placeholder').textContent = teamName;
        targetSlot.classList.add('filled');
        playSound('sound-cymbal');
        
        if (dreadBg) {
            dreadBg.remove();
            potEl.classList.remove('dread');
            playSound('sound-gasp');
        }
        
        const opponentIndex = position % 2 === 0 ? position + 1 : position - 1;
        if (teamPositions[opponentIndex]) {
            commentaryEl.textContent = `${teamName}の相手は${teamPositions[opponentIndex]}に決定！`;
        } else {
            commentaryEl.textContent = `${teamName}は ${position + 1}番！ 相手はまだ決まりません！`;
        }
        await sleep(1500);
        drawnTeamContainer.classList.remove('fade-in-out');
    }

    // --- 3. 抽選会フェーズ2：ノーシード校の配置 ---
    potNameEl.textContent = "ノーシード校";
    const nonSeeds = lotteryOrder.filter(t => !seeds.includes(t));
    for (const teamName of nonSeeds) {
        let dreadBg = null;
        if (isStrongRank(teamName)) {
            dreadBg = document.createElement('div');
            dreadBg.className = 'dread-mode-bg';
            document.body.appendChild(dreadBg);
            potEl.classList.add('dread');
            commentaryEl.textContent = `会場が静まり返る... 強豪 ${teamName} が登場...`;
            await sleep(2500);
        }

        commentaryEl.textContent = `${teamName}がクジを引きます...`;
        playSound('sound-drumroll');
        await sleep(250);

        drawnTeamEl.textContent = teamName;
        drawnTeamContainer.classList.add('fade-in-out');

        const slotIndex = Math.floor(Math.random() * availableNonSeedSlots.length);
        const position = availableNonSeedSlots.splice(slotIndex, 1)[0];
        teamPositions[position] = teamName;
        
        await sleep(200);

        const targetSlot = document.querySelector(`.lottery-slot[data-index="${position}"]`);
        targetSlot.querySelector('.team-name-placeholder').textContent = teamName;
        targetSlot.classList.add('filled');
        playSound('sound-cymbal');
        
        if (dreadBg) {
            dreadBg.remove();
            potEl.classList.remove('dread');
            playSound('sound-gasp');
        }
        
        commentaryEl.textContent = `${teamName}は ${position + 1}番 に決定！`;
        let didComment = checkDeathBlock(position);

        if (!didComment) {
            const opponentIndex = position % 2 === 0 ? position + 1 : position - 1;
            if(teamPositions[opponentIndex]) {
                const opponentName = teamPositions[opponentIndex];
                const isRival = RIVALRIES.some(r => r.teams.includes(teamName) && r.teams.includes(opponentName));
                if (isRival || (isStrongRank(teamName) && isStrongRank(opponentName))) {
                    commentaryEl.textContent = `決まったー！1回戦から屈指の好カード！ ${teamName} vs ${opponentName}`;
                    playSound('sound-gasp');
                    document.querySelector(`.lottery-slot[data-index="${opponentIndex}"]`).classList.add('highlight');
                    targetSlot.classList.add('highlight');
                    await sleep(1500);
                }
            }
        }
        await sleep(250);
        drawnTeamContainer.classList.remove('fade-in-out');
    }

    // --- 4. 終了処理 ---
    commentaryEl.textContent = '全ての組み合わせが決定しました！';
    await sleep(2000);
    
    await generateCaptainInterviews(teamPositions);
 // 最後に、決定した組み合わせを渡してトーナメントを生成
    document.getElementById('lottery-modal').classList.add('hidden');
    createNewTournament(false, 'summer', teamPositions); 
}

/**
 * 抽選会後の主将インタビューを生成・表示する（ランク差対応・最終版）
 * @param {Array<string>} teamPositions - 抽選会で決定した最終的なチームの組み合わせ
 */
async function generateCaptainInterviews(teamPositions) {
    const interviewModal = document.getElementById('interview-modal');
    const interviewContent = document.getElementById('interview-content');
    interviewContent.innerHTML = `<div class="loader">AI記者が主将インタビューを作成中...</div>`;
    interviewModal.classList.remove('hidden');

    const matchups = [];
    for(let i=0; i<64; i+=2){
        matchups.push({team1: teamPositions[i], team2: teamPositions[i+1]});
    }

    // 注目カードを3つに増やす
    const notableMatchups = shuffleArray(matchups).slice(0, 3);

    // ▼▼▼ ここからが新しい処理 ▼▼▼
    const matchupsWithRanks = notableMatchups.map(m => ({
        team1: m.team1,
        rank1: calculateRank(m.team1, tournamentState),
        team2: m.team2,
        rank2: calculateRank(m.team2, tournamentState)
    }));
    const promptDataText = matchupsWithRanks.map(m => 
        `- ${m.team1} (ランク: ${m.rank1}) vs ${m.team2} (ランク: ${m.rank2})`
    ).join('\n');
    // ▲▲▲

    const prompt = `あなたは高校野球専門のAI記者です。夏の大会の組み合わせ抽選会が終了しました。
以下の注目カードについて、両チームの主将になりきって、抽選結果に対するリアルな反応を語ってください。

### 注目カードと各チームのランク
${promptDataText}

### あなたがなりきる「高校生の主将」の思考パターン
- **格下の相手と当たった場合 (例: Aランク vs Dランク):**
  - 少し安堵した様子を見せる。「正直、ホッとした」「自分たちの野球をすれば負けない」
  - しかし油断は禁物だと付け加える。「どのチームも強いので、一戦必勝で戦いたい」
- **格上の相手と当たった場合 (例: Eランク vs Aランク):**
  - 明らかに絶望したり、驚いたりする。「まさか初戦で当たるとは…」「正直、厳しい相手」
  - しかし、挑戦者として「胸を借りるつもりで全力でぶつかりたい」「一矢報いたい」と闘志も見せる。
- **実力が拮抗している相手と当たった場合 (例: Cランク vs Cランク):**
  - 「ここが最初の山場になる」「厳しい戦いになることは覚悟している」と、相手への敬意を示す。
  - 「最高の試合をしたい」と、ライバルとの対戦を心待ちにしている様子を見せる。

### 指示
- 上記の思考パターンに基づき、各カードの両主将のコメントを生成してください。
- チームの背景（例：王者、古豪）も少しだけコメントに反映させてください。

### 出力形式 (JSON配列)
[
    {"team": "〇〇高校", "captain_comment": "（主将のコメント）"},
    {"team": "△△高校", "captain_comment": "（主将のコメント）"}
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        const interviews = parseJsonFromText(result.candidates[0].content.parts[0].text);

        if (interviews && Array.isArray(interviews)) {
            interviewContent.innerHTML = interviews.map(iv => `
                <div class.p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-bold text-lg text-gray-800">${iv.team} 主将</h4>
                    <p class="mt-1 text-gray-700">「${iv.captain_comment}」</p>
                </div>
            `).join('');
        } else {
            throw new Error("Parsed JSON is not an array or is null.");
        }
    } catch (e) {
        interviewContent.innerHTML = `<p class="text-center text-red-600">インタビューの生成に失敗しました。</p>`;
        console.error(e);
    }
    
    document.getElementById('close-interview-btn').onclick = () => {
        interviewModal.classList.add('hidden');
        document.getElementById('lottery-modal').classList.add('hidden');
        SoundManager.stopBgm();
        createNewTournament(false, 'summer', teamPositions);
    };
}
     
    async function initializeApp() {
  SoundManager.init(); 
 // --- 1. Preload the background image ---
    const bgContainer = document.querySelector('.ballpark-background');
    if (bgContainer) {
        const img = new Image();
        const imageUrl = 'ballpark.jpg'; // The local image path
        
        img.onload = function() {
            // Image loaded successfully, set it as the background and start the dust effect
            bgContainer.style.backgroundImage = `url(${imageUrl})`;
            createDustEffect();
        };
        img.onerror = function() {
            // If the image fails to load, log an error but still start the dust effect
            console.error('Failed to load the background image.');
            createDustEffect();
        };
        
        img.src = imageUrl; // This starts the image download
    } else {
        // If the background container doesn't exist, just start the dust effect
        createDustEffect();
    }
       
 // --- ここから診断コード ---
        try {
            alert('デバッグ開始：initializeApp関数が実行されました。');
            
            if (teamsTextarea) {
                alert('成功：チーム一覧を表示するテキストエリアが見つかりました。');
            } else {
                alert('エラー：チーム一覧を表示するテキストエリアが見つかりません！ id="teams-list" を確認してください。');
                return;
            }

            if (INITIAL_TEAM_POOL && INITIAL_TEAM_POOL.length > 0) {
                alert(`成功：${INITIAL_TEAM_POOL.length}件のチームデータが読み込まれました。`);
            } else {
                alert('エラー：チームデータが読み込めていません！ TEAM_DATAの定義を確認してください。');
                return;
            }

            teamsTextarea.value = INITIAL_TEAM_POOL.join('\n');
            alert('成功：チーム一覧をテキストエリアに表示しました。');

        } catch (e) {
            alert('致命的なエラーが発生しました： ' + e.message);
        }

        // --- ここまで診断コード ---

        
    const savedStateJSON = localStorage.getItem('tournamentState');
    if (savedStateJSON) {
        try {
            const lastState = JSON.parse(savedStateJSON);
            if (lastState && lastState.tournamentYear) {
                const confirmed = await showConfirm("前回の続きから再開しますか？\n（「いいえ」で最初から、または「合い言葉」で再開）");
                
                if (confirmed) { // 「はい」が押された場合
                    tournamentState = lastState;
                    setupEl.classList.add('hidden');
                    tournamentDisplayEl.classList.remove('hidden');
                    renderTournament(tournamentState);
                    return; 
                } else { // ▼▼▼ 「いいえ」が押された場合の処理を追加 ▼▼▼
                    // 古いセーブデータを完全に消去する
                    localStorage.removeItem('tournamentState');
                }
            }
        } catch (e) {
            console.error("保存されたデータの読み込みに失敗:", e);
            localStorage.removeItem('tournamentState'); 
        }
    }        
        setupEl.classList.remove('hidden');
        tournamentDisplayEl.classList.add('hidden');
　　　　teamsTextarea.value = INITIAL_TEAM_POOL.join('\n');

 updateTicker();
}

    // --- Event Listeners ---
    
    generateBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("新しいトーナメントを開始すると、現在の進行状況は失われます。よろしいですか？");
    if (confirmed) startLotteryEvent();
});
    resumeBtn.addEventListener('click', () => {
        saveLoadModal.classList.remove('hidden');
        loadTabBtn.click();
    });

    nextTournamentBtn.addEventListener('click', async () => {
        const confirmed = await showConfirm("現在の大会を終了し、次の大会へ進みますか？");
        if(confirmed) {
            let nextTournamentType;
            if (tournamentState.currentTournament === 'summer') nextTournamentType = 'autumn';
            else if (tournamentState.currentTournament === 'autumn') nextTournamentType = 'spring';
            else nextTournamentType = 'summer';
            createNewTournament(true, nextTournamentType);
        }
    });

    resetBtn.addEventListener('click', async () => {
        const confirmed = await showConfirm("すべての大会記録をリセットして、最初の状態に戻しますか？");
        if(confirmed){
            localStorage.clear();
            location.reload();
        }
    });

    saveBtn.addEventListener('click', () => {
        document.getElementById('save-code-area').classList.add('hidden');
        saveLoadModal.classList.remove('hidden');
        saveTabBtn.click();
    });
    
    startRankingPlayoffsBtn.addEventListener('click', async () => {
         const confirmed = await showConfirm("全ブロックの予選が終了しました。地区内順位決定戦に進みますか？");
         if(confirmed) setupAutumnRankingTournaments();
    });
    
    // startMainTournamentBtn のイベントリスナー内

startMainTournamentBtn.addEventListener('click', async () => {
    // ★★★ 春季大会用の分岐を追加 ★★★
    if (tournamentState.currentTournament === 'spring') {
        const confirmed = await showConfirm("全代表校が決定しました。県大会本戦に進みますか？");
        if (confirmed) setupSpringMainTournament_Round1();
    } 
    // ★★★ ここまで追加 ★★★
    else { // 秋季大会の既存ロジック
        const confirmed = await showConfirm("全代表校が決定しました。県大会本戦に進みますか？");
        if (confirmed) setupAutumnMainTournament();
    }
});

    skipR1Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("1回戦を自動で進行しますか？");
        if (confirmed) skipRound(1);
    });
    skipR2Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("2回戦を自動で進行しますか？");
        if (confirmed) skipRound(2);
    });
    skipR3Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("3回戦を自動で進行しますか？");
        if (confirmed) skipRound(3);
    });

skipR4Btn.addEventListener('click', async () => {
    const confirmed = await showConfirm("準々決勝を自動で進行しますか？");
    if (confirmed) skipRound(4);
});

skipR5Btn.addEventListener('click', async () => {
    const confirmed = await showConfirm("準決勝を自動で進行しますか？");
    if (confirmed) skipRound(5);
});

skipFinalBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("決勝戦を自動で進行しますか？");
    if (confirmed) skipFinal();
});
skipAutumnBlocksBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("秋季地区ブロック予選をすべて自動で進行しますか？");
    if (confirmed) skipAutumnRegionalBlocks();
});

skipAutumnRankingBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("秋季地区の第5代表決定戦をすべて自動で進行しますか？");
    if (confirmed) skipAutumnRankingTournaments();
});

skipAutumnMainBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("秋季県大会本戦をすべて自動で進行しますか？");
    if (confirmed) skipAutumnMainTournament();
});
    
skipSpringQualifiersBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("春季地区予選をすべて自動で進行しますか？");
    if (confirmed) skipSpringQualifiers();
});

skipSpringRound1Btn.addEventListener('click', async () => {
    const confirmed = await showConfirm("春季県大会1回戦を自動で進行しますか？");
    if (confirmed) skipSpringMainRound1();
});

skipSpringMainBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("春季県大会2回戦以降をすべて自動で進行しますか？");
    if (confirmed) skipSpringMainTournament();
});

    generateSummaryBtn.addEventListener('click', async () => {
        generateSummaryBtn.disabled = true;
        generateSummaryBtn.textContent = '記事を生成中...';
        newsContainer.innerHTML = `<div class="loader">AI記者がハイライト記事を執筆中...</div>`;
        const summaryArticle = await generateBest8PreviewArticle();
        if (summaryArticle) {
            tournamentState.news.push(summaryArticle);
            saveState();
            renderNews(tournamentState.news);
        }
        generateSummaryBtn.classList.add('hidden');
        generateSummaryBtn.disabled = false;
        generateSummaryBtn.textContent = 'ベスト8ハイライト記事を生成';
    });

document.body.addEventListener('click', async (e) => {




    // --- 試合進行ボタン (▶) ---
    if (e.target.matches('.win-btn')) {
        const teamSlot = e.target.closest('.team-slot');
        const matchEl = e.target.closest('[data-match-id]');
        if (!teamSlot || !matchEl || teamSlot.classList.contains('empty')) return;

        const matchId = matchEl.dataset.matchId;
        const winnerName = teamSlot.dataset.teamName;
        if (!winnerName) return;

        const score1El = matchEl.querySelector('[data-team-pos="1"]');
        const score2El = matchEl.querySelector('[data-team-pos="2"]');

        if(!score1El || !score2El || score1El.value === '' || score2El.value === '') {
            showAlert('スコアを入力してください。');
            return;
        }

        let dbMatch = findMatchById(matchId);
        if (dbMatch) {
            dbMatch.score1 = score1El.value;
            dbMatch.score2 = score2El.value;
            dbMatch.summary = matchEl.querySelector('.match-summary-input')?.value || '';
        }

        await processMatchWin(matchId, winnerName);
    }

// --- 「勢力図をアニメーションで見る」ボタン（モーダルを開く） ---
    else if (e.target.matches('.view-analysis-btn')) {
        document.getElementById('analysis-modal').classList.remove('hidden');
        currentBlock = 'A'; // 初期表示はAブロック
        playBlockAnimation(currentBlock);
    }
    // --- 【新しく追加】勢力図モーダル内のタブボタン ---
    else if (e.target.matches('.analysis-block-tab-btn')) {
        const blockId = e.target.dataset.block;
        if (blockId && blockId !== currentBlock) {
            currentBlock = blockId;
            playBlockAnimation(currentBlock);
        }
    }
    // --- 勢力図モーダルを閉じるボタン ---
    else if (e.target.matches('#analysis-modal-close-btn')) {
        document.getElementById('analysis-modal').classList.add('hidden');
    }
    // --- 試合詳細入力ボタン ---
    else if (e.target.matches('.details-btn')) {
        openDetailsModal(e.target.dataset.matchId);
    }

    // --- 【詳細モーダル内】イニング追加ボタン ---
    else if (e.target.matches('.add-inning-btn') || e.target.matches('#add-inning-score-btn')) {
        e.preventDefault();
        addExtraInning();
    }
    
    // --- 天候ボタン ---
    else if (e.target.matches('.weather-btn')) {
        const weatherType = e.target.dataset.weather;
        setWeather(weatherType);
    }


   // document.body.addEventListener('click', ...) 内の、まとめサイト関連の if ブロックを全てこれで置き換える

    // ▼▼▼ このブロックで、統合型まとめサイト関連の処理を全て書き換える ▼▼▼

    // --- 「まとめサイトを見る」ボタン ---
    const showMatomeBtn = e.target.closest('#show-matome-site-btn');
    if (showMatomeBtn) {
        const modal = document.getElementById('integrated-matome-modal');
        const articlesContainer = document.getElementById('matome-articles-container');
        modal.classList.remove('hidden');
        
        // ローダーを表示し、最新記事を読み込む
        articlesContainer.innerHTML = `<div class="loader text-center py-8">記事を読み込んでいます...</div>`;
        
        // 初期表示は「トップ」タブ
        document.querySelectorAll('.matome-tab-content').forEach(tab => tab.classList.add('hidden'));
        document.getElementById('matome-tab-top').classList.remove('hidden');
        document.querySelectorAll('.matome-tab-btn').forEach(btn => btn.classList.remove('active', 'bg-blue-600', 'text-white'));
        document.querySelector('.matome-tab-btn[data-tab="top"]').classList.add('active', 'bg-blue-600', 'text-white');

        (async () => {
            const matomeHtml = await generateMatomeSiteHtml();
            articlesContainer.innerHTML = matomeHtml;
        })();
    }

 // --- 設定モーダルを開く/閉じる ---
    if (e.target.closest('#open-settings-btn')) {
        // 現在の設定をモーダルに反映
        document.getElementById('toggle-article-generation').checked = tournamentState.settings.enableArticleGeneration;
        document.getElementById('toggle-bbs-generation').checked = tournamentState.settings.enableBbsGeneration;
        document.getElementById('settings-modal').classList.remove('hidden');
    }
    if (e.target.closest('#settings-modal-close-btn')) {
        document.getElementById('settings-modal').classList.add('hidden');
    }


    // --- 統合型まとめサイトモーダルを閉じるボタン ---
    if (e.target.closest('#matome-modal-close-btn')) {
        document.getElementById('integrated-matome-modal').classList.add('hidden');
        // BBSスレッド表示エリアも隠す
        document.getElementById('bbs-thread-display-area').classList.add('hidden');
    }

    // --- まとめサイト内のタブ切り替え ---
    const tabBtn = e.target.closest('.matome-tab-btn');
    if (tabBtn) {
        document.querySelectorAll('.matome-tab-btn').forEach(btn => {
            btn.classList.remove('active', 'bg-blue-600', 'text-white', 'hover:bg-blue-700');
            btn.classList.add('text-gray-700', 'hover:bg-gray-100');
        });
        tabBtn.classList.add('active', 'bg-blue-600', 'text-white');
        tabBtn.classList.remove('text-gray-700', 'hover:bg-gray-100');

        const tabId = tabBtn.dataset.tab;
        document.querySelectorAll('.matome-tab-content').forEach(content => {
            content.classList.add('hidden');
        });
        document.getElementById(`matome-tab-${tabId}`).classList.remove('hidden');

        // タブ切り替え時にBBSスレッド表示エリアは隠す
        document.getElementById('bbs-thread-display-area').classList.add('hidden');

        // 「トップ」タブに戻ったら記事を再読み込み (必要に応じて)
        if (tabId === 'top') {
            const articlesContainer = document.getElementById('matome-articles-container');
            articlesContainer.innerHTML = `<div class="loader text-center py-8">記事を読み込んでいます...</div>`;
            (async () => {
                const matomeHtml = await generateMatomeSiteHtml();
                articlesContainer.innerHTML = matomeHtml;
            })();
        }
    }
    
    // --- まとめサイト内の記事リンククリック ---
    // --- まとめサイト内の記事リンククリック ---
    const matomeLink = e.target.closest('.matome-article-link');
    if (matomeLink) {
        e.preventDefault();
        const headline = matomeLink.dataset.headline;
        const type = matomeLink.dataset.type;
        const category = matomeLink.dataset.category;
        const matchId = matomeLink.dataset.matchId;

        const threadDisplayArea = document.getElementById('bbs-thread-display-area');
        const threadTitleEl = document.getElementById('bbs-thread-title');
        const threadContentEl = document.getElementById('bbs-thread-content');
        
        document.querySelectorAll('.matome-tab-content').forEach(content => content.classList.add('hidden'));
        threadDisplayArea.classList.remove('hidden');

        threadTitleEl.textContent = headline;
        threadContentEl.innerHTML = `<div class="loader text-center py-8">AIが掲示板の反応を生成中...</div>`;
        
        (async () => {
            let result;
            if (type === 'game' && matchId) {
                const match = findMatchById(matchId);
                // 詳細データがある場合のみ、高度な分析を行う
                if (match && match.winner && match.details) { 
    const playerStatsText = formatPlayerStatsForPrompt(match);
    const playByPlayText = generatePlayByPlayText(match);
    const winnerJourney = getCurrentTournamentPerformance(match.winner, matchId);
    const nextOpponentInfo = findNextOpponent(match.winner, matchId);
    
    // ★ここからが変更点★
    // 勝者と敗者、両チームのスタメン変更を分析
    const loserName = match.team1 === match.winner ? match.team2 : match.team1;
    const winnerLineupChanges = analyzeLineupChanges(match.winner, match);
    const loserLineupChanges = analyzeLineupChanges(loserName, match);
    // ★変更点はここまで★
                    let nextOpponentJourney = null;
                    if (nextOpponentInfo && nextOpponentInfo.opponentName && !['（未定）', '優勝'].includes(nextOpponentInfo.opponentName)) {
                        nextOpponentJourney = getCurrentTournamentPerformance(nextOpponentInfo.opponentName, matchId);
                    }
                    const context = {
                        winnerName: match.winner,
                        loserName: match.team1 === match.winner ? match.team2 : match.team1,
                        dbMatch: match,
                        playerStatsText: playerStatsText,
                        playByPlayText: playByPlayText, // ★試合経過をコンテキストに追加
                        winnerJourney: winnerJourney,
                        nextOpponent: nextOpponentInfo,
                        nextOpponentJourney: nextOpponentJourney,
        // ★分析結果をコンテキストに追加★
        winnerLineupChanges: winnerLineupChanges,
        loserLineupChanges: loserLineupChanges
                    };
                    result = await generateGameMatchBbsComments(context);
                } else if (match && match.winner) {
                    // 詳細データがない場合は、シンプルなコンテキストで呼び出す
                    const context = { winnerName: match.winner, loserName: match.team1 === match.winner ? match.team2 : match.team1, dbMatch: match };
                    result = await generateGameMatchBbsComments(context);
                }
    
                   // ★変更点はここまで★
                
            } else if (type === 'real') {
                // 【現実のニュースの場合】
                // index.html内に新設した generateRealNewsBbsComments 関数を直接呼び出す
                const comments = await generateRealNewsBbsComments(headline, category);
                if (comments) {
                    result = { title: headline, comments: comments };
                }
            }
            // ▲▲▲ ここまで修正 ▲▲▲

            // --- 結果の描画処理 (変更なし) ---
            if (result && result.comments) {
                threadTitleEl.textContent = `【スレ】${result.title}`;
                threadContentEl.innerHTML = ''; // ローダーを消す

                                // --- ここからが「ライブ感」演出 ---
                for (const comment of result.comments) {
                    const commentEl = document.createElement('div');
                    commentEl.className = 'bbs-comment opacity-0 transition-opacity duration-500'; // 最初は透明
                    commentEl.innerHTML = `
                        <p class="font-semibold text-gray-700 text-sm">${comment.personality}</p>
                        <p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>
                    `;
                    threadContentEl.appendChild(commentEl);
                    
                    // 少し遅れてフワッと表示させる
                    setTimeout(() => {
                        commentEl.classList.remove('opacity-0');
                    }, 50);

                    // 次のコメントが表示されるまで、ランダムな時間待つ
                    const delay = Math.random() * 800 + 200; // 0.2秒から1.0秒
                    await new Promise(resolve => setTimeout(resolve, delay));
                    
                    // 自動で一番下までスクロール
                    threadContentEl.scrollTop = threadContentEl.scrollHeight;
                }
                // --- 演出ここまで ---

            } else {
                threadContentEl.innerHTML = `<p class="text-center text-red-500">スレッドの生成に失敗しました。</p>`;
            }
        })();
        // ▲▲▲ ここまで書き換え ▲▲▲
    }


    // --- BBSスレッドから一覧に戻るボタン ---
    if (e.target.closest('#bbs-thread-back-btn')) {
        document.getElementById('bbs-thread-display-area').classList.add('hidden');
        document.getElementById('matome-tab-top').classList.remove('hidden'); // トップタブに戻る
    }
    // ▲▲▲ ここまで置き換え ▲▲▲ 
   
 // --- スキャンダル告発/無視ボタン ---
  // document.body.addEventListener('click', ...) 内のスキャンダルボタンの処理を置き換え

    // --- スキャンダル告発/無視ボタン ---
    const scandalBtn = e.target.closest('.report-scandal-btn, .ignore-scandal-btn');
    if (scandalBtn && tournamentState.activeScandal) {
        const { teamName, scandalId } = tournamentState.activeScandal;
        const scandalDef = SCANDAL_DEFINITIONS.find(s => s.id === scandalId);
        if (!scandalDef) return;

        const choice = scandalBtn.classList.contains('report-scandal-btn') ? 'report' : 'ignore';
        const consequence = scandalDef.consequences[choice];

        // 効果を適用
        consequence.applyEffect(teamName, tournamentState);

        // 結果記事を生成
        const outcomeArticle = {
            title: consequence.outcomeTitle(teamName),
            body: consequence.outcomeBody(teamName),
            timestamp: Date.now()
        };
        
        // 噂記事をニュースリストから削除し、結果記事を追加
        tournamentState.news = tournamentState.news.filter(n => !n.isScandalRumor);
        tournamentState.news.push(outcomeArticle);
        
        // スキャンダルを解決済みにする
        tournamentState.activeScandal = null;

        renderTournament(tournamentState); // トーナメント表とニュースを再描画
        saveState();
    }
// --- ドキュメンタリー密着取材ボタン ---
    // --- ドキュメンタリー密着取材ボタン（逆境） ---
    else if (e.target.matches('.underdog-doc-btn')) { // ← クラス名を変更
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？...`);
        if (confirmed) {
            startDocumentary('underdog', teamName); // ← type を渡すように変更
        }
    }

    // ▼▼▼ ここから追加 ▼▼▼
    // --- ドキュメンタリー密着取材ボタン（強豪） ---
    else if (e.target.matches('.powerhouse-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) {
            startDocumentary('powerhouse', teamName);
        }
    }

// ▼▼▼ ここから追加 ▼▼▼
    // --- ドキュメンタリー密着取材ボタン（古豪復活） ---
    else if (e.target.matches('.powerhouse-revival-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) {
            startDocumentary('powerhouse_revival', teamName);
        }
    }

 else if (e.target.matches('.one-man-team-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) {
            startDocumentary('one_man_team', teamName);
        }
    }

    // --- 「＋ 走者プレーを追加」ボタン ---
    else if (e.target.matches('.add-runner-play-btn')) {
        e.preventDefault();
        const container = e.target.closest('.at-bat-block').querySelector('.runner-plays-container');
        if (!container) return;

        if (container.children.length >= 3) {
            alert('一度に追加できる走者プレーは3つまでです。');
            return;
        }

        const table = e.target.closest('.batting-table');
        const playersOnField = Array.from(table.querySelectorAll('.player-name')).map(input => ({name: input.value.trim()})).filter(p => p.name);
        const nameOptions = playersOnField.map(p => `<option value="${p.name}">${p.name}</option>`).join('');

        const baserunningPlays = ['盗塁', '盗塁死', 'タッチアップ', '進塁', '生還', '走塁死', '牽制死', '挟殺プレーでアウト'];
        const bases = ['一塁へ', '二塁へ', '三塁へ', '本塁へ(生還)'];
        const playOptions = baserunningPlays.map(p => `<option value="${p}">${p}</option>`).join('');
        const baseOptions = bases.map(b => `<option value="${b}">${b}</option>`).join('');

        const newPlayHTML = `
            <div class="runner-play-input flex gap-1 items-center mt-1">
                <select class="runner-name w-1/3 text-xs p-1 border rounded"><option value="">-誰が-</option>${nameOptions}</select>
                <select class="runner-play w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-何をした-</option>${playOptions}</select>
                <select class="runner-base w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-どこへ-</option>${baseOptions}</select>
                <button class="remove-runner-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </div>
        `;
        container.insertAdjacentHTML('beforeend', newPlayHTML);
    }
    
    // --- 走者プレーの「×」削除ボタン ---
    else if (e.target.matches('.remove-runner-play-btn')) {
        e.target.closest('.runner-play-input').remove();
    }

    // --- おまかせ入力ボタン ---
    else if (e.target.matches('.quick-sim-btn')) {
        e.preventDefault();
        autoFillMatchDetails(e.target.dataset.matchId);
    }

    // --- 1イニングに複数打席を追加するボタン ---
    else if (e.target.matches('.add-at-bat-btn')) {
        e.preventDefault();
        const table = e.target.closest('.batting-table');
        const playersOnField = Array.from(table.querySelectorAll('.player-name')).map(input => ({ name: input.value.trim() })).filter(p => p.name);
        
        // 新しい空の打席ブロック（打者入力欄＋走者入力欄の正しいセット）を生成
        const newAtBatHTML = createBattingResultDropdowns(playersOnField, '');
        
        // クリックされたボタンの直前に、新しいブロックを挿入
        e.target.insertAdjacentHTML('beforebegin', newAtBatHTML);
    }

    // --- 交代選手追加ボタン ---
    else if (e.target.matches('.add-substitute-btn')) {
        e.preventDefault();
        const teamKey = e.target.dataset.teamKey;
        const tableBody = document.getElementById(`batting-table-${teamKey}`).querySelector('tbody');
        if (!tableBody) return;

        const orderInput = prompt("何番打者の交代選手を追加しますか？（例：3）");
        if (!orderInput || isNaN(orderInput) || orderInput < 1 || orderInput > 9) {
            alert("1から9の正しい打順を入力してください。");
            return;
        }
        const order = parseInt(orderInput);

        const allOrderRows = Array.from(tableBody.querySelectorAll(`tr[data-order^="${order}"]`));
        if (allOrderRows.length === 0) {
            alert(order + '番打者が見つかりません。');
            return;
        }
        const targetRow = allOrderRows[allOrderRows.length - 1];

        const newRow = document.createElement('tr');
        const subCount = allOrderRows.filter(row => row.dataset.order.includes('sub')).length + 1;
        newRow.dataset.order = `${order}-sub-${subCount}`;
        
        const numInnings = tableBody.parentElement.querySelector('thead tr').children.length - 6;
        let resultInputs = '';
        for (let j = 0; j < numInnings; j++) {
            resultInputs += `<td class="col-inning batting-result-cell align-top p-1">
                                ${createBattingResultDropdowns('')}
                                ${createRunnerInputsHTML([], '')}
                             </td>`;
        }
        
        newRow.innerHTML = `
            <td class="col-order"></td>
            <td><select class="player-number w-full bg-transparent"><option value=""></option>${Array.from({length:20},(_,i)=>`<option value="${i+1}">${i+1}</option>`).join('')}</select></td>
            <td class="pl-4"><input type="text" class="player-name" placeholder="交代選手名"></td>
            <td><select class="player-pos w-full bg-transparent"><option value=""></option>${['投', '捕', '一', '二', '三', '遊', '左', '中', '右'].map(p=>`<option value="${p}">${p}</option>`).join('')}</select></td>
            <td>
                <select class="sub-type-select w-full bg-transparent">
                    <option value="" selected>-</option><option value="PH">代打</option><option value="PR">代走</option>
                    <option value="DEF">守備</option><option value="PITCHER">投手</option>
                </select>
            </td>
            ${resultInputs}
        `;
        targetRow.parentNode.insertBefore(newRow, targetRow.nextSibling);
    }

    // --- 守備変更ボタン ---
    else if (e.target.matches('.pos-change-btn')) {
        const playerName = e.target.dataset.playerName;
        const teamKey = e.target.dataset.teamKey;
        const inning = prompt(`${playerName}選手が何回からポジションを変更しましたか？`);
        if (!inning || isNaN(inning)) return;
        const newPos = prompt(`${inning}回から、${playerName}選手の守備位置はどこになりましたか？ (例: 投, 一, 中)`);
        if (!newPos) return;

        const match = findMatchById(currentMatchIdForDetails);
        if (match) {
            if (!match.details) match.details = {};
            if (!match.details.positionChanges) match.details.positionChanges = [];
            match.details.positionChanges.push({ inning: parseInt(inning), teamKey, playerName, newPos });
            alert(`${inning}回から${playerName}選手が${newPos}を守るように記録しました。`);
        }
    }

    // --- 投手追加ボタン ---
    else if (e.target.matches('.add-row-btn')) {
        e.preventDefault();
        const tableId = e.target.dataset.tableId;
        const table = document.getElementById(tableId).querySelector('tbody');
        const newRow = table.insertRow();
        newRow.innerHTML = `
            <td><select><option value="" selected>-</option><option value="W">○</option><option value="L">●</option><option value="S">S</option><option value="H">H</option></select></td>
            <td><input type="text" value=""></td><td><input type="text" value=""></td><td><input type="number" value=""></td>
            <td><input type="number" value=""></td><td><input type="number" value=""></td><td><input type="number" value=""></td>
            <td><input type="number" value=""></td><td><input type="number" value=""></td><td><input type="number" value=""></td>
        `;
    }

    // --- 先攻後攻入れ替えボタン ---
    else if (e.target.matches('#swap-teams-btn')) {
        swapTeamDetails(e.target.dataset.matchId);
    }

    // --- チーム名クリック（ステータス表示） ---
    else if (e.target.matches('.clickable-team-name')) {
        const teamName = e.target.dataset.teamName;
        if(teamName && teamName !== 'null' && teamName !== '') {
            showTeamStatusModal(teamName);
        }
    }
    // --- 記事表示ボタン（通常記事の「本文」） ---
    else if (e.target.matches('.news-article-btn')) {
        const article = tournamentState.news[parseInt(e.target.dataset.index, 10)];
        if (article && article.body) {
            document.getElementById('modal-title').textContent = article.title;
            document.getElementById('modal-body').textContent = article.body;
            document.getElementById('modal-meta').innerHTML = `<p>${new Date(article.timestamp).toLocaleDateString('ja-JP')}</p>`;
            newsModal.classList.remove('hidden');
            newsModal.classList.add('flex');
        } else {
            alert('記事の本文データを取得できませんでした。');
        }
    }

    // --- 記事表示ボタン（新聞の「新聞を読む」） ---
    else if (e.target.matches('.newspaper-view-btn')) {
        const article = tournamentState.news[parseInt(e.target.dataset.index, 10)];
        if (article.isNewspaper && article.newspaperData) {
            renderNewspaperModal(article.newspaperData);
            newspaperModal.classList.remove('hidden');
        }
    }

 // ▼▼▼ 抜け落ちていたのは、このブロックです ▼▼▼
    // --- 掲示板の「返信する」ボタン ---
    const replyBtn = e.target.closest('.reply-btn');
    if (replyBtn) {
        e.preventDefault();
        const commentId = replyBtn.dataset.commentId;
        const formContainer = document.getElementById(`reply-form-container-${commentId}`);
        if (formContainer) {
            formContainer.classList.toggle('hidden');
        }
        return;
    }
    // ▲▲▲ ▲▲▲

// document.body.addEventListener('click', ...) の中

    
    // document.body.addEventListener('click', ...) 内の該当箇所を、以下のように修正・追記

    // ▼▼▼ 既存の「.retry-btn」の else if ブロックを、以下の内容にまるごと置き換える ▼▼▼
    // --- AI記事の再生成ボタン（エラー記事・成功記事の両方に対応） ---
    // --- AI記事の再生成ボタン（成功した記事用） ---
     // --- AI記事の再生成ボタン（成功・失敗記事の両方に対応） ---
    const regenerateBtn = e.target.closest('.regenerate-btn, .retry-btn');
    if (regenerateBtn) {
        const articleIndex = parseInt(regenerateBtn.dataset.index, 10);
        const originalArticle = tournamentState.news[articleIndex];
        if (!originalArticle || !originalArticle.context) {
            alert("この記事は再生成できません。");
            return;
        }
        articleForRegeneration = { index: articleIndex, article: originalArticle };
        document.getElementById('feedback-include').value = '';
        document.getElementById('feedback-exclude').value = '';
        document.getElementById('feedback-modal').classList.remove('hidden');
    }
    
    // --- フィードバックモーダルからの再生成実行ボタン ---
    // ▼▼▼ このブロックで、既存の該当箇所を置き換えてください ▼▼▼

    // --- フィードバックモーダルからの再生成実行ボタン ---
    // --- フィードバックモーダルからの再生成実行ボタン ---
    const feedbackSubmitBtn = e.target.closest('#feedback-submit-btn');
    if (feedbackSubmitBtn) {
        if (!articleForRegeneration) return;
        const { index, article } = articleForRegeneration;
        const context = article.context;
        
        // UIを準備
        feedbackSubmitBtn.textContent = '生成中...';
        feedbackSubmitBtn.disabled = true;
        const userFeedback = {
            include: document.getElementById('feedback-include').value,
            exclude: document.getElementById('feedback-exclude').value
        };
        document.getElementById('feedback-modal').classList.add('hidden');
        articleForRegeneration = null;
        tournamentState.news.splice(index, 1);
        renderNews(tournamentState.news);
        newsContainer.innerHTML = `<div class="loader">AI記者があなたの指示を基に記事を再執筆中です...</div>`;
        
        // 非同期でAIの再生成処理を開始
        (async () => {
            let articlePromise;
            
            // ★★★ ここからが修正箇所 ★★★
            // 再生成する記事がドキュメンタリーかどうかを context の中身で判断する
            if (context.isDocumentary) {
                // 【ドキュメンタリー記事の場合】
                // context から必要な情報を取り出し、専用の関数を呼び出す
                const { type, teamName, matchData } = context;
                articlePromise = generateDocumentaryArticle('intro', type, teamName, matchData, userFeedback);
            
            } else {
                // 【通常の試合記事の場合】
                articlePromise = generateNewsArticle(context, userFeedback);
            }
            // ★★★ 修正箇所はここまで ★★★

            const newArticle = await articlePromise;
            
            // (以降の createErrorArticle や UI更新処理は、ご提示のコードのままで問題ありません)
            const createErrorArticle = () => ({
                title: "記事生成エラー", body: "記事の再生成に失敗しました。",
                timestamp: Date.now(), error: true, errorId: context.matchId || 'error', 
                context: context
            });

            if (newArticle && !newArticle.error) {
                newArticle.context = context;
                const isVerified = context.isDocumentary ? true : await factCheckArticle(newArticle, createHighlightsText(context.dbMatch, context.winnerName).highlights);

                if (isVerified) {
                    tournamentState.news.splice(index, 0, newArticle);
                    showArticleReviewModal(newArticle);
                } else {
                    tournamentState.news.splice(index, 0, createErrorArticle());
                }
            } else {
                tournamentState.news.splice(index, 0, createErrorArticle());
            }
            
            saveState();
            renderNews(tournamentState.news);
            feedbackSubmitBtn.textContent = 'この指示で再生成';
            feedbackSubmitBtn.disabled = false;
        })();
    }    
// ▲▲▲ ここまで置き換え ▲▲▲
    // --- フィードバックモーダルの「キャンセル」ボタン ---
    if (e.target.matches('#feedback-cancel-btn')) {
        document.getElementById('feedback-modal').classList.add('hidden');
        articleForRegeneration = null;
    }
    // ▲▲▲ ここまで追加 ▲▲▲    // ▲▲▲ ここまで追加 ▲▲▲

// ▼▼▼ ADD THE NEW BLOCK HERE ▼▼▼
    // --- BBS Comment Retry Button ---
    else if (e.target.matches('.retry-bbs-btn')) {
        const btn = e.target;
        const index = parseInt(btn.dataset.index, 10);
        const errorComment = tournamentState.bbsComments[index];
        if (!errorComment || !errorComment.context) return;

        btn.textContent = '生成中...';
        btn.disabled = true;

        const { winnerName, loserName, dbMatch, matchId, winnerData, loserData, winnerDetailedData, loserDetailedData, highlightsText } = errorComment.context;
        
        const newComments = await generateBbsComments(winnerName, loserName, dbMatch, matchId, winnerData, loserData, winnerDetailedData, loserDetailedData, highlightsText);

        if (newComments && newComments.length > 0) {
            tournamentState.bbsComments.splice(index, 1, ...newComments);
        } else {
            btn.textContent = '再生成';
            btn.disabled = false;
            alert('再生成に失敗しました。');
        }
        
        renderBbsComments(tournamentState.bbsComments);
        saveState();
    }
    // ▲▲▲ ▲▲▲

});
    

// <script>タグの、他のイベントリスナーの近くに追加

document.body.addEventListener('change', (e) => {
    if (e.target.matches('#toggle-article-generation')) {
        tournamentState.settings.enableArticleGeneration = e.target.checked;
        saveState();
    }
    if (e.target.matches('#toggle-bbs-generation')) {
        tournamentState.settings.enableBbsGeneration = e.target.checked;
        saveState();
    }
});

   // ==========================================================
//  2.「送信」イベントを処理するリスナー (新設)
// ==========================================================
document.body.addEventListener('submit', async (e) => {
    
    // --- 掲示板の「返信フォーム」が送信された場合 ---
    if (e.target.matches('.reply-form')) {
        e.preventDefault();
        const form = e.target;
        const parentCommentId = form.dataset.commentId;
        const bbsType = form.dataset.bbsType;
        const textarea = form.querySelector('textarea');
        const userReplyText = textarea.value;

        if (!userReplyText.trim()) return;

        form.innerHTML = `<div class="loader text-xs">AIが返信を考えています...</div>`;
        
        const commentSource = bbsType === 'general' ? tournamentState.bbsComments : tournamentState.daiyaBbsComments;
        const parentComment = findCommentById(commentSource, parentCommentId);
        const aiPersona = parentComment.personality;
        const context = { tournamentSummary: getTournamentStatusSummary() };
        
        const aiReply = await generateBbsReply(parentCommentId, userReplyText, bbsType, aiPersona, context);

        if (aiReply) {
            const freshParentComment = findCommentById(commentSource, parentCommentId);
            if (freshParentComment) {
                if (!freshParentComment.replies) {
                    freshParentComment.replies = [];
                }
                freshParentComment.replies.push(aiReply);
            }
            if (bbsType === 'general') renderBbsComments(tournamentState.bbsComments);
            else renderDaiyaBbsComments(tournamentState.daiyaBbsComments);
            saveState();
        } else {
            form.innerHTML = `<textarea class="w-full p-2 border rounded text-sm" placeholder="返信を入力..." required></textarea><button type="submit" class="mt-1 bg-blue-500 text-white px-3 py-1 text-xs rounded hover:bg-blue-600">送信</button>`;
            alert("AIが返信を生成できませんでした。");
        }
    } 
    // --- メインのコメント投稿フォームが送信された場合 ---
    else if (e.target.matches('#main-comment-form')) {
        e.preventDefault();
        const textarea = document.getElementById('main-comment-textarea');
        const userCommentText = textarea.value;
        if (!userCommentText.trim()) return;

        textarea.disabled = true;
        e.target.querySelector('button').disabled = true;
        e.target.querySelector('button').textContent = 'AIが返信中...';

        const userComment = {
            id: crypto.randomUUID(),
            personality: 'あなた',
            text: userCommentText,
            timestamp: Date.now(),
            replies: []
        };
        
        const aiReplies = await generateMultipleReplies(userCommentText);
        userComment.replies = aiReplies;

        tournamentState.bbsComments.push(userComment);
        renderBbsComments(tournamentState.bbsComments);
        saveState();

        textarea.value = '';
        textarea.disabled = false;
        e.target.querySelector('button').disabled = false;
        e.target.querySelector('button').textContent = '投稿する';
    }

}); // ★★★ 閉じカッコ } の正しい位置はここです ★★★

// --- 編集モーダルの「この記事で確定」ボタン ---
    document.getElementById('review-save-btn').addEventListener('click', () => {
        if (articleForReview) {
            // テキストボックスの現在の内容で記事データを更新
            articleForReview.title = document.getElementById('review-title').value;
            articleForReview.body = document.getElementById('review-body').value.replace(/\n/g, '\\n');
            
            // 更新した記事をニュースリストに追加
            tournamentState.news.push(articleForReview);
            renderNews(tournamentState.news);
            saveState();
            
            closeReviewModal();
        }
    });

    // --- 編集モーダルの「キャンセル」ボタン ---
    document.getElementById('review-cancel-btn').addEventListener('click', () => {
        closeReviewModal();
    });

document.body.addEventListener('input', (e) => {
        if (e.target.matches('.match-summary-input')) {
            const matchId = e.target.dataset.matchId;
            let match;
            if (tournamentState.matches[matchId]) {
                match = tournamentState.matches[matchId];
            } else {
                 const [region, bracketId] = matchId.split('-');
                 if (tournamentState.autumnData?.regions[region]) {
                    const regionData = tournamentState.autumnData.regions[region];
                    if(bracketId.startsWith('B')) match = regionData.blocks.find(b=>b.id === `${region}-${bracketId}`).matches[matchId];
                    else if(bracketId === 'CHAMP') match = regionData.champBracket.matches[matchId];
                    else if(bracketId === 'REP') match = regionData.repechageBracket.matches[matchId];
                 }
            }
            if (match) {
                match.summary = e.target.value;
                saveState();
            }
        }



// イニングスコアが入力された場合
    else if (e.target.closest('#inning-score-table')) {
        updateTotalScores();
    }


    
// ▼▼▼ THIS IS THE NEW BLOCK TO ADD ▼▼▼
    // --- When an "Inning Event" is typed in ---
    else if (e.target.matches('.inning-events-input')) {
        const teamKey = e.target.dataset.teamKey;
        const inningIndex = parseInt(e.target.dataset.inningIndex, 10);
        if (inningIndex >= 0) {
            updateInningState(teamKey, inningIndex); // Instantly update the out count
        }
    }
    // ▲▲▲ END OF ADDITION ▲▲▲
});
// ==========================================================
//  プルダウン変更イベントの監視 (change)
// ==========================================================
document.body.addEventListener('change', (e) => {
    // --- 打席結果プルダウンが変更された場合 ---
    if (e.target.matches('.batting-result-part')) {
        const cell = e.target.closest('td.batting-result-cell');
        if (!cell) return;
        
        const inningIndex = Array.from(cell.parentElement.children).indexOf(cell) - 5;
        const teamKey = e.target.closest('table.batting-table').id.includes('team1') ? 'team1' : 'team2';
        
        if (inningIndex >= 0) {
            updateInningState(teamKey, inningIndex); // 即座にアウトカウントを更新
        }
    }
});

    modalBg.addEventListener('click', () => newsModal.classList.add('hidden'));
    modalClose.addEventListener('click', () => newsModal.classList.add('hidden'));
    document.getElementById('details-save').addEventListener('click', saveDetailedStats);
    document.getElementById('details-close').addEventListener('click', () => detailsModal.classList.add('hidden'));
    saveLoadCloseBtn.addEventListener('click', () => saveLoadModal.classList.add('hidden'));
    newspaperCloseBtn.addEventListener('click', () => newspaperModal.classList.add('hidden'));
document.getElementById('status-modal-close').addEventListener('click', () => {
    document.getElementById('team-status-modal').classList.add('hidden');
});

    saveTabBtn.addEventListener('click', () => {
        saveTabBtn.classList.add('border-blue-500'); saveTabBtn.classList.remove('text-gray-500');
        loadTabBtn.classList.remove('border-blue-500'); loadTabBtn.classList.add('text-gray-500');
        saveTabContent.classList.remove('hidden'); loadTabContent.classList.add('hidden');
    });
    loadTabBtn.addEventListener('click', () => {
        loadTabBtn.classList.add('border-blue-500'); loadTabBtn.classList.remove('text-gray-500');
        saveTabBtn.classList.remove('border-blue-500'); saveTabBtn.classList.add('text-gray-500');
        loadTabContent.classList.remove('hidden'); saveTabContent.classList.add('hidden');
    });
    generateSaveCodeBtn.addEventListener('click', () => {
        const jsonString = JSON.stringify(tournamentState);
        const compressed = pako.deflate(jsonString);
        const base64 = uint8ArrayToBase64(compressed);
        document.getElementById('save-code-output').textContent = base64;
        document.getElementById('save-code-area').classList.remove('hidden');
    });
    copySaveCodeBtn.addEventListener('click', () => {
        navigator.clipboard.writeText(document.getElementById('save-code-output').textContent);
        const feedback = document.getElementById('copy-feedback');
        feedback.textContent = 'コピーしました！';
        setTimeout(() => { feedback.textContent = '' }, 2000);
    });
    loadFromCodeBtn.addEventListener('click', () => {
        try {
            const code = document.getElementById('load-code-input').value;
            const binaryString = atob(code);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) { bytes[i] = binaryString.charCodeAt(i); }
            const decompressed = pako.inflate(bytes, { to: 'string' });
            const loadedState = JSON.parse(decompressed);
            tournamentState = loadedState;
            saveState();
            location.reload();
        } catch (e) {
            showAlert('データの読み込みに失敗しました。');
        }
    });
    // アプリケーション起動
    initializeApp();
</script>
    </body>
</html>