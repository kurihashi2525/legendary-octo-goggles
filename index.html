<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【最終実装版】AI記者付きトーナメント表</title>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&family=Noto+Serif+JP:wght@700&display=swap" rel="stylesheet">
 <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Yuji+Syuku&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
/* styleタグ内の分かりやすい場所に追加 */

.player-profile-card {
            background-color: #ffffff;
            border: 1px solid #e5e7eb; /* border-gray-200 */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 2px 4px rgba(0,0,0,0.03);
            display: flex;
            flex-direction: column;
            padding: 1rem;
            transition: all 0.2s ease-out;
        }
        .player-profile-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.08);
        }
        .player-profile-header {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.5rem;
            margin-bottom: 0.75rem;
        }
        .player-profile-number {
            font-size: 2.25rem; /* text-4xl */
            font-weight: 900;
            color: #1e3a8a; /* 283学園のテーマカラー */
            line-height: 1;
            margin-right: 0.75rem;
        }
        .player-profile-name {
            font-size: 1.125rem; /* text-xl */
            font-weight: 700;
            color: #1f2937; /* text-gray-800 */
            flex-grow: 1;
        }
        .player-profile-grade {
            font-size: 0.875rem; /* text-sm */
            font-weight: 700;
            color: #1e3a8a;
        }
        .player-profile-captain {
            font-size: 0.75rem;
            font-weight: 700;
            color: #b91c1c; /* text-red-700 */
            margin-left: 0.25rem;
        }
        .player-profile-body {
            font-size: 0.875rem; /* text-sm */
            color: #4b5563; /* text-gray-600 */
            line-height: 1.6;
        }
        .player-profile-body strong {
            color: #1f2937; /* text-gray-800 */
            font-weight: 600;
            margin-right: 0.25rem;
        }



       
        #campus-map-container {
            position: relative;
            width: 100%;
            max-width: 800px; 
            margin: 1.5rem auto; /* 上下にマージン、左右にauto */
            aspect-ratio: 16 / 9;
            background-color: #e5e7eb; /* bg-gray-200 */
            border-radius: 0.5rem; /* rounded-lg */
            overflow: hidden;
            border: 2px solid #e5e7eb;
        }
        #campus-map-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: grayscale(30%) brightness(1.1);
        }

        /* 2. ホットスポット (+) ボタン */
        .hotspot {
            position: absolute;
            width: 32px;
            height: 32px;
            background-color: #1e3a8a; /* 283学園テーマカラー */
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: all 0.2s ease-out;
            /* 脈動アニメーション */
            animation: hotspotPulse 2s infinite ease-in-out;
        }
        .hotspot:hover {
            transform: scale(1.2);
            animation-play-state: paused; /* ホバー中は脈動を停止 */
        }
        @keyframes hotspotPulse {
            0% { transform: scale(1); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); }
            50% { transform: scale(1.1); box-shadow: 0 6px 25px rgba(30, 58, 138, 0.7); }
            100% { transform: scale(1); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); }
        }
        .hotspot > span {
            pointer-events: none; /* 中の+マークがクリックを邪魔しないように */
        }

        /* 3. ホットスポット・ポップアップ */
        .hotspot-popup {
            position: absolute;
            width: 280px;
            background-color: white;
            border: 1px solid #d1d5db; /* border-gray-300 */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 60; /* ヘッダー(z-50)より手前 */
            /* アニメーション用 */
            opacity: 0;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            pointer-events: none; /* 見えないときはクリックさせない */
            transform: translateY(0);
        }
        .hotspot-popup.visible {
            opacity: 1;
            transform: translateY(-10px); /* 少し浮き上がる */
            pointer-events: auto;
        }
        .hotspot-popup-image {
            width: 100%;
            height: 120px;
            object-fit: cover;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
        }
        .hotspot-popup-content {
            padding: 1rem;
        }
        .hotspot-popup-title {
            font-weight: 700;
            font-size: 1.125rem; /* text-lg */
            color: #1e3a8a; /* 283学園テーマカラー */
            margin-bottom: 0.5rem;
        }
        .hotspot-popup-text {
            font-size: 0.875rem; /* text-sm */
            color: #4b5563; /* text-gray-600 */
        }
        .hotspot-popup-close {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 28px;
            height: 28px;
            background-color: #4b5563; /* text-gray-600 */
            color: white;
            border-radius: 50%;
            border: 2px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        /* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ▼▼▼ 勢力図分析アニメーション用のCSS（レイアウト修正版）▼▼▼ */
#analysis-stage {
    background: radial-gradient(ellipse at center, rgba(15, 23, 42, 1) 0%, rgba(0, 0, 0, 1) 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    padding: 2rem; /* 内側に余白を追加 */
}
.round-column {
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    height: 100%;
}
.analysis-matchup {
    margin: 10px 0;
    position: relative;
}
.analysis-team {
    padding: 4px 10px;
    background-color: rgba(0, 183, 255, 0.2);
    border: 1px solid rgba(0, 183, 255, 0.7);
    color: #e0f2fe;
    border-radius: 4px;
    font-weight: bold;
    font-size: 0.9rem;
    margin: 4px 0;
    transition: all 0.5s ease-in-out;
    opacity: 0;
    width: 150px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    /* ▼▼▼ 以下の2行を削除、またはコメントアウト ▼▼▼ */
    /* position: absolute; */
    /* ▲▲▲ */
}
.analysis-team.show {
    opacity: 1;
}
.analysis-team.highlight {
    background-color: rgba(255, 204, 0, 0.4);
    border-color: rgba(255, 204, 0, 1);
    color: white;
    transform: scale(1.1);
    box-shadow: 0 0 15px rgba(255, 204, 0, 0.7);
}

.new-thread-modal {
    position: fixed;
    inset: 0;
    background-color: rgba(0, 0, 0, 0.75);
    display: flex; /* hidden/flexで表示切替 */
    align-items: center;
    justify-content: center;
    z-index: 250; /* まとめサイトより手前 */
}

/* 勝ち上がり線のスタイル */
.matchup-connector {
    position: absolute;
    top: 50%;
    right: -20px;
    width: 20px;
    height: 2px;
    background-color: rgba(0, 183, 255, 0.5);
}
.round-connector {
    position: absolute;
    top: 25%;
    right: -30px;
    width: 2px;
    height: 50%;
    background-color: rgba(0, 183, 255, 0.5);
}
/* ▲▲▲ ここまで ▲▲▲ */

/* まとめサイトのロゴスタイル */
.matome-site-logo-container {
    position: relative;
    width: 80px; /* ロゴの幅 */
    height: 50px; /* ロゴの高さ */
    overflow: hidden;
    border-radius: 5px; /* 角を少し丸める */
    box-shadow: 0 2px 4px rgba(0,0,0,0.3); /* 影で立体感を出す */
}

.matome-site-logo-bg {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 画像をコンテナに合わせて表示 */
    position: absolute;
    top: 0;
    left: 0;
    filter: brightness(0.7) blur(1px); /* 少し暗く、ぼかして文字を読みやすく */
}

.matome-site-logo-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-weight: bold;
    font-size: 0.9rem; /* 文字サイズ調整 */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8); /* 文字の視認性を高める影 */
    white-space: nowrap; /* テキストの折り返しを防ぐ */
}

/* 新しいまとめサイトモーダルのためのスタイル */
/* スクロールバーのカスタマイズ (TailwindCSS JIT mode with plugins is better, but this is a quick fix) */
.scrollbar-thin {
    scrollbar-width: thin;
    scrollbar-color: #a0aec0 #edf2f7; /* thumb color track color */
}

.scrollbar-thin::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.scrollbar-thin::-webkit-scrollbar-thumb {
    background-color: #a0aec0; /* gray-400 */
    border-radius: 10px;
    border: 2px solid #edf2f7; /* gray-200 */
}

.scrollbar-thin::-webkit-scrollbar-track {
    background-color: #edf2f7; /* gray-200 */
    border-radius: 10px;
}

/* ヘッダーのロゴ画像とタイトルを縦方向に中央揃え */
#integrated-matome-modal .flex.justify-between.items-center img {
    vertical-align: middle;
}

/* タブボタンのアニメーション */
.matome-tab-btn {
    position: relative;
    z-index: 1;
    margin-right: -1px; /* タブ間の隙間をなくす */
    border: 1px solid #e2e8f0; /* gray-300 */
    border-bottom: none;
    background-color: #f7fafc; /* gray-50 */
}
.matome-tab-btn.active {
    background-color: #2563eb; /* blue-600 */
    color: white;
    border-color: #2563eb; /* active tab border color */
    border-bottom-color: transparent;
    z-index: 2;
}

/* 記事リンクのホバーエフェクト */
.matome-article-link p.font-bold:hover {
    color: #2563eb; /* blue-600 */
    text-decoration: underline;
}

/* BBSコメントのスタイル */
.bbs-comment {
    background-color: #ffffff;
    border: 1px solid #e2e8f0;
    padding: 1rem;
    border-radius: 0.5rem;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
}
.bbs-comment p.font-semibold {
    color: #4a5568; /* gray-700 */
    font-size: 0.875rem; /* text-sm */
    margin-bottom: 0.25rem;
}
.bbs-comment p.text-gray-800 {
    color: #2d3748; /* gray-800 */
    line-height: 1.5;
}

/* ▼▼▼ 新しいローダー用のCSS ▼▼▼ */
.loader {
    text-align: center;
    padding: 40px 20px;
    font-style: italic;
    color: #4b5563; /* gray-600 */
    font-size: 1.1rem;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 8px;
    margin: 1rem 0;
}

.loader .ellipsis span {
    opacity: 0;
    animation: pulse-ellipsis 1.4s infinite;
}
.loader .ellipsis span:nth-child(1) { animation-delay: 0s; }
.loader .ellipsis span:nth-child(2) { animation-delay: 0.2s; }
.loader .ellipsis span:nth-child(3) { animation-delay: 0.4s; }

@keyframes pulse-ellipsis {
    0% { opacity: 0.2; }
    50% { opacity: 1; }
    100% { opacity: 0.2; }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ 禍々しい雰囲気用のCSS ▼▼▼ */
.dread-mode-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(127, 29, 29, 0.5); /* 不気味な赤色のオーバーレイ */
    z-index: 199; /* 抽選会モーダルのすぐ下 */
    pointer-events: none;
    animation: fadeIn 0.5s forwards;
}

#lottery-pot.dread {
    background-color: #7f1d1d; /* red-900 */
    border-color: #fca5a5; /* red-300 */
    animation: pulse-dread 1s infinite;
}

@keyframes pulse-dread {
    0%, 100% {
        transform: scale(1.05);
        box-shadow: 0 0 15px 5px rgba(255, 100, 100, 0.7);
    }
    50% {
        transform: scale(1.1);
        box-shadow: 0 0 30px 15px rgba(255, 100, 100, 0.9);
    }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ 抽選会イベント用のCSS ▼▼▼ */
#drawn-team-container.fade-in-out {
    animation: fadeInOut 2.5s ease-in-out forwards;
}

@keyframes fadeInOut {
    0% { opacity: 0; transform: scale(0.8); }
    20%, 80% { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(0.8); }
}

.lottery-slot {
    border: 1px solid #d1d5db;
    background-color: #f3f4f6;
    padding: 4px 8px;
    font-size: 14px;
    font-weight: 500;
    border-radius: 4px;
    transition: all 0.3s ease-in-out;
}
.lottery-slot.filled {
    background-color: #fffbeb; /* amber-100 */
    border-color: #f59e0b; /* amber-500 */
    font-weight: 700;
    transform: scale(1.05);
}
.lottery-slot.highlight {
    background-color: #ef4444; /* red-500 */
    color: white;
    border-color: #b91c1c; /* red-700 */
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}
.animate-fade-in-up {
    animation: fadeInUp 0.5s ease-out forwards;
}
@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* Weather Effects */
.rain {
    position: absolute;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
}
.drop {
    position: absolute;
    bottom: 100%;
    width: 1px;
    height: 50px;
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.4));
    animation: drop 0.5s linear infinite;
}
@keyframes drop {
    to { transform: translateY(100vh); }
}

.sunshine {
    position: absolute;
    top: -50px;
    left: -50px;
    width: 100px;
    height: 100px;
    z-index: 2;
}
.sun {
    position: absolute;
    width: 100px;
    height: 100px;
    background: radial-gradient(circle, rgba(255,255,220,0.8) 0%, rgba(255,255,220,0) 60%);
    border-radius: 50%;
}
.sun-flare {
    position: absolute;
    width: 200px;
    height: 200px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    animation: flare 5s infinite;
}
@keyframes flare {
    0% { transform: scale(1); opacity: 0.1; }
    50% { transform: scale(1.2); opacity: 0.2; }
    100% { transform: scale(1); opacity: 0.1; }
}

/* Weather Control Buttons */
.weather-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.5);
    background-color: rgba(255, 255, 255, 0.2);
    font-size: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
}
.weather-btn:hover {
    background-color: rgba(255, 255, 255, 0.4);
    border-color: white;
}

/* ▼▼▼ このブロックを追加 ▼▼▼ */
        .subtitle-text {
            color: white;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
        }
        .setup-header {
            color: white !important; /* Tailwind CSSより優先させる */
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            border-bottom-color: rgba(255, 255, 255, 0.5) !important; /* 下線も白っぽくする */
        }
        /* ▲▲▲ ▲▲▲ */
/* チーム通算成績モーダル（タブ切り替え）のスタイル */
.team-stats-tab-btn {
    border-color: transparent;
    color: #6b7280; /* text-gray-500 */
    padding: 0.5rem 1rem;
    font-weight: 600;
    border-bottom-width: 2px;
}
.team-stats-tab-btn:hover {
    color: #1f2937; /* text-gray-800 */
}
.team-stats-tab-btn.active {
    color: #2563eb; /* text-blue-600 */
    border-color: #2563eb; /* border-blue-600 */
}
.team-stats-tab-content.hidden {
    display: none;
}
/* スタメン履歴用のスタイル */
.lineup-history-tournament {
    margin-bottom: 1.5rem;
}
.lineup-history-title {
    font-size: 1.25rem; /* text-xl */
    font-weight: 700;
    color: #1f2937; /* text-gray-800 */
    border-bottom: 2px solid #e5e7eb; /* border-gray-200 */
    padding-bottom: 0.5rem;
    margin-bottom: 1rem;
}
.lineup-history-match {
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px dashed #d1d5db; /* border-gray-300 */
}
.lineup-history-match:last-child {
    border-bottom: none;
    margin-bottom: 0;
}
.lineup-history-match-header {
    font-size: 1rem;
    font-weight: 600;
    color: #1e3a8a; /* text-blue-800 */
    margin-bottom: 0.5rem;
}
/* スコアブック風フォントを適用 */
.lineup-history-list {
    display: grid;
    /* 画面幅に応じて列数を自動調整 */
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 0.5rem 1rem;
    font-family: 'Yuji Syuku', serif; 
    font-size: 1rem; /* 少しフォントを大きく */
}
/* ▼▼▼ スポーツ報知風 Web記事デザイン ▼▼▼ */
        .newspaper-container { 
            font-family: 'Noto Sans JP', sans-serif; 
            padding: 1.5rem; 
            background-color: #ffffff; 
            border: 1px solid #ddd;
        }
        .newspaper-early { /* 昔の試合は白黒に */
            filter: grayscale(80%);
        }
        .newspaper-late { /* 最近の試合はカラー */
            border-top: 4px solid #a10e25;
        }
        .newspaper-header { 
            text-align: left; 
            border-bottom: 1px solid #eee; 
            padding-bottom: 0.75rem; 
            margin-bottom: 1rem; 
        }
        .newspaper-title { /* スポーツ報知 */
            font-size: 1.5rem; 
            font-weight: 700;
            color: #d00;
            font-family: 'sans-serif'; /* ロゴ風 */
        }
        .newspaper-date { 
            font-size: 0.8rem;
            color: #666;
            margin-top: 4px;
        }
        
        /* 縦書き・flexレイアウトを廃止 */
        .newspaper-content { 
            /* display: flex; を削除 */
        }
        
        /* メイン見出し (縦書き -> 横書き) */
        .newspaper-main-headline { 
            /* writing-mode を削除 */
            font-size: 2.25rem; /* 36px */
            font-weight: 900; 
            color: #222;
            line-height: 1.3;
            letter-spacing: 0.05em;
            /* border-right を削除 */
            padding-bottom: 1rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #333;
        }
        .newspaper-late .newspaper-main-headline { 
            color: #a10e25;
            border-bottom-color: #a10e25;
        }

        /* サブ見出し (記事タイトル -> リード文) */
        .newspaper-sub-headline { 
            font-size: 1.1rem; /* 18px */
            font-weight: 700; 
            color: #333;
            margin-bottom: 1.5rem; 
            border: none;
            padding-bottom: 0;
            line-height: 1.7;
            background-color: #f9f9f9;
            padding: 1rem;
            border-radius: 4px;
            border-left: 4px solid #a10e25;
        }
        
        /* 写真 (本文の前に移動) */
        .newspaper-image-placeholder { 
            width: 100%; 
            max-width: 600px;
            margin: 0 auto 0.5rem auto; /* キャプションとのマージンを調整 */
            height: auto;
            aspect-ratio: 16 / 10;
            background-color: #e0e0e0; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-family: 'Noto Sans JP', sans-serif; 
            color: #888; 
            border: 1px dashed #aaa; 
            border-radius: 4px;
        }
        /* 写真キャプション (sinbun.txtのfigcaption参考) */
        .newspaper-image-caption {
            font-size: 0.85rem;
            color: #555;
            text-align: center;
            margin-bottom: 1.5rem;
        }

        /* 本文 (多段組を廃止) */
        .newspaper-text { 
            font-family: 'Noto Sans JP', sans-serif; 
            /* column-count を削除 */
            text-align: left; /* justify をやめる */
            font-size: 1rem; /* 16px */
            line-height: 1.9; /* 行間を広くとる */
            color: #333;
        }

        /* スコアボックス (デザイン変更) */
        .newspaper-score-box { 
            border: 1px solid #ccc; 
            padding: 1rem; 
            text-align: center; 
            margin-top: 2rem; 
            background-color: #f9f9f9;
            border-radius: 4px;
        }
        .newspaper-score-box h3 { 
            font-weight: 700; 
            margin-bottom: 0.75rem; 
            font-size: 1rem; 
            color: #333;
        }
        .newspaper-score-box .score { 
            font-size: 1.75rem; 
            font-weight: 700;
            color: #000;
        }
        .newspaper-late .newspaper-score-box { 
            background-color: #fff8f8; 
            border-color: #a10e25; 
        }
        /* ▲▲▲ スポーツ報知風 Web記事デザイン ここまで ▲▲▲ */
.lineup-history-list li {
    padding-left: 0.5rem;
    white-space: nowrap;
}
/* ▼▼▼ このブロックを追加 ▼▼▼ */
     .main-title {
            font-family: 'Yuji Syuku', serif;
            font-size: 3rem; /* 少し大きくして迫力を出す */
            letter-spacing: 0.2em; /* 文字間を調整 */
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7);
            animation: fadeIn 2s ease-in-out; /* フェードインアニメーション */
        }

        .subtitle-text {
            color: white;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            animation: fadeIn 2.2s ease-in-out; /* アニメーションを追加 */
        }

        /* メインコンテンツエリアをガラスパネル風に */
        .setup-card {
            background-color: rgba(10, 10, 20, 0.65) !important; /* 半透明背景を優先 */
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px); /* 背景をぼかす（対応ブラウザのみ） */
            padding: 2.5rem !important; /* paddingを調整 */
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            animation: fadeIn 1.5s ease-in-out;
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .setup-header {
            color: white !important;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            border-bottom-color: rgba(255, 255, 255, 0.5) !important;
        }

        /* チーム一覧エリアを名簿風に */
        #teams-list {
            background-color: rgba(0, 0, 0, 0.2) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            color: #f0f0f0 !important;
            font-size: 0.9rem;
            line-height: 1.6;
            padding: 1.5rem !important;
        }

        /* ボタンエリアにアニメーションを追加 */
        #setup .mt-8 {
            animation: fadeIn 2.5s ease-in-out;
        }

        /* フェードイン用アニメーションの定義 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

/* 5. 打点(RBI)ボタン */
        .rbi-btn {
            border: 2px solid #16a34a; /* border-green-600 */
            background-color: #f0fdf4; /* bg-green-50 */
            color: #15803d; /* text-green-700 */
            padding: 0.75rem 0.5rem;
            font-size: 1rem; /* text-base */
            font-weight: 700;
            border-radius: 0.375rem; /* rounded-md */
            transition: all 0.1s ease-in;
            text-align: center;
        }
        .rbi-btn:hover {
            background-color: #16a34a; /* hover:bg-green-600 */
            color: white;
            transform: scale(1.05);
        }
        /* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ▲▲▲ ここまで ▲▲▲ */
/* ▼▼▼ このブロックを <style> タグ内に「新規追加」 ▼▼▼ */
/* 個人通算成績モーダル用のスタイル */
.player-stats-header {
    text-align: center;
    border-bottom: 2px solid #1e3a8a;
    margin-bottom: 1rem;
}
.player-stats-name {
    font-size: 1.75rem; /* text-2xl */
    font-weight: 700;
    color: #1f2937; /* text-gray-800 */
}
.player-stats-team {
    font-size: 1rem;
    font-weight: 500;
    color: #4b5563; /* text-gray-600 */
    margin-bottom: 0.5rem;
}
.stats-section-title {
    font-size: 1.25rem; /* text-xl */
    font-weight: 700;
    color: #1e3a8a; /* text-blue-800 */
    margin-bottom: 0.75rem;
    border-bottom: 1px solid #dbeafe; /* border-blue-200 */
    padding-bottom: 0.25rem;
}
.stats-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 4列グリッド */
    gap: 0.75rem;
    background-color: #f9fafb; /* bg-gray-50 */
    padding: 0.75rem;
    border-radius: 0.375rem;
}
.stats-grid-item {
    text-align: center;
    background-color: #ffffff;
    padding: 0.5rem;
    border-radius: 0.25rem;
    border: 1px solid #e5e7eb;
}
.stats-grid-item .stats-label {
    font-size: 0.75rem; /* text-xs */
    font-weight: 600;
    color: #6b7280; /* text-gray-500 */
    text-transform: uppercase;
}
.stats-grid-item .stats-value {
    font-size: 1.5rem; /* text-2xl */
    font-weight: 700;
    color: #1f2937;
    line-height: 1.2;
}
.stats-grid-item.highlight .stats-value {
    color: #1e3a8a; /* text-blue-800 */
}
/* ▲▲▲ 新規追加ここまで ▲▲▲ */
/* ▼▼▼ このブロックを追加 ▼▼▼ */
#news-ticker-container {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    display: flex;
    align-items: center;
    z-index: 50; /* 他の要素より手前に */
    height: 30px;
    font-family: 'Noto Sans JP', sans-serif;
    border-top: 1px solid rgba(255, 255, 255, 0.3);
}
.ticker-label {
    background-color: #e53935; /* 赤色 */
    font-weight: bold;
    padding: 0 12px;
    height: 100%;
    display: flex;
    align-items: center;
    font-size: 0.9rem;
}
.ticker-content {
    flex-grow: 1;
    overflow: hidden; /* はみ出したテキストを隠す */
    padding-left: 1rem;
}
#ticker-text {
    white-space: nowrap; /* テキストを改行させない */
    /* アニメーション時間を少し長めに設定してゆっくり流す */
    animation: scroll-ticker 40s linear infinite;
}
@keyframes scroll-ticker {
    0% { transform: translateX(100%); }
    100% { transform: translateX(-100%); }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* 写実的な天候アニメーション用のスタイル */
   /* 写実的な天候アニメーション用のスタイル（★調査モード★） */
/* 背景画像 */
.ballpark-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* Layer 1 (Bottom) */
    /* ▼▼▼ This line is the only change ▼▼▼ */
    background-image: url('ballpark.jpg'); /* Use the local image */
    /* ▲▲▲ END OF CHANGE ▲▲▲ */
    background-size: cover;
    background-position: center;
    filter: blur(2px) brightness(0.7);
    animation: subtle-breathing 20s ease-in-out infinite;
}
/* 土埃のアニメーション用コンテナ */
#dust-container {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; /* クリックの邪魔をしない */
    z-index: 2; /* 階層2（中間） */
}
/* メインコンテンツのコンテナ */
#app-container {
    position: relative; /* z-indexを有効にするため */
    z-index: 3; /* 階層3（一番手前） */
}
@keyframes subtle-breathing {
    0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); }
}
.dust-particle {
    position: absolute; background-color: rgba(255, 255, 255, 0.5);
    border-radius: 50%; opacity: 0; animation: drift-up linear infinite;
}
@keyframes drift-up {
    0% { transform: translateY(100vh) translateX(var(--x-start)); opacity: 0; }
    10% { opacity: 1; } 90% { opacity: 1; }
    100% { transform: translateY(-100px) translateX(var(--x-end)); opacity: 0; }
}
/* Input field color-coding */
.result-hit { background-color: #eff6ff !important; color: #1d4ed8; } /* Blue for hits */
.result-out { background-color: #fee2e2 !important; color: #b91c1c; } /* Red for outs */
.result-on-base { background-color: #f0fdf4 !important; color: #15803d; } /* Green for walks, etc. */

.clickable-team-name {
    cursor: pointer;
    transition: color 0.2s;
}
.clickable-team-name:hover {
    color: #1d4ed8; /* blue-700 */
}
        body { 
    font-family: 'Inter', 'Noto Sans JP', sans-serif; 
}
.setup-card { 
    background-color: transparent; /* 背景を透明に */
    padding: 24px; 
    border-radius: 12px; 
    box-shadow: none; /* 影を削除 */
    margin-bottom: 24px;
}
.display-card {
    background-color: #fff; padding: 24px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); margin-bottom: 24px;
}
        #main-bracket-container { display: flex; justify-content: center; padding: 20px; font-size: 12px; overflow-x: auto; border: 1px solid #e5e7eb; background-color: #f9fafb; border-radius: 8px;}
        .bracket-half { display: flex; }
        .bracket-half.right { flex-direction: row-reverse; }
        .bracket-final { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0 10px; flex-shrink: 0; min-width: 60px; }
        .bracket-final .final-matchup { border: 2px solid #f59e0b; background-color: #fffbeb; border-radius: 6px; padding: 5px; margin-top: 10px; }
        .bracket-final .winner-box { font-weight: bold; color: #b45309; text-align: center; padding: 10px 20px; white-space: nowrap; font-size: 1.25rem; }
        .bracket-final .final-title { font-weight: 600; color: #4b5563; margin-bottom: 10px; writing-mode: vertical-rl; letter-spacing: 2px; }
        .round { display: flex; flex-direction: column; justify-content: space-around; flex-shrink: 0; width: 280px; padding: 0 10px; }
        .matchup { margin: 8px 0; position: relative; display: flex; flex-direction: column; justify-content: center; flex-grow: 1; }
        .team-slot { display: flex; align-items: center; background-color: #ffffff; border: 1px solid #e5e7eb; border-radius: 4px; margin-bottom: 4px; transition: background-color 0.3s; position: relative; }
        .team-slot:last-of-type { margin-bottom: 0; }
        .team-name { flex-grow: 1; padding: 6px 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .team-name .rank { font-weight: bold; margin-right: 4px; }
        .team-name .rank-A { color: #ef4444; }
        .team-name .rank-B { color: #f97316; }
        .team-name .rank-C { color: #eab308; }
        .team-name .rank-D { color: #3b82f6; }
        .team-name .rank-E { color: #6b7280; }
        .team-name.seed { font-weight: bold; color: #ca8a04; }
        .score-input { width: 40px; padding: 6px 4px; border-left: 1px solid #e5e7eb; text-align: center; background-color: #fff; }
        .win-btn { background-color: #d1d5db; color: #fff; border: none; padding: 6px 8px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; cursor: pointer; font-weight: bold; transition: background-color 0.2s; }
        .team-slot:not(.empty) .win-btn { background-color: #3b82f6; }
        .team-slot:not(.empty):hover .win-btn { background-color: #2563eb; }
        .team-slot.winner { background-color: #dbeafe; border-color: #93c5fd; font-weight: 600; }
        .team-slot.loser { background-color: #f3f4f6; opacity: 0.6; }
        .team-slot.empty .team-name { color: #9ca3af; }
        .team-slot.empty .score-input, .team-slot.empty .win-btn, .team-slot.empty .details-btn { display: none; }
        .matchup::after { content: ''; position: absolute; top: 50%; width: 10px; height: 2px; background-color: #cbd5e1; }
        .bracket-half.left .matchup::after { right: -10px; }
        .bracket-half.right .matchup::after { left: -10px; }
        .round.subsequent-round .matchup::before { content: ''; position: absolute; top: -8px; height: calc(100% + 16px); width: 2px; background-color: #cbd5e1; }
        .bracket-half.left .round.subsequent-round .matchup::before { right: -10px; }
        .bracket-half.right .round.subsequent-round .matchup::before { left: -10px; }
        .hidden { display: none; }
        .news-article { border-left: 4px solid #3b82f6; cursor: pointer; transition: background-color 0.2s; }
        #modal-bg { background-color: rgba(0,0,0,0.5); }
        .confirm-modal, .details-modal, .save-load-modal, .newspaper-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .confirm-modal-content, .details-modal-content, .save-load-modal-content, .newspaper-modal-content { background-color: white; padding: 24px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .details-modal-content { width: 95%; max-width: 1000px; max-height: 90vh; overflow-y: auto;}
        .save-load-modal-content { width: 95%; max-width: 500px; }
        .newspaper-modal-content { width: 95%; max-width: 800px; max-height: 95vh; overflow-y: auto; }
        .confirm-modal-content { text-align: center; }
        .loader { text-align: center; padding: 20px; font-style: italic; color: #6b7280; }
        .details-btn { background-color: #6b7280; color: white; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: auto; margin-right: 2px; }
        .details-btn:hover { background-color: #4b5563; }
        .matchup-footer { text-align: center; margin-top: 2px; display: flex; justify-content: center; align-items: center; gap: 4px;}
        .stats-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .stats-table th, .stats-table td { border: 1px solid #e5e7eb; padding: 4px 6px; text-align: center; }
        .stats-table th { background-color: #f3f4f6; }
        .stats-table input { width: 100%; border: none; text-align: center; background: transparent;}
        .stats-table input:focus { outline: 1px solid #3b82f6; }
        .modal-body-scroll { max-height: 70vh; overflow-y: auto; }
        #save-code-output { word-break: break-all; background-color: #f3f4f6; padding: 8px; border-radius: 4px; max-height: 200px; overflow-y: auto; user-select: all; }
        .bbs-comment { background-color: #ffffff; border: 1px solid #e5e7eb; padding: 8px 12px; border-radius: 8px; font-size: 14px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .match-summary-input { resize: none; height: 40px; }
        .article-error { background-color: #fee2e2; border-left: 4px solid #ef4444; color: #b91c1c; padding: 1rem; border-radius: 0.5rem; display: flex; justify-content: space-between; align-items: center; }
        .retry-btn { background-color: #ef4444; color: white; padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-weight: 600; cursor: pointer; }
        .retry-btn:hover { background-color: #dc2626; }
        .namco-news-item { cursor: pointer; transition: background-color 0.2s; }
        .namco-news-tag { background-color: #f97316; color: white; font-size: 0.75rem; padding: 2px 8px; border-radius: 9999px; margin-left: 8px; }
      
.region-map-scroll-container {
    display: flex;
    overflow-x: auto;
    padding-bottom: 16px; /* Space for the scrollbar */
    gap: 16px;
}
.region-column { 
    flex: 0 0 250px; /* Prevent cards from shrinking */
    background-color: #ffffff; 
    border: 1px solid #e5e7eb; 
    border-radius: 8px; 
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
}
.region-header { 
    padding: 12px 16px; 
    background-color: #f9fafb; 
    border-bottom: 1px solid #e5e7eb; 
}
.region-title { 
    font-weight: 700; 
    font-size: 1.1rem; 
    color: #1f2937; 
}
.region-stats { 
    font-size: 0.8rem; 
    color: #4b5563; 
    font-weight: 500;
}
.region-team-list { 
    list-style: none; 
    padding: 12px 16px; 
    margin: 0;
    flex-grow: 1; /* Allow list to fill space */
}
.region-team { 
    padding: 6px 0; 
    font-size: 0.9rem;
    border-bottom: 1px solid #f3f4f6;
}
.region-team:last-child {
    border-bottom: none;
}
.team-surviving { 
    font-weight: 500; 
    color: #1f2937; 
}
.team-eliminated { 
    color: #9ca3af; 
    text-decoration: line-through; 
}
         .scorebook-font {
            font-family: 'Yuji Syuku', serif;
        }
        

        .rivalry-match .team-slot { border: 2px solid #ef4444 !important; background-color: #fff1f2; }
        .feud-match .team-slot { border: 2px solid #8b5cf6 !important; background-color: #f5f3ff; }
        .rivalry-match .team-slot.winner { background-color: #fecaca; }
        .feud-match .team-slot.winner { background-color: #ddd6fe; }
    
/* 詳細入力テーブル用のスタイル */
/* 詳細入力テーブル用のスタイル（最終版） */
/* ▼▼▼ このブロックを <style> タグ内に「新規追加」 ▼▼▼ */
/* チーム通算成績モーダル用のスタイル */
.career-stats-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
    table-layout: auto;
}
.career-stats-table th, .career-stats-table td {
    border: 1px solid #e5e7eb;
    padding: 6px 4px;
    text-align: center;
    white-space: nowrap;
}
.career-stats-table thead tr {
    background-color: #f3f4f6; /* bg-gray-100 */
}
.career-stats-table .player-name {
    text-align: left;
    padding-left: 8px;
    font-weight: 600;
    min-width: 100px;
}
.career-stats-table .stat-highlight {
    font-weight: 700;
    background-color: #fef9c3; /* bg-yellow-100 */
}
.career-stats-table tbody tr:hover {
    background-color: #f9fafb; /* bg-gray-50 */
}


/* 1. ヒーローセクションのアニメーション */
        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in-down {
            animation: fadeInDown 1.0s ease-out forwards;
        }
        .animate-fade-in-up {
            opacity: 0; /* 最初は非表示 */
            animation: fadeInUp 1.0s ease-out 0.5s forwards; /* 0.5秒遅れて開始 */
        }
        /* .is-visible はJSでアニメーション開始時に付与されます */
        .animate-fade-in-up.is-visible {
            opacity: 1;
        }

        /* 2. スクロール連動フェードイン用 */
        .fade-in-section {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
        }
        .fade-in-section.is-visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* 3. 選手カードのホバーエフェクト強化 */
        .player-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 15px 30px -5px rgba(0, 0, 0, 0.2), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
        }
        /* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ▼▼▼ このブロックを <style> タグ内に「新規追加」 ▼▼▼ */
/* チーム通算成績モーダル（ソート機能付き）のスタイル */
.career-stats-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
    table-layout: auto;
}
.career-stats-table th, .career-stats-table td {
    border: 1px solid #e5e7eb;
    padding: 6px 4px;
    text-align: center;
    white-space: nowrap;
}
.career-stats-table thead tr {
    background-color: #f3f4f6; /* bg-gray-100 */
}
/* ★ ソート可能なヘッダーのスタイル ★ */
.career-stats-table th.sortable-header {
    cursor: pointer;
    position: relative;
    padding-right: 20px; /* 矢印用のスペース */
}
.career-stats-table th.sortable-header:hover {
    background-color: #e5e7eb; /* bg-gray-200 */
}
.career-stats-table .sort-arrow {
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 14px;
    color: #9ca3af; /* text-gray-400 */
}

/* 4. 打球方向ホットスポット */
.direction-hotspot {
    position: absolute;
    width: 15%;
    height: 15%;
    background-color: rgba(255, 255, 255, 0.8);
    border: 2px dashed #9ca3af; /* border-gray-400 */
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
    font-weight: 700;
    color: #374151; /* text-gray-700 */
    cursor: pointer;
    transform: rotate(-45deg); /* グラウンドの回転を戻す */
    transition: all 0.2s ease-out;
    opacity: 0; /* 普段は非表示 */
    pointer-events: none; /* 普段はクリックさせない */
}
.direction-hotspot:hover {
    background-color: #fef9c3; /* bg-yellow-100 */
    border-color: #f59e0b; /* border-yellow-500 */
    transform: rotate(-45deg) scale(1.1);
}
/* .direction-mode クラスが付与されたら表示 */
.baseball-diamond.direction-mode .direction-hotspot {
    opacity: 1;
    pointer-events: auto;
}

/* 各守備位置の配置 (45度回転した基準で) */
#pos-p { top: 42.5%; left: 42.5%; } /* 投手 */
#pos-c { top: 75%; left: 42.5%; } /* 捕手 */
#pos-1b { top: 42.5%; left: 75%; } /* 一塁 */
#pos-2b { top: 25%; left: 60%; } /* 二塁 */
#pos-3b { top: 42.5%; left: 10%; } /* 三塁 */
#pos-ss { top: 25%; left: 25%; } /* 遊撃 */
#pos-lf { top: 15%; left: 0%; } /* 左翼 */
#pos-cf { top: 0%; left: 42.5%; } /* 中堅 */
#pos-rf { top: 15%; left: 85%; } /* 右翼 */
/* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ★ 昇順・降順の矢印 ★ */
.career-stats-table th.sort-asc .sort-arrow::after {
    content: ' ▲';
    color: #1e3a8a; /* text-blue-800 */
}
.career-stats-table th.sort-desc .sort-arrow::after {
    content: ' ▼';
    color: #1e3a8a; /* text-blue-800 */
}
.career-stats-table .player-name {
    text-align: left;
    padding-left: 8px;
    font-weight: 600;
    min-width: 100px;
}
.career-stats-table .stat-highlight {
    font-weight: 700;
    background-color: #fef9c3; /* bg-yellow-100 */
}
.career-stats-table tbody tr:hover {
    background-color: #f9fafb; /* bg-gray-50 */
}
/* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ヒーローセクションの背景 */
        .hero-bg {
            background: linear-gradient(rgba(17, 24, 39, 0.7), rgba(17, 24, 39, 0.7)), url('https://images.unsplash.com/photo-1519069632080-756b57d9b542?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAzNTV8MHwxfGFsbHx8fHx8fHx8fDE3MTUyNDU0Njd8&ixlib=rb-4.0.3&q=80&w=1080');
            background-size: cover;
            background-position: center 70%;
            background-attachment: fixed; /* 背景を固定し、パララックス（視差）効果を出す */
        }
        /* スローガン用の特大フォント */
        .slogan {
            font-size: clamp(4rem, 15vw, 10rem); /* 画面幅に応じてサイズ変更 */
            font-weight: 900;
            line-height: 1;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        /* セクションタイトルの下線 */
        .section-title {
            position: relative;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
        }
        .section-title::after {
            content: '';
            position: absolute;
            bottom: -1px; /* ボーダーライン上に配置 */
            left: 0;
            width: 60px;
            height: 4px;
            background-color: #1e3a8a; /* 濃い青 (283学園のテーマカラー) */
        }
        /* 選手カードのホバーエフェクト */
        .player-card {
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }
        .player-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        /* ページ内リンクが飛んだ際のヘッダーのズレを調整 */
        section[id] {
            scroll-margin-top: 80px; /* ヘッダーの高さ分（約） */
        }
        /* ヘッダーナビゲーションのホバーエフェクト */
        .nav-link {
            position: relative;
            transition: color 0.2s;
        }
        .nav-link::after {
            content: '';
            position: absolute;
            width: 0;
            height: 2px;
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #1e3a8a;
            transition: width 0.3s ease-out;
        }
        .nav-link:hover::after,
        .nav-link:focus::after {
            width: 100%;
        }
        /* ギャラリー画像のホバーエフェクト */
        .gallery-image {
            transition: transform 0.3s ease-in-out, filter 0.3s ease-in-out;
        }
        .gallery-image:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
        }

        /* ▼▼▼ トーナメント表用のCSS ▼▼▼ */
        .bracket-wrapper {
            max-width: 100%;
            overflow-x: auto; /* 横スクロールを可能にする */
            padding: 2rem 1rem;
            background-color: #ffffff; /* bg-white */
            border: 1px solid #d1d5db; /* border-gray-300 */
            border-radius: 0.5rem; /* rounded-lg */
            margin-top: 1.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        .tournament-container {
            display: flex;
            align-items: stretch; /* 各ラウンドの高さを揃える */
            min-width: 3200px; /* 全体の最小幅を指定 */

.baseball-diamond.runner-select-mode .base.runner {
    cursor: pointer;
    background-color: #f59e0b; /* bg-yellow-500 */
    border-color: #d97706; /* border-yellow-600 */
    animation: runnerPulse 1s infinite;
}
@keyframes runnerPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

        }
        .bracket-final {
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; padding: 0 1.5rem; flex-shrink: 0;
        }
        .final-matchup { width: 280px; }
        .final-matchup .match {
            border-width: 2px; border-color: #f59e0b;
            box-shadow: 0 4px 10px rgba(245, 158, 11, 0.2);
        }
        .final-matchup .team { font-size: 1.125rem; padding: 0.75rem 1rem; }
        .final-matchup .score { font-size: 1.25rem; }
        .winner-box {
            text-align: center; margin-top: 1.5rem; padding: 0.75rem 1.5rem;
            background-color: #fffbeb; border: 2px solid #fcd34d; border-radius: 0.375rem;
        }
        .winner-box h2 { font-size: 1.5rem; font-weight: 700; color: #d97706; }
        .bracket-half { display: flex; align-items: stretch; }
        .bracket-half.right { flex-direction: row-reverse; }
        .round {
            /* width: 230px; や width: 280px; などの定義は
               index.html 側の既存の .round 定義と競合するため、ここでは除外します */
        }
        .round-title {
            text-align: center; font-weight: 700; font-size: 1rem;
            color: #4b5563; margin-bottom: 1rem; white-space: nowrap;
        }
        .matchup {
            /* .matchup の定義も index.html 側と競合するため、必要なもの以外は除外 */
        }
        .match {
            border: 1px solid #d1d5db; background: #fff;
            border-radius: 0.375rem; overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .team {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0.5rem 0.75rem; font-size: 0.875rem; line-height: 1.25; min-height: 38px;
        }
        .team.winner { font-weight: 700; color: #111827; }
        .team.loser { color: #6b7280; opacity: 0.7; }
        .team.loser .name { text-decoration: line-through; }
        .team .score {
            width: 30px; text-align: right; border-left: 1px solid #e5e7eb;
            padding-left: 0.5rem; font-size: 0.95rem; font-weight: 500;
        }
        .team.winner .score { color: #dc2626; font-weight: 700; }
        .team:first-child { border-bottom: 1px solid #d1d5db; }
        .r1 .matchup { margin: 0.25rem 0; }
        .r1 .team { padding: 3px 6px; font-size: 11px; min-height: 28px; }
        .r1 .team .score { width: 20px; font-size: 11px; }
        .connector-line {
            position: absolute; top: 50%; width: 1.5rem; height: 2px;
            background-color: #9ca3af; z-index: 1;
        }
        .bracket-half.left .connector-line { right: -1.5rem; }
        .bracket-half.right .connector-line { left: -1.5rem; }
        .connector-path {
            position: absolute; top: 50%; height: 100%; width: 2px;
            background-color: #9ca3af; z-index: 0;
        }
        .r2 .matchup { margin: 0.5rem 0; }
        .r2 .connector-path { top: -25%; height: 150%; }
        .r3 .matchup { margin: 1.25rem 0; }
        .r3 .connector-path { top: -75%; height: 250%; }
        .r4 .matchup { margin: 3.25rem 0; }
        .r4 .connector-path { top: -175%; height: 450%; }
        .r5 .matchup { margin: 8rem 0; }
        .r5 .connector-path { top: -400%; height: 900%; }
        .bracket-half.left .connector-path { right: -1.5rem; }
        .bracket-half.right .connector-path { left: -1.5rem; }
        /* ▲▲▲ トーナメント表CSSここまで ▲▲▲ */
        
/* 8. H2H (Head-to-Head) 戦力比較チャート */
        .h2h-chart-container {
            border-top: 2px solid #e5e7eb; /* border-gray-200 */
            margin-top: 1.5rem; /* mt-6 */
            padding-top: 1.5rem; /* pt-6 */
        }
        .h2h-chart-title {
            font-size: 1.25rem; /* text-xl */
            font-weight: 700;
            color: #1f2937; /* text-gray-800 */
            margin-bottom: 1rem; /* mb-4 */
        }
        .h2h-stat-row {
            margin-bottom: 1rem; /* mb-4 */
        }
        .h2h-stat-label {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            font-size: 0.875rem; /* text-sm */
            font-weight: 600;
            color: #4b5563; /* text-gray-600 */
            margin-bottom: 0.25rem; /* mb-1 */
        }
        .h2h-stat-label-team1 { color: #1d4ed8; } /* text-blue-700 */
        .h2h-stat-label-team2 { color: #be123c; } /* text-red-700 */
        
        .h2h-bar-wrapper {
            display: flex;
            gap: 2px; /* 隙間 */
            height: 24px; /* バーの高さ */
            background-color: #e5e7eb; /* bg-gray-200 */
            border-radius: 0.25rem; /* rounded */
            overflow: hidden;
        }
        .h2h-bar {
            transition: width 0.5s ease-out;
        }
        .h2h-bar-team1 { background-color: #3b82f6; } /* bg-blue-500 */
        .h2h-bar-team2 { background-color: #e11d48; } /* bg-red-600 */
        /* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* 7. 選手コンディション (調子) アイコン */
        .condition-icon {
            font-size: 0.9em;
            margin-left: 4px;
            display: inline-block;
            vertical-align: baseline;
        }
        .details-table .condition-icon {
            font-size: 1.1em;
            vertical-align: middle;
        }

        /* ▼▼▼ 一球速報モーダル用のCSS ▼▼▼ */
        .modal-hidden { display: none; }
        #boxscore-modal-body {
            background-color: #f9fafb; /* bg-gray-50 */
            padding: 1rem;
            border-radius: 0.25rem;
            font-size: 12px; /* ベースのフォントサイズ */
        }
        /* 一球速報.com風 スコアボード */
        .boxscore-table {
            width: 100%; border-collapse: collapse;
            font-size: 14px; margin-bottom: 1rem;
        }
        .boxscore-table th, .boxscore-table td {
            border: 1px solid #d1d5db; padding: 6px 8px; text-align: center;
        }
        .boxscore-table .team-name {
            text-align: left; font-weight: 700; width: 20%;
        }
        .boxscore-table .inning-header th {
            background-color: #374151; color: white;
            font-weight: 500; padding: 4px 6px;
        }
        .boxscore-table .total-header { background-color: #374151; color: white; }
        .boxscore-table .score-cell {
            font-size: 1.1rem; font-weight: 700; width: 35px;
        }
        .boxscore-table .total-score {
            font-size: 1.25rem; font-weight: 700; background-color: #fef9c3;
        }
        /* 一球速報.com風 打撃成績テーブル */
        .batting-stats-table {
            width: 100%; border-collapse: collapse; font-size: 12px;
            table-layout: fixed; /* テーブルレイアウトを固定 */
        }
        .batting-stats-table th, .batting-stats-table td {
            border: 1px solid #e5e7eb; padding: 5px 4px;
            text-align: center; white-space: nowrap; /* 折り返し禁止 */
        }
        .batting-stats-table thead tr { background-color: #f3f4f6; }
        .batting-stats-table .pos { width: 8%; }
        .batting-stats-table .player { width: 20%; text-align: left; padding-left: 8px; }
        .batting-stats-table .at-bat { width: 5%; }
        .batting-stats-table .runs { width: 5%; }
        .batting-stats-table .hits { width: 5%; }
        .batting-stats-table .rbi { width: 5%; }
        .batting-stats-table .so { width: 5%; }
        .batting-stats-table .walks { width: 5%; }
        .batting-stats-table .results { width: 42%; text-align: left; padding-left: 8px; white-space: normal; } /* 結果は折り返し許可 */
        .batting-stats-table tbody tr:hover { background-color: #fef9c3; }
        .batting-stats-table .sub-player td { background-color: #f9fafb; color: #4b5563; }
        .batting-stats-table .sub-player .player { padding-left: 20px; }
        .batting-stats-table .team-totals { font-weight: 700; background-color: #f3f4f6; }
        /* 投手成績テーブル */
        .pitching-stats-table {
            width: 100%; border-collapse: collapse; font-size: 12px;
            margin-top: 1rem; table-layout: fixed;
        }
        .pitching-stats-table th, .pitching-stats-table td {
            border: 1px solid #e5e7eb; padding: 5px 4px;
            text-align: center; white-space: nowrap;
        }
        .pitching-stats-table thead tr { background-color: #f3f4f6; }
        .pitching-stats-table .player { width: 25%; text-align: left; padding-left: 8px; }
        .pitching-stats-table .result { width: 6%; }
        .pitching-stats-table .ip { width: 8%; }
        .pitching-stats-table .bf { width: 8%; }
        .pitching-stats-table .hits { width: 8%; }
        .pitching-stats-table .so { width: 8%; }
        .pitching-stats-table .walks { width: 8%; }
        .pitching-stats-table .runs { width: 8%; }
        .pitching-stats-table .er { width: 8%; }
        .pitching-stats-table .era { width: 13%; }
        /* ▲▲▲ 一球速報CSSここまで ▲▲▲ */

/* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ▲▲▲ 新規追加ここまで ▲▲▲ */
/* ▼▼▼ アニメーション説明用のCSS ▼▼▼ */
.match-schedule {
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 11px;
            font-weight: 600;
            color: #4b5563; /* gray-600 */
            text-align: center;
            padding: 2px 0;
            border-top: 1px dashed #cbd5e1; /* gray-300 */
            border-bottom: 1px dashed #cbd5e1; /* gray-300 */
            margin-top: 3px;
            background-color: #f9fafb; /* gray-50 */
        }
/* ▲▲▲ 追加ここまで ▲▲▲ */
#animation-stage {
    font-size: 0.75rem; /* 全体の文字サイズを小さめに */
    transition: background-color 0.5s ease;
}
.anim-region, .anim-block, .anim-bracket {
    border: 1px solid #ccc;
    background-color: white;
    padding: 8px;
    margin: 5px;
    border-radius: 4px;
    text-align: center;
    opacity: 0;
    transition: all 0.5s ease-in-out;
    position: relative; /* 子要素の絶対配置基準 */
}
.anim-team {
    display: inline-block;
    background-color: #e0f2fe; /* blue-100 */
    border: 1px solid #7dd3fc; /* blue-300 */
    color: #0c4a6e; /* blue-800 */
    padding: 2px 5px;
    margin: 1px;
    border-radius: 3px;
    font-weight: 500;
    opacity: 0;
    transform: scale(0.8);
    transition: all 0.3s ease-in-out;
}
.anim-team.seed {
    background-color: #fef9c3; /* yellow-100 */
    border-color: #facc15; /* yellow-400 */
    color: #713f12; /* yellow-900 */
    font-weight: bold;
}
.anim-team.winner {
    background-color: #dcfce7; /* green-100 */
    border-color: #4ade80; /* green-400 */
    color: #14532d; /* green-900 */
    font-weight: bold;
}
.anim-team.loser {
    background-color: #f1f5f9; /* slate-100 */
    border-color: #cbd5e1; /* slate-300 */
    color: #64748b; /* slate-500 */
    opacity: 0.6 !important;
    text-decoration: line-through;
}
.anim-team.show, .anim-region.show, .anim-block.show, .anim-bracket.show {
    opacity: 1;
    transform: scale(1);
}
.anim-highlight {
    box-shadow: 0 0 15px 5px rgba(251, 191, 36, 0.7); /* amber-400 */
    transform: scale(1.1) !important;
    z-index: 10;
}
.anim-arrow {
    position: absolute;
    width: 0;
    height: 0;
    border-top: 5px solid transparent;
    border-bottom: 5px solid transparent;
    opacity: 0;
    transition: opacity 0.5s ease-in-out 0.5s; /* 少し遅れて表示 */
}
.anim-arrow.right {
    border-left: 8px solid #60a5fa; /* blue-400 */
}
.anim-arrow.show {
    opacity: 1;
}

.details-table { 
    border-collapse: collapse; 
    font-size: 12px; 
    
}

/* 1. インタラクティブ・スコアカード モーダル本体 */
#scorecard-modal {
    z-index: 180; /* チームステータス(170)より手前 */
}
.scorecard-grid {
    display: grid;
    grid-template-areas:
        "header"
        "diamond"
        "actions"
        "log";
    grid-template-rows: auto 1fr auto auto;
    gap: 1rem;
    width: 100%;
    height: 100%;
    padding: 1rem;
}
@media (min-width: 768px) { /* md: */
    .scorecard-grid {
        grid-template-areas:
            "header header"
            "diamond actions"
            "diamond log";
        grid-template-columns: 2fr 1fr;
        grid-template-rows: auto 1fr auto;
    }
}

/* 2. 野球のグラウンド */
.baseball-diamond {
    grid-area: diamond;
    position: relative;
    width: 100%;
    max-width: 400px; /* 最大幅 */
    aspect-ratio: 1 / 1; /* 正方形 */
    margin: auto;
    background-color: #f7fafc; /* bg-gray-50 */
    border: 2px solid #e2e8f0; /* border-gray-300 */
    border-radius: 8px;
    transform: rotate(45deg);
}
.base {
    position: absolute;
    width: 12%;
    height: 12%;
    background-color: white;
    border: 2px solid #a0aec0; /* border-gray-400 */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: all 0.2s ease-out;
}
.base.runner {
    background-color: #2563eb; /* bg-blue-600 */
    border-color: #1d4ed8;
    box-shadow: 0 0 15px 5px rgba(59, 130, 246, 0.7);
}
#base-home { bottom: -6%; left: 50%; transform: translateX(-50%) rotate(-45deg); border-radius: 0; width: 15%; height: 15%; }
#base-1b { top: 50%; right: -6%; transform: translateY(-50%); }
#base-2b { top: -6%; left: 50%; transform: translateX(-50%); }
#base-3b { top: 50%; left: -6%; transform: translateY(-50%); }
#pitchers-mound {
    position: absolute;
    top: 50%; left: 50%;
    width: 10%; height: 10%;
    background-color: #a0aec0; /* bg-gray-400 */
    border-radius: 50%;
    transform: translate(-50%, -50%);
}

/* 3. 操作パネル */
#scorecard-actions { grid-area: actions; }
#scorecard-log { grid-area: log; }
.result-btn {
    border: 1px solid #d1d5db; /* border-gray-300 */
    padding: 0.75rem 0.5rem;
    font-size: 0.875rem; /* text-sm */
    font-weight: 600;
    border-radius: 0.375rem; /* rounded-md */
    transition: all 0.1s ease-in;
    text-align: center;
}
.result-btn:hover {
    border-color: #9ca3af; /* hover:border-gray-400 */
    transform: translateY(-1px);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}
.result-btn-hit { background-color: #eff6ff; color: #1d4ed8; } /* bg-blue-50, text-blue-700 */
.result-btn-out { background-color: #fee2e2; color: #b91c1c; } /* bg-red-50, text-red-700 */
.result-btn-walk { background-color: #f0fdf4; color: #15803d; } /* bg-green-50, text-green-700 */
.result-btn-other { background-color: #fef9c3; color: #a16207; } /* bg-yellow-50, text-yellow-700 */
/* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* 283学園ホームページ用ハイライト */
        #homepage-modal #results .team.hp-team-283 {
            background-color: #eff6ff; /* bg-blue-50 */
            border-color: #93c5fd; /* border-blue-300 */
        }
        #homepage-modal #results .team.hp-team-283.winner {
            background-color: #1e3a8a; /* bg-blue-800 */
            color: white;
            font-weight: 900;
        }
        #homepage-modal #results .team.hp-team-283.winner .score,
        #homepage-modal #results .team.hp-team-283.winner .name {
            color: white;
        }
        #homepage-modal #results .team.hp-team-283.loser {
            background-color: #eef2ff; /* bg-indigo-50 */
            opacity: 0.8;
        }
        #homepage-modal #results .team.hp-team-283.loser .name {
            text-decoration: line-through;
        }
        /* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ▼▼▼ この新しいルールを追加 ▼▼▼ */
.details-table th {
    white-space: nowrap; /* ヘッダーの文字が折り返さないようにする */
}
/* ▲▲▲ ▲▲▲ */
.details-table td { 
    border: 1px solid #e5e7eb; 
    padding: 4px; 
    text-align: center; 
    vertical-align: middle; 
}
.details-table th { background-color: #f9fafb; font-weight: 600; }
.details-table input, .details-table select { width: 100%; border: none; text-align: center; background: transparent; font-size: 12px; }
.details-table input:focus, .details-table select:focus { outline: 1px solid #3b82f6; }

/* ★列幅設定★ */
/* イニングスコアテーブル */
#inning-score-table { table-layout: auto; width: auto; } /* スコアボードは自動幅 */
#inning-score-table .col-team { min-width: 120px; text-align: left; padding-left: 8px; }
#inning-score-table .col-inning-score { width: 40px; }
#inning-score-table .col-total { width: 50px; }
#inning-score-table .col-add-inning { width: 40px; }

/* ▼▼▼ このブロックをまるごと追加 ▼▼▼ */
/* 投手成績テーブル */
.details-table[id^="pitching-table"] .col-pitcher-result { min-width: 50px; }
.details-table[id^="pitching-table"] .col-pitcher-name { min-width: 130px; } /* 選手名欄を広く */
.details-table[id^="pitching-table"] .col-pitcher-throw-bat { min-width: 80px; }
.details-table[id^="pitching-table"] .col-pitcher-style { min-width: 110px; } /* 投げ方 (スリークォーター) */
.details-table[id^="pitching-table"] .col-pitcher-type { min-width: 80px; }
.details-table[id^="pitching-table"] .col-pitcher-velocity { min-width: 80px; }
.details-table[id^="pitching-table"] .col-stat { min-width: 60px; } /* 回数, 打者, 球数 etc. */
/* ▲▲▲ 追加ここまで ▲▲▲ */



/* 打撃成績テーブル */
/* ★列幅設定（min-widthで最低幅を保証）★ */
.batting-table .col-order { min-width: 40px; }
.batting-table .col-number { min-width: 60px; }
.batting-table .col-throw-bat { min-width: 80px; } /* 「投/打」列の幅を確保 */
.batting-table .col-player { min-width: 120px; }
.batting-table .col-pos { min-width: 100px; }
.batting-table .col-sub-type { min-width: 80px; }
.batting-table .col-inning { min-width: 400px; }  /* ←お好みの幅に調整してください */
/* ▲▲▲ ▲▲▲ */
        .add-row-btn { background-color: #e5e7eb; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-top: 4px; }

        .add-row-btn:hover { background-color: #d1d5db; }　



　 </style>
</head>
<body class="p-4 md:p-8">
     <audio id="lottery-bgm" src="./bgm.mp3" loop preload="auto"></audio>
    <div class="ballpark-background"></div>
    <div id="dust-container"></div>
 <div id="rain-container" class="rain hidden"></div>
    <div id="sun-container" class="sunshine hidden">
        <div class="sun"></div>
        <div class="sun-flare"></div>
    </div>
    <div id="app-container" class="max-w-full mx-auto">
/div>

<div id="news-ticker-container">
    <div class="ticker-label">NEWS</div>
    <div class="ticker-content">
        <p id="ticker-text"></p>
    </div>
</div>

    <div id="weather-controls" class="fixed bottom-4 right-4 z-10">
        <div class="flex gap-2 p-2 bg-black bg-opacity-20 rounded-lg">
            <button id="unmute-btn" class="weather-btn">🔇</button>
            <button class="weather-btn" data-weather="sun">☀️</button>
            <button class="weather-btn" data-weather="rain">🌧️</button>
            <button class="weather-btn" data-weather="none">💨</button>
        </div>
    </div>
        
<div class="flex items-center justify-center space-x-4 p-4 mt-4 bg-slate-800/50 rounded-lg">
            <span class="font-semibold text-white">大会開始時のAI自動生成</span>
            <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="initial-ai-generation-toggle" class="sr-only peer" checked>
                <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                <span class="ml-3 text-sm font-medium text-gray-300 peer-checked:text-white">ON</span>
            </label>
        </div>

<div id="settings-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[200]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 class="text-xl font-bold">設定</h3>
            <button id="settings-modal-close-btn" class="text-gray-400 hover:text-gray-600">&times;</button>
        </div>
        <div class="space-y-4">
            <div class="flex items-center justify-between">
                <span class="font-semibold">試合記事の自動生成</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-article-generation" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
            </div>
            <div class="flex items-center justify-between">
                <span class="font-semibold">掲示板の自動生成</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-bbs-generation" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
            </div>
        </div>
    </div>
</div>



        <div class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white main-title">AI記者付きトーナメント表</h1>
            <p id="tournament-year-display" class="mt-2 subtitle-text">（最終実装版）</p>
        </div>

        <div id="setup" class="setup-card">
             <div class="w-full">
                 <h2 class="text-xl font-semibold mb-4 border-b pb-2 setup-header">参加チーム (126チーム)</h2>
                 <textarea id="teams-list" class="w-full h-96 p-3 border border-gray-300 rounded-lg" readonly></textarea>
             </div>
             <div class="mt-8 text-center">
                 <button id="resume-btn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-green-700 shadow-md mb-4 w-full md:w-auto">
                   再開（合い言葉入力）
                 </button>
                 <button id="generate-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 shadow-md w-full md:w-auto">
                     新しいトーナメントを開始
                 </button>
　　　　　　　　<button id="help-btn" class="bg-gray-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-gray-600 shadow-md mt-4 w-full md:w-auto">
    遊び方
</button>
 <button id="show-matome-site-btn" class="bg-orange-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-orange-600 shadow-md mt-4 w-full md:w-auto">
    📰 まとめサイトを見る
    </button>            
 </div>
        </div>




        <div id="tournament-display" class="hidden">
            <div id="autumn-regional-blocks-container" class="display-card hidden"></div>
            <div id="autumn-ranking-playoffs-container" class="display-card hidden"></div>
            <button id="skip-autumn-blocks-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 shadow-md hidden">地区ブロック予選をスキップ</button>
<button id="skip-autumn-ranking-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 shadow-md hidden">地区順位決定戦をスキップ</button>
<button id="skip-autumn-main-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 shadow-md hidden">県大会本戦をスキップ</button>
<button id="skip-spring-qualifiers-btn" class="bg-teal-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-600 shadow-md hidden">春季地区予選をスキップ</button>
<button id="skip-spring-round1-btn" class="bg-teal-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-600 shadow-md hidden">春季県大会1回戦をスキップ</button>
<button id="skip-spring-main-btn" class="bg-teal-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-600 shadow-md hidden">春季県大会2回戦以降をスキップ</button>


            <div id="autumn-controls" class="text-center my-4 hidden">
                <button id="start-ranking-playoffs-btn" class="bg-purple-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-purple-700 shadow-md hidden">
                    地区内順位決定戦へ進む
                </button>
                <button id="start-main-tournament-btn" class="bg-teal-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-teal-700 shadow-md hidden">
                    県大会本戦へ進む
                </button>

            </div>

            

<div id="region-map-section" class="display-card hidden scorebook-font">
                 <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">地区別 勝ち残り状況</h2>
                 <div id="region-map-container" class="w-full"></div>
            </div>
             <div id="namco-news-section" class="hidden display-card border-2 border-orange-400">
                 <h2 class="text-xl font-bold text-orange-600 mb-3 text-center">ナムコグループからのお知らせ</h2>
                 <div id="namco-news-content" class="space-y-2"></div>
             </div>
            <div class="flex justify-between items-start mb-4">
                <div>
                    <button id="generate-summary-btn" class="hidden bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 shadow-md">
                        ここまでの大会ハイライト記事を生成
                    </button>
                    <button id="next-tournament-btn" class="hidden bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 shadow-md">
                        次の大会へ進む
                    </button>
                </div>
               <div class="ml-auto">
                    <div class="flex items-center justify-end space-x-2">
                       
<button id="skip-r1-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">1回戦スキップ</button>
<button id="skip-r2-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">2回戦スキップ</button>
<button id="skip-r3-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">3回戦スキップ</button>
<button id="skip-r4-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">4回戦スキップ</button>
<button id="skip-r5-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">準々決勝スキップ</button>
<button id="skip-r6-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">準決勝スキップ</button>
<button id="skip-final-btn" class="hidden bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 shadow-md">決勝スキップ</button>

<button id="generate-summary-btn" class="hidden bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 shadow-md">
    準々決勝(R5) 展望記事を生成
</button>


                        <span id="save-feedback" class="text-gray-600 font-bold opacity-0 transition-opacity duration-500"></span>
<button id="show-matome-site-btn" class="bg-orange-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-600 shadow-md">
    📰 まとめ
    </button>
                        

   <button id="open-settings-btn" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 shadow-md">⚙️ 設定</button>
<button id="save-btn" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-700 shadow-md">セーブ</button>
                        <button id="reset-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 shadow-md">リセット</button>
                    </div>
                    <div id="skip-loader-container" class="h-6 text-right mt-1">
                         <span id="skip-loader" class="hidden text-sm text-gray-600 font-bold">試合を進行しています...</span>
                    </div>
                </div>
            </div>
            <div id="main-bracket-wrapper" class="display-card scorebook-font">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">トーナメント表</h2>
                <div class="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4 rounded-md text-sm">
                    <p><b>PCでの表示について:</b> トーナメント表の全体が表示されない場合は、表のエリア内でマウスのホイールを回しながら <b>Shiftキー</b> を押すか、表の下に表示されるスクロールバーを直接ドラッグすることで、左右にスクロールできます。</p>
                </div>
                <div id="main-bracket-container"></div>
            </div>
            <div id="news-section" class="display-card">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">注目ニュース</h2>
                <div id="news-articles" class="space-y-4">
                    <p class="text-gray-500 text-center">まだニュースはありません。</p>
                </div>
            </div>
             <div id="daiya-bbs-section" class="hidden display-card border-4 border-green-600">
                 <h2 id="daiya-bbs-title" class="text-2xl font-bold text-green-800 mb-4 text-center">【特設】代矢東 応援掲示板</h2>
                 <div id="daiya-bbs-comments" class="space-y-3">
                     <p class="text-gray-500 text-center">まだ反応はありません。</p>
                 </div>
             </div>
             <div id="bbs-section" class="display-card">
                 <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">掲示板の反応</h2>
<div class="mb-4 p-4 border rounded-lg bg-white">
    <form id="main-comment-form">
        <textarea id="main-comment-textarea" class="w-full p-2 border rounded" rows="2" placeholder="コメントを書き込む... (例: 今日の姫川はレベチだったわ！)" required></textarea>
        <div class="text-right mt-2">
            <button type="submit" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">投稿する</button>
        </div>
    </form>
</div>
                 <div id="bbs-comments" class="space-y-3">
                     <p class="text-gray-500 text-center">まだ反応はありません。</p>
                 </div>
             </div>
        </div>
    </div>

    <div id="news-modal" class="fixed inset-0 z-50 hidden items-center justify-center">
        <div id="modal-bg" class="absolute inset-0"></div>
        <div class="relative bg-white rounded-lg shadow-xl max-w-2xl w-full m-4">
            <div class="p-6 modal-body-scroll">
                <h3 id="modal-title" class="text-2xl font-bold text-gray-900"></h3>
                <div id="modal-meta" class="text-gray-400 text-sm mt-2 flex items-center gap-4"></div>
                <p id="modal-body" class="mt-4 text-gray-600 whitespace-pre-wrap"></p>
            </div>
            <button id="modal-close" class="absolute top-3 right-3 text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    
  
<div id="integrated-matome-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 hidden items-center justify-center z-[200]">
    <div class="bg-gray-100 p-2 md:p-4 rounded-lg shadow-xl w-full max-w-7xl max-h-[95vh] flex flex-col overflow-hidden">
        
        <div class="flex justify-between items-center mb-2 px-2 md:px-0">
            <h2 class="text-2xl md:text-3xl font-extrabold text-red-700 font-sans tracking-wide">
                <img src="koshien.jpg" alt="なんJスタジアム" class="h-10 md:h-12 inline-block mr-2">
                俺たちの甲子園速報＠なんJまとめ
            </h2>
            <button id="matome-modal-close-btn" class="text-gray-400 hover:text-gray-600">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>

        <div class="flex border-b border-gray-300 bg-white shadow-sm mb-3 text-sm md:text-base sticky top-0 z-10">
            <button class="matome-tab-btn active bg-blue-600 text-white py-2 px-4 rounded-t hover:bg-blue-700 transition-colors" data-tab="top">トップ</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="blog">このブログについて</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="twitter">Twitter</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="antenna">なんJアンテナ</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="baseball-mag">BaseBall MAG</button>
            </div>

        <div id="matome-content-area" class="flex-grow overflow-y-auto bg-gray-50 p-2 md:p-4 rounded-b-lg scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200">
            
            <div id="matome-tab-top" class="matome-tab-content grid grid-cols-1 md:grid-cols-3 gap-4 active">
                <div class="md:col-span-2 mb-4">
                    <button id="open-new-thread-modal-btn" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 shadow-md transition-all duration-150">
                        ＋ 新しいスレッドを立てる
                    </button>
                </div>
                <div class="md:col-span-2 space-y-4">
                    <div class="bg-white p-4 rounded-lg shadow-md">
                        <h3 class="text-lg font-bold text-gray-800 border-b pb-2 mb-3">🔥 本日の注目記事</h3>
                        <div id="matome-articles-container" class="space-y-2">
                            <div class="loader text-center py-8">記事を読み込んでいます...</div>
                        </div>
                    </div>

                    <div class="bg-white p-4 rounded-lg shadow-md">
                        <h3 class="text-lg font-bold text-gray-800 border-b pb-2 mb-3">✅ まとめ</h3>
                        <ul class="list-none space-y-1">
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">野球部員(14)「甲子園は興味ない」</a></li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">DeNA・ジャクソン、衝撃のスリーランホームランｗｗｗｗｗｗ</a></li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">【画像】「下着ディズニー」パスｗｗｗｗｗｗｗｗｗ</a></li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">【悲報】レンチンで簡単に旨いポテチ味付けられるライフハックがヤバイ</a></li>
                        </ul>
                    </div>
                </div>
                
                <div class="space-y-4">
                    <div class="bg-white p-2 rounded-lg shadow-md text-center">
                        <h3 class="text-md font-bold text-gray-800 border-b pb-1 mb-2">他社から乗り換えで</h3>
                        <img src="sumaho.jpg" alt="広告" class="w-full h-auto rounded">
                        <p class="text-sm text-gray-600 mt-1">人気スマホ<span class="text-xl font-bold text-red-600">500</span>円！</p>
                        <p class="text-xs text-gray-500">2025/8/31まで</p>
                    </div>

                    <div class="bg-white p-4 rounded-lg shadow-md">
                        <h3 class="text-lg font-bold text-gray-800 border-b pb-2 mb-3">💡 なんJアンテナ</h3>
                        <ul class="list-none space-y-1 text-sm">
                            <li><a href="#" class="text-gray-700 hover:text-blue-600">なんJ PRIDE: 巨人岡本和真(28) .300 40本 100打点</a></li>
                            <li><a href="#" class="text-gray-700 hover:text-blue-600">MLB NEWS: 大谷翔平、本日も二刀流で大活躍</a></li>
                            <li><a href="#" class="text-gray-700 hover:text-blue-600">まとめヒストリア: 昔のなんJスレを振り返る</a></li>
                        </ul>
                    </div>
                    
                </div>
            </div>

            <div id="matome-tab-blog" class="matome-tab-content hidden p-4 bg-white rounded-lg shadow-md">
                <h3 class="text-xl font-bold">このブログについて</h3>
                <p class="mt-2 text-gray-700">当ブログ「俺たちの甲子園速報＠なんJまとめ」は、架空の高校野球トーナメントと現実世界のなんJネタを融合させた、唯一無二のまとめサイトです。</p>
                <p class="mt-2 text-gray-700">野球に関する話題を中心に、時事ネタや芸能ニュース、学歴コンプレックスから派生する議論まで、なんJで話題になった様々なスレッドを独自の視点でまとめています。</p>
                <p class="mt-2 text-gray-700">管理人「甲子園の申し子」が、日夜巡回し、ホットな情報をお届けします。</p>
            </div>
            <div id="matome-tab-twitter" class="matome-tab-content hidden p-4 bg-white rounded-lg shadow-md">
                <h3 class="text-xl font-bold">Twitter</h3>
                <p class="mt-2 text-gray-700">@koshien_nanjのアカウントで、日々熱い実況をしています！</p>
                <div class="mt-4 bg-gray-100 p-3 rounded">
                    <p class="font-bold">なんJまとめ速報 @koshien_nanj</p>
                    <p class="text-sm mt-1">今日の試合も熱すぎる！○○高校、まさかの逆転サヨナラ勝ちｗｗｗ #高校野球 #甲子園 <span class="text-blue-500">#なんJ</span></p>
                    <p class="text-xs text-gray-500 mt-2">1時間前</p>
                </div>
                <div class="mt-4 bg-gray-100 p-3 rounded">
                    <p class="font-bold">なんJまとめ速報 @koshien_nanj</p>
                    <p class="text-sm mt-1">【悲報】ワイの応援してた高校、初戦敗退…今年はもう終わりや… <span class="text-blue-500">#甲子園の夏</span></p>
                    <p class="text-xs text-gray-500 mt-2">3時間前</p>
                </div>
            </div>
            <div id="bbs-thread-display-area" class="hidden p-4 bg-white rounded-lg shadow-md flex flex-col h-full">
                <div class="flex justify-between items-center border-b pb-3 mb-4">
                    <h3 id="bbs-thread-title" class="text-xl md:text-2xl font-bold text-gray-800"></h3>

<div>
                        <button id="retry-matome-thread-btn" class="bg-red-600 text-white font-bold py-1 px-3 rounded hover:bg-red-700 text-sm hidden" data-match-id="">
                            再生成
                        </button>

                    <button id="bbs-thread-back-btn" class="bg-blue-500 text-white font-bold py-1 px-3 rounded hover:bg-blue-600 text-sm">
                        一覧に戻る
                    </button>
                </div>
</div>
                <div id="bbs-thread-content" class="overflow-y-auto space-y-4 flex-grow">
                    <div class="loader text-center py-8">スレッドを読み込んでいます...</div>
                </div>
                <div class="mt-4 p-3 bg-gray-50 rounded-lg border-t text-sm text-gray-600">
                    <p>コメントは、AIによる自動生成です。特定の意見や人物を意図するものではありません。</p>
                </div>
            </div>

        </div>
    </div>
</div>

  <div id="confirm-modal" class="confirm-modal hidden">
        <div class="confirm-modal-content">
            <p id="confirm-modal-text" class="mb-4 text-lg"></p>
            <button id="confirm-ok" class="bg-red-600 text-white px-6 py-2 rounded-lg mr-2">はい</button>
            <button id="confirm-cancel" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">いいえ</button>
        </div>
    </div>

    <div id="details-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="details-modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-6xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">試合詳細入力</h3>
        <div id="details-modal-body" class="overflow-y-auto space-y-6 flex-grow pr-2"> {/* pr-2 を追加してスクロールバーとの隙間を作る */}
            </div>
        
                <div class="mt-6 text-center border-t pt-4">
            <button id="details-save" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 mr-4">
                この内容で保存
            </button>
            <button id="details-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-400">
                キャンセル
            </button>
        </div>
               
    </div>
</div>
            



    
    <div id="save-load-modal" class="save-load-modal hidden">
        <div class="save-load-modal-content">
            <div class="flex border-b">
                <button id="save-tab-btn" class="px-4 py-2 font-semibold border-b-2 border-blue-500">セーブ (合い言葉の発行)</button>
                <button id="load-tab-btn" class="px-4 py-2 text-gray-500">ロード (合い言葉の入力)</button>
            </div>
            <div id="save-tab-content" class="py-4">
                <p class="text-sm mb-2">現在の進行状況を保存するための「合い言葉」を発行します。下のボタンを押してください。</p>
                <button id="generate-save-code-btn" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700">合い言葉を発行</button>
                <div id="save-code-area" class="hidden mt-4">
                    <p class="text-sm font-bold text-green-600">合い言葉が発行されました。以下をコピーして安全な場所に保管してください。</p>
                    <div class="flex items-center mt-2">
                        <div id="save-code-output" class="flex-grow text-xs"></div>
                        <button id="copy-save-code-btn" class="ml-2 bg-gray-200 px-3 py-1 rounded text-xs font-semibold hover:bg-gray-300">コピー</button>
                    </div>
                    <p id="copy-feedback" class="text-xs text-green-600 mt-1 h-4"></p>
                </div>
            </div>
            <div id="load-tab-content" class="py-4 hidden">
                <p class="text-sm mb-2">保存した「合い言葉」を以下に貼り付けてください。</p>
                <textarea id="load-code-input" placeholder="合い言葉をここに貼り付け" class="w-full h-32 p-2 border rounded mb-2"></textarea>
                <button id="load-from-code-btn" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">このデータで再開する</button>
            </div>
             <div class="mt-4 text-right">
                 <button id="save-load-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
             </div>
        </div>
    </div>

    <div id="newspaper-modal" class="newspaper-modal hidden">
        <div class="newspaper-modal-content">
            <div id="newspaper-modal-body"></div>
            <div class="mt-4 text-center">
                <button id="newspaper-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
            </div>
        </div>
    </div>


<div id="feedback-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-[150]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記者への追加指示</h3>
        <div class="space-y-4">
            <div>
                <label for="feedback-include" class="block text-sm font-medium text-gray-700">✅ この要素を必ず含めてください</label>
                <textarea id="feedback-include" rows="4" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="例：殊勲打を放った〇〇選手のコメントを中心に。&#10;例：敗れた△△高校のエースの涙にも触れてほしい。"></textarea>
            </div>
            <div>
                <label for="feedback-exclude" class="block text-sm font-medium text-gray-700">❌ この要素・展開は避けてください</label>
                <textarea id="feedback-exclude" rows="3" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="例：監督の采配ミスという論調はもういい。&#10;例：ありきたりな「全員野球」という言葉は使わないで。"></textarea>
            </div>
        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="feedback-submit-btn" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">この指示で再生成</button>
            <button id="feedback-cancel-btn" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="review-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記事の最終確認・編集</h3>
        <div class="overflow-y-auto space-y-4 flex-grow">
            <div>
                <label for="review-title" class="block text-sm font-medium text-gray-700">タイトル</label>
                <input type="text" id="review-title" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div>
                <label for="review-body" class="block text-sm font-medium text-gray-700">本文</label>
                <textarea id="review-body" rows="15" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 whitespace-pre-wrap"></textarea>
            </div>
        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="review-save-btn" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">この記事で確定</button>
            <button id="review-cancel-btn" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="lottery-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 hidden items-center justify-center z-[200] font-sans">
    <div id="lottery-content" class="bg-white rounded-lg shadow-2xl w-full max-w-6xl h-[95vh] flex flex-col p-6">
        <h2 class="text-4xl font-bold text-center mb-4 scorebook-font text-gray-800 tracking-widest">夏の高校野球 組み合わせ抽選会</h2>
        <div id="lottery-stage" class="flex-grow bg-gray-800 rounded p-4 flex gap-4 overflow-hidden relative border-4 border-gray-600">
            <div class="w-1/3 flex flex-col items-center justify-between bg-gray-200 rounded-lg shadow-inner p-4">
                <div id="lottery-pot-container" class="w-full flex flex-col items-center">
                    <p id="pot-name" class="text-2xl font-bold text-gray-700 mb-2">Aシード</p>
                    <div id="lottery-pot" class="w-48 h-48 bg-red-800 border-4 border-yellow-400 text-white flex items-center justify-center text-5xl font-bold shadow-lg rounded-full cursor-pointer transition-transform duration-200 hover:scale-105">
                        抽選
                    </div>
                </div>
                <div id="drawn-team-container" class="w-full h-32 border-4 border-dashed border-gray-400 rounded-lg flex items-center justify-center opacity-0 bg-white">
                    <p id="drawn-team" class="text-4xl font-bold text-gray-800"></p>
                </div>
            </div>
            <div id="lottery-bracket" class="w-2/3 grid grid-cols-2 gap-x-4 h-full overflow-y-auto p-2 bg-gray-100 rounded-lg shadow-inner">
                <div id="lottery-bracket-left" class="space-y-1"></div>
                <div id="lottery-bracket-right" class="space-y-1"></div>
            </div>
        </div>
        <div class="h-32 flex flex-col justify-between pt-4">
            <div id="lottery-commentary" class="h-20 text-center text-2xl font-semibold text-gray-800 bg-yellow-100 border-2 border-yellow-300 rounded p-2 flex items-center justify-center">
                <p>静岡大会 抽選会へようこそ。主将は抽選箱をクリックしてクジを引いてください。</p>
            </div>
            <div id="lottery-controls" class="text-center">
    <button id="start-lottery-btn" class="bg-blue-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-blue-700">抽選を開始</button>
    <button id="skip-lottery-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 ml-4">スキップ</button>
</div>
        </div>
    </div>
</div>

<div id="analysis-modal" class="fixed inset-0 bg-black bg-opacity-90 hidden flex flex-col items-center justify-center z-[250] p-4 font-sans">
    <div class="w-full max-w-6xl h-full flex flex-col">
        <div class="flex-shrink-0 flex justify-between items-center mb-4">
            <div id="analysis-block-tabs" class="flex space-x-1 p-1 bg-gray-800 rounded-lg">
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="A">Aブロック</button>
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="B">Bブロック</button>
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="C">Cブロック</button>
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="D">Dブロック</button>
            </div>
            <button id="analysis-modal-close-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
        </div>
        
        <div id="analysis-stage" class="flex-grow bg-gray-900 rounded-lg relative overflow-hidden">
            </div>

        <div id="analysis-narration-box" class="flex-shrink-0 h-28 mt-4 bg-gray-800 border-t-2 border-cyan-500 rounded-b-lg p-4 overflow-y-auto">
            <p id="analysis-narration-text" class="text-white text-lg leading-relaxed whitespace-pre-wrap"></p>
        </div>
    </div>
</div>

<div id="interview-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-[300]">
    <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full p-6 m-4 animate-fade-in-up">
        <h3 class="text-2xl font-bold text-gray-900 mb-4 border-b pb-2">抽選会後 主将インタビュー</h3>
        <div id="interview-content" class="space-y-4 max-h-[60vh] overflow-y-auto"></div>
        <div class="text-center mt-6">
            <button id="close-interview-btn" class="bg-blue-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-blue-700">大会を始める</button>
        </div>
    </div>
</div>

<div id="new-thread-modal" class="new-thread-modal hidden">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">新規スレッド作成</h3>
        <div class="space-y-4">
            <div>
                <label for="new-thread-title" class="block text-sm font-medium text-gray-700">スレッドタイトル</label>
                <input type="text" id="new-thread-title" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="例：〇〇高校の鈴木、ガチで天才すぎる">
            </div>
            <div>
                <label for="new-thread-comment" class="block text-sm font-medium text-gray-700">本文 (>>1)</label>
                <textarea id="new-thread-comment" rows="6" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="例：1回戦のピッチング見たか？あれは本物だわ..."></textarea>
            </div>
        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="new-thread-submit" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 mr-4">
                スレを立てる
            </button>
            <button id="new-thread-cancel" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-400">
                キャンセル
            </button>
        </div>
    </div>
</div>

<div id="help-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記者付きトーナメント表 取扱説明書 (Ver. 秋/春対応版)</h3>
        <div class="overflow-y-auto space-y-6 flex-grow pr-4 text-gray-700">

            <div>
                <h4 class="font-bold text-lg text-blue-700 mb-2">はじめに：あなただけの高校野球史を創る</h4>
                <p class="text-sm">
                    このシミュレーターの目的は、単に試合の勝ち負けを決めることではありません。あなたの采配や入力した詳細な試合内容に基づき、AIがリアルタイムで「ニュース記事」「掲示板の反応」「まとめサイト風スレッド」、時には「密着ドキュメンタリー」を生成します。夏の甲子園、秋の新チーム、春の選抜へと続く一年間のドラマを通じて、あなただけの唯一無二の高校野球の歴史を創り上げ、その目撃者となることが、このゲームの最大の醍醐味です。
                </p>
            </div>

            <div>
                <h4 class="font-bold text-lg text-blue-700 mb-2">基本的なゲームの流れ</h4>
                <ol class="list-decimal list-inside space-y-2 text-sm">
                    <li><strong>トーナメント開始:</strong> 「新しいトーナメントを開始」ボタンでゲームを始めます。初回は夏の静岡県大会からスタートします。抽選会イベントを経て、組み合わせが決定されます。</li>
                    <li><strong>スコア入力:</strong> トーナメント表の各試合カードに、半角数字で最終スコアを入力します。</li>
                    <li><strong>勝者決定:</strong> スコア入力後、勝った方のチームの青い「▶」ボタンを押します。</li>
                    <li><strong>AIコンテンツ生成:</strong> 勝者が決まると、AIが自動で試合に関する「ニュース記事」や「掲示板の反応」を生成します。（設定でON/OFF可能）</li>
                    <li><strong>詳細入力 (任意・推奨):</strong> 試合カードの「詳細入力」ボタンから、イニングスコアや個人成績を入力すると、AIが生成する物語のリアリティと深みが格段に向上します。</li>
                    <li><strong>大会進行:</strong> 全ての試合が終了すると、優勝チームが決定します。夏の大会終了後は自動的に秋の大会へ、秋の後は春へ、春の後は次の年の夏へと進みます。</li>
                    <li><strong>セーブ＆ロード:</strong> 「セーブ」ボタンでいつでも進行状況を「合い言葉」として保存できます。「再開」ボタンから「合い言葉」を入力すれば、中断したところから再開できます。</li>
                </ol>
            </div>

            <div>
                <h4 class="font-bold text-lg text-orange-700 mb-2">【重要】一年間の大会サイクルとルール</h4>
                <p class="text-sm mb-3">
                    この世界では、高校野球の一年間（夏→秋→春）が自動で進行します。各大会には異なる目的とルールがあり、それぞれが次の大会のシード権などに影響します。
                </p>
                <div class="space-y-4">
                    <div class="p-4 border rounded-lg bg-yellow-50">
                        <h5 class="font-semibold text-gray-800">夏の大会 (甲子園への道)</h5>
                        <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                            <li>3年生にとって最後の大会。64校による一発勝負のトーナメント。</li>
                            <li>春季大会のベスト8がシード校となります。</li>
                            <li>優勝校は夏の甲子園に出場したとみなされ、AIがその全国での戦績（例: 全国ベスト8、甲子園初戦敗退など）を自動でシミュレートし、記録します。</li>
                            <li>大会前には組み合わせ抽選会イベントが発生します。</li>
                        </ul>
                    </div>

                    <div class="p-4 border rounded-lg bg-purple-50">
                        <h5 class="font-semibold text-gray-800">秋の大会 (新チーム始動・センバツへの序章)</h5>
                        <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                            <li>1,2年生の新チームで挑む最初の公式戦。</li>
                            <li>まず、東部・中部・西部・伊豆の4地区に分かれて地区予選を行います。
                                <div class="mt-2 mb-2 p-2 bg-purple-100 rounded text-xs border border-purple-300">
                                    <p class="font-semibold mb-1">地区予選の仕組み:</p>
                                    <p class="mb-1"><strong>東部・中部・西部地区 (各5枠):</strong></p>
                                    <pre class="whitespace-pre-wrap leading-tight">
[地区20チーム]
    │
    ├─▶ [ブロックA (5)] ─▶ 優勝 (県) / 準優勝 ┐
    ├─▶ [ブロックB (5)] ─▶ 優勝 (県) / 準優勝 ┤
    ├─▶ [ブロックC (5)] ─▶ 優勝 (県) / 準優勝 ┼─▶ [第5代表決定戦 (4)] ─▶ 優勝 (県)
    └─▶ [ブロックD (5)] ─▶ 優勝 (県) / 準優勝 ┘   (敗者復活)</pre>
                                    <p class="mt-1"><strong>伊豆地区 (1枠):</strong></p>
                                    <pre class="whitespace-pre-wrap leading-tight">[伊豆4チーム] ─▶ [トーナメント] ─▶ 優勝 (県)</pre>
                                </div>
                            </li>
                            <li>各地区予選を勝ち抜いた計16チームが県大会本戦 (トーナメント) に進出します。
                                <div class="mt-2 mb-2 p-2 bg-purple-100 rounded text-xs border border-purple-300">
                                    <p class="font-semibold mb-1">県大会本戦 (16チーム):</p>
                                    <pre class="whitespace-pre-wrap leading-tight">
    ┌─ 東部代表 (5) ┐
    ├─ 中部代表 (5) ┤
    ├─ 西部代表 (5) ┼─▶ [県大会 (16チームT)] ─▶ 優勝/準優勝 (センバツ有力)
    └─ 伊豆代表 (1) ┘                       └─▶ ベスト8以上 (春季シード)</pre>
                                </div>
                            </li>
                            <li>県大会の**優勝・準優勝校**は、春のセンバツ甲子園への出場権を得る可能性があります（AIが確率で判定）。</li>
                            <li>県大会ベスト8以上の成績を収めると、次の**春季大会のシード権**を獲得できます。</li>
                        </ul>
                    </div>

                    <div class="p-4 border rounded-lg bg-green-50">
                        <h5 class="font-semibold text-gray-800">春の大会 (夏のシード権獲得戦)</h5>
                        <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                            <li>夏の大会の前哨戦となる重要な大会。</li>
                            <li>秋季大会ベスト8のチームはシード校となり、県大会2回戦から登場します。</li>
                            <li>それ以外の全チームは、まず地区予選に参加し、各地区代表枠 (東5, 中5, 西5, 伊豆1) を争います。</li>
                            <li>地区予選を突破した16チームが、県大会1回戦で対戦します。</li>
                            <li>1回戦の勝者8チームが、2回戦で待つシード8チームと対戦します（計16チームによる本戦トーナメント）。</li>
                            <li>この大会で**ベスト8**以上の成績を収めると、次の**夏の大会のシード権**を獲得できます。
                                <div class="mt-2 mb-2 p-2 bg-green-100 rounded text-xs border border-green-300">
                                    <p class="font-semibold mb-1">県大会の仕組み:</p>
                                    {/* Mermaid Diagram Code Block - Requires Mermaid.js library */}
                                    <pre><code class="language-mermaid">
graph TD
    subgraph 県大会
        R1[1回戦 (予選突破16チーム)] --> |勝者8チーム| R2
        subgraph 本戦トーナメント
            S[シード8チーム (秋ベスト8)] --> R2{2回戦 (16チーム)}
            R2 --> QF{準々決勝 (ベスト8)}
            QF --> SF{準決勝 (ベスト4)}
            SF --> F{決勝}
        end
        QF --▶ |夏のシード権獲得| SumSeed(夏の大会シード権)
    end

    subgraph 地区予選
        O[シード以外のチーム] --> RegQ{地区予選}
        RegQ --> |16チーム| R1
    end

    style S fill:#f9f,stroke:#333,stroke-width:2px
    style SumSeed fill:#ccf,stroke:#333,stroke-width:2px
                                    </code></pre>
                                    <p class="mt-1 text-gray-500">(図の説明) シード校は2回戦から登場。地区予選突破組は1回戦から戦い、勝ち上がるとシード校と対戦。ベスト8以上で夏のシード権獲得。</p>
                                </div>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>

            <div>
                <h4 class="font-bold text-lg text-teal-700 mb-2">【最重要】詳細入力：物語を深化させる鍵</h4>
                <p class="text-sm mb-3">
                    試合結果のスコアだけでなく、「詳細入力」を行うことで、AIが生成する記事やコメントの質が劇的に向上し、より深みのある物語が生まれます。面倒でも、ぜひ入力してみてください。
                </p>
                <ul class="list-disc list-inside space-y-2 text-sm bg-teal-50 p-4 rounded-lg">
                    <li><strong>イニングスコア:</strong> 試合展開をAIに伝えます。「初回に大量得点した試合」と「9回に逆転サヨナラした試合」では、生成される記事のドラマ性が全く異なります。延長戦は「+回」ボタンで追加できます。</li>
                    <li><strong>打撃成績:</strong>
                        <ul class="list-circle list-inside ml-4 text-xs">
                            <li>**打席結果:** プルダウンから結果・方向・打点などを選択します。1イニングに複数打席あった場合は「+2打席目を追加」で入力できます。</li>
                            <li>**走塁:** 「+走者プレーを追加」で盗塁、進塁、走塁死などを入力できます。</li>
                            <li>**出場:** 代打・代走・守備交代などの情報は、交代選手の活躍を描写する上で重要です。</li>
                            <li>AIはここでの入力に基づき、その試合のヒーローを特定し、記事の中心人物として描写します。</li>
                        </ul>
                    </li>
                    <li><strong>投手成績:</strong> 投手名、投球回、失点、奪三振などを入力します。先発完投、リリーフ成功、炎上など、投手の活躍や苦闘が記事に反映されます。「+投手を追加」で継投も記録できます。</li>
                    <li><strong>試合の決め手 (トーナメント表のテキストエリア):</strong> スコア入力欄の下にある小さなテキストエリアです。ここに**最も伝えたい試合のハイライト**（例：「エース〇〇、気迫の150球完投勝利」「伏兵△△のサヨナラ打」など）を簡潔に入力すると、AIは他のどの情報よりもこれを**最優先**し、記事全体のテーマとして扱います。</li>
                </ul>
                <p class="text-xs mt-2 text-gray-600">※詳細入力画面の「先攻・後攻を入れ替え」ボタンで、入力内容ごとチームを入れ替えられます。</p>
                <p class="text-xs mt-1 text-gray-600">※スコア入力欄の横にある「🎲」ボタンで、現在のスコアに基づいてAIがおまかせで詳細内容を自動生成することも可能です。</p>
            </div>

            <div>
                <h4 class="font-bold text-lg text-indigo-700 mb-2">AIが生成するコンテンツ</h4>
                <ul class="list-disc list-inside space-y-2 text-sm">
                    <li><strong>ニュース記事:</strong> 試合結果や大会の展望、時にはスキャンダル疑惑(!)など、様々な記事が自動生成されます。「本文」ボタンで内容を読めます。記事にカーソルを合わせると表示される「再生成」ボタンから、AIに追加指示を与えて記事を書き直させることも可能です（フィードバック機能）。</li>
                    <li><strong>掲示板の反応:</strong> AIが匿名掲示板のファンになりきり、試合結果やニュースに対してリアルなコメントを生成します。あなたもコメントを投稿でき、AIファンがそれに返信してくれます。</li>
                    <li><strong>まとめサイト風スレッド:</strong> 「📰 まとめ」ボタンからアクセスできるモーダル内で、現実のニュースとゲーム内の試合結果が混在した、なんJまとめサイト風の表示が楽しめます。各記事をクリックすると、その話題に関するAI生成の掲示板スレッドを読むことができます。</li>
                    <li><strong>ナムコグループニュース:</strong> 系列校（765総合、283学園など）の試合結果や組み合わせに関する、企業公式発表風のお知らせが表示されることがあります。</li>
                    <li><strong>スポーツ新聞:</strong> 大会が進むと（準々決勝以降）、AIがその日のハイライトを一面記事にしたスポーツ新聞風のコンテンツを生成することがあります。「新聞を読む」ボタンで表示できます。</li>
                    <li><strong>密着ドキュメンタリー:</strong> 特定のチーム（強豪、古豪、逆境校など）に焦点を当てたドキュメンタリー記事が生成されることがあります。試合の勝敗に応じて連載形式で物語が進行します。</li>
                </ul>
            </div>

             <div>
                <h4 class="font-bold text-lg text-pink-700 mb-2">その他の機能</h4>
                <ul class="list-disc list-inside space-y-2 text-sm">
                    <li><strong>チームステータス:</strong> トーナメント表のチーム名をクリックすると、そのチームの過去の最高成績や直近の成績、獲得した称号（例：ジャイアントキラー）などを確認できます。</li>
                    <li><strong>スキップ機能:</strong> 各大会やラウンドごとに用意された「スキップ」ボタンを使うと、試合結果を自動で（ランク差などを考慮して）生成し、大会を高速で進行させることができます。</li>
                    <li><strong>設定:</strong> 画面右上の「⚙️ 設定」ボタンから、ニュース記事や掲示板コメントの自動生成をON/OFFできます。</li>
                    <li><strong>抽選会/勢力図分析:</strong> 夏の大会開始時には抽選会イベントが、抽選後には各ブロックの勢力図をAIが分析・解説するアニメーションが表示されます。</li>
                 </ul>
            </div>

            <div>
                <h4 class="font-bold text-lg text-red-700 mb-2">トラブルシューティング</h4>
                <ul class="list-disc list-inside space-y-2 text-sm">
                    <li><strong>エラーで動作がおかしくなった / クラッシュする:</strong> 最も多い原因は、ブラウザに保存されている古いセーブデータと、最新版のゲームコードの間で矛盾が生じていることです。**「リセット」ボタンを押して一度完全にデータを消去してから**「新しいトーナメントを開始」すると解決することがほとんどです。開発中の仕様変更後は特にリセットをお試しください。</li>
                    <li><strong>AIの記事やコメントがおかしい / 事実と違う:</strong> AIに与える情報が不足しているか、AIが稀に勘違いをしている可能性があります。
                        <ul class="list-circle list-inside ml-4 text-xs">
                            <li>記事の場合は、「再生成」ボタンからフィードバックを与えてみてください。</li>
                            <li>思ったような記事にならない場合、詳細入力でより多くの情報（特に敗れたチームの成績や、活躍した選手名）を具体的に入力したり、「試合の決め手」欄を活用したりすると改善されることがあります。</li>
                        </ul>
                    </li>
                     <li><strong>セーブデータ（合い言葉）が読み込めない:</strong> コードが更新されると、古いバージョンの合い言葉は読み込めなくなる場合があります。ご了承ください。</li>
                </ul>
            </div>

       </div> <div id="tournament-animation-section" class="mt-6 border-t pt-4">

                <h4 class="font-bold text-lg text-purple-700 mb-3 text-center">図解アニメーションで見る大会システム</h4>

                <div class="flex justify-center space-x-4 mb-4">

                    <button id="show-autumn-anim-btn" class="bg-purple-500 text-white px-4 py-2 rounded hover:bg-purple-600">🍂 秋季大会を見る</button>

                    <button id="show-spring-anim-btn" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">🌸 春季大会を見る</button>

                </div>

                <div id="animation-stage" class="bg-gray-100 p-4 rounded min-h-[300px] border relative overflow-hidden flex flex-col justify-center items-center">

                    <p id="anim-placeholder" class="text-gray-500">上のボタンを押してアニメーションを開始</p>

                </div>

                <p id="animation-narration" class="mt-3 text-center text-sm font-semibold h-10"></p>

                <div class="flex justify-center space-x-4 mt-3">

                    <button id="prev-step-btn" class="bg-gray-400 text-white px-4 py-1 rounded hover:bg-gray-500 disabled:opacity-50" disabled>＜ 前へ</button>

                    <button id="next-step-btn" class="bg-blue-500 text-white px-4 py-1 rounded hover:bg-blue-600 disabled:opacity-50" disabled>次へ ＞</button>

                </div>

            </div>

            </div> <div class="mt-6 text-center border-t pt-4">

            <button id="help-modal-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>

        </div>

    </div> </div>

<div id="player-stats-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[170]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 class="text-xl font-bold text-gray-800">個人通算成績</h3>
            <button id="player-stats-modal-close" class="text-gray-400 hover:text-gray-600 text-3xl">&times;</button>
        </div>
        
        <div id="player-stats-modal-body" class="overflow-y-auto flex-grow space-y-6 p-2">
            <div class="loader text-center py-16">選手データを読み込み中...</div>
        </div>
    </div>
</div>

<div id="team-stats-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[170]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-5xl max-h-[90vh] flex flex-col">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 id="team-stats-modal-title" class="text-2xl font-bold text-gray-800">（チーム名） 通算成績</h3>
            <button id="team-stats-modal-close" class="text-gray-400 hover:text-gray-600 text-3xl">&times;</button>
        </div>
        
        <div id="team-stats-modal-body" class="overflow-y-auto flex-grow p-2">
            <div class="flex border-b mb-4 sticky top-0 bg-white z-10">
                <button class="team-stats-tab-btn active" data-tab="stats">
                    通算成績
                </button>
                <button class="team-stats-tab-btn" data-tab="lineups">
                    試合別スタメン
                </button>
            </div>

            <div id="team-stats-tab-content-stats" class="team-stats-tab-content space-y-6">
                <div class="loader text-center py-16">選手データを読み込み中...</div>
            </div>
            
            <div id="team-stats-tab-content-lineups" class="team-stats-tab-content hidden space-y-4">
                <div class="loader text-center py-16">スタメン履歴を読み込み中...</div>
            </div>
        </div>
        
    </div>
</div>

<div id="team-status-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">


    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] flex flex-col">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 id="status-modal-team-name" class="text-2xl font-bold text-gray-800"></h3>
            <button id="status-modal-close" class="text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        
        <div class="space-y-4 overflow-y-auto pr-2">
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">最高戦績</h4>
                <p id="status-modal-best" class="text-lg text-amber-600 font-bold"></p>
            </div>
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">直近の成績</h4>
                <div id="status-modal-history" class="space-y-1 text-gray-700"></div>
            </div>
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">称号</h4>
                <div id="status-modal-traits" class="flex flex-wrap gap-2"></div>
            </div>
            
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider mb-2">今大会 チームチャート</h4>
                <div id="team-chart-container" class="relative" style="height: 300px;">
                    <canvas id="team-radar-chart"></canvas>
                </div>
            </div>
            
            <div class="mt-4">
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">今大会 チーム成績 (数字)</h4>
                <p id="status-modal-team-stats" class="text-lg text-blue-700 font-bold"></p>
            </div>
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">チーム通算成績 (全大会)</h4>
                <p id="status-modal-career-stats" class="text-lg text-gray-800 font-bold"></p>
            </div>
            
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">監督</h4>
                <div id="status-modal-coach" class="text-gray-700"></div>
            </div>

<div id="status-modal-homepage-link-container" class="mt-6 border-t pt-4 text-center hidden">
                <a id="status-modal-homepage-link" class="inline-block bg-blue-700 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-800 transition-colors cursor-pointer">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5 inline-block -mt-1 mr-2">
                        <path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.665l3-3Z" />
                        <path d="M8.603 17.39a4 4 0 0 0 5.656-5.656l-3-3a4 4 0 0 0-.225-5.865.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.665l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 0 0 5.656 5.656Z" />
                    </svg>
                    公式ホームページへ
                </a>
            </div>

        </div>
        
    </div>
</div>
<script type="module">

const BATTING_RESULTS = {
    hits: ['安', '二塁打', '三塁打', '本塁打'],
    outs: ['三振', 'ゴロ', '飛', '邪', '直', '併殺'],
    walks: ['四球', '死球', '敬遠'],
    sacrifices: ['犠打', '犠飛', '犠失'], // ← ここに追加
    other: ['野選', 'エラー']
};
const DIRECTIONS = ['投', '捕', '一', '二', '三', '遊', '左', '中', '右'];
const RBIS = ['1点', '2点', '3点', '4点'];

    // --- ライバル関係と称号の定義 ---
    const RIVALRIES = [
        { teams: ["静岡", "掛川西"], type: "公立の覇権争い" },
        { teams: ["283学園", "静岡商業"], type: "伝統と王者の覇権対決" },
        { teams: ["765総合高校", "静岡"], type: "新旧王者対決" },
        { teams: ["静岡", "静岡商業"], type: "伝統の一戦" }
    ];
    const TITLES = {
        GIANT_KILLER: { id: 'giant_killer', name: 'ジャイアントキラー', desc: '格上の強豪校を倒した実績を持つ。' },
        REPECHAGE_KING: { id: 'repechage_king', name: '不屈の敗者復活組', desc: '敗者復活戦から這い上がってきた実績があり、非常に粘り強い。' },
        WALL_OF_TOKYO: { id: 'wall_of_tokyo', name: '西東京の壁', desc: '西東京地区に立ちはだかる絶対的強者。' } // 例
    };
const tournamentNameMap = { summer: '夏季大会', autumn: '秋季大会', spring: '春季大会' };

// ▼▼▼ このブロックをまるごと置き換える ▼▼▼
const SCANDAL_DEFINITIONS = [
    {
        id: 'overpractice',
        condition: (teamName) => ['A', 'B'].includes(calculateRank(teamName, tournamentState)),
        
        // 文字列から関数に変更
        rumorTitle: (teamName) => `【週刊熱闘】${teamName}に「違法練習」疑惑か？`,
        rumorBody: (teamName) => `強豪として知られる${teamName}だが、その強さの裏には、高校野球連盟が定める練習時間規定を大幅に超過するほどの猛練習があるというタレコミが本誌に寄せられた。深夜までバットの音が鳴り響くという近隣住民の証言もあり、今後の動向が注目される。`,
        
        consequences: {
            report: {
                // こちらも同様に関数に変更
                outcomeTitle: (teamName) => `【速報】${teamName}、練習規定違反で公式戦を辞退`,
                outcomeBody: (teamName) => `先日、週刊誌で報じられた${teamName}の練習時間規定違反問題で、高野連は調査の結果、違反の事実を認定。同校は事態を重く受け止め、今大会の残り試合を辞退することを発表した。`,
                applyEffect: (teamName, state) => {
        if (state.teamRecords[teamName]) {
            state.teamRecords[teamName].penalty = 'forfeit';
        }

        const currentMatch = findCurrentMatchForTeam(teamName, state);
        if (!currentMatch) return; // 該当する試合がなければ何もしない

        const opponent = currentMatch.team1 === teamName ? currentMatch.team2 : currentMatch.team1;

        // 相手がいない場合（シードなど）は、単に負け扱いにする
        if (!opponent) {
            currentMatch.winner = `(不戦敗)`;
            currentMatch.team1 = teamName;
            currentMatch.team2 = null;
            return;
        }

        // 不戦勝として試合結果を記録
        currentMatch.winner = opponent;
        currentMatch.summary = `${teamName}の不祥事による不戦勝`;

        if (currentMatch.team1 === opponent) {
            currentMatch.score1 = 'W'; // Win
            currentMatch.score2 = 'L'; // Lose
        } else {
            currentMatch.score1 = 'L';
            currentMatch.score2 = 'W';
        }

        // チーム記録を更新
        if(state.teamRecords[opponent]) state.teamRecords[opponent].wins++;
        if(state.teamRecords[teamName]) state.teamRecords[teamName].losses++;
        
        // 勝者を次のラウンドへ自動で進める
        advanceWinnerToNextRound(currentMatch, opponent, state);
    }
            },
            ignore: {
                outcomeTitle: (teamName) => `${teamName}の練習問題、高野連は「事実確認できず」`,
                outcomeBody: (teamName) => `先日、一部週刊誌で報じられた${teamName}の練習時間に関する疑惑に対し、高野連は「現時点で違反の事実は確認できなかった」と発表。噂は噂のまま、球児たちの夏は続く。`,
                applyEffect: (teamName, state) => { /* 何もしない */ }
            }
        }
    }
];
// ▲▲▲ ここまで置き換え ▲▲▲
    // --- DOM Elements ---
    const setupEl = document.getElementById('setup');
    const tournamentDisplayEl = document.getElementById('tournament-display');
    const teamsTextarea = document.getElementById('teams-list');
    const generateBtn = document.getElementById('generate-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const resetBtn = document.getElementById('reset-btn');
    const nextTournamentBtn = document.getElementById('next-tournament-btn');
    const saveBtn = document.getElementById('save-btn');
    const mainBracketContainer = document.getElementById('main-bracket-container');
    const mainBracketWrapper = document.getElementById('main-bracket-wrapper');
    const newsContainer = document.getElementById('news-articles');
    const bbsCommentsContainer = document.getElementById('bbs-comments');
    const daiyaBbsSection = document.getElementById('daiya-bbs-section');
    const daiyaBbsCommentsContainer = document.getElementById('daiya-bbs-comments');
    const namcoNewsSection = document.getElementById('namco-news-section');
    const namcoNewsContent = document.getElementById('namco-news-content');
    const tournamentYearDisplay = document.getElementById('tournament-year-display');

    let skipR1Btn = document.getElementById('skip-r1-btn');
    let skipR2Btn = document.getElementById('skip-r2-btn');
    let skipR3Btn = document.getElementById('skip-r3-btn');
    let skipR4Btn = document.getElementById('skip-r4-btn');
    let skipR5Btn = document.getElementById('skip-r5-btn');
    let skipR6Btn = document.getElementById('skip-r6-btn'); // ★ 新規追加
    let skipFinalBtn = document.getElementById('skip-final-btn');
    let generateSummaryBtn = document.getElementById('generate-summary-btn');
    let skipLoader = document.getElementById('skip-loader');

    // Autumn Tournament UI
    const autumnRegionalContainer = document.getElementById('autumn-regional-blocks-container');
    const autumnRankingContainer = document.getElementById('autumn-ranking-playoffs-container');
    const autumnControls = document.getElementById('autumn-controls');
    const startRankingPlayoffsBtn = document.getElementById('start-ranking-playoffs-btn');
    const startMainTournamentBtn = document.getElementById('start-main-tournament-btn');
// ▼▼▼ ここから3行追加 ▼▼▼
const skipAutumnBlocksBtn = document.getElementById('skip-autumn-blocks-btn');
const skipAutumnRankingBtn = document.getElementById('skip-autumn-ranking-btn');
const skipAutumnMainBtn = document.getElementById('skip-autumn-main-btn');
// ▲▲▲ ここまで追加 ▲▲▲
// ▼▼▼ ここから3行追加 ▼▼▼
const skipSpringQualifiersBtn = document.getElementById('skip-spring-qualifiers-btn');
const skipSpringRound1Btn = document.getElementById('skip-spring-round1-btn');
const skipSpringMainBtn = document.getElementById('skip-spring-main-btn');
// ▲▲▲ ここまで追加 ▲▲▲
    // Modals
    const newsModal = document.getElementById('news-modal');
    const modalBg = document.getElementById('modal-bg');
    const modalClose = document.getElementById('modal-close');
    const confirmModal = document.getElementById('confirm-modal');
    const detailsModal = document.getElementById('details-modal');
    const saveLoadModal = document.getElementById('save-load-modal');
    const saveTabBtn = document.getElementById('save-tab-btn');
    const loadTabBtn = document.getElementById('load-tab-btn');
    const saveTabContent = document.getElementById('save-tab-content');
    const loadTabContent = document.getElementById('load-tab-content');
    const generateSaveCodeBtn = document.getElementById('generate-save-code-btn');
    const loadFromCodeBtn = document.getElementById('load-from-code-btn');
    const saveLoadCloseBtn = document.getElementById('save-load-close');
    const copySaveCodeBtn = document.getElementById('copy-save-code-btn');
    const newspaperModal = document.getElementById('newspaper-modal');
    const newspaperModalBody = document.getElementById('newspaper-modal-body');
    const newspaperCloseBtn = document.getElementById('newspaper-close');

    
    // --- State Management ---
    let tournamentState = {};
    let currentMatchIdForDetails = null;
    let articleForRegeneration = null; 
    let soundEffects = {};
let currentBlock = 'A';
    const UNDERDOG_TEAMS = ["虎府島総合", "浜松特支", "川根", "伊豆総合", "湖西", "小山", "新居", "熱海", "伊豆中央", "島田", "島田工業", "裾野"];
    const POWERHOUSE_TEAMS = ["283学園", "常葉菊川", "静岡", "掛川西", "静岡商業", "聖隷クリストファー", "765総合高校"];
　　const POWERHOUSE_REVIVAL_TEAMS = ["浜松商業", "静清", "飛龍"];
　　const ONE_MAN_TEAMS = ["富士宮北"];

// ▼▼▼ このオブジェクトで、既存のSoundManagerを完全に置き換えてください ▼▼▼
// ▼▼▼ サウンド管理システム ▼▼▼
// ▼▼▼ サウンド管理システム（ローカルファイル対応・最終完成版）▼▼▼
// ▼▼▼ BGM管理に特化した新しいサウンドマネージャー ▼▼▼
// ▼▼▼ BGMの音量調整機能付きサウンドマネージャー ▼▼▼
const SoundManager = {
    bgm: null,
    isReady: false,
    volume: 0.07, // BGMの音量を設定 (0.0がミュート, 1.0が最大)

    init() {
        this.bgm = document.getElementById('lottery-bgm');
        
        const unlockAudio = () => {
            if (!this.isReady && this.bgm) {
                this.isReady = true;
                this.bgm.volume = this.volume; // 初期音量を設定
                this.bgm.play().catch(e => console.error("BGM unlock failed:", e));
                this.bgm.pause();
                console.log("BGM ready.");
            }
            document.body.removeEventListener('click', unlockAudio);
        };
        
        document.body.addEventListener('click', unlockAudio, { once: true });
    },

    startBgm() {
        if (this.isReady && this.bgm) {
            this.bgm.volume = this.volume; // 再生前に音量を設定
            this.bgm.currentTime = 0;
            this.bgm.play().catch(e => console.error("BGM play failed:", e));
        }
    },

    stopBgm() {
        if (this.bgm) {
            this.bgm.pause();
            this.bgm.currentTime = 0;
        }
    }
};
// ▲▲▲
// ▲▲▲
// ▲▲▲ ▲▲▲
// ▲▲▲

    // ▼▼▼ 100種類の日本の苗字リスト ▼▼▼
const JAPANESE_SURNAMES = [
    "佐藤", "鈴木", "高橋", "田中", "伊藤", "渡辺", "山本", "中村", "小林", "加藤",
    "吉田", "山田", "佐々木", "山口", "松本", "井上", "木村", "林", "斎藤", "清水",
    "山崎", "森", "池田", "橋本", "阿部", "石川", "山下", "中島", "石井", "小川",
    "前田", "岡田", "長谷川", "藤田", "後藤", "村上", "近藤", "坂本", "遠藤", "青木",
    "藤井", "西村", "三浦", "岡本", "松田", "中川", "中野", "原田", "小野", "田村",
    "竹内", "金子", "和田", "中山", "石田", "上田", "森田", "原", "柴田", "酒井",
    "工藤", "横山", "宮崎", "宮本", "内田", "高木", "安藤", "谷口", "大野", "丸山",
    "今井", "高田", "藤原", "武田", "松井", "杉山", "村田", "大塚", "千葉", "岩崎",
    "桜井", "野口", "松尾", "菊地", "野村", "新井", "渡部", "佐野", "安田", "宮田",
    "小島", "大西", "杉本", "市川", "古川", "久保", "川崎", "飯田", "中田", "堀"
];

// ▼▼▼ このブロックを「新規追加」(11984行目あたり) ▼▼▼
const FACILITY_DATA = {
    "ground": {
        title: "メイングラウンド",
        text: "甲子園と同じ黒土と天然芝を使用。両翼100m、センター122mの広さを誇り、ナイター設備も完備しています。",
        imgSrc: "https://images.unsplash.com/photo-1515512210878-38904790e8c7?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&q=80&w=1080"
    },
    "dome": {
        title: "屋内練習場「TSUBASA DOME」",
        text: "天候に左右されない全天候型ドーム。ブルペン4箇所、フリーバッティング3箇所を完備し、雨の日でも実戦的な練習が可能です。",
        imgSrc: "https://images.unsplash.com/photo-1578899653835-34a162d355e0?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&q=80&w=1080"
    },
    "data-lab": {
        title: "データ解析室",
        text: "天井監督のID野球の心臓部。全選手の投球・打撃フォームを常時モニタリングし、AIによる分析がリアルタイムで行われます。",
        imgSrc: "https://images.unsplash.com/photo-1551288049-bebda4e38f71?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&q=80&w=1080"
    }
};

// ▲▲▲ 置き換えここまで ▲▲▲
// ▼▼▼ このブロックをまるごと「新規追加」(1191行目あたり、JAPANESE_SURNAMES の下など) ▼▼▼
const TEAM_ROSTER_MASTER = {
    "283学園": [
        { number: "1", name: "白瀬", grade: 3, position: "投手", throwBat: "R/R", height: 184, weight: 82, origin: "東京シニア" },
        { number: "2", name: "有栖川", grade: 3, position: "捕手", throwBat: "R/L", height: 178, weight: 78, origin: "神奈川ボーイズ" },
        { number: "3", name: "姫川", grade: 3, position: "投手/一塁手", throwBat: "R/R", height: 182, weight: 80, origin: "大阪シニア" },
        { number: "4", name: "樋口", grade: 3, position: "二塁手", throwBat: "R/R", height: 170, weight: 68, origin: "静岡葵中学" },
        { number: "5", name: "八宮", grade: 2, position: "三塁手", throwBat: "R/R", height: 175, weight: 72, origin: "浜松ボーイズ" },
        { number: "6", name: "十王", grade: 3, position: "遊撃手", throwBat: "R/L", height: 176, weight: 70, origin: "名古屋ドリームス" },
        { number: "7", name: "芹沢", grade: 2, position: "外野手", throwBat: "R/S", height: 172, weight: 69, origin: "沼津シニア" },
        { number: "8", name: "花海佑", grade: 1, position: "外野手", throwBat: "R/R", height: 177, weight: 73, origin: "北海道シニア" },
        { number: "9", name: "花海咲", grade: 3, position: "外野手", throwBat: "L/L", height: 178, weight: 75, origin: "北海道シニア", isCaptain: true },
        { number: "10", name: "黛", grade: 2, position: "投手", throwBat: "R/R", height: 180, weight: 76, origin: "富士シニア" },
        { number: "11", name: "市川", grade: 2, position: "投手", throwBat: "L/L", height: 179, weight: 74, origin: "静岡蒲原中学" },
        { number: "12", name: "福丸", grade: 2, position: "捕手", throwBat: "R/R", height: 176, weight: 77, origin: "焼津リトルシニア" },
        { number: "13", name: "鈴木", grade: 2, position: "一塁手", throwBat: "R/L", height: 181, weight: 85, origin: "愛知ボーイズ" },
        { number: "14", name: "有村", grade: 1, position: "内野手", throwBat: "R/R", height: 173, weight: 67, origin: "福岡シニア" },
        { number: "15", name: "田中", grade: 3, position: "内野手", throwBat: "R/R", height: 174, weight: 70, origin: "静岡服織中学" },
        { number: "16", name: "大崎", grade: 1, position: "外野手", throwBat: "R/L", height: 170, weight: 68, origin: "三島リトルシニア" },
        { number: "17", name: "風野", grade: 2, position: "内野手", throwBat: "R/R", height: 169, weight: 65, origin: "新潟シニア" },
        { number: "18", name: "西城", grade: 2, position: "投手", throwBat: "R/R", height: 183, weight: 81, origin: "広島ボーイズ" },
        { number: "19", name: "浅倉", grade: 1, position: "内野手", throwBat: "R/R", height: 168, weight: 64, origin: "長崎シニア" },
        { number: "20", name: "杜野", grade: 1, position: "外野手", throwBat: "L/L", height: 171, weight: 67, origin: "宮城シニア" }
    ]
};
// ▲▲▲ 置き換えここまで ▲▲▲
// ▼▼▼ サウンド管理システム ▼▼▼

// ▲▲▲

// --- Team Master Data ---
    const TEAM_DATA = {
    "天竜": {
        name_yomi: "てんりゅう",
        region: "西部",
        type: "公立",
        deviation: 38,
        best: "県大会ベスト16",
        last: "県大会ベスト16",
        info: "創部3年目にしてベスト16入りを果たした期待の新興勢力。新任の志賀監督の下、挑戦者としてのびのびとプレーした昨年とは一転、今年は他校からのマークも厳しくなる。昨年の躍進がフロックでなかったことを証明できるか、真価が問われる夏となる。西部地域の学校からの甲子園での成績が乏しいため、突如現れた彗星に期待の声も多い。エースの三橋やリードオフマンの田島を筆頭に部員数は少ないながらも力のある選手も多い。チームとしての目標は昨年を超えるベスト8ではなく甲子園出場。西部地域の雄となるために、まずは今年、どこまで上位勢に食らいつけるかが正念場である。。",
        coach: { name: '志賀 剛', style: '育成上手', experience: '新任' }
    },
    "桐陽": {
        name_yomi: "とうよう",
        region: "東部",
        type: "私立",
        deviation: 80,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "元プロの元木監督を招聘し、強化に乗り出した新興私立。プロ流の厳しい練習はチーム内に軋轢も生んでいるが、個々の能力は飛躍的に向上しており、140km以上を計測する選手が6人もいるなど、そのポテンシャルは計り知れない。監督の指導方針がチームとして完全に噛み合った時、一気に大会の主役へ躍り出る可能性を秘めている。",
        coach: { name: '元木 大介', style: '積極打撃', experience: 'プロOB' }
    },
    "浜松商業": {
        name_yomi: "はままつしょうぎょう",
        region: "西部",
        type: "公立",
        deviation: 32,
        best: "甲子園優勝",
        last: "県大会2回戦",
        info: "30年前の甲子園優勝校として野球ファンの間では知名度のある高校。近年はナムコグループや新興私立の台頭により低迷しており、昔のような圧倒的な強さはないが、今もなお中堅レベルの実力校として虎視眈々と聖地を狙っている。輝かしい栄光を取り戻すべく、今大会での躍進に期待したいい。",
        coach: { name: '伊武 雅之', style: 'データ野球', experience: 'ベテラン' }
    },
    "初星学園": {
        name_yomi: "はつぼしがくえん",
        region: "中部",
        type: "私立",
        deviation: 110,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "全国で唯一アイドル科を持つ学校として知られている創立3年目のナムコグループ系列校。全国からアイドル科を目当てに受験する人も多く、学校としての注目度も高い。男女比では学校の特色も相まって驚異の8割が女子である。創部3年目の野球部としての設備はナムコグループ系列ということもあり整っており、直近の練習試合ではホームランも複数飛び出すなど、選手のポテンシャルも低くはない。練習ではアイドル科の生徒との合同トレーニングを組むこともあり、違う学科であれど、お互いアスリートの視点でアドバイスを送りあうなど学校の特色を活かした練習メニューもある。野球部で目立った実績はないが、アイドル科ではなく「野球の初星」と呼ばれるように躍進してほしい",
        coach: { name: '石川 実', style: '育成上手', experience: '中堅' }
    },
    "浜松特支": {
        name_yomi: "はままつとくし",
        region: "西部",
        type: "公立",
        deviation: 45,
        best: "なし",
        last: "なし",
        info: "創部一年目、全員1年生。県内初の試みとして、特別支援学校に設立された野球部。視覚障害、聴覚障害、知的障害、肢体不自由、病弱・身体虚弱の子どもを対象とした特別支援学校は、全国におよそ1100校ある。その中で高野連に加盟し、単独チームとして公式戦に出場しているのは、この浜松特別支援学校だけだ。部員たちは、野球のルールを覚えることや、仲間と声を掛け合うこと、その一つ一つが大きな挑戦だ。北村監督は、野球の技術以前に、彼らが野球というスポーツを心から楽しみ、自分を表現する喜びを知ってもらうにはどうすれば良いのか、答えのない問いに日々向き合っている。しかし、春の練習試合で今大会第一シードの283学園との招待試合で喫した『52-0』の大敗は、彼らから野球の楽しさを根こそぎ奪い去った。部室代わりの理科準備室には、彼らの野球ノートが置かれており、中を見ると「たのしくない」「こわい」といった文面が多く見受けられた。エラーをすれば下を向いて泣き出し、打席ではデッドボールを怖がって腰が引ける。そして、なにより知的障害を持った子が硬式野球を行うことについての安全性を問われる声が多々あった。北村監督は勝利ではなく『試合を成立させること』の絶望的な難しさに直面している。夏の目標は9回を戦い抜き、スコアボードに『0』以外の数字を灯すこと。それは甲子園出場よりも遥かに高く、そして切実な壁だ。",
        coach: { name: '北村 大輔', style: '全員野球', experience: '新任' }
    },
    "765総合高校": {
        name_yomi: "なむこそうごう",
        region: "中部",
        type: "私立",
        deviation: 75,
        best: "甲子園ベスト16",
        last: "県大会2回戦",
        info: "大手ナムコグループが母体となる、県内屈指の資金力と設備を誇る私立校。黒井監督の徹底した管理野球の下、個々の能力が高く、大崩れしない安定した戦いぶりが特徴。２年前には甲子園初出場も果たし、破竹の勢いでベスト16まで勝ち進み、一躍有名校となったのは記憶に新しいだろう。しかし昨年の夏は２回戦敗退、秋は初戦敗退、春も初戦敗退と苦しい時期が続いている。聖地を知るメンバーは今の3年生のみとなった今、逆襲を誓い再び甲子園を目指す。ノーシードではあるがその実力はシード校級であり今大会のダークホースと言っても過言ではないだろう",
        popularity: true,
        coach: { name: '黒井 崇男', style: '総合力', experience: 'ベテラン' }
    },
    "川根": {
        name_yomi: "かわね",
        region: "中部",
        type: "公立",
        deviation: 53,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "今年度限りでの閉校が決まっており、野球部にとってはこれが最後の夏となる。グラウンド脇では校舎の解体作業が進むという異例の環境だが、選手たちは動揺を見せず練習に打ち込む。監督・選手ともに大会終了後はそれぞれ別の道を歩むことになる。「母校の名を刻みたい」という想いは一つ。有終の美を飾るべく、チームの士気は非常に高い。",
        coach: { name: '鈴木 誠', style: '堅実', experience: 'ベテラン' }
    },
    "283学園": {
        name_yomi: "つばさがくえん",
        region: "西部",
        type: "私立",
        deviation: 60,
        best: "甲子園1回戦",
        last: "県優勝(甲子園初戦敗退)",
        info: "昨年度の県大会王者。愛称は「ツバガク」。エース白瀬、二刀流の姫川や十王、花海咲など１年次からのレギュラーメンバーを軸に投打のバランスが取れた強豪校。。しかし、初出場となった昨年の夏の甲子園では初戦の浦和学院戦に7-9で敗戦し涙を飲み、全国の壁を痛感した。新チームになってからは樋口や花海佑などの新戦力も台頭し、春の大会では圧倒的な戦いで優勝し、第１シードに君臨。名将・天井監督は、昨年の経験を糧に、県内連覇とその先の「全国での一勝」を見据える。王者としてのプレッシャーをはねのけ、再び頂点に立てるか注目が集まる。",
        popularity: true,
        coach: { name: '天井 努', style: 'ID野球', experience: '名将' }
    },
    "島田工業": {
        name_yomi: "しまだこうぎょう",
        region: "中部",
        type: "公立",
        deviation: 41,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "県内でも有数の工業高校で、部員の多くが技術職を目指している。実習などで練習時間が限られるハンデを、田中監督が叩き込む「根性野球」でカバー。最後まで諦めない粘り強さがチームの持ち味。スター選手は不在だが、一丸となった時の結束力は高く、強豪校にとってはやりにくい相手として知られる。。",
        coach: { name: '田中 鉄平', style: '根性野球', experience: 'ベテラン' }
    },
    "磐田南": {
        name_yomi: "いわたみなみ",
        region: "西部",
        type: "公立",
        deviation: 63,
        best: "甲子園出場",
        last: "初戦敗退",
        info: "全国トップクラスの進学校。野球は「文武両道」を掲げる課外活動の一環だが、その実力は侮れない。選手個々の野球IQが高く、データを駆使した緻密な戦術を得意とする。知性派集団が、夏のトーナメントに旋風を巻き起こす。余談だが、全国制覇の経験を持つサッカー部が応援に駆けつけることもあり、その独特の応援スタイルも名物となっている。ちなみにサッカー形式の野球応援が珍しいということで、これを目当てに試合に見に来るという隠れファンも多い。",
        coach: { name: '中田 譲二', style: '守備重視', experience: '中堅' }
    },
    "三島北": {
        name_yomi: "みしまきた",
        region: "東部",
        type: "公立",
        deviation: 20,
        best: "県大会ベスト8",
        last: "県大会ベスト8",
        info: "2年生エース左腕・榛名を擁する公立の実力校。max148キロの球速を持つ榛名の投球が試合の鍵を握るが、打線がエースを援護できるかが長年の課題。絶対的エースの存在に頼るだけでなく、チーム全体で得点を奪う総合力が試される。安定して上位に進出する力は十分に持っている。",
        coach: { name: '大川 透', style: '投手中心', experience: '中堅' }
    },
    "静岡": {
        name_yomi: "しずおか",
        region: "中部",
        type: "公立",
        deviation: 105,
        best: "甲子園3回戦",
        last: "県大会ベスト4",
        info: "創立93年、甲子園出場13回。そしてスポーツに力を入れながらも勉学でも優秀。その輝かしい歴史、実績は地元民のみならず県民の誇り、また憧れでもあり、老若男女問わず地元民に愛される伝統校である。近年は他校の私立やナムコグループとの選手獲得競争に一つ遅れをとっており、甲子園からは遠ざかっているが、歴史は厚く、私立並みの設備とOBからの厚い支援、そして、なによりも代矢東の試合がある際には球場に多くのOBが駆け付け、大応援団を結成し、相手を圧倒する。近年はナムコグループが県内を牛耳りかけているため、公立の希望の星としてメディアに取り上げられることも多い。県内を席巻するナムコグループへの『公立最後の砦』として、その存在は象徴的な意味を持ち始めた。名将・高島は伝統と現代野球の融合に腐心する。これは単なる高校野球ではない。地域の誇りと未来をかけた代理戦争なのだ。",
        popularity: true,
        coach: { name: '高島 礼', style: '伝統野球', experience: '名将' }
    },
    "飛龍": {
        name_yomi: "ひりゅう",
        region: "東部",
        type: "私立",
        deviation: 99,
        best: "甲子園2回戦",
        last: "初戦敗退",
        info: "かつては甲子園出場経験もある私立校だが、数年前に起きた不祥事の影響でチームは低迷。現在は若き林田監督と共に、失われた信頼を取り戻すべく再建の道を歩んでいる。地域への清掃活動などを通じて地道な努力を続けており、グラウンドでの結果で完全復活をアピールしたいところだ。。",
        coach: { name: '林田 健太郎', style: '機動力野球', experience: '期待の若手' }
    },
    "聖隷クリストファー": {
        name_yomi: "せいれいくりすとふぁー",
        region: "西部",
        type: "私立",
        deviation: 94,
        best: "甲子園2回戦",
        last: "県大会ベスト8",
        info: "毎年優勝候補に挙げられる西部地区の雄。名将・片岡監督が築き上げた投手を中心とした堅守は全国レベルと評される。しかし、その堅実さゆえに打線が湿りがちで、トーナメント終盤で涙を飲む展開が続く。タレントは揃っており、悲願の甲子園出場に向けて、伝統の守備力に加えて得点力をどう向上させるか。長年の課題である「ベスト8の壁」を越えられるかが今大会の焦点となる。",
        popularity: true,
        coach: { name: '片岡 鉄心', style: '守備重視', experience: '名将' }
    },
    "裾野": {
        name_yomi: "すその",
        region: "東部",
        type: "公立",
        deviation: 48,
        best: "なし",
        last: "なし",
        info: "エースの茂野が中心となって創部された新しいチーム。部員のほとんどが高校から野球を始めた初心者であり、戦力としては未知数。茂野の圧倒的な個人技でどこまで勝ち上がれるかが注目される。チームとしての一体感が生まれれば、面白い存在になるかもしれない。",
        coach: { name: '茂野 吾郎', style: '超攻撃型', experience: '新任' }
    },
    "富士宮北": {
        name_yomi: "ふじのみやきた",
        region: "東部",
        type: "公立",
        deviation: 51,
        best: "甲子園出場",
        last: "初戦敗退",
        info: "プロ注目のmax158kmの本格派右腕・斎藤を擁する公立校。彼の存在により、例年以上の注目を集めている。佐々木監督はエースへの負担を考慮しつつ、チーム全体の底上げを図る。斎藤の快投はもちろん、彼を支える野手陣の奮起が、上位進出への鍵となる。",
        coach: { name: '佐々木 朗', style: '投手中心', experience: '中堅' }
    },
    "美城学園": {
        name_yomi: "みしろがくえん",
        region: "中部",
        type: "私立",
        deviation: 81,
        best: "県大会ベスト4",
        last: "県大会2回戦",
        info: "ナムコグループ系列校の草分け的存在。かつてはグループの中心だったが、近年は同じ系列の765総合や283学園に有力選手が集まり、苦戦を強いられている。三城監督の下、プライドをかけた戦いで古豪の意地を見せ、グループ内での序列を覆したいところだ。",
        coach: { name: '三城 常務', style: 'エリート野球', experience: 'ベテラン' }
    },
    "沼津高専": {
        name_yomi: "ぬまづこうせん",
        region: "東部",
        type: "公立",
        deviation: 18,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "全国トップクラスの偏差値を誇る超進学校。相手チームのデータを徹底的に分析し、確率に基づいた戦術を組み立てる「シンキング・ベースボール」が持ち味。身体能力では他校に劣る部分もあるが、その知性で補って余りある。セオリーの穴を突く戦い方は、どんな強豪にとっても脅威となる。。",
        coach: { name: '京大 一郎', style: 'データ野球', experience: '中堅' }
    },
    "三島南": {
        name_yomi: "みしまみなみ",
        region: "東部",
        type: "公立",
        deviation: 42,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "数年前に21世紀枠として甲子園に出場した経験を持つ。数年前ほどの力はないが、今年のチームは全員野球で相手に挑み、守備でリズムを作りながら、つなぐバッティングで得点する野球が特長。エースの吉田と主砲の打川を中心に、泥臭い野球でこの夏は下克上で甲子園まで勝ち上がる。",
        popularity: true,
        coach: { name: '吉田 輝夫', style: '全員野球', experience: 'ベテラン' }
    },
    "御殿場南": {
        name_yomi: "ごてんばみなみ",
        region: "東部",
        type: "公立",
        deviation: 34,
        best: "県大会ベスト16",
        last: "県大会ベスト16",
        info: "50年ぶりとなるベスト16に進出した昨年の躍進で、地元を大いに沸かせた公立校。データ分析を得意とする山内監督の指導の下、派手さはないが堅実な野球で勝ち上がった。周囲の「まぐれ」という声を覆し、自分たちの実力が本物であることを証明したい今大会は、真価を問われる重要な夏となる。。",
        coach: { name: '山内 浩司', style: '堅実', experience: '中堅' }
    },
    "掛川西": {
        name_yomi: "かけがわにし",
        region: "西部",
        type: "公立",
        deviation: 91,
        best: "甲子園2回戦",
        last: "県大会ベスト4",
        info: "静岡高校と並ぶスポーツが盛んな県内二大公立校。サッカー部などが全国的に有名なスポーツ強豪校であり、野球部も毎年安定して上位に進出する実力を持つが、あと一歩で甲子園に届かないシーズンが続く。名将・円堂監督が掲げる、常識にとらわれない大胆な采配は、多くのファンを魅了している。今年こそ他競技の輝かしい実績に追いつきたい。。",
        coach: { name: '円堂 守', style: '超次元野球', experience: '名将' }
    },
    "浜松市立": {
        name_yomi: "はままついちりつ",
        region: "西部",
        type: "公立",
        deviation: 55,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "毎年安定した力を持つ中堅公立校だが、トーナメント中盤で強豪校と当たり敗退することが多く、「壁」を越えられずにいる。この状況を打破すべく、ベテランの山口監督は今年は機動力野球に特化。塁に出れば積極的に次の塁を狙う、しつこい野球で番狂わせを狙う。。",
        coach: { name: '山口 一', style: '機動力野球', experience: 'ベテラン' }
    },
    "浜松学院興誠": {
        name_yomi: "はままつがくいんこうせい",
        region: "西部",
        type: "私立",
        deviation: 52,
        best: "県大会ベスト16",
        last: "県大会ベスト16",
        info: "体育科のみで構成される通信制の私立校。全国から選手が集まり、寮生活を送りながら野球に打ち込んでいる。サッカー界で実績のある岡田監督が、競技の垣根を越えて指導にあたっており、その育成手腕に注目が集まる。独特の環境で育った選手たちが、チームとしてどう機能するかが鍵。",
        coach: { name: '岡田 武史', style: '育成上手', experience: 'ベテラン' }
    },
    "焼津水産": {
        name_yomi: "やいづすいさん",
        region: "中部",
        type: "公立",
        deviation: 44,
        best: "県大会ベスト16",
        last: "県大会2回戦",
        info: "港町に根ざした水産高校で、スタンドに翻る大漁旗がチームのシンボル。一昨年のベスト16進出という実績もあり、地元の期待は大きい。浜田監督が率いるチームは、チャンスでの集中打を得意とする攻撃的な野球が持ち味。昨年の不振を乗り越え、再び「大漁」を狙う。",
        coach: { name: '浜田 大吉', style: '積極打撃', experience: '中堅' }
    },
    "袋井": {
        name_yomi: "ふくろい",
        region: "中部",
        type: "公立",
        deviation: 59,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "県内有数のマンモス校で、毎年一定数の有望な新入生が入部する。突出したスター選手はいないものの、全部員のレベルが高く、総合力で勝負するチーム。ベテラン千葉監督の下、選手層の厚さを活かした多彩な戦術が強み。昨年の初戦敗退の雪辱を誓う。。",
        coach: { name: '千葉 繁', style: '総合力', experience: 'ベテラン' }
    },
    "浜松城北工業": {
        name_yomi: "はままつじょうほくこうぎょう",
        region: "西部",
        type: "公立",
        deviation: 66,
        best: "県大会ベスト4",
        last: "初戦敗退",
        info: "県大会ベスト4の経験もある公立校。元プロの金本監督が注入する、積極果敢なフルスイング野球がチームの代名詞。その攻撃的なスタイルは、時にラフプレーと批判されることもあるが、勝利への執念はどのチームよりも強い。昨年の初戦敗退から這い上がり、再び頂点を目指す。。",
        coach: { name: '金本 知憲', style: '積極打撃', experience: 'プロOB' }
    },
    "磐田東": {
        name_yomi: "いわたひがし",
        region: "西部",
        type: "私立",
        deviation: 90,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "轟監督の「打撃こそ正義」という哲学に基づき、練習の大部分を打撃練習に費やす超攻撃型チーム。その破壊力は県内トップクラスで、大量得点で試合をひっくり返す力を持つ。一方で、守備力に課題を残しており、試合展開が非常に不安定なのが特徴。観客を魅了する、スリリングな試合運びで勝ち上がりを狙う。。",
        coach: { name: '轟 雷蔵', style: '打撃偏重', experience: 'ベテラン' }
    },
    "静岡商業": {
        name_yomi: "しずおかしょうぎょう",
        region: "中部",
        type: "公立",
        deviation: 57,
        best: "甲子園優勝",
        last: "県大会ベスト8",
        info: "甲子園優勝経験もある伝統校で、毎年優勝候補の筆頭に挙げられる。エース成宮を筆頭とする投手力は全国屈指のレベルを誇る。昨年の大会では準々決勝で敗退しており、今年は王座奪還を目指す。名将・国友監督の下、投打に隙がなく、総合力は県内トップクラス。。",
        popularity: true,
        coach: { name: '国友 広重', style: '総合力', experience: '名将' }
    },
    "御殿場西": {
        name_yomi: "ごてんばにし",
        region: "東部",
        type: "私立",
        deviation: 96,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "トーナメント中盤の大きな壁として、毎年安定した力を見せる私立の実力校。ベテラン田崎監督が築き上げた堅実な野球は、どのチームにとってもやりにくい。一方で、近年はベスト8前後での敗退が続き、上位進出には課題も残る。強豪校にとっては厄介な「門番」から脱却し、頂点を狙えるかが問われる。。",
        coach: { name: '田崎 圭介', style: '堅実', experience: 'ベテラン' }
    },
    "誠恵": {
        name_yomi: "せいけい",
        region: "東部",
        type: "私立",
        deviation: 38,
        best: "甲子園出場",
        last: "初戦敗退",
        info: "かつては甲子園にも出場した古豪だが、近年は部員不足に悩み低迷している。勝利のためなら手段を選ばないベテラン影山監督の非情な采配は、物議を醸すことも少なくない。しかし、恵まれない戦力で勝ち上がるため、綺麗事だけでは済まされないというチームの現実も表している。。",
        coach: { name: '影山 秀路', style: 'ラフプレー', experience: 'ベテラン' }
    },
    "科学技術": {
        name_yomi: "かがくぎじゅつ",
        region: "中部",
        type: "私立",
        deviation: 23,
        best: "県大会ベスト4",
        last: "県大会ベスト16",
        info: "VRトレーニングやAIによるデータ解析など、最新技術を積極的に導入している新時代の私立校。その先進的な取り組みはメディアでも度々取り上げられ、知名度は高い。速水監督の下、科学的なアプローチで選手の能力を最大限に引き出す。データ野球が伝統的な強豪校にどこまで通用するのか、注目が集まる。。",
        coach: { name: '速水 奨', style: 'データ野球', experience: '中堅' }
    },
    "小山": {
        name_yomi: "おやま",
        region: "東部",
        type: "公立",
        deviation: 49,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "人口1万人の小さな町にある、全校生徒100人にも満たない小規模校。町の期待を一身に背負い、彼らはグラウンドに立つ。チャンス時に全校生徒と町民が一体となって踊る『小山舞踊』は、相手チームを呑み込む独特の雰囲気を生み出す。ベテラン猫田監督の下、体格では劣る選手たちが機動力で掻き回す。町全体の想いが、奇跡を起こすかもしれない。",
        coach: { name: '猫田 権蔵', style: '機動力野球', experience: 'ベテラン' }
    },
    "虎府島総合": {
        name_yomi: "こふとうそうごう",
        region: "西部",
        type: "公立",
        deviation: 47,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "本土から定期船で4時間。台風が来れば1週間は孤島と化す。それが虎府島だ。グラウンドは塩害で芝生がまだらに枯れ、雨が降れば沼地と化す。練習相手は漁の合間に集まる島の草野球チームの地元の方々。彼らから教わるのは『気合』と『潮の流れの読み方』だ。本土の他校の情報は、月に一度届く野球雑誌だけ。しかし、この絶望的なハンデが彼らの魂を鋼鉄に変えた。その逆境が「虎府島スピリッツ」と呼ばれる強靭な精神力とチームの結束を育んだ。試合の日には島民が大挙して応援に駆けつけるなど、地域との絆はどこよりも強い。噂によると島民の約半数にも及ぶらしい。もはやこれは単なるスポーツではない。島が、生きるために戦う物語だ。",
        coach: { name: '島袋 譲二', style: '全員野球', experience: 'ベテラン' }
    },
    "知徳": {
        name_yomi: "ちとく",
        region: "東部",
        type: "私立",
        deviation: 71,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "『力こそ全て』を校訓に掲げ、練習のほとんどをウエイトトレーニングに費やす脳筋集団。金剛監督の指導の下、全選手がベンチプレス100kg以上を誇るパワーは本物だ。しかし、その大味な野球は、栄養管理や科学的トレーニングを取り入れる強豪校の前に、いつもあと一歩で屈してきた。筋肉は裏切らない。その言葉を信じ、彼らは今日も鉄アレイを握る。",
        coach: { name: '金剛 毅', style: 'パワー野球', experience: '中堅' }
    },
    "静清": {
        name_yomi: "せいせい",
        region: "中部",
        type: "私立",
        deviation: 55,
        best: "甲子園優勝",
        last: "初戦敗退",
        info: "半世紀前に甲子園5連覇を達成した伝説的な古豪。近年は低迷が続くが、その名前は今も高校野球ファンに畏敬の念を抱かせている。かつての名将の血を引く犬飼監督が、伝統の堅守を復活させ、「帝国の再建」を目指す。古豪復活への道のりは険しいが、その一挙手一投足に注目が集まる。。",
        coach: { name: '犬飼 賢人', style: '守備重視', experience: '名将' }
    },
    "日大三島": {
        name_yomi: "にちだいみしま",
        region: "東部",
        type: "私立",
        deviation: 96,
        best: "甲子園出場",
        last: "県大会ベスト16",
        info: "2022年の春夏連続甲子園出場が記憶に新しい日大三島。昨秋は県大会3回戦で敗退し、気合を入れ直したところだ。指揮をとるのは永田裕治監督だ。報徳学園（兵庫）時代には全国制覇を含む、春夏通算18回の甲子園出場。2020年に日大三島に赴任すると、2022年には春夏連続で甲子園に導いた。今チームも百戦錬磨の名将から全員野球の大切さ、勝負に対する厳しさを学び、選手たちの顔つきが少しずつ変わってきた。名将の就任から4年が過ぎようとしている。。",
        coach: { name: '小和田 雅人', style: '堅実', experience: 'ベテラン' }
    },
    "浜松開誠館": {
        name_yomi: "はままつかいせいかん",
        region: "西部",
        type: "私立",
        deviation: 120,
        best: "甲子園2回戦",
        last: "県大会ベスト16",
        info: "ポテンシャルは県内トップとも称されることもあるトーナメント屈指のダークホース。2023年には甲子園出場も果たし、一躍強豪としての名誉を築いた。策士・佐野監督が率いるチームは、相手チームの徹底的な分析に基づいた奇策を得意とする。その予測不能な戦いぶりは、、ひとたび波に乗れば一気に勝ち上がる力を持っている。。",
        coach: { name: '佐野 秀幸', style: '奇策', experience: '策士' }
    },
    "東海大翔洋": {
        name_yomi: "とうかいだいしょうよう",
        region: "中部",
        type: "私立",
        deviation: 61,
        best: "県準優勝",
        last: "県大会ベスト16",
        info: "一昨年の夏はノーシードから決勝まで勝ち進むも765総合に敗れ、準優勝。新しいスタイルで今夏こそ甲子園へ！勝利への執念を引き継ぐ現チームの特徴は「機動力」。前チームとはまた違ったスタイルに期待がかかる。機動力以外もレベルアップしている。投手は140キロ右腕の甘田圭澄（2年）が君臨。課題だった2番手も、1年生を中心に台頭しつつある。一方の攻撃力は7試合計90安打を叩き出した昨年のチームに比べて劣るが、機動力を使った野球を展開。チームナンバーワンの俊足・松下揮人（2年＝外野手）や岸川を筆頭に足の速い選手が多いのも追い風となっている。守りからリズムを作り、1点ずつ積み重ねていくニュースタイルが浸透してきた「タテジマ軍団」。2004年夏以来となる甲子園に向けて牙を研ぐ。。",
        coach: { name: '須田 幸雄', style: '総合力', experience: 'ベテラン' }
    },
    "283学園B": {
        name_yomi: "つばさがくえんB",
        region: "西部",
        type: "私立",
        deviation: 59,
        best: "なし",
        last: "なし",
        info: "王者・283学園の『二軍』。昨年の優勝により部員数が急激に増加した283学園。一時は100人も超えたため、それに伴い、異例の措置として設立されたBチーム。Aチームに上がれなかった選手で構成されているが、監督に就任した七草の手腕もあり、その実力は侮れない。「打倒Aチーム」を掲げ、ハングリー精神は本家以上。公式戦での兄弟対決が実現すれば、大きな注目を集めるだろう。県内からは同じ県内に同じ高校のチームの二つ目を作り大会に参加させるのは違反行為なのでは、という声が多く上がったが、県内はナムコグループが牛耳っているため、ごり押しで可決させた。",
        coach: { name: '七草 はづき', style: '育成上手', experience: '期待の若手' }
    },
    "伊豆伊東": {
        name_yomi: "いずいとう",
        region: "伊豆",
        type: "公立",
        deviation: 43,
        best: "県大会2回戦",
        last: "県大会2回戦",
        info: "数年前に共学化した元女子高で、野球部は創部まもない新しいチーム。学校側の全面的なバックアップを受け、期待の若手、伊集院監督が指導にあたる。全国レベルと名高い吹奏楽部の応援もチームの大きな武器。まだ発展途上だが、今後の成長が期待される注目株だ。。",
        coach: { name: '伊集院 隼人', style: '機動力野球', experience: '期待の若手' }
    },
    "富士東": {
        name_yomi: "ふじひがし",
        region: "東部",
        type: "公立",
        deviation: 63,
        best: "県大会2回戦",
        last: "県大会2回戦",
        info: "富士東は最上級生の奮起に注目だ。昨年は４人しかいない３年生全員が活躍を見せ、初戦で甲子園出場経験もある富士宮北を７―６で破った。一緒にプレーした岩田主将（３年）は「そういう上級生の姿を今年も後輩たちに見せたい」と意気込む。エースの眞山（３年）は、４日の招待試合で日大三島に１失点完投勝利。自信を胸に「チームを鼓舞する投球をしたい」と大舞台を見据える。。",
        coach: { name: '高橋 留美', style: '守備重視', experience: '中堅' }
    },
    "常葉菊川": {
        name_yomi: "とこはきくがわ",
        region: "西部",
        type: "私立",
        deviation: 55,
        best: "甲子園準優勝",
        last: "県準優勝",
        info: "織田監督が率いる、超攻撃的な野球を標榜する私立校。昨年の県大会では、その圧倒的な打撃力で準優勝に輝いた。守備に課題を残すものの、「点を取られたら取り返す」というスタイルは多くのファンを魅了している。今年もその破壊的な打線は健在で、頂点を目指す。。",
        coach: { name: '織田 信長', style: '超攻撃型', experience: 'ベテラン' }
    },
    "常葉橘": {
        name_yomi: "とこはたちばな",
        region: "中部",
        type: "私立",
        deviation: 92,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "投手陣は緩急をつける三浦、思い切りのいい山口らが主戦を争う。打線は長打力があるブランコ、中村ら中軸が信頼できる。石川、モーガンら上位が出て、得点機をつくりたい。下位打線の充実が鍵。守備は一年生の時から試合に出ている遊撃梶谷、昨年を経験した捕手鶴岡らセンターラインが軸。確実にアウトを取れる安定感が持ち味だ。",
        coach: { name: '渡辺 元智', style: '総合力', experience: '名将' }
    },
    "藤枝明誠": {
        name_yomi: "ふじえだめいせい",
        region: "西部",
        type: "私立",
        deviation: 90,
        best: "甲子園出場",
        last: "県大会ベスト8",
        info: "「雑草軍団」として知られ、堅実な守備と手堅い攻めの野球が持ち味のハングリー精神の強いチーム。ベテラン猪狩監督の指導の下、個々の選手の能力は非常に高い。チームとして噛み合った時の爆発力は、優勝候補をも脅かす。近年着々と結果を出しており、今大会は春の大会で上位の成績を収めたことにより、シード校として君臨している。「革命」の時は近い。",
        coach: { name: '猪狩 茂', style: '投手中心', experience: 'ベテラン' }
    },
    "駿河総合": {
        name_yomi: "するがそうごう",
        region: "中部",
        type: "私立",
        deviation: 47,
        best: "県大会準優勝",
        last: "県大会2回戦",
        info: "2019年夏に初の県決勝進出を果たした駿河総合。昨夏の「2020年夏季静岡県高等学校野球大会結果」でもベスト4入り。悲願の甲子園が手の届く位置まできている。同校はチーム力が年々上昇すると同時に、上のカテゴリーで活躍する卒業生が増えている。2018年に社会人野球を経てOBの杉山一樹（福岡ソフトバンク）がプロ入り。最速157キロの剛速球を武器に今季はローテーションの一角として期待される。さらに、2019年のドラフトで指名された紅林弘太郎（オリックス）はプロ1年目から1軍戦に出場。将来の主軸候補として注目を集めている。期待の若手・藤崎監督が持ち込んだデータ野球を武器に、着実に力をつけている。相手の油断を突く情報戦を得意とし、下馬評を覆すポテンシャルは十分。校名とは裏腹に、冷静沈着な野球で番狂わせを狙う。。",
        coach: { name: '藤崎 詩織', style: 'データ野球', experience: '期待の若手' }
    },
    "加藤学園": {
        name_yomi: "かとうがくえん",
        region: "東部",
        type: "私立",
        deviation: 99,
        best: "県大会ベスト16",
        last: "県大会2回戦",
        info: "投手陣は緩急をつける嶋、思い切りのいい榎本らが主戦を争う。打線は長打力がある右田、寺田ら中軸が信頼できる。川崎ら上位が出て、得点機をつくりたい。下位打線の充実が鍵。守備は一年生の時から試合に出ている遊撃坂口、昨年を経験した捕手古田らセンターラインが軸。夏までに確実にアウトを取れる安定感を身につけたい直近の練習試合では東海大翔洋にも勝利するなど今大会の優勝候補と言っても過言ではない",
        coach: { name: '鰯水 等', style: '堅実', experience: '中堅' }
    },
    "浜松工業": {
        name_yomi: "はままつこうぎょう",
        region: "西部",
        type: "公立",
        deviation: 64,
        best: "甲子園ベスト8",
        last: "県大会2回戦",
        info: "約30年前に甲子園ベスト8に進出し、「浜工旋風」を巻き起こしたことで知られる。近年は低迷していたが、当時のエースだった青葉が監督に就任し、再建に乗り出した。かつての英雄の帰還に、OBや地元の期待も高まっている。新しい世代の選手たちと共に、再び聖地を目指す。。",
        coach: { name: '青葉 健司', style: '育成上手', experience: '期待の若手' }
    },
    "伊豆総合": {
        name_yomi: "いずそうごう",
        region: "東部",
        type: "公立",
        deviation: 43,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "エースは最速１３６キロの力のあるストレートで勝負する。打撃陣に派手さはないものの走塁や戦術に磨きをかけ、足りない長打力をカバーする。落ち着いた雰囲気で野球に取り組んでいる。尾島太郎監督の指導は、堅実な守備と確実なバントなどを重視するスタイル。派手さはないが、大崩れしない安定感がある。。",
        coach: { name: '尾島 太郎', style: '守備重視', experience: 'ベテラン' }
    },
    "富士宮西": {
        name_yomi: "ふじのみやにし",
        region: "東部",
        type: "公立",
        deviation: 58,
        best: "甲子園ベスト16",
        last: "初戦敗退",
        info: "約30年前に甲子園出場経験のある古豪。近年は私立校の台頭に押され、上位進出から遠ざかっている。OBや地元ファンの「復活を」という期待が、時に選手たちのプレッシャーになることも。ベテラン拳崎監督は、選手たちが気負わずに実力を発揮できる環境作りに努めている。",
        coach: { name: '拳崎 史郎', style: '積極打撃', experience: 'ベテラン' }
    },
    "富士市立": {
        name_yomi: "ふじいちりつ",
        region: "東部",
        type: "私立",
        deviation: 61,
        best: "県大会ベスト8",
        last: "県大会2回戦",
        info: "セイバーメトリクスをいち早く導入し、データに基づいた野球を徹底する私立校。赤嶺監督の采配は、選手のコンディションや相手との相性など、あらゆる情報を分析した上で決定される。その合理的なアプローチは、時に非情とも映るが、着実に結果を残している。",
        coach: { name: '赤嶺 譲二', style: 'データ野球', experience: '中堅' }
    },
    "オイスカ浜松国際": {
        name_yomi: "おいすかはままつこくさい",
        region: "西部",
        type: "私立",
        deviation: 49,
        best: "県大会ベスト4",
        last: "県大会2回戦",
        info: "県内を牛耳る巨大資本『ナムコグループ』に対抗すべく、地元の有志『オイスカグループ』が設立した異色の高校。潤沢な資金を持つナムコ系列校とは対照的に、彼らが持つのは反骨精神と結束力だけだ。「伝説」と称される桐生監督の指導は、技術よりも精神的な強さを重視する。その熱いプレースタイルと反骨精神は多くのファンを惹きつけており、大会の波乱要因として注目されている。",
        coach: { name: '桐生 一馬', style: '根性野球', experience: '伝説' }
    },
    "新居": {
        name_yomi: "あらい",
        region: "中部",
        type: "公立",
        deviation: 48,
        best: "県大会初戦敗退",
        last: "初戦敗退",
        info: "夏の大会、公式戦通算0勝32敗。それがこの学校の歴史の全てだ。長年公式戦での勝利から遠ざかっており、部員数も常にギリギリという厳しい状況が続く公立校。練習環境も恵まれているとは言えないが、選手たちは野球が好きだという純粋な気持ちで白球を追い続けている。チームの悲願は、まず「公式戦で一勝」を挙げること。その瞬間に向けて、ひたむきな努力を重ねる。",
        coach: { name: '田中 一郎', style: '堅実', experience: '中堅' }
    },
    "韮山": {
        name_yomi: "にらやま",
        region: "東部",
        type: "公立",
        deviation: 68,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "県のシンボル『伊豆山』の麓にある県内屈指の進学校。彼らの名物は、険しい山道を毎日駆け上がる地獄のトレーニングだ。それで鍛え上げられた強靭な足腰は、他校の脅威。ベテラン山路監督が率いる機動力野球は、一度出塁を許すと止まらない。山の民の誇りを胸に、グラウンドを嵐のように駆け巡る。",
        coach: { name: '山路 和弘', style: '機動力野球', experience: 'ベテラン' }
    },
    "静岡学園": {
        name_yomi: "しずおかがくえん",
        region: "中部",
        type: "私立",
        deviation: 61,
        best: "甲子園出場",
        last: "県大会ベスト16",
        info: "創部19年の新興勢力ながら、甲子園出場経験を持つ実力校。しかし更なる飛躍のため、学校は大きな賭けに出た。かつて帝王実業を甲子園5連覇に導いた伝説の名将・國村監督を招聘したのだ。規律を重んじるベテラン監督の下、才能ある選手たちがどう融合するのか、優勝候補の一角として大きな注目を集めている。。",
        coach: { name: '國村 隼', style: '総合力', experience: '名将' }
    },
    "市立沼津": {
        name_yomi: "いちりつぬまづ",
        region: "東部",
        type: "公立",
        deviation: 62,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "全国レベルの吹奏楽部が奏でる応援は『市沼サウンド』として有名。その美しくも力強い音圧は、相手チームの集中力を削ぎ、味方を鼓舞する。ベテラン猫又監督が率いるチームは、その応援をバックに、粘り強い守備でリズムを作る。派手な選手はいないが、繋ぐ意識は県内随一。音の魔術師たちが、静かに、しかし確実に相手を追い詰めていく。",
        coach: { name: '猫又 育史', style: '守備重視', experience: 'ベテラン' }
    },
    "沼津城北": {
        name_yomi: "ぬまづじょうほく",
        region: "東部",
        type: "公立",
        deviation: 55,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "生徒の自主性を重んじる自由な校風で知られる公立校。野球部も西垣監督の指導方針の下、選手たちが自ら練習メニューや戦術を考える「考える野球」を実践している。その型にはまらないプレースタイルは、時にセオリーを覆す大きな波乱を巻き起こす可能性を秘めている。",
        coach: { name: '西垣 奈々', style: '奇策', experience: '期待の若手' }
    },
    "下田": {
        name_yomi: "しもだ",
        region: "伊豆",
        type: "公立",
        deviation: 50,
        best: "県大会初戦敗退",
        last: "初戦敗退",
        info: "過疎化が進む静かな港の町。全校生徒80人、野球部員は奇跡的に集まったが、グラウンドには雑草が生い茂り、練習は紅白戦もできず、監督が打つボールをただ延々と追いかけるだけ。昨年、町で唯一のスポーツ用品店がシャッターを下ろし、今は破れたボールを自分たちで縫って使うしかない。町の大人たちは、彼らが野球をしていることすら知らないかもしれない。消えゆく町で、誰にも知られず消えていく野球部。彼らが夏の大会に出場するのは、勝利のためではない。自分たちが『下田高校野球部』として確かにここに存在したという、たった一つの証を夏の青空に刻み込むためだけの、あまりにも切ない戦いだ。",
        coach: { name: '水上 善次', style: '堅実', experience: '中堅' }
    },
    "湖西": {
        name_yomi: "こさい",
        region: "西部",
        type: "公立",
        deviation: 57,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "大会ごとに成績が大きく変動する、ムラッ気のあるチームとして知られる。上位進出経験もありポテンシャルは高いが、格下相手への取りこぼしも少なくない。ベテラン海野監督は、長年の課題である精神的な安定感をチームにもたらそうと指導。今大会で安定した戦いぶりを見せられるかが躍進の鍵となる。。",
        coach: { name: '海野 平', style: '機動力野球', experience: 'ベテラン' }
    },
    "熱海": {
        name_yomi: "あたみ",
        region: "伊豆",
        type: "公立",
        deviation: 46,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "創立70年を迎える地域の伝統校だが、近年は過疎化の波に飲まれ、活気を失いつつある。野球部の活躍は、町に残された数少ない希望だ。『俺たちが勝てば、町が元気になる』。その想いを胸に、選手たちはグラウンドに立つ。選手は全員が地元出身。育成に定評のある根本監督の下、郷土愛を力に変えて戦う。そのひたむきなプレーには、多くの地元ファンがついている。地元出身の選手たちが、愛する故郷に勝利を届ける。",
        coach: { name: '根本 陸夫', style: '育成上手', experience: 'ベテラン' }
    },
    "静岡市立": {
        name_yomi: "しずおかいちりつ",
        region: "中部",
        type: "公立",
        deviation: 83,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "毎年投打にバランスの取れた好チームを編成するが、トーナメントの組み合わせに恵まれず、実力以上の結果を残せていない「悲運の公立校」。井上監督はどんな相手にも自分たちの野球を貫くことを選手に求める。今年こそ、厳しい組み合わせを乗り越えて上位進出を果たしたい。。",
        coach: { name: '井上 和彦', style: '総合力', experience: '中堅' }
    },
    "城南静岡": {
        name_yomi: "じょうなんしずおか",
        region: "中部",
        type: "公立",
        deviation: 59,
        best: "県大会ベスト4",
        last: "初戦敗退",
        info: "かつて県ベスト4の実績を持つ公立の実力校。昨年の初戦敗退の屈辱から、チームは「原点回帰」をテーマに伝統の積極打撃を徹底的に磨き直した。伊藤監督の下、古豪復活を目指すチームの士気は高い。ノーシードからの下剋上を狙う。。",
        coach: { name: '伊藤 健太郎', style: '積極打撃', experience: 'ベテラン' }
    },
    "浜松南": {
        name_yomi: "はままつみなみ",
        region: "西部",
        type: "公立",
        deviation: 56,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "近年、校舎が新築され、練習環境が大幅に改善された公立校。学校全体の期待が高まる中、期待の若手・高木監督がチームを率いる。まだ目立った実績はないが、最新の設備と新しいユニフォームで心機一転、新たな歴史を作るべく今大会に挑む。。",
        coach: { name: '高木 渉', style: '育成上手', experience: '期待の若手' }
    },
    "島田": {
        name_yomi: "しまだ",
        region: "中部",
        type: "公立",
        deviation: 53,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "大正8年創立という長い歴史を持つ伝統校だが、近年は部員不足から連合チームを組むなど、苦しい時期が続いている。今季から再び単独チームとして出場するが、戦力はまだ整っていない。まずは大会で一勝を挙げ、チームの新たな一歩を踏み出すことが目標となる。。",
        coach: { name: '島本 宏', style: '堅実', experience: '中堅' }
    },
    "伊豆中央": {
        name_yomi: "いずちゅうおう",
        region: "伊豆",
        type: "公立",
        deviation: 51,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "長年の部員不足から昨年まで連合チームとして出場していたが、今年から待望の単独出場を果たす。部員の多くが野球経験の浅い1年生で、チームはまだ発展途上。中田監督は、まずは公式戦で戦う経験を積ませ、チームの土台作りを進めている段階。今大会は未来への第一歩となる。。",
        coach: { name: '中田 島蔵', style: '全員野球', experience: '中堅' }
    },
"浜松修学舎": {
        name_yomi: "はままつしゅうがくしゃ", region: "西部", type: "私立", deviation: 55,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "近年急速に力をつけている私立校。豊富な練習量と「修学舎メソッド」と呼ばれる独自の育成法で、上位を虎視眈々と狙う。",
        coach: { name: '高橋 正和', style: '総合力', experience: '中堅' }
    },
    "浜松日体": {
        name_yomi: "はままつにったい", region: "西部", type: "私立", deviation: 58,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "文武両道を掲げる私立校。安定した実力を持ち、毎年トーナメント中盤の壁となる。",
        coach: { name: '渡辺 徹', style: '堅実', experience: '中堅' }
    },
    "掛川工業": {
        name_yomi: "かけがわこうぎょう", region: "西部", type: "公立", deviation: 43,
        best: "県大会2回戦", last: "初戦敗退",
        info: "掛川西、掛川東とは異なる、工業高校らしい実直な野球が持ち味。",
        coach: { name: '掛布 雅之', style: '積極打撃', experience: 'プロOB' }
    },
    "清水東": {
        name_yomi: "しみずひがし", region: "中部", type: "公立", deviation: 68,
        best: "県大会ベスト4", last: "県大会2回戦",
        info: "全国に名を轟かせるサッカー部の影に隠れがちだが、野球部も県内屈指の進学校として知性溢れるプレーを見せる。",
        coach: { name: '長谷部 誠', style: 'データ野球', experience: '期待の若手' }
    },
    "島田樟誠": {
        name_yomi: "しまだしょうせい", region: "中部", type: "私立", deviation: 65,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "近年、野球部の強化に力を入れている私立校。粘り強い戦いが持ち味。",
        coach: { name: '佐々木 恭介', style: '総合力', experience: 'ベテラン' }
    },
    "富士宮東": {
        name_yomi: "ふじのみやひがし", region: "東部", type: "公立", deviation: 47,
        best: "県大会2回戦", last: "初戦敗退",
        info: "富士山麓の地元選手で構成されたチーム。地の利を活かした戦いをしたい。",
        coach: { name: '工藤 公康', style: '投手中心', experience: 'プロOB' }
    },
    "浜名": {
        name_yomi: "はまな", region: "西部", type: "公立", deviation: 55,
        best: "県大会ベスト4", last: "県大会3回戦",
        info: "「浜名スマイル」を合言葉に、常に全力疾走と笑顔を絶やさない好チーム。公立校ながら安定して上位に進出する実力を持つ。",
        coach: { name: '山田 太郎', style: '全員野球', experience: '中堅' }
    },
    "掛川東": {
        name_yomi: "かけがわひがし", region: "西部", type: "公立", deviation: 63,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "文武両道を掲げる進学校。掛川西のライバル校の一つとして、安定した実力を持つ。",
        coach: { name: '東山 紀之', style: '堅実', experience: '中堅' }
    },
    "島田商業": {
        name_yomi: "しまだしょうぎょう", region: "中部", type: "公立", deviation: 62,
        best: "甲子園出場", last: "県大会2回戦",
        info: "「島商（しましょう）」の愛称で知られる古豪。近年は中堅に甘んじているが、伝統の堅実な「島商野球」で復活を目指す。",
        coach: { name: '池谷 幸雄', style: '堅実', experience: 'ベテラン' }
    },
    "清水桜が丘": {
        name_yomi: "しみずさくらがおか", region: "中部", type: "公立", deviation: 57,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "清水商業と庵原高校の統合校。サッカー部が有名だが、野球部も「清商（キヨショウ）」時代の勝負強さを受け継ぐ。",
        coach: { name: '大榎 克己', style: '堅実', experience: '中堅' }
    },
    "沼津商業": {
        name_yomi: "ぬまづしょうぎょう", region: "東部", type: "公立", deviation: 49,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "東部の伝統ある商業高校。緻密なデータ分析と機動力を絡めた「考える野球」が持ち味。",
        coach: { name: '小宮山 悟', style: 'データ野球', experience: 'ベテラン' }
    },
    "田方農業": {
        name_yomi: "たがたのうぎょう", region: "伊豆", type: "公立", deviation: 42,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "伊豆地区の雄。農業実習で鍛えた体力と、粘り強さが持ち味。「タノウ」の愛称で親しまれる。",
        coach: { name: '桑田 真澄', style: '育成上手', experience: 'プロOB' }
    },
    "浜松湖南": {
        name_yomi: "はままつこなん", region: "西部", type: "公立", deviation: 54,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "毎年安定した力を持つ中堅校。上位進出を虎視眈々と狙う。",
        coach: { name: '小林 幹英', style: '堅実', experience: '中堅' }
    },
    "沼津東": {
        name_yomi: "ぬまづひがし", region: "東部", type: "公立", deviation: 69,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "東部地区屈指の進学校。伝統的に「文武両道」を掲げ、知的なプレーで相手を翻弄する。",
        coach: { name: '古田 敦也', style: 'データ野球', experience: 'プロOB' }
    },
    "吉原": {
        name_yomi: "よしわら", region: "東部", type: "公立", deviation: 51,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "富士市を代表する公立校の一つ。粘り強い守備と、つなぐ打線で上位進出を狙う。",
        coach: { name: '吉井 理人', style: '投手中心', experience: '中堅' }
    },
    "浜松大平台": {
        name_yomi: "はままつおおひらだい", region: "西部", type: "公立", deviation: 40,
        best: "県大会2回戦", last: "初戦敗退",
        info: "比較的新しい公立校。まずはトーナメント中盤進出が目標。",
        coach: { name: '大野 豊', style: '投手中心', experience: 'プロOB' }
    },
    "藤枝西": {
        name_yomi: "ふじえだにし", region: "中部", type: "公立", deviation: 48,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "サッカーの強豪・藤枝東のライバル校。野球部も負けじと、粘り強い全員野球で勝利を目指す。",
        coach: { name: '西 勇輝', style: '全員野球', experience: '期待の若手' }
    },
    "磐田農業": {
        name_yomi: "いわたのうぎょう", region: "西部", type: "公立", deviation: 42,
        best: "県大会2回戦", last: "初戦敗退",
        info: "農業実習で鍛えた地力と体力が自慢。「磐農（いわたのう）」ナインが泥臭く白球を追う。",
        coach: { name: '野村 謙二郎', style: '機動力野球', experience: 'ベテラン' }
    },
    "静岡西": {
        name_yomi: "しずおかにし", region: "中部", type: "公立", deviation: 50,
        best: "県大会2回戦", last: "初戦敗退",
        info: "典型的な公立の中堅チーム。堅実な守備からリズムを作りたい。",
        coach: { name: '西崎 幸広', style: '投手中心', experience: '中堅' }
    },
    "浜松江之島": {
        name_yomi: "はままつえのしま", region: "西部", type: "公立", deviation: 45,
        best: "県大会2回戦", last: "初戦敗退",
        info: "粘り強い守備と小技を絡めた攻撃が持ち味のチーム。",
        coach: { name: '中村 剛', style: '堅実', experience: '中堅' }
    },
    "浜松西": {
        name_yomi: "はままつにし", region: "西部", type: "公立", deviation: 56,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "県内トップクラスの進学校。少ない練習時間を効率的に使い、知性で戦う。",
        coach: { name: '鈴木 一郎', style: 'データ野球', experience: '中堅' }
    },
    "池新田": {
        name_yomi: "いけしんでん", region: "西部", type: "公立", deviation: 44,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "御前崎市に位置する。海風で鍛えた強肩とパワーが武器の、侮れない中堅校。",
        coach: { name: '池山 隆寛', style: '積極打撃', experience: '中堅' }
    },
    "磐田北": {
        name_yomi: "いわたきた", region: "西部", type: "公立", deviation: 53,
        best: "県大会2回戦", last: "初戦敗退",
        info: "地元の選手を中心に構成された、地域密着型の公立校。",
        coach: { name: '山本 浩二', style: '全員野球', experience: 'ベテラン' }
    },
    "磐田西": {
        name_yomi: "いわたにし", region: "西部", type: "公立", deviation: 51,
        best: "県大会2回戦", last: "初戦敗退",
        info: "粘り強い野球が信条。接戦に持ち込み勝機を伺う。",
        coach: { name: '渡辺 俊介', style: '守備重視', experience: '中堅' }
    },
    "小笠": {
        name_yomi: "おがさ", region: "西部", type: "公立", deviation: 50,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "かつてはベスト8にも名を連ねた古豪。近年は安定した力を見せ、復活の兆しがある。",
        coach: { name: '高橋 昭雄', style: '機動力野球', experience: 'ベテラン' }
    },
    "御殿場": {
        name_yomi: "ごてんば", region: "東部", type: "公立", deviation: 43,
        best: "県大会2回戦", last: "初戦敗退",
        info: "富士山の麓、標高の高いグラウンドで鍛えられた足腰が自慢。",
        coach: { name: '槙原 寛己', style: '堅実', experience: '中堅' }
    },
    "相良": {
        name_yomi: "さがら", region: "中部", type: "公立", deviation: 47,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "牧之原市の実力校。投手力を中心とした堅実な試合運びで、シード校撃破を狙う。",
        coach: { name: '相川 亮二', style: '守備重視', experience: '中堅' }
    },
    "佐久間": {
        name_yomi: "さくま", region: "西部", type: "公立", deviation: 35,
        best: "県大会2回戦", last: "初戦敗退",
        info: "浜松市天竜区の山間部に位置する。部員不足に悩みながらも、地域の期待を背負って戦う。",
        coach: { name: '佐々木 朗希', style: '投手中心', experience: '新任' }
    },
    "静岡北": {
        name_yomi: "しずおかきた", region: "中部", type: "私立", deviation: 52,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "スポーツ科も擁する私立校。個々の身体能力は高いが、チームとしてのまとまりが課題。",
        coach: { name: '高田 繁', style: '機動力野球', experience: 'ベテラン' }
    },
    "静岡農業": {
        name_yomi: "しずおかのうぎょう", region: "中部", type: "公立", deviation: 46,
        best: "県大会2回戦", last: "初戦敗退",
        info: "「静農（しずのう）」の愛称。実習で培った粘り強さと体力が武器。",
        coach: { name: '稲葉 篤紀', style: '全員野球', experience: '中堅' }
    },
    "清水西": {
        name_yomi: "しみずにし", region: "中部", type: "公立", deviation: 47,
        best: "県大会2回戦", last: "初戦敗退",
        info: "粘り強い守備が持ち味の公立校。接戦に持ち込みたい。",
        coach: { name: '西 清孝', style: '守備重視', experience: 'ベテラン' }
    },
    "清流館": {
        name_yomi: "せいりゅうかん", region: "中部", type: "公立", deviation: 45,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "焼津市にある比較的新しい高校。吉田高校と大井川高校が統合。地域の期待を背負い、上位を目指す。",
        coach: { name: '川上 憲伸', style: '投手中心', experience: 'プロOB' }
    },
    "遠江総合": {
        name_yomi: "とおとうみそうごう", region: "西部", type: "公立", deviation: 42,
        best: "県大会2回戦", last: "初戦敗退",
        info: "森町・周智高校の後継校。地域の星として、まずは初戦突破、そして上位進出を目指す。",
        coach: { name: '遠山 奬志', style: '堅実', experience: '中堅' }
    },
    "榛原": {
        name_yomi: "はいばら", region: "中部", type: "公立", deviation: 59,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "「榛高（はいこう）」の愛称。進学校ながら、機動力を絡めた攻撃的な野球で上位を伺う。",
        coach: { name: '原 辰徳', style: '超攻撃型', experience: 'ベテラン' }
    },
    "浜北西": {
        name_yomi: "はまきたにし", region: "西部", type: "公立", deviation: 50,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "「北西（きたにし）」の愛称。堅実な守備と粘り強い打撃で、強豪校に食らいつく。",
        coach: { name: '西 俊児', style: '守備重視', experience: '中堅' }
    },
    "浜松北": {
        name_yomi: "はままつきた", region: "西部", type: "公立", deviation: 40,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "静岡県トップクラスの進学校。限られた時間で超効率的な練習をこなす。",
        coach: { name: '北別府 学', style: 'データ野球', experience: 'ベテラン' }
    },
    "浜松湖東": {
        name_yomi: "はままつことう", region: "西部", type: "公立", deviation: 60,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "進学校の一つだが、野球部の練習も熱心。隙のない堅実な野球で勝ち上がる。",
        coach: { name: '佐藤 健', style: '堅実', experience: '中堅' }
    },
    "浜松湖北": {
        name_yomi: "はままつこほく", region: "西部", type: "公立", deviation: 45,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "引佐、気賀、三ケ日の3校が統合して誕生。奥浜名湖の広大な敷地で鍛えた総合力で勝負する。",
        coach: { name: '北川 博敏', style: '積極打撃', experience: '中堅' }
    },
    "浜松東": {
        name_yomi: "はままつひがし", region: "西部", type: "公立", deviation: 62,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "浜松市内の有力進学校。分析力と堅実な守備で上位を狙う。",
        coach: { name: '東尾 修', style: '投手中心', experience: 'ベテラン' }
    },
    "富岳館": {
        name_yomi: "ふがくかん", region: "東部", type: "公立", deviation: 44,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "富士宮市にある。農業系の学科も持つ総合高校。富士山のような、どっしりとした戦いを見せたい。",
        coach: { name: '富田 勝', style: '堅実', experience: 'ベテラン' }
    },
    "袋井商業": {
        name_yomi: "ふくろいしょうぎょう", region: "西部", type: "公立", deviation: 48,
        best: "県大会2回戦", last: "初戦敗退",
        info: "商業高校ならではの緻密な分析と、伝統的な「守りの野球」で勝利を目指す。",
        coach: { name: '伊藤 裕季', style: '守備重視', experience: 'ベテラン' }
    },
    "富士": {
        name_yomi: "ふじ", region: "東部", type: "公立", deviation: 65,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "東部地区の伝統ある進学校。スマートな試合運びと、ここ一番での集中力が光る。",
        coach: { name: '斎藤 雅樹', style: '投手中心', experience: 'ベテラン' }
    },
    "藤枝北": {
        name_yomi: "ふじえだきた", region: "中部", type: "公立", deviation: 46,
        best: "県大会2回戦", last: "初戦敗退",
        info: "サッカーの強豪として知られるが、野球部も地元選手を中心に奮闘している。",
        coach: { name: '山田 暢久', style: '全員野球', experience: '中堅' }
    },
    "藤枝東": {
        name_yomi: "ふじえだひがし", region: "中部", type: "公立", deviation: 35,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "「サッカー王国」の一角を担う超名門校。野球部もその伝統を受け継ぎ、フィジカルの強さを活かしたプレーが持ち味。",
        coach: { name: '中山 雅史', style: '積極打撃', experience: '期待の若手' }
    },
    "焼津中央": {
        name_yomi: "やいづちゅうおう", region: "中部", type: "公立", deviation: 41,
        best: "県大会ベスト16", last: "県大会3回戦",
        info: "文武両道を掲げる進学校。効率的な練習で、上位進出を狙う。",
        coach: { name: '石田 雅昭', style: 'データ野球', experience: '中堅' }
    },
    "横須賀": {
        name_yomi: "よこすか", region: "西部", type: "公立", deviation: 52,
        best: "県大会ベスト8", last: "県大会2回戦",
        info: "「スカ」の愛称で知られる古豪。近年は安定した実力を保持しており、上位進出も珍しくない。",
        coach: { name: '衣笠 祥雄', style: '根性野球', experience: 'ベテラン' }
    },
    "吉原工業": {
        name_yomi: "よしわらこうぎょう", region: "東部", type: "公立", deviation: 44,
        best: "県大会2回戦", last: "初戦敗退",
        info: "「ヨシコウ」の愛称。工業高校らしい、ひたむきなプレーが信条。",
        coach: { name: '高橋 由伸', style: '積極打撃', experience: 'プロOB' }
    },
    "星陵": {
        name_yomi: "せいりょう", region: "東部", type: "私立", deviation: 60,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "富士宮市にある私立校。中高一貫の強みを活かし、投打にバランスの取れたチームを編成する。",
        coach: { name: '星野 仙一', style: '投手中心', experience: '名将' }
    }



};


/**
 * 試合会場の定義
 * 1回戦～3回戦は全10球場、準々決勝以降は主要4球場に集約する想定
 */
// ▼▼▼ この STADIUM_DATA の定義をまるごと置き換えてください ▼▼▼
const STADIUM_DATA = [
    { name: "草薙総合運動場硬式野球場", abbr: "草", region: "中部" },
    { name: "愛鷹広域公園野球場", abbr: "愛", region: "東部" },
    { name: "富士総合運動公園野球場", abbr: "富", region: "東部" },
    { name: "ちゅ～るスタジアム清水", abbr: "ち", region: "中部" },
    { name: "焼津球場", abbr: "焼", region: "中部" },
    { name: "島田球場", abbr: "島", region: "中部" },
    { name: "掛川球場", abbr: "掛", region: "西部" },
    { name: "浜岡球場", abbr: "岡", region: "西部" },
    { name: "磐田球場", abbr: "磐", region: "西部" },
    { name: "浜松球場", abbr: "浜", region: "西部" }
];
// ▲▲▲ 置き換えここまで ▲▲▲

// ▼▼▼ このブロックをまるごと追加 ▼▼▼
// 3回戦用の主要4球場（草薙、愛鷹、清水、浜松）
const ROUND_3_STADIUMS = [
    STADIUM_DATA[0], // 草薙
    STADIUM_DATA[1], // 愛鷹
    STADIUM_DATA[3], // ちゅ～るスタジアム清水
    STADIUM_DATA[9]  // 浜松
];

const QUARTER_FINAL_STADIUMS = [
    STADIUM_DATA[0], // 草薙
    STADIUM_DATA[3]  // ちゅ～るスタジアム清水
];

// 準々決勝以降用の球場（草薙のみ）
const FINAL_STAGE_STADIUMS = [
    STADIUM_DATA[0] // 草薙
];
// ▲▲▲ 追加ここまで ▲▲

/**
 * AIの解像度を上げるための「静岡県高校野球の常識・勢力図」（現実ベース＋架空・詳細版）
 * 全てのAI関数がこの情報を参照し、文脈を理解する。
 * (★ユーザー指摘に基づき、年度を修正した最終版)
 */
const PREFECTURE_LORE = `
静岡県の高校野球界は、長らく「公立の雄」である **静岡**（シズコウ）と**掛川西**（カケニシ）、そして甲子園優勝経験もある「古豪」**浜松商業**（ハマショウ）や**静岡商業**（静商） といった伝統校が上位を占める時代が長かった。

その均衡を打ち破ったのが、2007年のセンバツ全国制覇 を果たした**常葉菊川**（常葉大菊川）である。彼らの「超攻撃型野球」は一世を風靡し、県の勢力図を「伝統校 vs 菊川」の構図に変えた。

しかし、2010年代後半から現在（2025年）にかけて、勢力図はさらに複雑化する。「新・私立強豪」の時代である。
**加藤学園**（2023年春の王者）、**日大三島**（2022年センバツ出場）、**浜松開誠館**（2023年センバツ出場）、そして**聖隷クリストファー** (2023年の春の選抜高校野球に春夏通じて初の甲子園出場を決めた)が台頭。
静岡県は「伝統校 vs 菊川 vs 新・私立強豪」が激突する、全国屈指の「戦国時代」に突入していた。

この戦国時代に、さらに巨大な波乱要因として参入したのが、巨大資本「ナムコグループ」である。
ナムコはまず「**765総合高校**」を設立し、2年前に甲子園ベスト16という鮮烈なデビューを飾った。
さらに昨年、満を持して「**283学園**」を創部すると、姫川や白瀬といった全国レベルの選手を揃え、いきなり夏の県大会を制覇。昨年の王者として今大会の「倒すべき本命」となっている。

その結果、現在の静岡県（2025年）の常識は、以下の4大勢力によって構成されている。

1.  **【ナムコ資本】 (新・絶対王者)**
    * **283学園**: 昨年の覇者。圧倒的な戦力を誇る本命。
    * **765総合**: 2年前に甲子園を経験。王者283に次ぐ戦力。
    * (その他、美城学園, 初星学園, 283学園B など)

2.  **【現代・私立強豪】 (群雄割拠)**
    * **加藤学園**: 2023年春の王者。勢いのあるチームの一つ。
    * **日大三島**: 名将・永田監督の元、2022年に復活。
    * **浜松開誠館**: 2023年の春のセンバツ代表校。
    * **聖隷クリストファー**: 2023年の春の選抜高校野球に出場。
    * **常葉菊川**: 2007年の全国制覇の衝撃は今も健在。超攻撃型野球は脅威。
    * (その他、藤枝明誠, 磐田東、常葉橘、藤枝明誠、東海大翔洋など)

3.  **【伝統・公立校】 (公立の砦)**
    * **静岡**: 「公立最後の砦」として、新旧私立とナムコ資本に対抗する最大の希望。
    * **掛川西**: 静岡と並ぶ公立の雄。2018年夏甲子園出場、2023年夏ベスト4 と実力は健在。
    * **静岡商業**: 2006年夏甲子園出場。古豪としての意地がある。

4.  **【復活を目指す古豪】 (Cランク・古豪)**
    * **浜松商業**: かつての全国優勝校。近年は低迷しているが、復活を願うファンは多い。
    * **静清**: 浜商同様、近年は上位争いから遠ざかっている古豪。

この「常識」は、AI記者やBBS住民の基本的な思考パターンとなります。
---
### 参考：高校野球における「打順の常識」
AIは以下の「打順の役割」を理解し、分析やコメントに反映すること。

-   **1番 (リードオフマン):** チームで最も俊足で出塁率が高い選手。彼が出塁できるかが攻撃の鍵。
-   **2番 (つなぎ役):** バントや進塁打が得意な器用な選手。1番を2塁に進めるのが仕事。最近はこの打順に強打者を置くことも増えている。
-   **3番 (強打者):** チームで最も打撃技術が高い選手。チャンスメイクもでき、長打も打てる。
-   **4番 (主砲):** チーム最強の打者。ランナーを返す（打点）ことが最大の使命。彼が打てないとチームは勝てない。
-   **5番 (強打者):** 4番の「後片付け」役。4番が返せなかったランナーを返したり、チャンスを拡大したりする。
-   **6番, 7番 (下位打線):** 上位打線ほどのプレッシャーはないが、ここで打てるとチームは勢いづく。
-   **8番 (守備要員):** 守備は上手いが打撃は期待されていないことが多い。
-   **9番 (第2の1番):** 投手（打撃が苦手）の次であることが多く、打撃が良い選手が置かれると、1番打者に戻るまでの「第2のチャンスメーカー」として機能する。
---
### 参考：高校野球における「投打の左右の常識」
AIは以下の「相性」を理解し、分析やコメントに反映すること。

-   **右投手 vs 右打者:** 一般的に投手が有利。外角に逃げるスライダーが有効。
-   **右投手 vs 左打者:** 一般的に打者が有利。内角に食い込む球（クロスファイア）が鍵。
-   **左投手 vs 左打者:** 一般的に投手が有利。「ワンポイントリリーフ」として起用されることも。
-   **左投手 vs 右打者:** 一般的に打者が有利。
-   **戦術:** 相手エースが「右腕」の場合、スタメンに「左打者」を並べる「ジグザグ打線」は有効な戦術である。逆に、相手が「左腕」なのに左打者を並べると「なぜだ？」と疑問視される。
**両打 (スイッチヒッター):** 相手投手の左右によって有利な打席に立てるため、特に1番・2番にいると非常に厄介な存在となる。
---
### 参考：高校野球における「球速の常識」（投手の左右・レベル別）
AIは以下の「球速帯」が持つ意味を、**投手の左右**と**学校のレベル（公立か強豪か）**で判断基準を変えて分析すること。

-   **120km/h 〜 125km/h帯:**
    - **（右腕の場合）:** **「公立校の1、2回戦レベルであれば、エースとして十分通用する」**球速。
        - **分析:** ただし、これだけで強豪私立の上位打線を抑えるのは難しい。「技巧派」や「軟投派」として、打者の手元で小さく動く「ツーシーム」や、90km/h台の「スローカーブ」で緩急をつけ、**打たせて取る**投球術が生命線となる。
        - BBS反応：「120km台でもコントロール良ければ打てんよな」「公立のエースって感じ」「ザ・技巧派」
    - **（左腕の場合）:** **非常に価値がある。**球速は遅くとも、このレベルの**「左腕（サウスポー）」**であること自体に希少価値がある。
        - **分析:** ご指摘の通り、**強豪校でも、**相手の左打者を抑えるための「ワンポイントリリーフ」や、食い込む「クロスファイア」を武器にする技巧派の2番手投手としてベンチ入りすることが多い。
        - BBS反応：「左で120後半なら十分」「左のサイドとか一番嫌だわ」「ワンポイント専用機やな」

-   **130km/h 〜 135km/h帯:**
    - **（右腕の場合）:** **公立校なら間違いなく「エース級」。**私立強豪校でも2番手・3番手投手としてベンチ入りするレベル。
        - **分析:** このレベルの投手は非常に多く、トーナメントを勝ち上がるには、球速以外の武器（例：鋭く落ちるスプリット、高速スライダー）がカギとなる。
    - **（左腕の場合）:** **強豪校のエース**として十分なレベル。
        - **分析:** **「甲子園出場校のエース」**としても珍しくない。右打者のアウトコースに逃げるスライダーや、左打者のインコースを突くシュート（クロスファイア）を武器に、打たせて取る「試合を作る」タイプの投手が多い。
    - BBS反応（右腕）：「130km台出れば公立じゃ無双できる」「私立の中軸に通用するか」
    - BBS反応（左腕）：「左で135km出てれば、右の140kmより打ちにくい」「こういう技巧派左腕が甲子園で勝つんだよな」

-   **140km/h 〜 145km/h帯:**
    - **（右腕の場合）:** **「県内屈指」**の好投手。Aランクの強豪校でエースナンバーを背負うレベル。
    - **（左腕の場合）:** **「超高校級」**。プロがスカウトの上位候補としてマークし始める。左腕でこの球速は圧倒的なアドバンテージとなる。
    - BBS反応（右腕）：「はっや！」「県内屈指の〇〇くん」「これは打てんわ」
    - BBS反応（左腕）：「左で145kmはエグい」「ドラフト候補やろ」

-   **150km/h 〜 155km/h帯:**
    - **（共通）:** **「ドラフト級」**。左右問わず、高校生レベルを逸脱した「怪物」であり、ドラフト1位指名も現実的。
    - BBS反応：「ファッ！？150超えキター！」「バケモンだろこいつ」「ドラ1確定」

-   **160km/h 〜 165km/h帯:**
    - **（共通）:** 歴史的な投手。
    - BBS反応：「大谷かよ」「漫画の世界」
`;
// ▲▲▲ ここまでを貼り付け（または上書き） ▲▲▲


    const DETAILED_TEAM_DATA = {
        "283学園": {
            summary: "夏の連覇の先に、聖地での勝利を目指す。昨年王者、守備の一体感と打線のつながりを強みに、試合ごとに成長。チームスローガンは『強』。個の技量に頼らず、一人ひとりの力を集めて戦う。姫川白瀬の投手リレーは全国ピカイチ",
            players: [
                { name: "姫川", year: 3, position: "ピッチャー", desc: "投打の中心。MAX151kmの直球とスプリットで相手を圧倒する、プロ注目の高校通算42本塁打の怪物。" },
                { name: "花海咲", year: 3, position: "センター", desc: "1年夏からベンチ入りを果たしている、経験豊富な走攻守三拍子揃ったスラッガー。攻守の要として監督からの信頼は厚い。" },
                { name: "鈴木", year: 2, position: "ファースト", desc: "チャンスに強い仕事人。" },
                { name: "十王", year: 3, position: "ショート", desc: "監督も絶大な信頼を寄せる鉄壁の守備を誇る名手。チャンスメイクも得意な打者。" },
                { name: "八宮", year: 2, position: "サード", desc: "2年生ながら5番に座ることもあるクラッチヒッター。ポテンシャルが高い。" },
                { name: "樋口", year: 3, position: "セカンド", desc: "強肩強打のパワーヒッター。勝負強い打撃が光る。" },
                { name: "有栖川", year: 3, position: "キャッチャー", desc: "大舞台に強い主軸。変化球打ちの技術はチームトップクラス。" },
                { name: "芹沢", year: 2, position: "レフト", desc: "小技と守備センスが光る渋い選手。チャンスでの一打も。" },
                { name: "花海佑", year: 1, position: "ライト", desc: "1年生のスーパースター。兄・咲との連携も抜群。既に通算13本塁打。" },
                { name: "黛", year: 2, position: "ピッチャー", desc: "チーム最速の直球を持つ。春はメンバー外の悔しさをバネに復調を目指す。" },
 { name: "西城", year: 2, position: "ピッチャー", desc: "球威のある直球で打者を詰まらせる速球派投手。制球に課題はあるもののポテンシャルはピカイチ。打者としての能力も高い" },
                { name: "白瀬", year: 3, position: "ピッチャー", desc: "試合の後半を締めるクローザー的役割のエース。最速155kmの伸び上がるストレートを武器に打者を次々と打ち取る。春の大会では静岡高校相手に完全試合も達成した。" }
            ]
        },
        "常葉菊川": {
            summary: "個々のレベルアップが結実し昨年は準優勝。個人成績の可視化と実力主義でチーム内の競争を活性化させ、初の甲子園を目指す。スローガンは『個々の能力重視』。",
            players: [
                { name: "沖田", year: 3, position: "ピッチャー", desc: "投打の大黒柱。MAX157kmの速球を持つ主砲。" },
                { name: "土方", year: 3, position: "キャッチャー", desc: "グラウンド上の監督。高いスローイング技術と高校通算28本塁打のパワーを持つ。" },
                { name: "宮本", year: 3, position: "ファースト", desc: "力強い打撃と勝負強さが魅力の3番打者。" },
                { name: "柳生", year: 2, position: "セカンド", desc: "バッティングセンスに優れる2年生。落ち着いたプレーが光る。" },
                { name: "近藤", year: 3, position: "サード", desc: "ガッツあふれるプレーでチームを引っ張る5番打者。高校通算46本塁打。" },
                { name: "坂本", year: 3, position: "ショート", desc: "走攻守三拍子揃った抜群の身体能力を持つショート。" },
                { name: "岡田", year: 3, position: "ライト", desc: "高校通算71本塁打を誇る絶対的な4番。恵まれた体格からの強打が武器。" },
                { name: "森", year: 2, position: "センター", desc: "50m6秒フラットの俊足。攻守にわたり抜群の勝負強さを見せる。" },
                { name: "上泉", year: 3, position: "レフト", desc: "バランスと勝負強い打撃が武器。逆転劇のきっかけを作る。" },
                { name: "拝", year: 3, position: "ピッチャー", desc: "巧みな投球術と強い精神力を持つ控え投手。MAX155km。" },
                { name: "疋田", year: 2, position: "ピッチャー", desc: "クレバーさと強気を兼ね備えた2年生投手。昨夏も登板経験あり。" }
            ]
        },
        "掛川西": {
            summary: "昨年ベスト4。選手の長所を活かす野球で、磨き上げた守備力とタイプの違う3年生投手3人の継投を武器に、2005年以来の夏の聖地を目指す。",
            players: [
                { name: "豪炎寺", year: 3, position: "ピッチャー", desc: "最速158kmの直球と縦スライダーで打者を打ち取る絶対的エース。" },
                { name: "円堂", year: 3, position: "キャッチャー", desc: "冷静なリードで多彩な投手陣を引っ張る扇の要。3番打者としても活躍。" },
                { name: "壁山", year: 3, position: "ファースト", desc: "190cmの長身を生かした守備と長打力が魅力。" },
                { name: "半田", year: 3, position: "セカンド", desc: "小柄ながら攻守に堅実なプレーでチームに貢献。" },
                { name: "一ノ瀬", year: 3, position: "サード", desc: "チーム一の打球の速さを誇る2番打者。" },
                { name: "土門", year: 3, position: "ショート", desc: "ミスの少ない堅実な守備で試合のリズムを作る内野の要。" },
                { name: "染岡", year: 3, position: "レフト", desc: "監督も絶大な信頼を寄せる大砲。気持ちの強さも魅力。" },
                { name: "風丸", year: 3, position: "センター", desc: "サイクルヒット達成経験もあるリードオフマン。ミート力が格段にアップ。" },
                { name: "栗松", year: 2, position: "ライト", desc: "力強いスイングから放たれる長打が魅力の2年生。" },
                { name: "鬼道", year: 3, position: "ピッチャー", desc: "キレのある縦スライダーと内角への直球が魅力の右腕。" },
                { name: "松野", year: 2, position: "ピッチャー", desc: "MAX144kmのストレートとカットボールが武器の2年生。奪三振能力が高い。" }
            ]
        },
        "静岡": {
            summary: "投打の大黒柱を中心にダイナミックなベースボールを展開。攻めの姿勢を貫き、聖地を見据える伝統校。どこからでも得点できる打線が強み。",
            players: [
                { name: "倉田", year: 3, position: "ピッチャー", desc: "常時150km超の速球を投げる本格派エース。" },
                { name: "澄川", year: 3, position: "キャッチャー", desc: "強肩強打の司令塔。盗塁阻止率は随一。4番としてもチームを背負う" },
                { name: "舟橋", year: 3, position: "ファースト", desc: "高校通算63本塁打のプロ注目スラッガー。得点圏での勝負強さが光る。" },
                { name: "江野", year: 3, position: "セカンド", desc: "俊足と広い守備範囲が武器の機動力内野手。" },
                { name: "松浪", year: 3, position: "サード", desc: "大柄な体の目立つパワーヒッター。多少体勢が崩れても外野の頭を超える" },
                { name: "別津", year: 3, position: "ショート", desc: "軽快なフットワークが光る守備職人。つなぎ役もこなしながら長打力も光る。" },
                { name: "長内", year: 3, position: "レフト", desc: "小柄ながら高い身体能力を持つ。クリーンアップの後を打ちランナーを残さない。" },
                { name: "阿部", year: 3, position: "センター", desc: "190cmの巨体がトレードマークのスラッガー。脱力したフォームから目が覚めるような打球を繰り出す。" },
                { name: "大谷", year: 3, position: "ライト", desc: "安定した打率を誇る右打者。正確な返球も魅力。" },
                { name: "山本", year: 3, position: "ピッチャー", desc: "最速152kmの剛腕。リリーフも先発もこなす万能型。" },
                { name: "砂田", year: 3, position: "ピッチャー", desc: "左腕から多彩な変化球を投げるクローザー的存在。" }
            ]
        },
        "聖隷クリストファー": {
            summary: "昨年ベスト8。選手の長所を活かした攻撃力と堅守を武器に雪辱を期す。タイプの異なる3人の投手による継投が強み。",
            players: [
                { name: "沢村", year: 2, position: "ピッチャー", desc: "最速140kmの直球と多彩な変化球で三振を奪う次世代エース左腕。" },
                { name: "降谷", year: 3, position: "ピッチャー", desc: "長身から投げ下ろすスライダーとシュートが武器の大型右腕。" },
                { name: "御幸", year: 3, position: "キャッチャー", desc: "攻守にわたる高い野球センスを誇るプロ注目の司令塔。" },
                { name: "前園", year: 2, position: "一塁手／外野手", desc: "高い打撃技術と強肩を持つ大型野手。" },
                { name: "小湊", year: 3, position: "二塁手", desc: "堅実な守備と巧みなバットコントロールが光る。" },
                { name: "金丸", year: 3, position: "三塁手", desc: "打球反応が速く、強肩が武器。中距離ヒッター。" },
                { name: "倉持", year: 2, position: "ショート", desc: "俊敏な動きと華麗な守備が魅力の内野の要。" },
                { name: "結城", year: 3, position: "レフト", desc: "長打力を武器に快音を響かせる強打者。" },
                { name: "東条", year: 3, position: "センター", desc: "強肩と確実な捕球で外野を統率する守備職人。" },
                { name: "白州", year: 3, position: "ライト", desc: "打撃センスが光る左打者。冷静な状況判断が持ち味。" }
            ]
        },



        "三島北": {
            summary: "雪辱を期す知性派軍団。絶対的エース榛名を擁し、データを駆使した緻密な野球で昨夏の悔しさを晴らす。チームスローガンは『知は力なり』。",
            players: [
                { name: "榛名", year: 3, position: "ピッチャー", desc: "最速140km後半の直球と高速スライダーで三振の山を築く絶対的エース。" },
                { name: "秋丸", year: 3, position: "キャッチャー", desc: "冷静沈着なリードでエース榛名を支える扇の要。" },
                { name: "大川", year: 3, position: "ファースト", desc: "チーム不動の4番。一振りで試合の流れを変えるパワーが魅力。" },
                { name: "福原", year: 3, position: "ショート", desc: "卓越したバットコントロールと選球眼を持つ1番打者。守備も堅実。" },
                { name: "町田", year: 3, position: "センター", desc: "走攻守三拍子揃ったアベレージヒッター。3番を担う。" }
            ]
        },
        "静岡商業": {
            summary: "王座奪還へ、揺るぎなき『王国』のプライド。昨年の雪辱に燃える絶対王者。投打にタレントを揃え、最強左腕・成宮を軸に再び全国の頂点を目指す。スローガンは『常勝』。",
            players: [
                { name: "成宮", year: 3, position: "ピッチャー", desc: "「キング」の異名を持つ世代最強左腕。MAX150km/hの直球と魔球チェンジアップを操る。" },
                { name: "神谷", year: 3, position: "センター", desc: "50m5秒台の俊足を誇る「チーター」。攻守に規格外の身体能力を見せる。" },
                { name: "白河", year: 3, position: "ショート", desc: "卓越した野球センスと華麗な守備が光る内野の司令塔。" },
                { name: "多田野", year: 2, position: "キャッチャー", desc: "「キング」成宮の女房役を射止めた2年生捕手。冷静なリードが持ち味。" },
                { name: "山岡", year: 3, position: "サード", desc: "頼れる4番打者。昨年は６番ながらも大会打点王などに輝いた。今年は満を持して4番に君臨し、勝負強い打撃をする。高校通算61本。" }
            ]
        },
        "藤枝明誠": {
            summary: "守りを固めて試合をつくる明誠らしさは健在。投手は左腕の宇垣、左腕宮城らが中心で、成長著しい捕手宜野座がリードする。１年時から主力の主将宮原は１番中堅として攻守でチームをけん引。中軸の比嘉は長打力があり、ここぞの場面で期待がかかる。総力戦で勝利を積み上げ、頂点を目指す。",
            players: [
                { name: "宮城", year: 3, position: "ピッチャー", desc: "明誠の投手陣を１年次から支えてきた経験豊富なエース左腕。140kmを超えるストレートと鋭いフォークが持ち味" },
                { name: "宜野座", year: 2, position: "キャッチャー", desc: "不動の4番。高校生離れしたパワーを誇る規格外の長距離砲。「明誠の頭脳」と称されるリードも武器。" },
                { name: "新垣", year: 3, position: "ファースト", desc: "チャンスに強い5番バッター。変化球への対応がうまく簡単に打ち取られない" },
                { name: "比嘉", year: 3, position: "セカンド", desc: "チームの中核を担う３番バッター。広角に打ち分ける技術と堅実な守備が光る。" },
                { name: "宮原", year: 3, position: "センター", desc: "俊足が武器の外野手。意外な勝負強さも見せる。" }
            ]
        }
    };
    const INITIAL_TEAM_POOL = Object.keys(TEAM_DATA);

    // --- Utility & State Functions ---
   

 function shuffleArray(array) {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
    }
    
    function saveState() {
        try {
            localStorage.setItem('tournamentState', JSON.stringify(tournamentState));
        } catch (e) {
            console.error("進行状況の保存に失敗しました:", e);
            showAlert("進行状況の保存に失敗しました。ブラウザのストレージ容量が不足している可能性があります。");
        }
    }
    
    function uint8ArrayToBase64(bytes) {
        let binary = '';
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    function getRankFromHistoryString(historyString) {

        if (historyString.includes('優勝')) return 1;

        if (historyString.includes('準優勝')) return 2;

        if (historyString.includes('ベスト4')) return 4;

        if (historyString.includes('ベスト8')) return 8;

        if (historyString.includes('ベスト16')) return 16;

        if (historyString.includes('3回戦')) return 16;

        if (historyString.includes('2回戦')) return 32;

        if (historyString.includes('初戦敗退')) return 64;

        return 64;

    }
    function getRankString(rank) {
 // ★★★ このifブロックを関数の先頭に追加 ★★★
    if (rank <= -1) {
        for (const key in KOSHIEN_RESULTS) {
            if (KOSHIEN_RESULTS[key].rank === rank) {
                return KOSHIEN_RESULTS[key].label;
            }
        }
    }
    // ★★★ ここまで追加 ★★★
        if (rank === 1) return "優勝";
        if (rank === 2) return "準優勝";
        if (rank <= 4) return "ベスト4";
        if (rank <= 8) return "ベスト8";
        if (rank <= 16) return "ベスト16";
        if (rank <= 32) return "3回戦敗退";
        if (rank <= 64) return "2回戦敗退";
        return "初戦敗退";
    }
// --- Utility & State Functions --- などに追加

/**
 * Creates a subtle, realistic dust particle animation.
 */
function createDustEffect() {
    const container = document.getElementById('dust-container');
    if (!container) return;
    
    const particleCount = 20; // The number of dust particles

    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'dust-particle';
        
        const size = Math.random() * 3 + 1; // Particle size between 1px and 4px
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // Use CSS variables to randomize the start and end points of the animation
        particle.style.setProperty('--x-start', `${Math.random() * 100}vw`);
        particle.style.setProperty('--x-end', `${Math.random() * 100}vw`);
        
        particle.style.animationDuration = `${Math.random() * 20 + 10}s`; // Duration between 10s and 30s
        particle.style.animationDelay = `${Math.random() * 10}s`; // Stagger the start time
        
        container.appendChild(particle);
    }
}
/**
 * スコアボードの合計点を更新する
 */
/**
/**
 * スコアボードの合計点を更新する
 */
function updateTotalScores() {
    const table = document.getElementById('inning-score-table');
    if(!table) return;

    table.querySelectorAll('tbody tr').forEach(row => {
        const total = Array.from(row.querySelectorAll('input')).reduce((sum, input) => {
            const value = parseInt(input.value);
            return isNaN(value) ? sum : sum + value;
        }, 0);
        
        const totalCell = row.querySelector('.total-score');
        if (totalCell) {
            totalCell.textContent = total;
        }
    });
}
/**
 * 戦績レコードを読みやすい文字列に変換する
 */
function formatRecordToString(record) {
    if (!record) return "データなし";
    const year = record.year.toString().slice(-2);
    const tournamentNameMap = { summer: '夏', autumn: '秋', spring: '春' };
    const tournament = tournamentNameMap[record.tournament] || '';
    const rank = getRankString(record.rank);
    // ★★★ 以下の行を変更 ★★★
    const prefix = record.rank < 0 ? '' : '県大会'; // 甲子園成績の場合は「県大会」をつけない
    return `'${year} ${tournament}: ${prefix}${rank}`;
    // ★★★ ここまで変更 ★★★
}

// AI Content Generation & Helpers のセクションに追加

/**
 * チームの今大会の軌跡を要約する
 * (★試合内容の要約(narrativeSummary)を反映する最終版)
 *
 * @param {string} teamName - チーム名
 * @param {string} currentMatchId - 現在処理中の試合ID (集計から除外するため)
 * @returns {string} - AIプロンプト用のチーム状況要約文
 */
function getCurrentTournamentPerformance(teamName, currentMatchId) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) return "今大会初戦。";

    const path = []; // 勝ち上がり履歴 (例: "1回戦で〇〇に 8-1 で勝利")
    const keyPerformances = new Set(); // 活躍ハイライト (例: "鈴木が1回戦で猛打賞")
    const playerAggStats = {}; // 今大会の個人成績集計用 (例: { "鈴木": { ab: 8, h: 3, ... } })

    // --- 1. 全大会の試合データを統合 ---
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };
    
    // --- 2. 現在の大会に絞り込み ---
    const currentTournamentKey = tournamentState.currentTournament;
    
    const currentTournamentMatchIds = Object.keys(allMatches).filter(matchId => {
        let isCurrentTournamentMatch = false;
        
        if (currentTournamentKey === 'summer') {
            // 夏: 'L-', 'R-', 'F-' (県大会本戦ID)
            isCurrentTournamentMatch = matchId.startsWith('L-') || matchId.startsWith('R-') || matchId.startsWith('F-');
        } else if (currentTournamentKey === 'autumn') {
            // 秋: 地区予選ID または (本戦フェーズなら) 県大会本戦ID
            const isRegional = matchId.startsWith('東部-') || matchId.startsWith('中部-') || matchId.startsWith('西部-') || matchId.startsWith('伊豆-');
            const isMain = matchId.startsWith('L-') || matchId.startsWith('R-') || matchId.startsWith('F-');
            isCurrentTournamentMatch = isRegional || (tournamentState.autumnPhase === 'main' && isMain);
        } else if (currentTournamentKey === 'spring') {
            // 春: 地区予選ID または (本戦フェーズなら) 県大会本戦ID
            const isRegional = matchId.includes('-SB') || matchId.includes('-SREP') || matchId.includes('-SIZU');
            const isMain = matchId.startsWith('L-') || matchId.startsWith('R-') || matchId.startsWith('F-');
            isCurrentTournamentMatch = isRegional || (tournamentState.springPhase !== 'regional_qualifiers' && isMain);
        }
        
        return isCurrentTournamentMatch;
    });

    // --- 3. 今大会の全試合を分析 ---
    for (const matchId of currentTournamentMatchIds) {
        // 処理中の試合(currentMatchId)自体は集計から除外
        if (matchId === currentMatchId) continue;
        
        const match = allMatches[matchId];
        
        // チームが関わった試合か、勝者が決まっているか
        if (match && match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            const opponent = match.team1 === teamName ? match.team2 : match.team1;
            if (!opponent) continue; // 不戦勝などは除外
            
            const roundName = getRoundNameFromMatchId(matchId); // ラウンド名取得

            // A. 勝ち試合の履歴を生成
            if (match.winner === teamName) {
                
                if (currentTournamentKey === 'summer') {
                    // 【夏大会】スコアとランクを含む複雑な表現
                    const winnerScore = (match.team1 === teamName ? match.score1 : match.score2) || 'W';
                    const loserScore = (match.team1 === teamName ? match.score2 : match.score1) || 'L';
                    const opponentRank = calculateRank(opponent, tournamentState);
                    
                    // ★★★ ここからが今回の修正箇所 ★★★
                    let narrativeSummary = "";
                    // 1. match.details に保存された要約文を取得
                    if (match.details && match.details.narrativeSummary) {
                        // "〇〇が勝利を掴んだ" や "投手戦となった" などの重複表現を削除
                        narrativeSummary = match.details.narrativeSummary
                            .replace(/で、?.*が勝利を掴んだ/, '')
                            .replace(/で、?.*が勝利した/, '')
                            .replace(/、?息詰まる投手戦となった/, 'の投手戦')
                            .replace(/、?壮絶な打撃戦となった/, 'の打撃戦');
                    }
                    
                    let pathText;
                    if (narrativeSummary) {
                        // 要約がある場合 (例: 9回サヨナラ勝ち)
                        pathText = `${roundName}で${opponent}(${opponentRank})に ${winnerScore}-${loserScore} で勝利 (${narrativeSummary})`;
                    } else {
                        // 要約がない場合 (詳細入力なし)
                        pathText = `${roundName}で${opponent}(${opponentRank})に ${winnerScore}-${loserScore} で勝利`;
                    }
                    path.push(pathText);
                    // ★★★ 修正ここまで ★★★

                } else {
                    // 【秋・春大会】シンプルな表現
                    path.push(`${roundName} vs ${opponent}`);
                }
            }

            // B. 個人成績（キーパフォーマンス）の収集 (変更なし)
            if (match.details) {
                const teamKey = match.team1 === teamName ? 'team1' : 'team2';
                
                const pitchers = match.details.pitching?.[teamKey] || [];
                pitchers.forEach(p => {
                    if (p.name && p.result === 'W' && parseFloat(p.innings) >= 6) {
                        keyPerformances.add(`${p.name}が${roundName}で好投`);
                    }
                });

                if (match.details.playerGameStats) {
                    const gameStats = match.details.playerGameStats[teamKey];
                    for (const playerName in gameStats) {
                        // 今大会の集計用オブジェクトを初期化
                        if (!playerAggStats[playerName]) {
                            playerAggStats[playerName] = { ab: 0, h: 0, hr: 0, rbi: 0 };
                        }
                        const agg = playerAggStats[playerName];
                        const game = gameStats[playerName];
                        
                        // この試合の成績を加算
                        agg.ab += game.ab || 0;
                        agg.h += game.h || 0;
                        agg.hr += game.hr || 0;
                        agg.rbi += game.rbi || 0;
                        
                        // 猛打賞
                        if (gameStats[playerName].h >= 3) {
                            keyPerformances.add(`${playerName}が${roundName}で猛打賞`);
                        }
                    }
                }
            }
        }
    } // (試合ループ終了)
    
    // --- 4. 最終的な文章の組み立て ---
    let summary = "";
    if (path.length === 0) {
        summary = "今大会初戦。";
    } else {
        if (currentTournamentKey === 'summer') {
            summary = `ここまでの勝ち上がり: ${path.join('、')}。`;
        } else {
            // 秋・春は「→」でつなぐ
            summary = `ここまでの勝ち上がり: ${path.join(' → ')}。`;
        }
    }
    
    // 5. 今大会の通算成績の分析 (変更なし)
    for (const playerName in playerAggStats) {
        const stats = playerAggStats[playerName];
        if (stats.ab >= 5) { // 5打数以上の選手を対象
            const battingAverage = (stats.ab > 0) ? (stats.h / stats.ab) : 0;
            if (battingAverage >= 0.4) {
                keyPerformances.add(`${playerName}が打率${battingAverage.toFixed(3)}と絶好調`);
            } else if (battingAverage <= 0.2 && battingAverage > 0) { // 0割は不振と言わない
                keyPerformances.add(`${playerName}が打率${battingAverage.toFixed(3)}と不振`);
            }
        }
    }
    
    if (keyPerformances.size > 0) {
        summary += ` 今大会の主な活躍: ${Array.from(keyPerformances).join('、')}。`;
    }

    return summary;
}
// ▼▼▼ このブロックをまるごと追加 ▼▼▼

/**
 * 本格的なまとめサイトのHTMLを、現実と架空のニュースを融合させて生成する
 * (★「ラウンド総括スレッド」も一覧に表示するよう修正)
 * @returns {Promise<string>} 生成されたHTML文字列
 */
async function generateMatomeSiteHtml() {
    let articles = [];
    
    // --- 1. 現実のニュースをまとめてリクエスト ---
    try {
        const response = await fetch('/.netlify/functions/get-news');
        if (!response.ok) {
            throw new Error(`サーバーエラー: ${response.status}`);
        }
        const realNewsArticles = await response.json();
        articles.push(...realNewsArticles);

    } catch (e) {
        console.error("サーバーからのニュース取得に失敗しました:", e);
        articles.push({ headline: "【速報】ニュースサーバー、ダウン中", type: 'real', timestamp: Date.now(), category: 'システム' });
    }

    // --- 2. ゲーム内のニュースを取得 ---
    const gameNewsList = tournamentState.news || [];
    
    // (A) 試合結果の記事 (dbMatch を持つ)
    gameNewsList.filter(n => n.context && n.context.dbMatch).slice(-5).forEach(gameNews => {
        const { winnerName, loserName, dbMatch } = gameNews.context;
        const winnerRank = calculateRank(winnerName, tournamentState);
        const loserRank = calculateRank(loserName, tournamentState);
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        let gameTitle = `【高校野球】${winnerName}が${loserName}に勝利！`;

        if (rankValues[winnerRank] < rankValues[loserRank]) {
            gameTitle = `【超絶悲報】${loserName}(${loserRank}ランク)、格下の${winnerName}(${winnerRank}ランク)に負けるｗｗｗｗ`;
        } else if ((parseInt(dbMatch.score1) + parseInt(dbMatch.score2)) > 15) {
            gameTitle = `【乱打戦】${winnerName}vs${loserName}、とんでもない試合になる`;
        }
        
        articles.push({
            headline: gameTitle,
            type: 'game',
            matchId: dbMatch.id,
            timestamp: gameNews.timestamp,
            category: '高校野球'
        });
    });
    
    // ★★★ ここからが修正箇所 ★★★
    // (B) ラウンド総括の記事 (isMatomeLink を持つ)
    gameNewsList.filter(n => n.isMatomeLink === true).forEach(summaryNews => {
        articles.push({
            headline: summaryNews.title, // 記事のタイトル (例: 【1回戦 総括】...)
            type: 'game', // まとめスレッドなので 'game' タイプとして扱う
            matchId: summaryNews.matomeThreadId, // リンク先のスレッドID
            timestamp: summaryNews.timestamp,
            category: '大会総括' // 専用カテゴリ
        });
    });
    // ★★★ 修正ここまで ★★★

    // --- 3. ユーザー作成スレッドを取得 ---
    const userThreads = tournamentState.userThreads || [];
    userThreads.forEach(userThread => {
        articles.push(userThread);
    });

    // --- 4. 全記事をタイムスタンプでソートしてHTMLを生成 ---
    articles.sort((a, b) => b.timestamp - a.timestamp);

    if (articles.length === 0) {
        return '<p class="text-center text-gray-500">まだ表示できるニュースがありません。</p>';
    }

    const categoryColors = {
        "高校野球": "bg-green-100 text-green-800",
        "大会総括": "bg-yellow-100 text-yellow-800", // ★総括スレッド用の色
        "自スレ": "bg-blue-100 text-blue-800", // ★自スレ用の色
        "スポーツ": "bg-blue-100 text-blue-800",
        "エンタメ": "bg-pink-100 text-pink-800",
        "国内": "bg-indigo-100 text-indigo-800",
        "国際": "bg-teal-100 text-teal-800",
        "経済": "bg-yellow-100 text-yellow-800",
        "IT": "bg-purple-100 text-purple-800",
        "科学": "bg-gray-200 text-gray-800",
        "主要": "bg-red-100 text-red-800",
        "システム": "bg-red-100 text-red-800"
    };

    return articles.map(article => {
        const time = new Date(article.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
        const commentCount = Math.floor(Math.random() * 800) + 50;
        const color = categoryColors[article.category] || "bg-gray-100 text-gray-800";

        const linkHref = article.type === 'real' ? `href="${article.url}" target="_blank" rel="noopener noreferrer"` : 'href="javascript:void(0)"';
        const dataAttributes = `data-headline="${article.headline}" data-type="${article.type}" data-category="${article.category}" data-match-id="${article.matchId || ''}"`;

        return `
            <a ${linkHref} class="matome-article-link block p-3 rounded-lg hover:bg-gray-100 transition-colors" ${dataAttributes}>
                <div class="flex items-center text-xs text-gray-500">
                    <span class="font-bold py-0.5 px-2 rounded-full ${color}">${article.category}</span>
                    <span class="ml-auto">${time}</span>
                </div>
                <p class="font-bold text-gray-800 mt-2 text-base">${article.headline}</p>
                <div class="text-right text-xs text-gray-500 mt-1">コメント: ${commentCount} 💬</div>
            </a>
        `;
    }).join('');
}
// ▲▲▲ 置き換えここまで ▲▲▲


/**
 * ゲーム内の試合結果に対する、なんJまとめサイト風のスレッドをAIに生成させる
 * (★敗退したC/D/Eランクの「快進撃」にも言及するよう修正)
 */
async function generateGameMatchBbsComments(matchContext) {
    const { 
        winnerName, loserName, dbMatch, matchId, playerStatsText, 
        winnerJourney, loserJourney, nextOpponent, nextOpponentJourney, 
        winnerLineupChanges, loserLineupChanges, highlights,
        injuryReport
    } = matchContext;

    const score = `${dbMatch.score1}-${dbMatch.score2}`;
    const winnerData = TEAM_DATA[winnerName];
    const loserData = TEAM_DATA[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, tournamentState.teamRecords[winnerName]);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, tournamentState.teamRecords[loserName]);
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const loserRankDesc = getRankDescription(loserRank);
    const winnerSeedRank = getSeedRankString(winnerName, tournamentState.seeds);
    const loserSeedRank = getSeedRankString(loserName, tournamentState.seeds);
    const tournamentName = tournamentNameMap[tournamentState.currentTournament] || '大会';
    const tournamentYear = tournamentState.tournamentYear;
    let tournamentBbsContext = "";
    if (tournamentState.currentTournament === 'summer') {
        tournamentBbsContext = "3年生にとってはガチで最後の夏や。";
    } else if (tournamentState.currentTournament === 'autumn') {
        tournamentBbsContext = "新チームの初陣やな。ここでの結果がセンバツ選考に響くで。";
    } else if (tournamentState.currentTournament === 'spring') {
        tournamentBbsContext = "夏のシード権がかかった前哨戦や。";
    }

    let nextOpponentText = '次の相手は未定やな。';
    if (nextOpponent) {
        if (nextOpponent.opponentName === '優勝') {
            nextOpponentText = (tournamentState.currentTournament === 'summer')
                ? '夏の甲子園出場決定や！'
                : (tournamentState.currentTournament === 'autumn' ? 'センバツ出場が有力となった。' : '今大会、見事優勝を果たした。');
        }
        else if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            const nextOpponentSeed = getSeedRankString(nextOpponent.opponentName, tournamentState.seeds); 
            const rankText = nextOpponent.opponentRank ? `(ランク:${nextOpponent.opponentRank})` : '';
            nextOpponentText = `次の${nextOpponent.roundName}の相手は${nextOpponent.opponentName}${nextOpponentSeed}${rankText}か。`;
        } 
        else if (nextOpponent.decidingMatch) {
            const dm = nextOpponent.decidingMatch;
            const team1Seed = getSeedRankString(dm.team1, tournamentState.seeds); 
            const team2Seed = getSeedRankString(dm.team2, tournamentState.seeds); 
            nextOpponentText = `次の${nextOpponent.roundName}の相手は、${dm.team1}${team1Seed}(${dm.rank1}ランク)と${dm.team2}${team2Seed}(${dm.rank2}ランク)の勝者やな。`;
        }
    }
    const nextOpponentJourneyText = (nextOpponent && nextOpponentJourney) ? `ちなみに、その${nextOpponent.opponentName}のここまでの軌跡は「${nextOpponentJourney}」。` : '';

    let highlightsText = '主な出来事はありませんでした。';
    if (highlights && highlights.length > 0) {
        highlightsText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
    }

    const roundName = getRoundNameFromMatchId(matchId);
    
    const hadaReportText = matchContext.hadaReportSummary ? `\n### データ6：記者の視点（羽田レポート）\n${matchContext.hadaReportSummary}\n` : '';
    const calledGameText = matchContext.calledGame ? `\n- **特記事項:** ${matchContext.calledInning}回コールドゲーム` : '';
    const rivalryText = matchContext.rivalryType ? `\n- **特記事項:** この試合は「${matchContext.rivalryType}」という因縁の対決でした。` : '';
    const lineupChangesText = `- ${winnerName}: ${winnerLineupChanges}\n- ${loserName}: ${loserLineupChanges}`;
    let atmosphereText = '';
    if (matchContext.atmosphere_team1 || matchContext.atmosphere_team2) {
        atmosphereText = '\n### データ6：試合前の雰囲気・公約\n';
        if (matchContext.atmosphere_team1) atmosphereText += `- ${dbMatch.team1}: ${matchContext.atmosphere_team1}\n`;
        if (matchContext.atmosphere_team2) atmosphereText += `- ${dbMatch.team2}: ${matchContext.atmosphere_team2}\n`;
    }
    let scheduleText = '';
    if (matchContext.schedule) {
        const sched = matchContext.schedule;
        const team1Region = TEAM_DATA[dbMatch.team1]?.region || '不明';
        const team2Region = TEAM_DATA[dbMatch.team2]?.region || '不明';
        let advantage = 'なし';
        if (sched.region === team1Region && sched.region !== team2Region) advantage = `${dbMatch.team1}の地元`;
        else if (sched.region !== team1Region && sched.region === team2Region) advantage = `${dbMatch.team2}の地元`;
        scheduleText = `\n### データ7：球場情報\n- **球場:** ${sched.stadiumFull} (${sched.region}地区)\n- **地の利:** ${advantage}\n`;
    }
    let ballQualityText = '';
    if (matchContext.team1BallQuality && matchContext.team2BallQuality) {
        ballQualityText = `\n### データ3：チーム別 打球品質レポート\n- ${matchContext.team1BallQuality}\n- ${matchContext.team2BallQuality}\n`;
    }
    
    // ★★★ ここからが「快進撃」判定 ★★★
    let cinderellaPraiseInstruction = "";
    const idParts = matchId.split('-');
    let roundNum = 0;
    if (idParts[0] !== 'F' && idParts[1] && idParts[1].startsWith('R')) {
        roundNum = parseInt(idParts[1].slice(1));
    }
    
    if ( (loserRank === 'E' && roundNum >= 3) ||
         (loserRank === 'D' && roundNum >= 4) ||
         (loserRank === 'C' && roundNum >= 5) )
    {
        cinderellaPraiseInstruction = `
- **【★快進撃への言及】**: 敗北した${loserName}は${loserRankDesc}(${loserRank}ランク)だったが、${roundName}まで勝ち上がった。この「快進撃」を**「${loserName}、ようやっとる」「来年が楽しみなチーム」**のように、必ず称賛すること。`;
    }
    // ★★★ 判定ここまで ★★★
    
    const prompt = `あなたは、匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは高校野球に詳しく、煽りやユーモアを交えながら会話を盛り上げます。
以下の試合データに基づき、ファンたちのリアルな会話コメントを**25〜27個**生成してください。

### 参考情報：静岡県高校野球の「常識」（勢力図）
${PREFECTURE_LORE}

### 現在の試合状況
- **大会:** ${tournamentYear}年度 ${tournamentName}
- **文脈:** ${tournamentBbsContext}
- **ラウンド:** ${roundName}
${scheduleText} 

### データ1：試合結果
- **勝利:** ${winnerName} ${winnerSeedRank} (ランク: ${winnerRank})
- **敗北:** ${loserName} ${loserSeedRank} (ランク: ${loserRank})
- **スコア:** ${score}
- **スタメン変更:**
${lineupChangesText}
${calledGameText} 
${rivalryText} 
${injuryReport || ''}

### データ2：チームの背景
- **${winnerName} ${winnerSeedRank}**: ${winnerDynamicInfo}
  - **軌跡**: ${winnerJourney}
- **${loserName} ${loserSeedRank}**: ${loserDynamicInfo}
  - **軌跡**: ${loserJourney}

### データ3：この試合の個人成績 (最終結果の要約)
${playerStatsText || '個人成績データはありません。'}

### データ4：試合の主な出来事 (ハイライト)
${highlightsText}
${ballQualityText} 

### データ5：トーナメント全体の状況
- **${winnerName}の軌跡(勝ち上がり)**: ${winnerJourney || '今大会初戦'}
- **次の試合**: ${nextOpponentText} ${nextOpponentJourneyText}
${atmosphereText}
${hadaReportText}

### データ6：今大会の主な投手登板履歴 (この試合より前)
${matchContext.pitcherGamelogInfo || '今大会、これが初登板です。'}

### データ7：今大会の主な打者成績履歴 (この試合より前)
${matchContext.batterGamelogInfo || '打者の試合履歴データはありません。'}

### 指示
あなたは今、上記の全データを眺めながら、他のファンと会話しています。**現在の試合が「${roundName}」であること**、**勝者の軌跡**、**次の試合情報**を踏まえつつ、以下の点をコメントに含めてください。

- **【★大会の文脈を反映】**: ${tournamentName}ならではの視点（例：「夏は3年生最後やな」「秋の新チームの仕上がり見えてきたな」）をコメントに含めること。
。
- **【★欠場者への言及】**: もし「主な欠場者」に名前がある場合、その選手がいないこと（例：「エースの姫川[🏥]抜きでよく勝ったわ」「〇〇がいたら結果は違ったかもな」）について必ずコメントすること。
${cinderellaPraiseInstruction} {/* ★ 快進撃の指示を挿入 */}
- **【最重要：次戦情報】**: 「データ5」の**\`次の試合:\`** に書かれている情報を**必ず**コメントに含めてください。「次は〇〇か…」のように具体的に言及し、**「未定」という言葉は絶対に使わないでください。**あなたは今、上記の全データを眺めながら、他のファンと会話しています。**現在の試合が「${roundName}」であること**、**勝者の軌跡**、**次の試合情報**を踏まえつつ、以下の点をコメントに含めてください。

- **【★シードランク言及】**: 試合情報に「(第1シード)」などのシードランクが含まれています。**「第1シードさすがやな」「第5シードが負けたンゴwww」**のように、シードランクにも具体的に言及してください。
- **【最重要：次戦情報】**: 「データ5」の**\`次の試合:\`** に書かれている情報を**必ず**コメントに含めてください。「次は〇〇か…」のように具体的に言及し、**「未定」という言葉は絶対に使わないでください。**
- **【試合への反応】**:
    - 試合結果（スコア、勝敗）に対する感想。
    - 「データ3（個人成績）」や「データ4（ハイライト）」で目立った選手やプレーへの言及。「データ3」の**背番号**にも注目すること。
    - **（重要）** 1桁番号（エース/レギュラー）が活躍するのは当然だが、**背番号2桁の選手が活躍した場合**、それを「控えの活躍」と安易に断定せず、「**背番号10だけど実質エース**」「**2桁の〇〇が仕事したな**」といった、**その選手の実力を評価する**コメントを生成すること。
    - もし敗北チームが善戦した場合 (スコア差が小さい、ランク差があるのに接戦など) は、その健闘を称えるコメント。
- **【常識の反映】**: あなたが熟知している「常識」（例：ナムコ vs 公立の砦、古豪の復活、王者283学園の動向）を、試合結果やデータと関連付けてコメントすること。
- **【その他】**:
    - なんJらしい短い煽りや草(w)を適度に含める。
    - 他のコメントへの安価 (>>) をいくつか含める。
    - ランク名を言い換える（A→名門、B→強豪、C→中堅、D→挑戦校、E→無名校）。
- **#は背番号と言い換えてください。(例　#1→背番号1)**
- **【羽田レポートへの言及】**: もし「データ6：記者の視点」に羽田記者の分析がある場合、**「羽田とかいう記者が～って言ってたけど…」** のように、その分析に同意したり、反論したりするコメントを**必ず**含めること。
- **【試合前の雰囲気】**: もし「データ6：試合前の雰囲気・公約」が提供されていたら（例：「エース温存公言」「コンディション最悪」など）、**その伏線が試合結果でどうなったか**について（例：「なお姫」「温存（）」「やっぱ体調悪かったんか」）必ず言及すること。
- **【球場への言及】**: もし「データ7：球場情報」があり、「地の利」がどちらかのチームにあった場合（例：静岡が草薙で試合）、**「謎の力キターw」「地元判定やめろ」「〇〇（球場名）まで遠征ご苦労さん」**など、球場に関するコメントを必ず含めること。
- **【★今大会の成績 (最重要)】**:
    - 「データ2」に**『今大会のチーム打率は.XXX』**という情報が含まれています。
    - この情報を**必ずコメントに含め**、チームの好調・不振（例：「〇〇、今大会打率.150とかマジ？」「打率3割超えの打線相手によく抑えたわ」）にも言及すること。
- **【投手の詳細属性】**: 「データ3（ボックススコア）」に「（右/オーバー/本格派/150km帯）」といった**投手の詳細属性**が記載されている場合、それにも言及すること。

// ▼▼▼ 既存の「盗塁」の指示ブロックを、以下で「置き換え」 ▼▼▼
- **【★盗塁への言及 (重要)】**:
    - 「データ3（個人成績）」に**盗塁(SB)**が記録されている選手がいたら、「〇〇、足はえーなw」「良い盗塁やった」と言及すること。
    - さらに、その選手の**「今大会の通算盗塁数」**（例：(今大会: ... 4盗)）も必ず参照し、**「姫川、今大会4盗塁目かよw」「こいつ打ちすぎだし走りすぎだろ」**といった具体的な数字に言及すること。
    - **盗塁が0でも批判は不要です。**
// ▲▲▲ 置き換えここまで ▲▲▲

- **【★通算成績への言及 (裁量)】**:
    - 「データ2」に**『(参考: チーム通算打率 .XXX, 通算 Y 盗塁)』**という情報が含まれている場合、必要に応じて（例：チームの伝統的な機動力を語る際など）、その「通算盗塁」にも言及すること。
    - **盗塁が0でも批判は不要です。**
- **【★注目の打席（最重要）】**:
    - 「データ4（ハイライト）」に「（★注目）」マークが付いている打席が、この試合の**ターニングポイント**や。
    - **「あの場面が全てやったな」「あそこの（★注目）〇〇の打席がデカすぎた」**のように、その「★注目」の打席が試合の勝敗を分けた決定的な瞬間であったと言及すること。
- **【コールド/因縁】**: もし試合がコールドゲームや「${matchContext.rivalryType || '因縁の対決'}」であった場合、その点について必ず言及すること。
- **【スタメン変更】**:スタメン変更があった場合(${lineupChangesText})触れなさい。
- **【選手の状態】**: 「データ3（個人成績）」に「(状態: 〇〇)」と書かれている選手に注目し、「絶好調の〇〇、今日も打ったなw」「不振だった△△、ついに目覚めたか？」など、**前回の試合からの連続性**を意識したコメントをすること。
- **【打球の質（打者・投手）】**: 「データ3（個人成績）」や「データ4（ハイライト）」にある**打球の質**（「鋭い当たり」「詰まった当たり」など）にも注目すること。
- **【打球の質（チーム全体）】**: 「データ3：チーム別 打球品質」を見て、チーム全体の調子について言及すること。
- **【打順の役割】**: 「常識」としてインプットされた**打順の役割**を意識してコメントすること。
- **【投打の左右の相性】**:
    - 「データ2（常識）」と「データ3（ボックススコア）」にある**投打の左右**にも注目すること。
    - **特に、相手が「左腕（サウスポー）」だった場合**や、監督が**「ワンポイントリリーフ」**を使った場合に、その相性について言及すること。
- **【★スタメン復帰】**: 「データ1：スタメン変更」に「〇〇がスタメン復帰」とあった場合、**「おお、〇〇戻ってきたか！」「ここで使うのは博打だろw」**のように、その選手への期待や不安をコメントに含めること。
- **【★登板履歴への言及】**: 「データ5：今大会の主な投手登板履歴」に情報がある場合、**「〇〇、1回戦でも投げてたよな」「連投大丈夫か？」**のように、その投手の登板間隔や過去の投球内容にも言及すること。
// ▼▼▼ 既存の「登板履歴への言及」指示を、以下の詳細な指示ブロックに「置き換え」 ▼▼▼
- **【★登板履歴への言及 (最重要)】**: 「データ5：今大会の主な投手登板履歴」の情報を必ず確認し、以下の点をコメントに含めること。
    - **連投/登板間隔**: 「〇〇、昨日も投げてなかったか？」「連投お疲れ様」「中1日でこれはキツイわ」
    - **酷使**: 「エース投げすぎだろ」「監督は鈴木を壊す気か」
    - **好不調の波**: 「前回炎上したのによう立ち直ったな」「こないだは良かったのに今日はアカンか」
    - **相手の質**: 「今まで雑魚狩りだったのがバレたなw」「強豪相手でも抑えるとか本物やん」
// ▲▲▲ 置き換えここまで ▲▲▲
// ▼▼▼ 挿入 ▼▼▼
- **【★打者履歴への言及 (最重要)】**: 「データ6：打者成績履歴」も必ず確認し、以下の点をコメントに含めること。
    - **好不調の波**: 「〇〇、今日で3試合連続ヒットやん！」「△△、10打数ノーヒットとかもう終わりだろ…」
    - **役割**: 「こいつ代打成功率100%じゃね？」「1番に上げたら打ち出したな」
    - **相手の質**: 「今まで雑魚狩りだったのがバレたなw」「Aランク投手から打つとか本物やん」
// ▲▲▲
### 出力形式【最重要】
解説や前置きは一切不要です。**必ず以下の JSON 配列形式 (\`[...]\`) のみ**で出力してください。
\`\`\`json
[
  {"personality": "1: 風吹けば名無し", "comment": "（生成したコメント1）"},
  {"personality": "2: 風吹けば名無し", "comment": "（生成したコメント2）"},
  // ... (合計25〜30個のコメント) ...
]
\`\`\`
`; 
    // ▲▲▲ プロンプト修正ここまで ▲▲▲

    // --- AIへのリクエスト部分は変更なし ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map((c, index) => ({
                    id: crypto.randomUUID(),
                    personality: c.personality || `${index + 1}: 風吹けば名無し`,
                    text: c.comment,
                    timestamp: Date.now() + index * 10,
                    replies: []
                }));
            } else {
                console.warn("AIが予期しないオブジェクト形式でBBSコメントを返しました。中身を取り出します。");
                if (commentsJson && commentsJson.comments && Array.isArray(commentsJson.comments)) {
                     return commentsJson.comments.map((c, index) => ({
                        id: crypto.randomUUID(),
                        personality: c.personality || `${index + 1}: 風吹けば名無し`,
                        text: c.comment,
                        timestamp: Date.now() + index * 10,
                        replies: []
                    }));
                }
            }
        }
        throw new Error("AIからの応答が、正しいコメント配列形式ではありません。");
    } catch (error) {
        console.error("AI game match BBS generation failed (seed-aware):", error);
        return {
            error: true,
            title: "掲示板コメント生成エラー(シード対応版)",
            body: "AIによるコメント生成に失敗しました。",
            timestamp: Date.now(),
            errorId: `error-${matchId}-bbs-seed`,
            context: matchContext
        };
    }
}

// ▼▼▼ このブロックをまるごと「新規追加」 ▼▼▼

// ▼▼▼ 既存の generateUserThreadBbsComments 関数 (12015行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * ユーザーが作成したスレッド（タイトル＋本文）に対し、なんJ風の掲示板コメントをAIに生成させる
 * (★試合の文脈（コンテキスト）をAIに渡して、本格的なレスを生成するよう強化した最終版★)
 * * @param {string} title - ユーザーが入力したスレッドタイトル
 * @param {string} firstCommentText - ユーザーが入力した本文 (>>1)
 * @param {string} gameContext - AIに提供する追加の試合/選手データ (formatPlayerGamelogsForPrompt などで生成)
 * @returns {Promise<Array|null>} コメントオブジェクトの配列
 */
async function generateUserThreadBbsComments(title, firstCommentText, gameContext) {
    let personaPrompt = `あなたは、日本の匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは少し皮肉屋で、ネットスラングを多用し、あらゆる話題に短いコメントを書き込みます。`;
    
    // ★ gameContext が提供されていれば、プロンプトに「知識」として挿入する
    const contextPrompt = gameContext 
        ? `
### 参考情報：静岡県高校野球の「常識」
${PREFECTURE_LORE}

### 参考情報：スレッドの話題に関連する最新データ
${gameContext}
`
        : `
### 参考情報
(特に関連する試合データはありません。一般的な話題として返信してください。)
`;

    const prompt = `${personaPrompt}

以下の【ユーザーが立てたスレッド】について、**リアルタイムでスレッドが進行していくかのように**、自然な流れで**10〜15個**の掲示板の反応を生成してください。

### スレッドタイトル
${title}

### スレ主(>>1)の本文
${firstCommentText}

${contextPrompt}

### スレッド進行の指示
1.  **序盤 (2〜5レス):** スレ主の投稿(>>1)に対し、即座に食いつく第一陣の反応。「マジか」「草」「また〇〇か」といった短いコメントが中心。
2.  **中盤 (6〜15レス):** - スレ主の話題に対して様々な角度からコメントを始める。肯定、否定、煽り、全く関係ない脱線などを織り交ぜる。
    - **【★最重要】**: もし「参考情報：最新データ」が提供されている場合、その**データ（Gamelog、チーム打率、登板間隔など）**を**必ず**引用し、スレ主(>>1)の意見（例：「鈴木が凄い」）を補強したり、反論したりしてください。
    - （例：「>>1 わかる。鈴木、これで3試合連続無失点じゃね？」「でも〇〇高校、チーム打率.180だぞ。鈴木が良くても勝てんわ」）
    - **「>>1」への安価（アンカー）**を使って、スレ主の意見に返信するやり取りを必ず含めること。
3.  **終盤 (16レス以降):** ある程度議論が出尽くした後の、まとめのようなコメントや、飽きてきた住民によるおふざけが始まる。
4.　**最終盤 (26レス以降):** スレも混沌としてきて、関係ない話題を持ってくる者や、勝手にコンプレックスを刺激され発狂するもの、ただの荒らしなどが湧き始め、グダグダになり解散する。

### 出力形式（JSON配列）
[
    {"personality": "2: 風吹けば名無し", "comment": "（住民2のコメント）"},
    {"personality": "3: 風吹けば名無し", "comment": "（住民3のコメント）"},
    ...
]`; // スレ主(1:)は除く

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map((c, index) => ({ // indexを調整 (2から始まるように)
                    id: crypto.randomUUID(),
                    personality: c.personality.startsWith(`${index + 2}:`) ? c.personality : `${index + 2}: ${c.personality}`, // 番号を2から振る
                    text: c.comment,
                    timestamp: Date.now() + index * 10
                }));
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI user thread BBS generation failed:", error);
        return null;
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲
/**
 * 現実のニュースヘッドラインに対する、なんJ風の掲示板コメントをAIに生成させる
 * @param {string} headline - 現実のニュースの見出し
 * @param {string} category - ニュースのカテゴリ
 * @returns {Promise<Array|null>} コメントオブジェクトの配列
 */
async function generateRealNewsBbsComments(headline, category) {
    let personaPrompt = `あなたは、日本の匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは少し皮肉屋で、ネットスラングを多用し、あらゆる話題に短いコメントを書き込みます。`;
    let instructions = ``;
    switch (category) {
        case '政治': instructions = `政治ニュースに詳しい住民として、与党や野党を煽ったり、将来を悲観したり、達観したようなコメントをしてください。`; break;
        case '芸能': instructions = `芸能ニュースが大好きな野次馬として、「〇〇ロスだわ」「どうせすぐ別れる」といった、お祝いと嫉妬が入り混じったコメントをしてください。`; break;
        case '学歴': instructions = `学歴コンプレックスを持つ住民として、「F欄のワイ、高みの見物」「結局は学歴よりコミュ力」といった、自虐や持論を展開してください。`; break;
        default: instructions = `一般的な住民として、ニュースに反応してください。`; break;
    }
    
    const prompt = `${personaPrompt}

以下の【${category}】のニュースヘッドラインについて、**リアルタイムでスレッドが進行していくかのように**、自然な流れで**10〜15個**の掲示板の反応を生成してください。

### ニュースヘッドライン
${headline}

### スレッド進行の指示
1.  **序盤 (1〜5レス):** スレ主の投稿に対し、即座に食いつく第一陣の反応。「マジか」「草」「また〇〇か」といった短いコメントが中心。
2.  **中盤 (6〜15レス):** 少し冷静になった住民たちが、ニュースに対して様々な角度からコメントを始める。肯定、否定、煽り、全く関係ない脱線などを織り交ぜる。**「>>1」「>>5」のような安価（アンカー）を使って、他のコメントに返信するやり取りを必ず含めること。**
3.  **終盤 (16レス以降):** ある程度議論が出尽くした後の、まとめのようなコメントや、飽きてきた住民によるおふざけが始まる。
4.　**最終盤 (26レス以降):** スレも混沌としてきて、関係ない話題を持ってくる者や、勝手にコンプレックスを刺激され発狂するもの、ただの荒らしなどが湧き始め、グダグダになり解散する。


### 出力形式（JSON配列）
[
    {"personality": "1: 風吹けば名無し", "comment": "（スレ主のコメント）"},
    {"personality": "2: 風吹けば名無し", "comment": "（住民2のコメント）"},
    {"personality": "3: 風吹けば名無し", "comment": "（住民3のコメント）"},
    ...
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now()
                }));
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI real news BBS generation failed:", error);
        return null;
    }
}
// ▲▲▲ ここまで追加 ▲▲▲

// ▲▲▲ ここまで追加 ▲▲▲

/**
 * 指定されたチームが次に出場する、まだ終わっていない試合を探す
 * @param {string} teamName - 探したいチーム名
 * @param {object} state - 現在のtournamentState
 * @returns {object|null} - 見つかった試合オブジェクト、またはnull
 */
function findCurrentMatchForTeam(teamName, state) {
    const allMatches = { ...state.matches, ...(state.autumnData?.allMatches || {}), ...(state.springData?.allMatches || {}) };
    let earliestMatch = null;
    let minRound = Infinity;

    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (!match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 0;
            if (roundNum < minRound) {
                minRound = roundNum;
                earliestMatch = match;
            }
        }
    }
    return earliestMatch;
}



/**
 * トーナメントの勝者を次のラウンドに進める（processMatchWinから抜粋・改造）
 * @param {object} match - 終了した試合のオブジェクト
 * @param {string} winnerName - 勝者名
 * @param {object} state - 現在のtournamentState
 */
function advanceWinnerToNextRound(match, winnerName, state) {
    const matchId = match.id;
    const idParts = matchId.split('-');
    const side = idParts[0];

    if (side === 'F') return; // 決勝戦なら何もしない

    const roundStr = idParts[1];
    const roundNum = parseInt(roundStr.slice(1));
    
    // このロジックは夏季・春季県大会（16 or 64チーム）を想定
    if (state.teams && state.teams.length > 0) {
        const numTeamsInTournament = state.teams.length;
        const finalRound = Math.log2(numTeamsInTournament);

        if (roundNum < finalRound) {
            const matchNum = parseInt(idParts[2].slice(1));
            const nextRoundNum = roundNum + 1;
            let nextMatchId = (nextRoundNum === finalRound) ? 'F-R1-M1' : `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
            
            if (!state.matches[nextMatchId]) {
                state.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
            }
            let slot = (nextRoundNum === finalRound) ? (side === 'L' ? 1 : 2) : (matchNum % 2 !== 0 ? 1 : 2);
            state.matches[nextMatchId][`team${slot}`] = winnerName;
        }
    }
    // TODO: 秋季大会などの複雑な進行ロジックが必要な場合は、ここに追加する
}

// ▲▲▲ ここまで追加 ▲▲▲


/**
 * 密着ドキュメンタリーを開始し、序章の記事を生成する
 * (★128チーム制＝1ブロック32チームに対応)
 * @param {'underdog' | 'powerhouse'} type - ドキュメンタリーの種類
 * @param {string} teamName - 取材対象のチーム名
 */
async function startDocumentary(type, teamName) {
    tournamentState.documentary = { target: teamName, type: type };
    newsContainer.innerHTML = `<div class="loader">AI記者が「${teamName}」の特別ドキュメンタリー番組の制作を開始しました...</div>`;
    
    renderTournament(tournamentState); 

    const firstMatch = Object.values(tournamentState.matches).find(m => 
        m.id.includes('-R1-') && (m.team1 === teamName || m.team2 === teamName)
    );
    
    let matchDataForArticle = { 
        opponent: '不明', opponentRank: 'E', opponentRecord: '情報なし',
        toughestRival: '不明', toughestRivalRecord: '情報なし'
    };

    if (firstMatch) {
        const opponentName = firstMatch.team1 === teamName ? firstMatch.team2 : firstMatch.team1;
        matchDataForArticle.opponent = opponentName;
        matchDataForArticle.opponentRank = calculateRank(opponentName, tournamentState);
        matchDataForArticle.opponentRecord = TEAM_DATA[opponentName]?.last || '情報なし';

        // ★★★ ここからが修正箇所 ★★★
        const teamIndex = tournamentState.teams.indexOf(teamName);
        const blockSize = Math.floor(tournamentState.teams.length / 4); // 128 / 4 = 32
        const blockIndex = Math.floor(teamIndex / blockSize);
        const blockStart = blockIndex * blockSize;
        const blockEnd = blockStart + blockSize;
        // ★★★ 修正ここまで ★★★
        
        const blockTeams = tournamentState.teams.slice(blockStart, blockEnd);
        
        let toughestRivalName = null;
        let highestRankValue = -1;
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };

        blockTeams.forEach(rivalName => {
            if (rivalName === teamName || rivalName === '(BYE)') return; // 自分と不戦勝は除外
            const rivalRank = calculateRank(rivalName, tournamentState);
            if (rankValues[rivalRank] > highestRankValue) {
                highestRankValue = rankValues[rivalRank];
                toughestRivalName = rivalName;
            }
        });
        
        if (toughestRivalName) {
            matchDataForArticle.toughestRival = toughestRivalName;
            matchDataForArticle.toughestRivalRecord = TEAM_DATA[toughestRivalName]?.last || '情報なし';
        }
    }
    
    const article = await generateDocumentaryArticle('intro', type, teamName, matchDataForArticle);

    if (article) {
        tournamentState.news.push(article);
    } else {
        tournamentState.news.push({
            title: "ドキュメンタリー記事生成エラー",
            body: `「${teamName}」のドキュメンタリー記事の生成に失敗しました。`,
            timestamp: Date.now(),
            error: true,
            context: {
                isDocumentary: true,
                type: type,
                teamName: teamName,
                matchData: matchDataForArticle
            }
        });
    }
    renderNews(tournamentState.news);
    saveState();
}
// ▲▲▲ 置き換えここまで ▲▲▲



async function generateDocumentaryArticle(phase, type, teamName, matchData = null, userFeedback = null) {
    const teamMasterData = TEAM_DATA[teamName];
    let prompt = `あなたは、情熱的で人間ドラマを描くのが得意なドキュメンタリー番組の記者です。あなたは今、高校野球チーム「${teamName}」に密着取材しています。`;
    let title = "";

    let charactersPrompt = `### 主な登場人物\n- 監督: ${teamMasterData.coach.name} (${teamMasterData.coach.style})\n`;
    if (DETAILED_TEAM_DATA[teamName]) {
        const detailedData = DETAILED_TEAM_DATA[teamName];
        const keyPlayers = detailedData.players.map(p => `- ${p.name}(${p.year}年, ${p.position}): ${p.desc}`).join('\n');
        charactersPrompt += `### 注目選手\n${keyPlayers}\n`;
    }
    
    let feedbackPrompt = '';
    if (userFeedback) {
        if (userFeedback.include && userFeedback.include.trim() !== '') {
            feedbackPrompt += `\n- **【最重要指示】** 以下の要素を必ず記事の中心に据えて、最もドラマチックに描写してください：\n${userFeedback.include}\n`;
        }
        if (userFeedback.exclude && userFeedback.exclude.trim() !== '') {
            feedbackPrompt += `\n- **【厳禁事項】** 以下の要素や表現は、絶対に記事に含めないでください：\n${userFeedback.exclude}\n`;
        }
    }
    const finalFeedbackPrompt = `\n### ディレクターからの追加指示\n${feedbackPrompt || '特になし'}`;

    // ==================================================================
    // --- 1. 古豪復活チーム (powerhouse_revival) ---
    // ==================================================================
    if (type === 'powerhouse_revival') {
        switch (phase) {
            case 'intro':
                title = `『${teamName}、復活への序曲』`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 1) { // 格上
                        reactionPrompt = `
5.  **【試練の初戦】**
    初戦の相手が格上の「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちが「不足はない相手」「復活をアピールするには最高の相手だ」と闘志を燃やす。
6.  **【監督の『建前』と『本音』】**
    監督は**選手たちの前で**、「挑戦者として、失うものは何もない。全力でぶつかるぞ」という趣旨で語る。
    しかし記者の前では**二人きりで**、「本当の山場は**${matchData.toughestRival}**戦でしょう。彼らは昨年${matchData.toughestRivalRecord}。この初戦は、そこへ向けてチームがどれだけ成長できるかの試金石ですね」という趣旨で、冷静に先を見据える。`;
                    } else { // 同格か格下
                        reactionPrompt = `
5.  **【油断という名の敵】**
    初戦の相手が「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。「勝てる」という安堵の空気が選手たちの間に流れる。
6.  **【監督の『建前』と『本音』】**
    その空気を察した監督が**選手たちの前で**、「油断が一番の敵だ。俺たちはまだ何も成し遂げていない」という趣旨で厳しく一喝する。
    しかし、記者の前では**二人きりで**、「正直、ホッとしました。**${matchData.toughestRival}**（彼らは昨年${matchData.toughestRivalRecord}）と当たるまでに、いくつか試合をこなして練度を上げたかったので」という趣旨で、安堵の理由が戦略的なものであることを明かす。`;
                    }
                }
                prompt += `
### 取材テーマ
かつて黄金時代を築いた古豪「${teamName}」が、失われた栄光を取り戻すべく挑む夏を追う。過去、現在、そして未来が交錯する物語の序章を描いてください。
${charactersPrompt}
### 構成案
1.  **【埃をかぶった優勝旗】**: 部室に眠る色褪せた優勝旗やトロフィーの描写から始める。過去の栄光の重圧と、現在のチームが置かれた状況（${teamMasterData.info}）を対比させる。
2.  **【OBたちの熱き眼差し】**: 練習を厳しい目で見つめるOB会長に「俺たちの時代は…」という昔語りと、現在のチームへの歯がゆさ、そして心の底にある期待を語らせる。
3.  **【重圧を背負う主将】**: 主将に「このユニフォームを着て戦うことの意味」を問う。伝統の重みと、それを力に変えようとする彼の覚悟を描写する。
4.  **【監督の信念と現実】**: 監督に「古豪復活への道筋」をインタビューする。OBからのプレッシャーの中で、彼が信じる今の選手たちの可能性と、現在の課題について語らせる。
${reactionPrompt}
7.  **【新たな歴史へ】**: 主将の「俺たちは俺たちの野球で、新しい歴史を作るだけ」という言葉で、復活をかけた夏の始まりを力強く宣言して締めくくる。
### 描写のポイント
- 時間軸の意識: 「過去の栄光」「現在の葛藤」「未来への挑戦」を意識し、物語に深みを与えること。
- 建前と本音: 監督の二面性を描くことで、キャラクターのリアリティを追求すること。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、復活への第一歩』`;
                prompt += `
### 取材テーマ
古豪「${teamName}」が ${matchData.opponent} との試合に ${matchData.score} で勝利しました。「名門復活への狼煙」となるこの一勝の価値を、感動的に描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」を物語の中心に据え、その場面を最もドラマチックに描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、この勝利の価値をより高める。
3.  監督に「伝統の粘り強さが出せた」という趣旨のコメントをさせる。
4.  主将に、次戦への意気込みと共に「先輩たちが築いた歴史に、新たな1ページを刻みたい」と語らせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、夢、またも届かず』`;
                prompt += `
### 取材テーマ
古豪「${teamName}」の夏が終わりを告げた。復活を願った人々の期待と、それに応えられなかった選手たちの無念さを描いてください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにしてチームの夢を打ち砕いたかを詳細に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、敗北の文脈をより深く描写する。
3.  グラウンドに泣き崩れる選手たちと、彼らにかける言葉が見つからない監督の姿。
4.  「彼らの挑戦は終わった。しかし、〇〇（校名）の野球部の灯が消えることはない」と、未来への希望で締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } 
    // ==================================================================
    // --- 2. 絶対的エースチーム (one_man_team) ---
    // ==================================================================
    else if (type === 'one_man_team') {
        switch (phase) {
            case 'intro':
                title = `『${teamName}のエースと、8人の仲間たち』`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 2) { // 絶望的な格上
                        reactionPrompt = `
5.  **【試される『個』の力】**
    初戦の相手が格上の強豪「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。野手たちが動揺する中、エースだけが「相手が誰であろうと、俺がゼロに抑えるだけです」という趣旨のコメントで闘志を燃やす。
6.  **【監督の『建前』と『本音』】**
    監督は**選手たちの前で**、「最高の相手だ。我々には〇〇（エース名）がいる。彼を信じろ」という趣旨のコメントで、エースへの絶対的な信頼を口にする。
    しかし記者の前では**二人きりで**、「正直、最悪のクジです。彼（エース）の負担を考えれば、勝ち進んだ先の**${matchData.toughestRival}**（昨年${matchData.toughestRivalRecord}）戦まで、他の選手に経験を積ませたかった」という趣旨のコメントで、チーム全体の成長を願う本音を漏らす。`;
                    } else { // 同格か格下
                        reactionPrompt = `
5.  **【エース温存か、否か】**
    初戦の相手が「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちの間に「この相手なら、エース抜きでも勝てるのでは？」という慢心が生まれる。
6.  **【監督の『賭け』】**
    監督が**選手たちの前で**、「初戦、〇〇（エース名）は投げない。お前たちで勝ち上がってこい」という趣旨の、非情とも思える決断を下す。
    記者の前では**二人きりで**、「これは賭けです。でも、**${matchData.toughestRival}**（昨年${matchData.toughestRivalRecord}）と戦うことを見据えれば、ここで他の選手が覚醒しなければ未来はない」という趣旨のコメントで、エースの将来とチームの未来を想う本音を語らせる。`;
                    }
                }
                prompt += `
### 取材テーマ
プロ注目の絶対的エースを擁する「${teamName}」。天才の苦悩と、彼を支える「その他大勢」と呼ばれた仲間たちのプライドを描く。
${charactersPrompt}
### 構成案
1.  **【殺到する報道陣】**: 練習グラウンドに集まる、エースだけを狙う無数のカメラの描写から始める。
2.  **【エースの孤独なマウンド】**: エースにインタビュー。「チームを勝たせるのが自分の仕事」と語る彼の言葉の裏にある、重いプレッシャーを描写する。
3.  **【名もなき脇役たちの意地】**: メディアからは注目されない他の野手たちに焦点を当てる。「俺たちは、あいつの引き立て役じゃない」という、彼らの静かなプライドと葛藤を引き出す。
4.  **【監督の信念】**: 監督に「彼らはワンマンチームですか？」と問う。「世間はそう言うだろう。だが、本当の主役が誰なのかを私だけは知っている」という趣旨の意味深な言葉を語らせる。
${reactionPrompt}
7.  **【一つのチームとして】**: 野手の一人が「俺たちが、あいつを甲子園のマウンドに連れて行く」と力強く宣言し、物語を締めくくる。
### 必ず含めるべき要素
- **チームが抱える状況を描写すること: ${teamMasterData.info}**
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `エース快投！しかし、勝利の影に${teamName}の結束あり`;
                prompt += `
### 取材テーマ
「${teamName}」が勝利。メディアはエースの快投ばかりを報じるだろう。しかし、その裏にあった仲間たちのファインプレーやチームの結束こそが真の勝因だったことを、あなたの視点で深く描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにチームの結束力を象徴するプレーだったかを物語の中心に据える。
2.  エースの投球内容を簡潔に紹介しつつ、「しかし、この日の主役は彼だけではなかった」と続ける。
3.  そのプレーをした選手に「エースを助けるのが俺たちの仕事ですから」と、誇らしげに語らせる。
4.  エースに「今日の勝利は、俺一人の力じゃない。みんなが守ってくれたおかげです」と、初めて仲間に感謝の言葉を述べさせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `英雄、あまりに早すぎる敗退。${teamName}の夏、終わる`;
                prompt += `
### 取材テーマ
絶対的エースを擁しながら、「${teamName}」は敗れた。天才と仲間たちの、残酷で、しかし美しい夏の終わりを描いてください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにして絶対的エースを打ち崩したのか、その一瞬を詳細に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れることで、敗北の衝撃を際立たせる。
3.  マウンドで呆然とするエースと、彼に駆け寄り「お前のせいじゃない」と声をかける仲間たちの姿を描く。
4.  「彼らはワンマンチームではなかった。勝つ時も、負ける時も、彼らは一つのチームだった」と締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } 
    // ==================================================================
    // --- 3. 強豪校 (powerhouse) ---
    // ==================================================================
    else if (type === 'powerhouse') {
        switch (phase) {
            case 'intro':
                title = `『${teamName}、王者の告白』序章`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 0) { // 同格か格上
                        reactionPrompt = `
5.  **【試される王国】**
    初戦の相手がいきなり実力校「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちの間に走る緊張感を「歓迎すべき試練」として描写する。
6.  **【監督の『建前』と『本音』】**
    監督は**選手たちの前で**、「初戦から最高の相手だ。挑戦者を受ける覚悟はできている」という趣旨で、チームのプライドを煽る。
    しかし記者の前では**二人きりで**、「厳しい戦いになる。だが、このブロックの本命は我々と**${matchData.toughestRival}**。彼らは昨年${matchData.toughestRivalRecord}。倒すためには、どこかで通らなければいけない道だ」という趣旨で、厳しい本音を語らせる。`;
                    } else { // 格下
                        reactionPrompt = `
5.  **【王者の静寂】**
    初戦の相手が「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちは表情一つ変えず、淡々と次の練習の準備を始める。
6.  **【監督の『建前』と『本音』】**
    監督が**選手たちの前で**は「油断するな」という趣旨で引き締めつつ、記者の前では**二人きりで**、「初戦は問題ない。本当の勝負は**${matchData.toughestRival}**戦。彼らは昨年${matchData.toughestRivalRecord}の実力校だ。そこが事実上の決勝戦になるだろう」という趣旨で、先を見据えた分析を語らせる。`;
                    }
                }
                prompt += `
### 取材テーマ
絶対的王者「${teamName}」の栄光の裏に隠された苦悩と、常人には理解しがたいプレッシャーを描く。
${charactersPrompt}
### 構成案
1.  **【静寂のトロフィー室】**: 無数に並ぶ優勝トロフィーが放つ輝きと、「勝って当然」という重圧を描写する。
2.  **【Bグラウンドの陽炎】**: ベンチ入りできなかった3年生が、最後の夏にも関わらず、黙々と後輩へのサポートを務める。彼の「チームへの愛」と「諦め」の独白を引き出す。
3.  **【監督の非情な勝負論】**: 監督にインタビュー。「勝つためには、時に非情にならなければならない。それが王者であり続けるということだ」という彼の哲学を語らせる。
4.  **【主将の孤独な背中】**: スター選手揃いのチームを一つにまとめることの難しさと、「負けることが許されない」という王者ならではの孤独な覚悟を主将に語らせる。
${reactionPrompt}
7.  **【王者、出陣】**: 主将が「俺たちの目標は、県大会優勝じゃない。その先にある」と、全国の頂点だけを見据えていることを示唆して締めくくる。
### 必ず含めるべき要素
- **チームが抱える状況を描写すること: ${teamMasterData.info}**
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、王者の告白』第${matchData.round}章`;
                prompt += `
### 取材テーマ
「${teamName}」が勝利。しかし彼らにとってこの勝利は歓喜ではなく、「次へ進むための義務」でしかない。その独特の空気感をリアルに描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」を引用し、それが王者としての力の証明であったことを示す。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、勝利が順当であったことを描写する。
3.  試合後、安堵の表情を浮かべるも、決して喜びを爆発させない選手たちの姿。
4.  監督に「今日のプレーで満足せず、次を見据えている」という趣旨の、冷静なコメントをさせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、王者の告白』最終章`;
                prompt += `
### 取材テーマ
絶対的王者「${teamName}」の夏が終わった。王国の崩壊の瞬間と、選手たちの初めて見せる涙、そして重圧からの解放を感傷的に記録してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにして絶対王者の歯車を狂わせたのか、その瞬間を克明に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、この敗戦が歴史的な番狂わせであることを強調する。
3.  試合終了のサイレンが鳴り響く、球場の信じられないような静寂を描写する。
4.  これまで常に気丈に振る舞ってきた主将が、初めてグラウンドに泣き崩れる姿に焦点を当てる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } 
    // ==================================================================
    // --- 4. 逆境チーム (underdog) ---
    // ==================================================================
    else { 
        switch (phase) {
            case 'intro':
                        // ▼▼▼ このブロックをまるごと置き換えてください ▼▼▼
                        title = `『${teamName}、魂の記録』序章：それでも、彼らはグラウンドに立つ`;
                        let reactionPrompt = '';
                        let teamSpecificInfo = teamMasterData.info || '特筆すべき情報なし';
                        let handicapFocusPrompt = ''; // 先に空で定義

                        // ▼▼▼ 【最重要】「浜松特支」専用の特別分岐 ▼▼▼
                        if (teamName === '浜松特支') {
                            handicapFocusPrompt = `
3.  **【特別な夏、その意味】**: 県内唯一の特別支援学校の野球部、浜松特支。部員は全員1年生。彼らにとって、これは初めての夏であり、全てが挑戦である。
4.  **【春の記憶と安全への声】**: 記者が北村監督に話を聞くと、彼は春の練習試合—王者・283学園に喫した「52-0」の大敗—について重い口を開く。「あの試合で、選手たちから野球の楽しさを奪ってしまったかもしれない」と。同時に、外部から寄せられる「知的障害を持つ彼らに、硬球を使った野球は本当に安全なのか」という厳しい批判の声にも直面していることを明かす。
5.  **【部室の野球ノート】**: 部室代わりの理科準備室に置かれた野球ノート。「こわい」「たご(※たのしくない)」。そこには、彼らの純粋な恐怖と苦しみが記されていた。
6.  **【ある選手の挑戦（高橋 健太）】**: チームの一人、高橋健太くん（仮名）に焦点を当てる。彼は重度の知的障害を抱えており、仲間とのコミュニケーションや、ルールの理解にも人一倍時間がかかる。だが、練習で唯一「バットにボールを当てる」ことだけは誰よりも得意だ。
7.  **【ある母親の涙】**: 練習をフェンス越しに見つめる健太くんの母親にインタビューする。「あの子が...あの子が、仲間と声を掛け合ってボールを追いかけている...。野球を始める前は、そんなこと想像もできませんでした」。彼女はそう言うと、感極まって涙を拭った。「勝たなくていい。ただ、あの子が楽しそうにバットを振って、9回まで試合ができたら...それだけで...」
8.  **【監督の葛藤】**: 北村監督の葛藤を描写する。「勝利」ではない。「試合を成立させること」の絶望的な難しさ、そして「彼らの安全を守りながら、どうやって野球の楽しさを取り戻させるか」という答えのない問いに日々向き合う姿を深く掘り下げる。
9.  **【彼らの目標】**: 主将に今大会の目標を聞く。「甲子園じゃない。9回まで戦い抜いて、スコアボードに...0以外の数字を灯したい」。その言葉の重みを描写する。`;
                        }
                        // ▼▼▼ 【ご要望】「廃校」チームの専用分岐（OB会長登場） ▼▼▼
                        else if (teamSpecificInfo.includes('最後の夏') || teamSpecificInfo.includes('閉校')) {
                            handicapFocusPrompt = `
3.  **【最後のグラウンド】**: 今年度で閉校となる${teamName}。グラウンド脇では校舎の解体作業が進む。重機の音が響く中、練習する異様な日常を描写する。
4.  **【OB会長の追憶】**: 練習をフェンス越しに見つめるOB会長（または後援会会長）にインタビューする。彼は、解体が進む母校を複雑な面持ちで見つめながら、「昔はここも全校生徒の応援で溢れかえっていた」「まさか自分たちの代で校名がなくなるとは思わなかったよ…」と、活気があった頃の昔の様子を語り、寂しそうに目を伏せる。
5.  **【3年生の想い】**: このユニフォームを着る最後の世代となった3年生に焦点を当てる。「母校の名前を刻みたい」というOB会長たちの想いも背負い、彼らの切実な覚悟と、後輩がいない（あるいは引き継げない）ことへの複雑な心境を引き出す。
6.  **【監督の務め】**: 監督に「最後の夏」に臨む心境を問う。技術的な指導以上に、彼らにとってこの夏がどのような意味を持つべきか、教育者としての葛藤と決意を語らせる。`;
                        }
                        // ▼▼▼ 他の逆境校の分岐 ▼▼▼
                        else if (teamSpecificInfo.includes('部員不足') || teamSpecificInfo.includes('連合チーム') || teamSpecificInfo.includes('0勝')) {
                             handicapFocusPrompt = `
3.  **【集まらない9人】**: ${teamName}の練習風景を描写する。助っ人の生徒（他部活）と共に練習する様子や、監督自らがノックの球拾いをする姿を描く。（※もし「0勝32敗」のような情報があれば、その歴史的敗北の重圧にも触れる）
4.  **【主将の苦労】**: 試合に出るだけでなく、部員の勧誘やチームの雰囲気作りに奔走する主将に焦点を当てる。「野球ができるだけでありがたい」という彼の言葉の重みを描写する。
5.  **【監督の信念】**: 監督に「なぜ野球部を続けるのか」を問う。勝利以前に、野球を通じて彼らに何を学んでほしいのか、その信念を語らせる。`;
                        } else if (teamSpecificInfo.includes('離島')) {
                             handicapFocusPrompt = `
3.  **【島を背負う】**: 本土から遠く離れた${teamName}。練習試合もままならず、情報も少ないという絶望的なハンデを描写する。
4.  **【島民の期待】**: 彼らの存在が、島にとってどのような希望となっているのか。練習を見守る地元住民や、漁の合間に手伝うOBの声を拾う。
5.  **【監督の戦略】**: 監督に「本土の強豪をどう倒すか」を問う。情報が少ない中で、彼らが磨いてきた「島ならではの野球」とは何かを語らせる。`;
                        } else {
                            // 上記以外の逆境校（デフォルト）
                            handicapFocusPrompt = `
3.  **【チームの現在地】**: 記者がチームの元を訪れる場面から始める。監督や選手にインタビューし、チームが抱える具体的なハンデ（例：${teamSpecificInfo}）と、それに対する彼らの想いを明らかにする。
4.  **【グラウンドの情景】**: 練習風景を描写する。部員数の少なさ（例：紅白戦ができない）、恵まれない練習環境（例：グラウンドが他の部と共用、道具が古い）といった、彼らの「日常」を具体的に描く。`;
                        }


                        if (matchData && matchData.opponent) {
                            const ourRank = calculateRank(teamName, tournamentState);
                            const opponentRank = matchData.opponentRank;
                            const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                            const rankDiff = rankValues[opponentRank] - rankValues[ourRank];
                            
                            // 構成案のステップ数を動的に計算
                            const handicapSteps = handicapFocusPrompt.split('\n').filter(line => line.trim().match(/^\d+\./)).length;
                            const stepOffset = 1 + 1 + handicapSteps; // (冒頭ナレーション + 現実) + ハンデ構成案のステップ数

                            if (rankDiff >= 2) { // 絶望的な格上
                                reactionPrompt = `
${stepOffset + 1}.  **【残酷な現実、そして監督の『建前』】**: 初戦の相手が格上の強豪「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。絶望と沈黙に包まれる選手たちを描写する。
${stepOffset + 2}.  **【監督室の『本音』】**: 監督が**選手たちの前で**は「これは試練だ。だが、歴史を創るチャンスでもある」と力強く語る一方、記者の前では**二人きりで**「いや、正直しんどいですよ…笑っちゃいましたもん、まさか〇〇（相手校名）と当たるなんて…」と、人間味あふれる弱音や本音を漏らす。`;
                            } else if (rankDiff >= 1) { // 少し格上
                                reactionPrompt = `
${stepOffset + 1}.  **【挑戦者たち】**: 初戦の相手が、格上の「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちが「不足はない相手」「一泡吹かせてやる」と闘志を燃やす様子を描写する。
${stepOffset + 2}.  **【監督の戦略】**: 監督は**選手たちの前で**「良い顔つきになったな」と彼らの士気を高めつつ、記者の前では**二人きりで**「正直、勝率は3割もないでしょう。でも、高校野球は何が起こるか分からない」と、冷静な分析と本音を語る。`;
                            } else { // 同格か格下
                                reactionPrompt = `
${stepOffset + 1}.  **【運命の初戦】**: 初戦の相手が実力の近い「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。「勝てる！」と少し浮足立つ選手たちを描写する。
${stepOffset + 2}.  **【監督の『建前』と『本音』】**: 監督が**選手たちの前で**「油断が一番の敵だ」と厳しく一喝する一方、記者の前では**二人きりで**「最高のクジを引きました。ここを勝てば、間違いなくチームは波に乗れる」と、安堵とプレッシャーが入り混じった本音を語る。`;
                            }
                        }

                        // 最後の決意表明のステップ番号も動的に
                        const finalStepNumber = (handicapFocusPrompt.split('\n').filter(line => line.trim().match(/^\d+\./)).length) + (reactionPrompt ? 2 : 0) + 3;
                        let finalPledge = '俺たちは野球がしたいだけ。相手が誰でも、全力で戦うだけです'; // デフォルト
                        if (teamName === '浜松特支') finalPledge = '怖いけど...逃げません。9回まで戦います';
                        if (teamSpecificInfo.includes('最後の夏')) finalPledge = 'これが最後の夏。一試合でも長く、この仲間と、母校の名前で野球がしたいです';


                        prompt += `
### 取材テーマ
「${teamName}」が抱える困難な状況と、それでも夢を諦めない彼らの姿を、深く、濃く描くドキュメンタリー序章。
${charactersPrompt}
### 構成案
1.  **【冒頭ナレーション】**: 「〇〇（地名）の空の下、今日も彼らの声が響く。${teamName === '浜松特支' ? '—たとえ、その声がまだ、野球への恐怖に震えていたとしても。' : 'しかし、その声はあまりにも少ない。'}」といった、チームの状況を象徴するナレーションから始める。
2.  **【彼らの"現実"】**: ${teamSpecificInfo}
${handicapFocusPrompt}
${reactionPrompt}
${finalStepNumber}. **【決意表明】**: 最後に、主将が「${finalPledge}」と、大会へ向かう決意を語り、締めくくる。
### 描写のポイント
- **五感を刺激する描写**: 練習風景では、土の匂い、古い革の匂い、金属バットの乾いた音、監督の怒鳴り声など、情景が目に浮かぶような具体的な描写を多用すること。
- **対比**: 「他校の恵まれた環境」と「彼らの現実」を対比させることで、逆境を際立たせること。
- **感情の機微**: 選手の「悔しさ」「焦り」だけでなく、その中にある「誇り」や「仲間との絆」も丁寧に描写すること。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;                break;
            case 'lose':
                title = `『${teamName}、魂の記録』最終章`;
                prompt += `
### 取材テーマ
「${teamName}」の夏が終わった。夢破れた彼らの姿と、それでも確かに残ったものを描くドキュメンタリー最終章。
### 対戦相手「${teamName}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」に触れ、あと一歩及ばなかった彼らの奮闘を称える。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、「よくやった」「悔しい」といった感情を増幅させる。
3.  試合終了の瞬間、泣き崩れるも、やがて顔を上げ、相手にエールを送る選手たちの姿を描写する。
4.  3年生の引退と、彼らの想いが後輩たちへと受け継がれていくことを示唆して、物語を締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    }
    
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) return { ...article, timestamp: Date.now() };
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI documentary article generation failed:", error);
        return null;
    }
}

/**
 * Sets the weather effect for the background.
 * @param {'none' | 'rain' | 'sun'} weatherType - The type of weather to display.
 */
function setWeather(weatherType) {
    const rainContainer = document.getElementById('rain-container');
    const sunContainer = document.getElementById('sun-container');

    // Hide all weather effects first
    rainContainer.classList.add('hidden');
    sunContainer.classList.add('hidden');
    rainContainer.innerHTML = ''; // Clear old raindrops

    if (weatherType === 'rain') {
        rainContainer.classList.remove('hidden');
        // Create 100 raindrops
        for (let i = 0; i < 100; i++) {
            const drop = document.createElement('div');
            drop.className = 'drop';
            drop.style.left = Math.random() * 100 + 'vw';
            drop.style.animationDelay = Math.random() * 0.5 + 's';
            drop.style.animationDuration = Math.random() * 0.2 + 0.3 + 's';
            rainContainer.appendChild(drop);
        }
    } else if (weatherType === 'sun') {
        sunContainer.classList.remove('hidden');
    }
}

/**
 * 詳細入力モーダル内のチームデータ、またはチーム名自体を入れ替える
 * @param {string} matchId - 対象の試合ID
 */
function swapTeamDetails(matchId) {
    const match = findMatchById(matchId);
    if (!match) return;

    // 1. チーム名と、トーナメント表に表示されているスコアを入れ替える
    const tempTeam = match.team1;
    match.team1 = match.team2;
    match.team2 = tempTeam;

    const tempScore = match.score1;
    match.score1 = match.score2;
    match.score2 = tempScore;

    // 2. もし詳細データが入力済みなら、その中身も入れ替える
    if (match.details) {
        // 打撃データを入れ替え
        const tempBatting = match.details.batting.team1;
        match.details.batting.team1 = match.details.batting.team2;
        match.details.batting.team2 = tempBatting;

        // 投手データを入れ替え
        const tempPitching = match.details.pitching.team1;
        match.details.pitching.team1 = match.details.pitching.team2;
        match.details.pitching.team2 = tempPitching;
        
        // イニングスコアを入れ替え
        if (match.details.inningScore) {
            const tempInningScore = match.details.inningScore.team1;
            match.details.inningScore.team1 = match.details.inningScore.team2;
            match.details.inningScore.team2 = tempInningScore;
        }
    }

    // 3. 変更を保存し、画面を更新する
    saveState();
    renderTournament(tournamentState); // トーナメント表も更新
    openDetailsModal(matchId); // モーダルを再描画して変更を反映
}

/**
 * [新機能] チームの全試合のスタメン履歴をHTMLで生成し、「試合別スタメン」タブに表示する
 * @param {string} teamName - チーム名
 */
function renderStartingLineupHistory(teamName) {
    const contentEl = document.getElementById('team-stats-tab-content-lineups');
    if (!contentEl) return;
    contentEl.innerHTML = '<div class="loader text-center py-16">スタメン履歴を読み込み中...</div>';

    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) {
        contentEl.innerHTML = '<p class="text-center text-red-500">チーム記録が見つかりません。</p>';
        return;
    }

    // 1. 全試合データをスキャン
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    // 2. チームが関わり、かつ詳細入力(スタメン)が存在する試合を収集
    const playedMatches = [];
    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        
        const teamKey = match.team1 === teamName ? 'team1' : (match.team2 === teamName ? 'team2' : null);

        // 条件：チームが関わっている AND 勝者が決まっている AND 詳細入力がある AND 打撃データがある
        if (teamKey && 
            match.winner && 
            match.details && 
            match.details.batting &&
            match.details.batting[teamKey] &&
            match.details.batting[teamKey].length > 0) 
        {
            // 試合IDからラウンド番号を簡易的に抽出
            let roundSortKey = 0;
            if (matchId.includes('-R')) {
                // 'L-R1-M1' -> R1 -> 1
                roundSortKey = parseInt(matchId.split('-R')[1].split('-')[0]);
            }
            if (matchId.startsWith('F-')) {
                roundSortKey = 100; // 決勝は最後
            }
            
            // TODO: 将来的に大会・年度別のソートキーを追加する
            // 現状はラウンド順のみでソート
            playedMatches.push({ ...match, roundSortKey, teamKey });
        }
    }
    
    // ラウンド順にソート (1回戦, 2回戦...)
    playedMatches.sort((a, b) => a.roundSortKey - b.roundSortKey);

    if (playedMatches.length === 0) {
        contentEl.innerHTML = '<p class="text-center text-gray-500">詳細入力されたスタメンの履歴がまだありません。</p>';
        return;
    }

    // 3. HTMLを生成 (現状は大会別ではなく、全履歴をラウンド順に表示)
    // TODO: 将来的に tournamentState.history を参照して大会別にグループ化する
    let html = `<div class="lineup-history-tournament">
        <h3 class="lineup-history-title">試合別スタメン履歴</h3>`;

    playedMatches.forEach(match => {
        const { teamKey, roundSortKey } = match;
        const opponentName = teamKey === 'team1' ? match.team2 : match.team1;
        const result = match.winner === teamName ? '〇' : '●';
        
        // スコアを正しく取得
        const scoreTeam = match[teamKey === 'team1' ? 'score1' : 'score2'];
        const scoreOpp = match[teamKey === 'team1' ? 'score2' : 'score1'];
        
        const roundName = getRoundNameFromMatchId(match.id);
        
        // スタメンを抽出
        const battingData = match.details.batting[teamKey] || [];
        const starters = battingData
            .filter(p => p.order && !p.order.toString().includes('sub') && parseInt(p.order) >= 1 && parseInt(p.order) <= 9)
            .sort((a, b) => parseInt(a.order) - parseInt(b.order)); // 打順(1-9)でソート

        if (starters.length > 0) {
            html += `
                <div class="lineup-history-match">
                    <h4 class="lineup-history-match-header">${roundName} vs ${opponentName} (${result} ${scoreTeam}-${scoreOpp})</h4>
                    <ul class="lineup-history-list">
                        ${starters.map(p => `<li>${p.order}. [${p.currentPos || p.pos || '?'}] ${p.name}</li>`).join('')}
                    </ul>
                </div>
            `;
        }
    });

    html += `</div>`;
    contentEl.innerHTML = html;
}

// ▼▼▼ この関数をまるごと「新規追加」(10673行目あたり、renderTeamStatsModal の直前) ▼▼▼

/**
 * [NEW] 個人の通算成績モーダルの中身を生成・表示する
 * (★「ReferenceError: renderCareerStatsModal is not defined」エラーを修正)
 * @param {string} playerName - 選手名
 * @param {string} teamName - チーム名
 */
function renderCareerStatsModal(playerName, teamName) {
    const modalBody = document.getElementById('player-stats-modal-body');
    if (!modalBody) {
        console.error("Fatal: player-stats-modal-body element not found.");
        return;
    }
    
    modalBody.innerHTML = ''; // Clear previous content
    
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord || !teamRecord.playerStats) {
        modalBody.innerHTML = `<p class="text-red-500 text-center">エラー: ${teamName} のチーム記録が見つかりません。</p>`;
        return;
    }

    const bStats = teamRecord.playerStats.batting?.[playerName];
    const pStats = teamRecord.playerStats.pitching?.[playerName];

    if (!bStats && !pStats) {
        modalBody.innerHTML = `<p class="text-gray-500 text-center">${playerName}選手の通算成績データはまだありません。</p>`;
        return;
    }

    let html = `
        <div class="player-stats-header">
            <h4 class="player-stats-name">${playerName}</h4>
            <p class="player-stats-team">${teamName}</p>
        </div>
    `;

    // --- 1. 打撃成績の表示 ---
    if (bStats && bStats.pa > 0) {
        // 必要な計算 (renderTeamStatsModalから拝借)
        const { games = 0, pa = 0, ab = 0, h = 0, hr = 0, rbi = 0, sb = 0, bb = 0, hbp = 0, sf = 0, tb = 0 } = bStats;
        const avg = (ab > 0) ? (h / ab).toFixed(3) : ".000";
        const obp_numerator = h + bb + hbp;
        const obp_denominator = ab + bb + hbp + sf;
        const obp = (obp_denominator > 0) ? (obp_numerator / obp_denominator).toFixed(3) : ".000";
        const slg = (ab > 0) ? (tb / ab).toFixed(3) : ".000";
        const ops = (parseFloat(obp) + parseFloat(slg)).toFixed(3);

        html += `
            <div>
                <h5 class="stats-section-title">通算打撃成績</h5>
                <div class="stats-grid">
                    <div class="stats-grid-item highlight">
                        <span class="stats-label">打率</span>
                        <span class="stats-value">${avg}</span>
                    </div>
                    <div class="stats-grid-item highlight">
                        <span class="stats-label">OPS</span>
                        <span class="stats-value">${ops}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">本塁打</span>
                        <span class="stats-value">${hr}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">打点</span>
                        <span class="stats-value">${rbi}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">試合</span>
                        <span class="stats-value">${games}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">打数</span>
                        <span class="stats-value">${ab}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">安打</span>
                        <span class="stats-value">${h}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">盗塁</span>
                        <span class="stats-value">${sb}</span>
                    </div>
                </div>
                <div class="stats-grid mt-2 grid-cols-5">
                    <div class="stats-grid-item"><span class="stats-label">打席</span><span class="stats-value text-xl">${pa}</span></div>
                    <div class="stats-grid-item"><span class="stats-label">四球</span><span class="stats-value text-xl">${bb}</span></div>
                    <div class="stats-grid-item"><span class="stats-label">死球</span><span class="stats-value text-xl">${hbp}</span></div>
                    <div class="stats-grid-item"><span class="stats-label">出塁率</span><span class="stats-value text-xl">${obp}</span></div>
                    <div class="stats-grid-item"><span class="stats-label">長打率</span><span class="stats-value text-xl">${slg}</span></div>
                </div>
            </div>
        `;
    }

    // --- 2. 投手成績の表示 ---
    if (pStats && pStats.career && pStats.career.ip > 0) {
        const career = pStats.career;
        const { games = 0, w = 0, l = 0, ip = 0, so = 0, er = 0, h = 0, bb = 0 } = career;
        const era_val = (ip > 0) ? ((er * 9) / ip) : Infinity;
        const whip_val = (ip > 0) ? ((bb + h) / ip) : Infinity;
        const k9_val = (ip > 0) ? ((so * 9) / ip) : 0;
        
        const era = (era_val === Infinity) ? "----" : era_val.toFixed(2);
        const whip = (whip_val === Infinity) ? "----" : whip_val.toFixed(2);
        const k9 = k9_val.toFixed(2);

        html += `
            <div>
                <h5 class="stats-section-title">通算投手成績</h5>
                <div class="stats-grid">
                    <div class="stats-grid-item highlight">
                        <span class="stats-label">防御率</span>
                        <span class="stats-value">${era}</span>
                    </div>
                    <div class="stats-grid-item highlight">
                        <span class="stats-label">WHIP</span>
                        <span class="stats-value">${whip}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">勝利</span>
                        <span class="stats-value">${w}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">敗北</span>
                        <span class="stats-value">${l}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">登板</span>
                        <span class="stats-value">${games}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">投球回</span>
                        <span class="stats-value">${ip.toFixed(1)}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">奪三振</span>
                        <span class="stats-value">${so}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">K/9</span>
                        <span class="stats-value">${k9}</span>
                    </div>
                </div>
            </div>
        `;
    }
    
    // --- 3. 試合履歴 (Gamelogs) の表示 ---
    const allGamelogs = [
        ...(bStats?.gamelogs || []).map(log => ({ ...log, type: 'batting' })),
        ...(pStats?.gamelogs || []).map(log => ({ ...log, type: 'pitching' }))
    ].sort((a, b) => (parseDate(a.date) || 0) - (parseDate(b.date) || 0)); // 日付順にソート

    if (allGamelogs.length > 0) {
        html += `
            <div>
                <h5 class="stats-section-title">今大会 試合別成績</h5>
                <div class="space-y-2 text-sm">
        `;
        
        // Gamelogを試合IDでグループ化
        const gamesGrouped = allGamelogs.reduce((acc, log) => {
            if (!acc[log.matchId]) {
                acc[log.matchId] = {
                    round: log.round,
                    opponent: log.opponent,
                    opponentRank: log.opponentRank,
                    batting: null,
                    pitching: null
                };
            }
            if (log.type === 'batting') acc[log.matchId].batting = log.stats;
            if (log.type === 'pitching') acc[log.matchId].pitching = log;
            return acc;
        }, {});

        Object.values(gamesGrouped).reverse().forEach(game => { // 新しい試合から表示
            let statsLine = '';
            if (game.batting) {
                const b = game.batting;
                statsLine += `打: ${b.ab}-${b.h} ${b.hr}HR ${b.rbi}点 ${b.sb}盗`;
            }
            if (game.pitching) {
                const p = game.pitching;
                const resultMark = {'W': '○', 'L': '●', 'S': 'Ｓ', 'H': 'Ｈ'}[p.result] || '';
                statsLine += (statsLine ? ' / ' : '') + `投: ${resultMark}${p.ip}回 ${p.so}K ${p.r}失(自${p.er})`;
            }
            
            html += `
                <div class="p-2 border rounded bg-gray-50">
                    <span class="font-semibold">${game.round} vs ${game.opponent} [${game.opponentRank}]</span>
                    <span class="block text-gray-700">${statsLine}</span>
                </div>
            `;
        });

        html += `</div></div>`;
    }

    modalBody.innerHTML = html;
}

// ヘルパー関数: parseDate (gamelogソート用)
const parseDate = (dateStr) => {
    if (!dateStr || !dateStr.includes('/')) return null;
    const [month, day] = dateStr.split('/').map(Number);
    // 年は現在の大会年度を仮定 (月が1-3月の場合は翌年扱い)
    const year = (tournamentState?.tournamentYear || new Date().getFullYear()) + (month <= 3 ? 1 : 0);
    return new Date(year, month - 1, day);
};
// ▲▲▲ 新規追加ここまで ▲▲▲


// ▼▼▼ 既存の「renderTeamStatsModal」関数 (10675行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * チーム全員の通算成績モーダルの中身を生成・表示する
 * (★「規定打席」ソートロジックを 試合数*3 に変更、投手の規定を撤廃★)
 * @param {string} teamName - チーム名
 */
function renderTeamStatsModal(teamName) {
    const modal = document.getElementById('team-stats-modal');
    const modalTitle = document.getElementById('team-stats-modal-title');
    
    const teamRecord = tournamentState.teamRecords[teamName];

    modalTitle.textContent = `${teamName} 通算成績`;
    
    const statsContentEl = document.getElementById('team-stats-tab-content-stats');

    if (!teamRecord || !teamRecord.playerStats) {
        statsContentEl.innerHTML = '<p class="text-center text-red-500">選手の成績データが見つかりません。</p>';
        return;
    }

    // --- 0. 現在のソート状態を取得（なければ選手名で昇順） ---
    const sortState = {
        batting: {
            key: modal.dataset.sortKeyBatting || 'name',
            dir: modal.dataset.sortDirBatting || 'asc'
        },
        pitching: {
            key: modal.dataset.sortKeyPitching || 'name',
            dir: modal.dataset.sortDirPitching || 'asc'
        }
    };
    
    // --- ヘルパー関数：ソート用の矢印(▲▼)クラスを生成 ---
    const getSortClass = (tableType, key) => {
        const state = sortState[tableType];
        if (state.key !== key) return '';
        return state.dir === 'asc' ? 'sort-asc' : 'sort-desc';
    };

    const { batting, pitching } = teamRecord.playerStats;
    let battingHtml = '';
    let pitchingHtml = '';

    // --- 1. 打撃成績の計算と表示 (★ソートロジック修正) ---
    if (batting && Object.keys(batting).length > 0) {
        const battingArray = Object.keys(batting).map(playerName => {
            const stats = batting[playerName];
            const { games = 0, pa = 0, ab = 0, h = 0, hr = 0, rbi = 0, sb = 0, bb = 0, hbp = 0, sf = 0, tb = 0 } = stats;
            const avg = (ab > 0) ? (h / ab) : 0;
            const obp_numerator = h + bb + hbp;
            const obp_denominator = ab + bb + hbp + sf;
            const obp = (obp_denominator > 0) ? (obp_numerator / obp_denominator) : 0;
            const slg = (ab > 0) ? (tb / ab) : 0;
            const ops = obp + slg;
            return { name: playerName, ...stats, avg, obp, slg, ops };
        }).filter(p => p.pa > 0 || p.games > 0); // ★打席0でも試合出場(games > 0)なら表示

        // --- ★★★ ここからが修正箇所 ★★★ ---
        const sortKey = sortState.batting.key;
        const sortDir = sortState.batting.dir === 'asc' ? 1 : -1;
        
        // ★ チームの総試合数を計算 (出場選手の中で最大の試合数)
        // (今大会の試合数ではなく、全履歴の試合数を参照)
        const totalGamesPlayed = Math.max(...battingArray.map(p => p.games || 0));
        // ★ 規定打席を「試合数 * 3」に設定
        const MINIMUM_PA_FOR_RANKING = totalGamesPlayed * 3;
        
        // 規定打席の対象となる率系のスタッツか？
        const isRankedStat = ['avg', 'obp', 'slg', 'ops'].includes(sortKey);

        battingArray.sort((a, b) => {
            let valA = a[sortKey], valB = b[sortKey];
            const paA = a.pa || 0;
            const paB = b.pa || 0;

            // 1. 率系のスタッツでソートする場合
            if (isRankedStat) {
                // ★ 規定打席のしきい値を MINIMUM_PA_FOR_RANKING に変更
                const aQualified = paA >= MINIMUM_PA_FOR_RANKING;
                const bQualified = paB >= MINIMUM_PA_FOR_RANKING;

                // 両方規定打席未満なら、打席数の多い順
                if (!aQualified && !bQualified) {
                    return (paB - paA); 
                }
                // Aだけ規定打席未満なら、Aを「下」にする
                if (!aQualified) {
                    return 1; // 1を返すとbが先(aが後)になる
                }
                // Bだけ規定打席未満なら、Bを「下」にする
                if (!bQualified) {
                    return -1; // -1を返すとaが先(bが後)になる
                }
                // 両方規定打席以上なら、通常のソートへ進む
            }

            // --- 2. 通常のソートロジック ---
            if (sortKey === 'name') return valA.localeCompare(valB, 'ja') * sortDir;
            if (valA === undefined || valA === null) valA = 0;
            if (valB === undefined || valB === null) valB = 0;
            return (valA - valB) * sortDir;
        });
        // --- ★★★ 修正ここまで ★★★ ---

        battingHtml = `
            <div>
                <h4 class="stats-section-title">通算打撃成績 (規定打席: ${MINIMUM_PA_FOR_RANKING})</h4>
                <div class="overflow-x-auto">
                    <table class="career-stats-table" id="batting-stats-table">
                        <thead>
                            <tr>
                                <th class="player-name sortable-header ${getSortClass('batting', 'name')}" data-sort-key="name" data-table-type="batting">選手名<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'games')}" data-sort-key="games" data-table-type="batting">試<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'avg')}" data-sort-key="avg" data-table-type="batting">打率<span class="sort-arrow"></span></th>
                                <th class="stat-highlight sortable-header ${getSortClass('batting', 'ops')}" data-sort-key="ops" data-table-type="batting">OPS<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'pa')}" data-sort-key="pa" data-table-type="batting">打席<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'ab')}" data-sort-key="ab" data-table-type="batting">打数<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'h')}" data-sort-key="h" data-table-type="batting">安打<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'hr')}" data-sort-key="hr" data-table-type="batting">本<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'rbi')}" data-sort-key="rbi" data-table-type="batting">点<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'sb')}" data-sort-key="sb" data-table-type="batting">盗<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'bb')}" data-sort-key="bb" data-table-type="batting">四<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'hbp')}" data-sort-key="hbp" data-table-type="batting">死<span class="sort-arrow"></span></th>
                                <th class="stat-highlight sortable-header ${getSortClass('batting', 'obp')}" data-sort-key="obp" data-table-type="batting">出塁率<span class="sort-arrow"></span></th>
                                <th class="stat-highlight sortable-header ${getSortClass('batting', 'slg')}" data-sort-key="slg" data-table-type="batting">長打率<span class="sort-arrow"></span></th>
                            </tr>
                        </thead>
                        <tbody>
        `;
        battingArray.forEach(stats => {
            // ★ 規定打席未満の選手は率をグレー表示
            const isQualified = stats.pa >= MINIMUM_PA_FOR_RANKING;
            const rateClass = isQualified ? 'stat-highlight' : 'text-gray-400';

            battingHtml += `
                <tr>
                    <td class="player-name">${stats.name}</td>
                    <td>${stats.games}</td><td class="${rateClass}">${stats.avg.toFixed(3)}</td><td class="${rateClass}">${stats.ops.toFixed(3)}</td>
                    <td>${stats.pa}</td><td>${stats.ab}</td><td>${stats.h}</td><td>${stats.hr}</td>
                    <td>${stats.rbi}</td><td>${stats.sb}</td><td>${stats.bb}</td><td>${stats.hbp}</td>
                    <td class="${rateClass}">${stats.obp.toFixed(3)}</td><td class="${rateClass}">${stats.slg.toFixed(3)}</td>
                </tr>
            `;
        });
        battingHtml += `</tbody></table></div></div>`;
    } else {
        battingHtml = `<div><h4 class="stats-section-title">通算打撃成績</h4><p class="text-sm text-gray-500">（通算打撃成績なし）</p></div>`;
    }

    // --- 2. 投手成績の計算と表示 (★規定投球回ロジック削除) ---
    if (pitching && Object.keys(pitching).length > 0) {
        
        // 2a. データを配列に変換し、計算値を付与
        const pitchingArray = Object.keys(pitching).map(playerName => {
            const pStats = pitching[playerName];
            const stats = pStats.career; // 通算成績
            if (!stats) return null;
            
            const { games = 0, w = 0, l = 0, ip = 0, so = 0, er = 0, h = 0, bb = 0 } = stats;
            const era = (ip > 0) ? ((er * 9) / ip) : Infinity; 
            const whip = (ip > 0) ? ((bb + h) / ip) : Infinity; 
            const k9 = (ip > 0) ? ((so * 9) / ip) : 0; 

            return { name: playerName, ...stats, era, whip, k9, gamelogs: pStats.gamelogs || [] };
        }).filter(p => p && (p.ip > 0 || p.games > 0)); // ★ games > 0 (登板のみ) も許可
        
        // 2b. 配列をソート
        const sortKey = sortState.pitching.key;
        const sortDir = sortState.pitching.dir === 'asc' ? 1 : -1;
        
        // ★ 規定投球回ロジックを「まるごと削除」
        const isPitchingRankedStat = ['era', 'whip', 'k9'].includes(sortKey);

        pitchingArray.sort((a, b) => {
            let valA = a[sortKey], valB = b[sortKey];
            const ipA = a.ip || 0;
            const ipB = b.ip || 0;

            // ★ 規定投球回の `if (isPitchingRankedStat)` ブロックを「まるごと削除」

            // 無限大(Infinity)のERAをソートのために大きな数値に変換
            if (isPitchingRankedStat) {
                if (valA === Infinity) valA = 999.99;
                if (valB === Infinity) valB = 999.99;
            }

            if (sortKey === 'name') return valA.localeCompare(valB, 'ja') * sortDir;
            if (valA === Infinity) valA = 999.99; 
            if (valB === Infinity) valB = 999.99;
            if (valA === undefined || valA === null) valA = 0;
            if (valB === undefined || valB === null) valB = 0;
            return (valA - valB) * sortDir;
        });

        // 2c. HTMLを生成
        pitchingHtml = `
            <div class="mt-6">
                <h4 class="stats-section-title">通算投手成績</h4>
                <div class="overflow-x-auto">
                    <table class="career-stats-table" id="pitching-stats-table">
                        <thead>
                            <tr>
                                <th class="player-name sortable-header ${getSortClass('pitching', 'name')}" data-sort-key="name" data-table-type="pitching">選手名<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'games')}" data-sort-key="games" data-table-type="pitching">登<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'w')}" data-sort-key="w" data-table-type="pitching">勝<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'l')}" data-sort-key="l" data-table-type="pitching">敗<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'ip')}" data-sort-key="ip" data-table-type="pitching">回<span class="sort-arrow"></span></th>
                                <th class="stat-highlight sortable-header ${getSortClass('pitching', 'era')}" data-sort-key="era" data-table-type="pitching">防御率<span class="sort-arrow"></span></th>
                                <th class="stat-highlight sortable-header ${getSortClass('pitching', 'whip')}" data-sort-key="whip" data-table-type="pitching">WHIP<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'so')}" data-sort-key="so" data-table-type="pitching">振<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'h')}" data-sort-key="h" data-table-type="pitching">被安<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'bb')}" data-sort-key="bb" data-table-type="pitching">与四<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'er')}" data-sort-key="er" data-table-type="pitching">自責<span class="sort-arrow"></span></th>
                                <th class="stat-highlight sortable-header ${getSortClass('pitching', 'k9')}" data-sort-key="k9" data-table-type="pitching">K/9<span class="sort-arrow"></span></th>
                            </tr>
                        </thead>
                        <tbody>
        `;
        pitchingArray.forEach(stats => {
            // ★ 規定投球回チェックを削除
            const rateClass = 'stat-highlight'; // ★ 常にハイライト
            
            const gamelogHtml = stats.gamelogs.length > 0 
                ? stats.gamelogs.map(log => `(${log.round} vs ${log.opponent}: ${log.ip}回 ${log.r}失点)`).join(', ')
                : '登板履歴なし';
                
            pitchingHtml += `
                <tr>
                    <td class="player-name">${stats.name}</td>
                    <td>${stats.games}</td><td>${stats.w}</td><td>${stats.l}</td>
                    <td>${stats.ip.toFixed(1)}</td><td class="${rateClass}">${stats.era === 999.99 ? '----' : stats.era.toFixed(2)}</td>
                    <td class="${rateClass}">${stats.whip === 999.99 ? '----' : stats.whip.toFixed(2)}</td>
                    <td>${stats.so}</td><td>${stats.h}</td><td>${stats.bb}</td><td>${stats.er}</td>
                    <td class="${rateClass}">${stats.k9.toFixed(2)}</td>
                </tr>
                <tr class="bg-gray-50">
                    <td colspan="12" class="text-left text-xs text-gray-600 p-2" style="white-space: normal;">
                        <strong>登板履歴:</strong> ${gamelogHtml}
                    </td>
                </tr>
            `;
        });
        pitchingHtml += `</tbody></table></div></div>`;
    } else {
        pitchingHtml = `<div class="mt-6"><h4 class="stats-section-title">通算投手成績</h4><p class="text-sm text-gray-500">（通算投手成績なし）</p></div>`;
    }

    statsContentEl.innerHTML = battingHtml + pitchingHtml;
}
// ▲▲▲ 置き換えここまで ▲▲▲


// ▼▼▼ 既存の「showTeamStatusModal」関数 (12891行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * チームステータスモーダルを表示する
 * (★「チームレーダーチャート」と「テキスト成績」を両方表示するハイスペック版)
 * @param {string} teamName - クリックされたチーム名
 */
function showTeamStatusModal(teamName) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) return;

    // --- 1. モーダル要素の取得 ---
    const modal = document.getElementById('team-status-modal');
    const bestEl = document.getElementById('status-modal-best');
    const historyEl = document.getElementById('status-modal-history');
    const traitsEl = document.getElementById('status-modal-traits');
    const coachEl = document.getElementById('status-modal-coach'); 
    const homepageLinkContainer = document.getElementById('status-modal-homepage-link-container');
    const homepageLink = document.getElementById('status-modal-homepage-link');
    const chartContainer = document.getElementById('team-chart-container');
    
    // ★★★ [NEW] テキスト成績用のPタグを取得 ★★★
    const statsEl = document.getElementById('status-modal-team-stats');
    const careerStatsEl = document.getElementById('status-modal-career-stats'); 

    // ★ 既存のチャートがあれば削除（再描画のため）
    const existingChart = Chart.getChart('team-radar-chart');
    if (existingChart) {
        existingChart.destroy();
    }

    // --- 2. チーム基本情報の表示 (変更なし) ---
    document.getElementById('status-modal-team-name').textContent = teamName;
    
    if (homepageLink) {
        homepageLink.removeAttribute('href');
        homepageLink.removeAttribute('target');
        homepageLink.style.cursor = 'pointer';
    }
    bestEl.textContent = teamRecord.best ? formatRecordToString(teamRecord.best) : 'まだありません';
    historyEl.innerHTML = '';
    if (teamRecord.history && teamRecord.history.length > 0) {
        teamRecord.history.slice(0, 2).forEach(rec => {
            const p = document.createElement('p');
            p.textContent = formatRecordToString(rec);
            historyEl.appendChild(p);
        });
    } else {
        historyEl.innerHTML = '<p>まだありません</p>';
    }
    traitsEl.innerHTML = '';
    if (teamRecord.teamTraits && teamRecord.teamTraits.length > 0) {
        teamRecord.teamTraits.forEach(traitId => {
            const trait = TITLES[traitId];
            if (trait) {
                const span = document.createElement('span');
                span.className = 'bg-blue-100 text-blue-800 text-xs font-semibold px-2.5 py-0.5 rounded-full';
                span.textContent = trait.name;
                traitsEl.appendChild(span);
            }
        });
    } else {
        traitsEl.innerHTML = '<p class="text-gray-500 text-sm">なし</p>';
    }
    const teamMasterData = TEAM_DATA[teamName];
    if (teamMasterData && teamMasterData.coach) {
        coachEl.textContent = `${teamMasterData.coach.name} (${teamMasterData.coach.experience} / ${teamMasterData.coach.style})`;
    } else {
        coachEl.textContent = '情報なし';
    }
    if (homepageLinkContainer && homepageLink) {
        if (teamName === "283学園") {
            homepageLink.setAttribute('data-target', 'homepage-modal'); 
            homepageLinkContainer.classList.remove('hidden');
        } else {
            homepageLinkContainer.classList.add('hidden'); 
        }
    }

    // --- 3. ★★★ チームレーダーチャートの生成 ★★★ ---
    const stats = teamRecord.tournamentStats || { h: 0, ab: 0, hr: 0, rbi: 0, sb: 0, so: 0 };
    const pitchingStats = calculateTeamPitchingStats(teamName); // { era, whip }
    
    const avg = (stats.ab > 0) ? (stats.h / stats.ab) : 0;
    const power = (stats.hr || 0) * 10;
    const speed = (stats.sb || 0) * 10;
    const eraNum = parseFloat(pitchingStats.era);
    const defense = (eraNum && eraNum < 6) ? (6 - eraNum) / 5 * 100 : (eraNum >= 6 ? 0 : 50);
    const so = (stats.so || 0);
    const bb = (stats.bb || 0) + (stats.hbp || 0);
    const eye = (bb > 0) ? (bb / (bb + so)) * 100 : 30;

    const normalize = (value) => Math.max(0, Math.min(100, Math.round(value)));

    const chartData = [
        normalize(avg * 500 - 100), // .200=0, .400=100
        normalize(power),
        normalize(speed),
        normalize(defense),
        normalize(eye)
    ];
    
    const ctx = document.getElementById('team-radar-chart')?.getContext('2d');
    if (ctx) {
        new Chart(ctx, {
            type: 'radar',
            data: {
                labels: ['打撃 (AVG)', '長打 (HR)', '機動 (SB)', '守備 (ERA)', '選球眼 (BB/K)'],
                datasets: [{
                    label: `${teamName} (今大会)`,
                    data: chartData,
                    fill: true,
                    backgroundColor: 'rgba(59, 130, 246, 0.2)',
                    borderColor: 'rgb(59, 130, 246)',
                    pointBackgroundColor: 'rgb(59, 130, 246)',
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: 'rgb(59, 130, 246)'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    r: {
                        angleLines: { color: 'rgba(0, 0, 0, 0.1)' },
                        grid: { color: 'rgba(0, 0, 0, 0.1)' },
                        pointLabels: {
                            font: { size: 12, weight: 'bold' },
                            color: '#333'
                        },
                        ticks: {
                            backdropColor: 'white',
                            color: '#777',
                            stepSize: 25,
                            font: { size: 10 }
                        },
                        min: 0,
                        max: 100
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }

    // --- 4. ★★★ テキスト成績の表示 (再追加) ★★★ ---
    if (statsEl) {
        if (stats && (stats.ab > 0 || stats.games > 0 || stats.sb > 0)) {
            const avgStr = (stats.ab > 0) ? (stats.h / stats.ab).toFixed(3) : ".---";
            const sbCount = stats.sb || 0;
            statsEl.textContent = `打率 ${avgStr} (${stats.ab}打数 ${stats.h}安打) ${stats.hr}本塁打 ${stats.rbi}打点 ${sbCount}盗塁`;
        } else if (stats) {
            statsEl.textContent = `(今大会 ${stats.ab}打数 ${stats.h}安打) 0盗塁`;
        } else {
            statsEl.textContent = '（今大会の集計データなし）';
        }
    }
    
    if (careerStatsEl) {
        const careerBattingStats = teamRecord.playerStats?.batting;
        let totalCareerSb = 0, totalCareerHr = 0;
        if (careerBattingStats) {
            for (const playerName in careerBattingStats) {
                const stats = careerBattingStats[playerName];
                totalCareerSb += stats.sb || 0;
                totalCareerHr += stats.hr || 0;
            }
        }
        careerStatsEl.textContent = `通算 ${totalCareerHr} 本塁打 / ${totalCareerSb} 盗塁`;
    }
    
    // --- 5. モーダルを表示 ---
    modal.classList.remove('hidden');
}
// ▲▲▲ 置き換えここまで ▲▲▲
// ▲▲▲ 置き換えここまで ▲▲▲ 
// ▲▲▲ 置き換えここまで ▲▲▲
// ▲▲▲ 置き換えここまで ▲▲▲

// ▲▲▲ 置き換えここまで ▲▲▲
  // --- Custom Alert/Confirm ---
    function showAlert(message) {
        alert(message);
    }

    function showConfirm(message) {
        return new Promise((resolve) => {
            const confirmOk = document.getElementById('confirm-ok');
            const confirmCancel = document.getElementById('confirm-cancel');
            document.getElementById('confirm-modal-text').textContent = message;
            confirmModal.classList.remove('hidden');

            const onOk = () => {
                confirmModal.classList.add('hidden');
                cleanup();
                resolve(true);
            };

            const onCancel = () => {
                confirmModal.classList.add('hidden');
                cleanup();
                resolve(false);
            };
            
            const cleanup = () => {
                confirmOk.removeEventListener('click', onOk);
                confirmCancel.removeEventListener('click', onCancel);
            };

            confirmOk.addEventListener('click', onOk);
            confirmCancel.addEventListener('click', onCancel);
        });
    }

// --- Utility & State Functions --- などに追加

// 甲子園での成績を定義（数字が小さいほど上位）
const KOSHIEN_RESULTS = {
    CHAMPION:       { rank: -1, label: '全国優勝' },
    RUNNER_UP:    { rank: -2, label: '全国準優勝' },
    BEST_4:         { rank: -4, label: '甲子園ベスト4' },
    BEST_8:         { rank: -8, label: '甲子園ベスト8' },
    BEST_16:        { rank: -16, label: '甲子園3回戦敗退' }, // ベスト16
    ROUND_2:        { rank: -32, label: '甲子園2回戦敗退' },
    ROUND_1:        { rank: -64, label: '甲子園初戦敗退' },
};

// チームのA～Eランクごとの、甲子園での成績確率（ウェイト方式）
const KOSHIEN_PROBABILITIES = {
    'A': [
        { result: 'CHAMPION', weight: 20 }, { result: 'RUNNER_UP', weight: 25 },
        { result: 'BEST_4', weight: 25 },   { result: 'BEST_8', weight: 15 },
        { result: 'BEST_16', weight: 10 },  { result: 'ROUND_2', weight: 4 },
        { result: 'ROUND_1', weight: 1 }
    ],
    'B': [
        { result: 'CHAMPION', weight: 5 },  { result: 'RUNNER_UP', weight: 10 },
        { result: 'BEST_4', weight: 20 },   { result: 'BEST_8', weight: 30 },
        { result: 'BEST_16', weight: 20 },  { result: 'ROUND_2', weight: 10 },
        { result: 'ROUND_1', weight: 5 }
    ],
    'C': [
        { result: 'CHAMPION', weight: 1 },  { result: 'RUNNER_UP', weight: 3 },
        { result: 'BEST_4', weight: 8 },    { result: 'BEST_8', weight: 20 },
        { result: 'BEST_16', weight: 30 },  { result: 'ROUND_2', weight: 28 },
        { result: 'ROUND_1', weight: 10 }
    ],
    'D': [
        { result: 'BEST_8', weight: 5 },    { result: 'BEST_16', weight: 15 },
        { result: 'ROUND_2', weight: 40 },  { result: 'ROUND_1', weight: 40 }
    ],
    'E': [
        { result: 'BEST_16', weight: 5 },   { result: 'ROUND_2', weight: 25 },
        { result: 'ROUND_1', weight: 70 }
    ],
};

/**
 * チームランクに基づき、甲子園での成績を確率で決定する
 * @param {string} teamRank - 'A'から'E'までのチームランク
 * @returns {string} - KOSHIEN_RESULTSのキー ('CHAMPION', 'BEST_8'など)
 */
function simulateKoshien(teamRank) {
    const probabilities = KOSHIEN_PROBABILITIES[teamRank] || KOSHIEN_PROBABILITIES['E'];
    const totalWeight = probabilities.reduce((sum, p) => sum + p.weight, 0);
    let random = Math.random() * totalWeight;

    for (const prob of probabilities) {
        if (random < prob.weight) {
            return prob.result;
        }
        random -= prob.weight;
    }
    return 'ROUND_1'; // フォールバック
}
   
 /**
     * 試合IDを元に、stateオブジェクトの深い階層から試合オブジェクトを検索して返す
     * (★全大会128チーム制統一に伴い、tournamentState.matches のみ検索するよう修正)
     */
    function findMatchById(matchId) {
        // 全ての試合は tournamentState.matches に保存される
        if (tournamentState.matches && tournamentState.matches[matchId]) {
            return tournamentState.matches[matchId];
        }
        
        // ★ 廃止された autumnData, springData への参照を削除 ★
        
        return null; // どこにも見つからなかった場合
    }
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * チームの今大会の勝ち上がりを「〇〇回戦 vs △△」のように要約するヘルパー関数
 */
function getTournamentPathSummary(teamName, currentMatchId) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) return "今大会初戦。";

    const path = [];
    const currentTournamentMatchIds = Object.keys(tournamentState.matches);

    for (const matchId of currentTournamentMatchIds) {
        if (matchId === currentMatchId) continue;
        const match = tournamentState.matches[matchId];
        
        if (match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            const opponent = match.team1 === teamName ? match.team2 : teamName;
            const roundName = getRoundNameFromMatchId(matchId);
            
            if (match.winner === teamName) {
                path.push(`${roundName} vs ${opponent}`);
            }
        }
    }
    
    return path.length === 0 ? "今大会初戦。" : `ここまでの勝ち上がり: ${path.join(' → ')}。`;
}

/**
     * 試合IDからラウンド名を取得するヘルパー関数
     * (★夏・秋・春 すべて128チーム制＝7ラウンド制のラウンド名に対応)
     */
    function getRoundNameFromMatchId(matchId) {
        if (!matchId) return "不明なラウンド";

        if (matchId.startsWith('F-R1-')) {
            return "決勝";
        }
        
        // ★★★ ここからが修正箇所 (秋・春の分岐を削除) ★★★
        if (!matchId.includes('-R')) {
             return "不明なラウンド";
        }
        
        const roundNum = parseInt(matchId.split('-')[1].slice(1));
        
        // 常に 128チーム制 (7ラウンド) のマップを使用
        const finalRound = 7;
        const roundNameMap_128 = { 
            [finalRound-1]: '準決勝',   // R6
            [finalRound-2]: '準々決勝', // R5
            [finalRound-3]: '4回戦'     // R4
        };
        return roundNameMap_128[roundNum] || `${roundNum}回戦`;
        // ★★★ 修正ここまで ★★★
    }
// ▲▲▲ 置き換えここまで ▲▲▲

// --- Team Rank Calculation (Reality-Adjusted Version) ---
    
/**
 * 2チーム間の因縁対決を判定し、フラグを返す（タグ機能不要版）
 * @param {string} team1Name - チーム1の名前
 * @param {string} team2Name - チーム2の名前
 * @returns {string | null} - 因縁のタイプ（例: "283直接対決"）、なければ null
 */
function checkRivalry(team1Name, team2Name) {
    if (!team1Name || !team2Name) return null;

    const data1 = TEAM_DATA[team1Name];
    const data2 = TEAM_DATA[team2Name];
    if (!data1 || !data2) return null;

    // 1. 283学園 vs 283学園B
    if ((team1Name === "283学園" && team2Name === "283学園B") || (team1Name === "283学園B" && team2Name === "283学園")) {
        return "283直接対決";
    }

    // ▼▼▼ 修正点 ▼▼▼
    // 2. ナムコ系列ダービー (タグの代わりに、ここでリストを直接定義)
    const namcoSchools = ["765総合高校", "283学園", "初星学園", "美城学園", "283学園B"];
    if (namcoSchools.includes(team1Name) && namcoSchools.includes(team2Name)) {
        return "ナムコダービー";
    }
    // ▲▲▲ 修正ここまで ▲▲▲

    // 3. 同地区の強豪対決 (Aランク vs Aランク or Aランク vs Bランク)
    if (data1.region === data2.region) {
        const rank1 = calculateRank(team1Name, tournamentState);
        const rank2 = calculateRank(team2Name, tournamentState);
        if ((rank1 === 'A' && rank2 === 'A') || (rank1 === 'A' && rank2 === 'B') || (rank1 === 'B' && rank2 === 'A')) {
            return `同地区強豪対決 (${data1.region})`;
        }
    }

    return null; // その他の因縁はなし
}

/**
 * 指定されたラウンドの全試合に日付と球場を割り当てる
 * @param {Array<string>} matchIds - スケジュールを割り当てる試合IDの配列
 * @param {Array<string>} dates - 使用する日付の配列 (例: ["7/10", "7/11"])
 * @param {Array<object>} stadiumList - 使用する球場のリスト (例: STADIUM_DATA)
 * @param {number} gamesPerDayPerStadium - 1球場・1日あたりの最大試合数
 */
function scheduleRoundMatches(matchIds, dates, stadiumList, gamesPerDayPerStadium) {
    if (!matchIds || matchIds.length === 0) return;

    let scheduleQueue = []; // [ { stadium, date, gameNum: 1 }, { stadium, date, gameNum: 2 }, ... ]
    
    // 全ての日付と球場で、開催可能な全スロットを作成
    for (const date of dates) {
        for (const stadium of stadiumList) {
            for (let i = 1; i <= gamesPerDayPerStadium; i++) {
                scheduleQueue.push({
                    date: date,
                    stadium: stadium.abbr, // 略称を保存
                    stadiumFull: stadium.name,
                    gameNum: i // 試合順 (①, ②, ...)
                });
            }
        }
    }

    // 試合IDにスケジュールを割り当て
    matchIds.forEach((matchId, index) => {
        const match = findMatchById(matchId);
        if (match && scheduleQueue[index]) { // スロットが足りる限り割り当て
            const schedule = scheduleQueue[index];
            match.schedule = {
                date: schedule.date,
                stadium: schedule.stadium,
                stadiumFull: schedule.stadiumFull,
                game: schedule.gameNum
            };
        } else if (match) {
            // スロットが足りなかった場合のフォールバック
            match.schedule = { date: dates[0], stadium: stadiumList[0].abbr, game: 1 };
        }
    });
}

/**
     * チームランクを計算する（現実の勢力図に合わせて調整版）
     */
    function calculateRank(teamName, state) {
        if (!teamName) return '';

        const teamData = TEAM_DATA[teamName];
        if (!teamData) {
            console.error(`TEAM_DATAにチーム「${teamName}」が見つかりません。`);
            return 'E';
        }

        let score = 0;
        
        // 1. 偏差値の影響を半分に (重すぎたため)
        score += teamData.deviation * 0.5;

        // 2. 過去の最高成績ボーナス (変更なし)
        if (teamData.best.includes('優勝')) score += 25;
        else if (teamData.best.includes('準優勝')) score += 20;
        else if (teamData.best.includes('ベスト4')) score += 15;
        else if (teamData.best.includes('出場')) score += 10; // 甲子園出場
        else if (teamData.best.includes('ベスト8')) score += 10;
        else if (teamData.best.includes('ベスト16')) score += 5;

        // 3. 直近の成績ボーナス (倍率を 3.0 → 1.0 に大幅ダウン)
        const rankMultiplier = 1.0; // ★倍率を 1.0 に変更
        if (state.teamRecords && state.teamRecords[teamName]) {
            const lastFinish = state.teamRecords[teamName].lastFinish;
            
            // ★甲子園成績のボーナスを追加
            if (lastFinish <= -1) score += 35 * rankMultiplier; // 全国優勝
            else if (lastFinish <= -2) score += 30 * rankMultiplier; // 全国準優勝
            else if (lastFinish <= -8) score += 25 * rankMultiplier; // 甲子園ベスト8以上
            // ▼県大会の成績
            else if (lastFinish === 1) score += 30 * rankMultiplier; // 県優勝
            else if (lastFinish === 2) score += 25 * rankMultiplier;
            else if (lastFinish <= 4) score += 20 * rankMultiplier;
            else if (lastFinish <= 8) score += 15 * rankMultiplier;
            else if (lastFinish <= 16) score += 5 * rankMultiplier;
            else if (lastFinish >= 64) score -= 5 * rankMultiplier;
        }

        // 4. 人気ボーナス (変更なし)
        if (teamData.popularity) score += 5;

        // 5. ランクの境界線（ボーダーライン）を調整
        if (score >= 60) return 'A'; // Aランク (旧 85+)
        if (score >= 50) return 'B'; // Bランク (旧 70+)
        if (score >= 40) return 'C'; // Cランク (旧 55+)
        if (score >= 30) return 'D'; // Dランク (旧 40+)
        return 'E'; // Eランク (旧 < 40)
    }



/**
 * 指定されたブロックのアニメーションを再生する（トーナメント表示版）
 * (★128チーム制＝1ブロック32チーム＝5ラウンドに対応)
 */
async function playBlockAnimation(blockId) {
    // (タブのアクティブ表示は変更なし)
    document.querySelectorAll('.analysis-block-tab-btn').forEach(btn => {
        const isActive = btn.dataset.block === blockId;
        btn.classList.toggle('bg-cyan-500', isActive);
        btn.classList.toggle('text-white', isActive);
        btn.classList.toggle('bg-gray-700', !isActive);
        btn.classList.toggle('text-gray-400', !isActive);
    });

    const stage = document.getElementById('analysis-stage');
    const narrationTextEl = document.getElementById('analysis-narration-text');
    const analysisData = tournamentState.blockAnalysisData;

    if (!analysisData || !analysisData[blockId]) {
        stage.innerHTML = `<p class="text-center text-gray-500">分析データを読み込めませんでした。</p>`;
        narrationTextEl.textContent = '';
        return;
    }
    const narration = analysisData[blockId];
    
    // ★★★ ここからが修正箇所 ★★★
    // 1ブロック32チーム
    const blockSize = 32; 
    const blockTeams = tournamentState.teams.slice(
        (blockId.charCodeAt(0) - 65) * blockSize, 
        (blockId.charCodeAt(0) - 64) * blockSize
    );
    // ★★★ 修正ここまで ★★★

    stage.innerHTML = '';
    narrationTextEl.textContent = '';
    
    // ★★★ 修正箇所 (R1〜R5まで追加) ★★★
    stage.innerHTML = `
        <div id="r1-col" class="round-column"></div>
        <div id="r2-col" class="round-column"></div>
        <div id="r3-col" class="round-column"></div>
        <div id="r4-col" class="round-column"></div>
        <div id="r5-col" class="round-column"></div>
    `;

    // 1回戦 (16試合)
    for(let i = 0; i < 16; i++) { // 8 -> 16
        const matchupEl = document.createElement('div');
        matchupEl.className = 'analysis-matchup';
        matchupEl.innerHTML = `
            <div class="analysis-team" data-team-name="${blockTeams[i*2]}">${blockTeams[i*2]}</div>
            <div class="analysis-team" data-team-name="${blockTeams[i*2+1]}">${blockTeams[i*2+1]}</div>
            <div class="matchup-connector"></div>
        `;
        stage.querySelector('#r1-col').appendChild(matchupEl);
    }
    
    // 2回戦 (8試合)
    for(let i = 0; i < 8; i++) { stage.querySelector('#r2-col').innerHTML += '<div class="analysis-matchup"><div class="analysis-team">???</div><div class="analysis-team">???</div><div class="matchup-connector"></div><div class="round-connector"></div></div>'; }
    // 3回戦 (4試合)
    for(let i = 0; i < 4; i++) { stage.querySelector('#r3-col').innerHTML += '<div class="analysis-matchup"><div class="analysis-team">???</div><div class="analysis-team">???</div><div class="matchup-connector"></div><div class="round-connector"></div></div>'; }
    // 4回戦 (2試合)
    for(let i = 0; i < 2; i++) { stage.querySelector('#r4-col').innerHTML += '<div class="analysis-matchup"><div class="analysis-team">???</div><div class="analysis-team">???</div><div class="matchup-connector"></div><div class="round-connector"></div></div>'; }
    // 準々決勝 (1試合)
    stage.querySelector('#r5-col').innerHTML += '<div class="analysis-matchup"><div class="analysis-team">???</div></div>';
    // ★★★ 修正ここまで ★★★

    await new Promise(r => setTimeout(r, 100));
    document.querySelectorAll('.analysis-team').forEach((el, i) => {
        setTimeout(() => el.classList.add('show'), i * 50);
    });

    for (let i = 0; i < narration.length; i++) {
        narrationTextEl.textContent += narration[i];
        await new Promise(r => setTimeout(r, 50));
    }
    
    blockTeams.forEach(team => {
        if (narration.includes(team)) {
            document.querySelectorAll(`.analysis-team[data-team-name="${team}"]`).forEach(el => {
                el.classList.add('highlight');
            });
        }
    });
}
// ▲▲▲ 置き換えここまで ▲▲▲
// ▼▼▼ この関数をまるごと追加してください ▼▼▼
/**
 * AIに各ブロックの勢力図を分析させ、ナレーション原稿を生成させる
 * (★128チーム制＝1ブロック32チームに対応)
 */
async function generateBlockAnalysisArticle(state) {
    const { teams, seeds } = state;
    const blocks = { A: [], B: [], C: [], D: [] };

    // ★★★ 修正箇所 ★★★
    const numBlocks = 4;
    const blockSize = Math.floor(teams.length / numBlocks); // 128 / 4 = 32

    teams.forEach((team, i) => {
        if (i < blockSize) blocks.A.push(team); // 0-31
        else if (i < blockSize * 2) blocks.B.push(team); // 32-63
        else if (i < blockSize * 3) blocks.C.push(team); // 64-95
        else blocks.D.push(team); // 96-127
    });
    // ★★★ 修正ここまで ★★★

    const blockAnalysisData = {};
    for (const blockId in blocks) {
        const blockTeams = blocks[blockId];
        const teamDetails = blockTeams.map(teamName => {
            const rank = calculateRank(teamName, state);
            const isSeed = seeds.some(s => s.team === teamName); // ★ シード判定を修正
            const teamData = TEAM_DATA[teamName];
            const tags = []; // タグは廃止されたが、互換性のため残す
            const hasStoryTag = false; // 同上

            if (isSeed || ['A', 'B'].includes(rank) || hasStoryTag) {
                const info = teamData?.info || '';
                return `${teamName}(${rank}${isSeed ? 'S' : ''}) [背景: ${info.substring(0, 40)}...]`;
            } 
            else if (['C'].includes(rank)) {
                 return `${teamName}(${rank})`;
            } 
            else {
                return `${teamName}(${rank})`;
            }
        }).join(', ');
        blockAnalysisData[blockId] = teamDetails;
    }

    const prompt = `あなたは高校野球の解説者です。以下の各ブロックのチームリストを分析し、それぞれの見どころを**150字程度**のナレーション原稿にまとめてください。

### 分析対象ブロック (チーム名とランク、Sはシード校、[]内は注目校の背景情報)
- **Aブロック:** ${blockAnalysisData.A}
- **Bブロック:** ${blockAnalysisData.B}
- **Cブロック:** ${blockAnalysisData.C}
- **Dブロック:** ${blockAnalysisData.D}

### 指示
- **物語を重視:** [背景]情報が提供されている注目校を中心に、そのチームが持つ物語や背景（例：古豪の復活、王者の苦悩）に触れながら解説してください。
- **簡潔に:** 全体のナレーションは150字程度に収めてください。
- 最も激戦区だと思われる「死のブロック」を特定してください。
- 4ブロック分、必ず全てのナレーションを生成してください。

### 出力形式 (JSON)
{
  "A": "（Aブロックのナレーション）",
  "B": "（Bブロックのナレーション）",
  "C": "（Cブロックのナレーション）",
  "D": "（Dブロックのナレーション）"
}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        return parseJsonFromText(result.candidates[0].content.parts[0].text);
    } catch (error) {
        console.error("AIブロック分析記事の生成に失敗:", error);
        return null;
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲
   

// ▼▼▼ この関数を「新規追加」(10400行目あたり、createNewTournament の直前) ▼▼▼

/**
 * [NEW] 128チーム制トーナメントの「(BYE)」(不戦勝)を自動処理する
 */
function processByes(state) {
    const r1MatchIds = Object.keys(state.matches).filter(id => id.includes('-R1-'));
    let byesProcessed = 0;

    r1MatchIds.forEach(matchId => {
        const match = state.matches[matchId];
        if (match.winner) return; // 既に処理済み

        const team1 = match.team1;
        const team2 = match.team2;
        let winnerName = null;

        if (team1 === '(BYE)' && team2 !== '(BYE)') {
            winnerName = team2;
        } else if (team2 === '(BYE)' && team1 !== '(BYE)') {
            winnerName = team1;
        } else if (team1 === '(BYE)' && team2 === '(BYE)') {
            // 両方BYE (ありえないはずだが、念のため)
            match.winner = '(BYE)'; // 勝者もBYE
            winnerName = '(BYE)';
        }

        if (winnerName) {
            byesProcessed++;
            match.winner = winnerName;
            match.summary = "不戦勝";
            
            // 次のラウンドに進める
            const idParts = matchId.split('-');
            const side = idParts[0]; // 'L' or 'R'
            const matchNum = parseInt(idParts[2].slice(1)); // 1-32
            
            const nextRoundNum = 2; // R2
            const nextMatchId = `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
            const nextMatch = state.matches[nextMatchId];
            
            if (nextMatch) {
                const slot = (matchNum % 2 !== 0 ? 1 : 2); // 奇数ならteam1, 偶数ならteam2
                nextMatch[`team${slot}`] = winnerName;
            }
        }
    });

    if (byesProcessed > 0) {
        console.log(`${byesProcessed}件の不戦勝(BYE)を自動処理しました。`);
        // BYE処理後にトーナメント表を再描画
        renderTournament(state);
        saveState();
    }
}
// ▲▲▲ 新規追加ここまで ▲▲▲

/**
 * 新しいトーナメントを開始するメイン関数
 * (★BYE 16枠固定配置、★R2-R4球場シャッフル に対応した最終版)
 */
async function createNewTournament(isNext = false, nextTournamentType = 'summer', predeterminedTeams = null) {
    setupEl.classList.add('hidden');
    tournamentDisplayEl.classList.remove('hidden');

    if (tournamentState.teamRecords) {
        for (const teamName in tournamentState.teamRecords) {
            const record = tournamentState.teamRecords[teamName];
            record.tournamentStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, r: 0, so: 0 };
        }
    }
    
    autumnControls.classList.add('hidden');
    startMainTournamentBtn.classList.add('hidden');
    startRankingPlayoffsBtn.classList.add('hidden');

    if (isNext && tournamentState.teamRecords) {
        for (const teamName in tournamentState.teamRecords) {
            if (tournamentState.teamRecords.hasOwnProperty(teamName)) {
                const record = tournamentState.teamRecords[teamName];
                record.previousRank = record.lastFinish;
                record.wins = 0;
                record.losses = 0;
            }
        }
    }
    
    mainBracketWrapper.classList.remove('hidden');
    tournamentState.is16team = false;
    tournamentState.currentTournament = nextTournamentType;
    
    const numTeamsInTournament = 128;
    const finalRound = 7;

    if (isNext) { 
        if (nextTournamentType === 'summer') {
            tournamentState.tournamentYear++;
        }
    }
    
    if (!isNext) { 
        tournamentState.tournamentYear = 2025;
        tournamentState.teamRecords = {};
        const initialAiEnabled = document.getElementById('initial-ai-generation-toggle').checked;
        tournamentState.settings = { 
            enableArticleGeneration: initialAiEnabled, 
            enableBbsGeneration: initialAiEnabled 
        };
        tournamentState.homepageNews = []; 
        INITIAL_TEAM_POOL.forEach(t => {
            const historicalRank = getRankFromHistoryString(TEAM_DATA[t].last);
            tournamentState.teamRecords[t] = { 
                wins: 0, losses: 0, best: null, history: [],
                lastFinish: historicalRank, 
                previousRank: null,
                teamTraits: [], 
                previousStarters: null,
                roster: null,
                playerStats: { batting: {}, pitching: {} },
                tournamentStats: { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, r: 0, so: 0 } 
            };
        });
    }
    
    let teams;
    let seeds = [];

    // (シード校の決定ロジックは変更なし)
    if (isNext) { 
        const lastTournamentTeams = Object.keys(tournamentState.teamRecords)
            .map(teamName => ({ name: teamName, ...tournamentState.teamRecords[teamName] }))
            .sort((a, b) => a.lastFinish - b.lastFinish); 
        seeds = lastTournamentTeams.slice(0, 8).map((t, i) => ({ team: t.name, rank: i + 1 })); 
    } else { 
        const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
        const setInitialSeedRank = (teamName) => {
            if (teamName === '283学園') return 1; if (teamName === '常葉菊川') return 2;
            if (teamName === '静岡') return 3; if (teamName === '掛川西') return 4;
            const rank = historicalRanks.find(hr => hr.name === teamName)?.rank || 128;
            if (rank === 8) return 8; return rank;
        };
        const adjustedHistoricalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: setInitialSeedRank(teamName) }));
        adjustedHistoricalRanks.sort((a, b) => a.rank - b.rank);
        seeds = adjustedHistoricalRanks.slice(0, 8).map((t, i) => ({ team: t.name, rank: i + 1 }));
    }
    
    // (組み合わせの決定)
    if (predeterminedTeams) {
        teams = predeterminedTeams;
    } else {
        const seedTeamsList = seeds.map(s => s.team);
        
        // ★★★ [NEW] 112校選抜 + 16BYE固定配置ロジック ★★★
        
        // 1. 全チーム(112校)からシード(8校)を除く
        let nonSeeds = INITIAL_TEAM_POOL.filter(t => !seedTeamsList.includes(t)); // 104校
        nonSeeds = shuffleArray(nonSeeds);
        
        teams = Array(numTeamsInTournament).fill(null); // 128スロット
        
        // 2. シード校（8校）を固定配置 (各16チームブロックの先頭)
        const seedPositions = [0, 16, 32, 48, 64, 80, 96, 112]; 
        
        const seedPlacements = {};
        const rank1_4 = seeds.filter(s => s.rank <= 4).sort((a, b) => a.rank - b.rank);
        seedPlacements[seedPositions[0]] = rank1_4.find(s => s.rank === 1).team; // A (0)
        seedPlacements[seedPositions[4]] = rank1_4.find(s => s.rank === 2).team; // C (64)
        seedPlacements[seedPositions[2]] = rank1_4.find(s => s.rank === 4).team; // B (32)
        seedPlacements[seedPositions[6]] = rank1_4.find(s => s.rank === 3).team; // D (96)
        const rank5_8 = shuffleArray(seeds.filter(s => s.rank > 4));
        const remainingSeedSlots = [16, 80, 48, 112]; // 残りのシード枠
        rank5_8.forEach((seed, i) => { seedPlacements[remainingSeedSlots[i]] = seed.team; });
        for (const position in seedPlacements) { teams[position] = seedPlacements[position]; }

        // 3. BYE（16校）を固定配置
        // (各16チームブロックのシード校がいない山に2つずつ)
        const byePositions = [
            4, 12,  // 1シード (0) の山
            20, 28, // 5-8シード (16) の山
            36, 44, // 4シード (32) の山
            52, 60, // 5-8シード (48) の山
            68, 76, // 2シード (64) の山
            84, 92, // 5-8シード (80) の山
            100, 108, // 3シード (96) の山
            116, 124  // 5-8シード (112) の山
        ];
        byePositions.forEach(slot => { teams[slot] = '(BYE)'; });
        
        // 4. ノーシード校（104校）を、残りの 104 スロットに配置
        const teamsToPlace = shuffleArray(nonSeeds); // 104校
        
        let nonSeedIndex = 0;
        for (let i = 0; i < numTeamsInTournament; i++) {
            if (teams[i] === null) { // スロットが空（シードでもBYEでもない）
                if(nonSeedIndex < teamsToPlace.length) {
                    teams[i] = teamsToPlace[nonSeedIndex];
                    nonSeedIndex++;
                }
            }
        }
        
        if (nonSeedIndex !== 104) {
             console.error(`抽選ロジックエラー: 104校を配置する予定でしたが、${nonSeedIndex}校しか配置されませんでした。`);
        }
    }
    
    // (トーナメントstateの初期化 ... 変更なし)
    tournamentState.teams = teams;
    tournamentState.matches = {};
    tournamentState.news = [];
    tournamentState.documentary = { target: null, type: null };
    tournamentState.activeScandal = null;
    tournamentState.seeds = seeds; 
    tournamentState.bbsComments = [];
    tournamentState.daiyaBbsComments = [];
    tournamentState.tickerHeadlines = []; 
    tournamentState.rivalries = RIVALRIES;
    tournamentState.feuds = tournamentState.feuds || []; 
    tournamentState.namcoNews = null;
    tournamentState.preGameComments = {};
    tournamentState.matomeThreads = {}; 
    tournamentState.userThreads = [];
    tournamentState.autumnData = { regions: {} };
    tournamentState.springData = { regions: {} };

    // (R1の試合オブジェクトを作成 ... 変更なし)
    const round1Setup = teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);
    round1Setup.forEach((match, index) => {
        const side = index < 32 ? 'L' : 'R';
        const matchNum = index < 32 ? index + 1 : index - 31;
        const matchId = `${side}-R1-M${matchNum}`;
        const rivalryType = checkRivalry(match.team1, match.team2);
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '', rivalryType: rivalryType };
    });

    // (R2〜R6, Fの空の箱を作成 ... 変更なし)
    for (let r = 2; r < finalRound; r++) {
        const numMatchesInRound = numTeamsInTournament / Math.pow(2, r);
        for (let m = 1; m <= numMatchesInRound / 2; m++) {
            const matchIdL = `L-R${r}-M${m}`;
            tournamentState.matches[matchIdL] = { id: matchIdL, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '', prevMatch1Id: `L-R${r-1}-M${(m*2)-1}`, prevMatch2Id: `L-R${r-1}-M${(m*2)}` };
            const matchIdR = `R-R${r}-M${m}`;
            tournamentState.matches[matchIdR] = { id: matchIdR, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '', prevMatch1Id: `R-R${r-1}-M${(m*2)-1}`, prevMatch2Id: `R-R${r-1}-M${(m*2)}` };
        }
    }
    tournamentState.matches['F-R1-M1'] = { id: 'F-R1-M1', team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '', prevMatch1Id: `L-R${finalRound-1}-M1`, prevMatch2Id: `R-R${finalRound-1}-M1` };
    
    // --- 3. スケジュール割り当て (★R2-R4の球場をシャッフル) ---
    let datesR1, datesR2, datesR3, datesR4, datesR5, datesR6, dateFinal;
    if (nextTournamentType === 'autumn') {
        datesR1 = ["9/10", "9/11", "9/12", "9/13"];
        datesR2 = ["9/15", "9/16"];
        datesR3 = ["9/18", "9/19"];
        datesR4 = ["9/21"];
        datesR5 = ["9/23"];
        datesR6 = ["9/25"];
        dateFinal = ["9/27"];
    } else if (nextTournamentType === 'spring') {
        datesR1 = ["4/10", "4/11", "4/12", "4/13"];
        datesR2 = ["4/15", "4/16"];
        datesR3 = ["4/18", "4/19"];
        datesR4 = ["4/21"];
        datesR5 = ["4/23"];
        datesR6 = ["4/25"];
        dateFinal = ["4/27"];
    } else {
        datesR1 = ["7/10", "7/11", "7/12", "7/13"];
        datesR2 = ["7/15", "7/16"];
        datesR3 = ["7/18", "7/19"];
        datesR4 = ["7/21"];
        datesR5 = ["7/23"];
        datesR6 = ["7/25"];
        dateFinal = ["7/27"];
    }
    
    // (R1のスケジュール割り当て ... 変更なし)
    const matchIdsR1 = Object.keys(tournamentState.matches).filter(id => id.includes('-R1-'));
    let fullScheduleQueueR1 = [];
    for (const date of datesR1) {
        for (const stadium of STADIUM_DATA) { 
            for (let i = 1; i <= 2; i++) { fullScheduleQueueR1.push({ date: date, stadium: stadium.abbr, stadiumFull: stadium.name, region: stadium.region, gameNum: i }); }
        }
    }
    fullScheduleQueueR1 = shuffleArray(fullScheduleQueueR1);
    const seedMatchIds = [];
    const normalMatchIds = [];
    const seedTeamsList = tournamentState.seeds.map(s => s.team); 
    matchIdsR1.forEach(matchId => {
        const match = findMatchById(matchId);
        if (match && (seedTeamsList.includes(match.team1) || seedTeamsList.includes(match.team2))) { seedMatchIds.push(matchId); } 
        else { normalMatchIds.push(matchId); }
    });
    seedMatchIds.forEach(matchId => {
        const match = findMatchById(matchId); if (!match) return;
        let targetRegion = null; let preferredStadiumAbbr = null;
        if (match.team1 === "静岡" || match.team2 === "静岡") { preferredStadiumAbbr = STADIUM_DATA[0].abbr; targetRegion = STADIUM_DATA[0].region; }
        else if (match.team1 === "掛川西" || match.team2 === "掛川西") { preferredStadiumAbbr = STADIUM_DATA[6].abbr; targetRegion = STADIUM_DATA[6].region; }
        else {
            const seedTeamName = seedTeamsList.includes(match.team1) ? match.team1 : match.team2;
            const seedTeamData = TEAM_DATA[seedTeamName];
            if (seedTeamData) { targetRegion = seedTeamData.region; if (targetRegion === '伊豆') targetRegion = '東部'; }
        }
        let schedule; let foundSlotIndex = -1;
        if (preferredStadiumAbbr) { foundSlotIndex = fullScheduleQueueR1.findIndex(s => s.stadium === preferredStadiumAbbr); }
        if (foundSlotIndex === -1 && targetRegion) { foundSlotIndex = fullScheduleQueueR1.findIndex(s => s.region === targetRegion); }
        if (foundSlotIndex === -1 && (preferredStadiumAbbr === STADIUM_DATA[0].abbr || preferredStadiumAbbr === STADIUM_DATA[6].abbr)) {
             let fallbackSlotIndex = fullScheduleQueueR1.findIndex(s => s.region === '東部');
             if (fallbackSlotIndex !== -1) { schedule = fullScheduleQueueR1.splice(fallbackSlotIndex, 1)[0]; }
             else { schedule = fullScheduleQueueR1.shift(); }
        } else if (foundSlotIndex !== -1) { schedule = fullScheduleQueueR1.splice(foundSlotIndex, 1)[0]; }
        else { schedule = fullScheduleQueueR1.shift(); }
        if (schedule) { match.schedule = { date: schedule.date, stadium: schedule.stadium, stadiumFull: schedule.stadiumFull, game: schedule.gameNum }; }
    });
    normalMatchIds.forEach(matchId => {
        const match = findMatchById(matchId); if (!match) return;
        const data1 = TEAM_DATA[match.team1]; const data2 = TEAM_DATA[match.team2];
        let targetRegion = '中部'; 
        if (data1 && data2) {
            const region1 = data1.region; const region2 = data2.region;
            if (region1 === region2) targetRegion = region1;
            else if ((region1 === '東部' && region2 === '西部') || (region1 === '西部' && region2 === '東部')) targetRegion = '中部';
            else if ((region1 === '東部' && region2 === '中部') || (region1 === '中部' && region2 === '東部')) targetRegion = '中部';
            else if ((region1 === '西部' && region2 === '中部') || (region1 === '中部' && region2 === '西部')) targetRegion = '西部';
            else if (region1 === '伊豆' || region2 === '伊豆') targetRegion = '東部';
            if (targetRegion === '伊豆') targetRegion = '東部';
        }
        let foundSlotIndex = fullScheduleQueueR1.findIndex(s => s.region === targetRegion);
        let schedule;
        if (foundSlotIndex === -1) { schedule = fullScheduleQueueR1.shift(); }
        else { schedule = fullScheduleQueueR1.splice(foundSlotIndex, 1)[0]; }
        if (schedule) { match.schedule = { date: schedule.date, stadium: schedule.stadium, stadiumFull: schedule.stadiumFull, game: schedule.gameNum }; }
    });
    
    // (R2以降の割り当て ... ★球場リストをシャッフル)
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R2-')), 
        datesR2, shuffleArray(STADIUM_DATA), 2 // R2 (32試合) -> 全10球場 (シャッフル)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R3-')), 
        datesR3, shuffleArray(ROUND_3_STADIUMS), 2 // R3 (16試合) -> 主要4球場 (シャッフル)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R4-')), 
        datesR4, shuffleArray(ROUND_3_STADIUMS), 2 // R4 (8試合) -> 主要4球場 (シャッフル)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R5-')), 
        datesR5, shuffleArray(QUARTER_FINAL_STADIUMS), 4 // R5 (準々 4試合) -> 2球場 (シャッフル)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R6-')), 
        datesR6, FINAL_STAGE_STADIUMS, 2 // R6 (準決 2試合) -> メイン球場
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.startsWith('F-R1-')), 
        dateFinal, FINAL_STAGE_STADIUMS, 1 // 決勝 (1試合) -> メイン球場
    );
// ▲▲▲ 置き換えここまで ▲▲▲
    
    // 4. 画面とAIの初期化
    renderTournament(tournamentState); 
    
    // 5. 不戦勝(BYE)の自動処理
    processByes(tournamentState);
    
    // 6. AI生成 (変更なし)
    if (tournamentState.settings.enableArticleGeneration) {
        (async () => {
            const newFeuds = await generateDynamicFeuds(tournamentState);
            if (newFeuds && newFeuds.length > 0) {
                tournamentState.feuds.push(...newFeuds);
                saveState(); 
                renderTournament(tournamentState); 
                const feudTitles = newFeuds.map(f => `「${f.teams[0]} vs ${f.teams[1]} (${f.type})」`).join('、');
                tournamentState.news.push({
                    title: "【速報】今大会の「因縁の対決」が決定！",
                    body: `大会本部は、AI解説者の分析に基づき、今大会の注目すべき「因縁の対決」を発表した。\n${feudTitles}など、1回戦から目が離せない戦いが続く。`,
                    timestamp: Date.now()
                });
                renderNews(tournamentState.news);
            }
        })();

        saveState(); 
        renderTournament(tournamentState); 
        const currentTournamentName = tournamentNameMap[tournamentState.currentTournament];
        newsContainer.innerHTML = `<div class="loader">AI記者が${currentTournamentName}の組み合わせと展望を分析中...</div>`;
        bbsCommentsContainer.innerHTML = `<div class="loader">AIが組み合わせを分析中...</div>`;
        namcoNewsSection.classList.remove('hidden');
        namcoNewsContent.innerHTML = `<div class="loader">ナムコグループからのお知らせを確認中...</div>`;
        let analysisArticlePromise = generateBracketAnalysisNewsArticle(tournamentState);
        let bracketBbsPromise = generateBracketBbsThread(tournamentState); 
        try {
            const topicArticles = await generateTopicSchoolArticles(tournamentState); 
            if (topicArticles && topicArticles.length > 0) {
                tournamentState.news.push(...topicArticles); 
            }
        } catch (e) { console.error("話題校紹介記事の生成中にエラーが発生しました:", e); }
        const [namcoNews, analysisArticle, bracketBbsResult] = await Promise.all([
            generateNamcoNews(tournamentState, 'bracket'),
            analysisArticlePromise,
            bracketBbsPromise
        ]);
        if (analysisArticle && !analysisArticle.error) { tournamentState.news.unshift(analysisArticle); }
        else if (analysisArticle && analysisArticle.error) { tournamentState.news.unshift(analysisArticle); }
        if (bracketBbsResult && !bracketBbsResult.error) { tournamentState.bbsComments.push(bracketBbsResult); }
        else if (bracketBbsResult && bracketBbsResult.error) { tournamentState.bbsComments.push({ ...bracketBbsResult, context: { isBracketThread: true } }); }
        if (namcoNews) tournamentState.namcoNews = namcoNews;
        renderNews(tournamentState.news);
        renderBbsComments(tournamentState.bbsComments); 
        renderNamcoNews(tournamentState.namcoNews);
        saveState();
    } else {
        saveState(); 
        renderTournament(tournamentState); 
        newsContainer.innerHTML = `<p class="text-gray-500 text-center">（AIによる自動記事生成は現在オフです。設定 ⚙️ からオンにできます）</p>`;
        bbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">（AIによる掲示板生成は現在オフです。設定 ⚙️ からオンにできます）</p>`;
        namcoNewsSection.classList.add('hidden');
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * AIに組み合わせ抽選時に「話題校紹介」の記事を数本生成させる
 * (★E, D, C, B, Aランクから各1校ずつ、計5校ピックアップ)
 * (★★AI生成失敗時に「エラー記事」として描画し、再生成を可能にする最終版★★)
 * @param {object} state - tournamentState
 * @returns {Promise<Array<object>>} - 生成された記事オブジェクト（またはエラー記事オブジェクト）の配列
 */
async function generateTopicSchoolArticles(state) {
    const { teams, seeds } = state;
    if (!teams || teams.length === 0) return [];

    const articles = [];
    const getTeamRank = (teamName) => calculateRank(teamName, state);
    
    // チームをシャッフル (同じランクからランダムに選ぶため)
    const shuffledTeams = shuffleArray(teams); 

    // ランク別にチームを分類
    const teamsByRank = { 'A': [], 'B': [], 'C': [], 'D': [], 'E': [] };
    shuffledTeams.forEach(team => {
        const rank = getTeamRank(team);
        teamsByRank[rank].push(team);
    });

    // --- 各ランクから1校ずつ選んで記事を生成 ---

    // 1. Eランク校の記事 (テーマ: 悲願の初戦突破へ)
    const teamE = teamsByRank['E'][0];
    if (teamE) {
        const article = await createTopicArticle(teamE, getTeamRank(teamE), 'E');
        if (article) {
            articles.push(article);
        } else {
            // ▼▼▼ ユーザーの要望: 失敗した場合、エラー記事オブジェクトを作成 ▼▼▼
            articles.push({
                title: `記事生成エラー (${teamE})`,
                body: "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                isTopicArticle: true, // これも話題校記事であることを示す
                context: { teamName: teamE, theme: 'E' } // ★再生成用のコンテキスト
            });
            // ▲▲▲
        }
    }

    // 2. Dランク校の記事 (テーマ: 躍進のベスト8へ)
    const teamD = teamsByRank['D'][0];
    if (teamD) {
        const article = await createTopicArticle(teamD, getTeamRank(teamD), 'D');
        if (article) {
            articles.push(article);
        } else {
            articles.push({
                title: `記事生成エラー (${teamD})`,
                body: "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                isTopicArticle: true, 
                context: { teamName: teamD, theme: 'D' } 
            });
        }
    }

    // 3. Cランク校の記事 (テーマ: 甲子園出場という悲願へ)
    const teamC = teamsByRank['C'][0];
    if (teamC) {
        const article = await createTopicArticle(teamC, getTeamRank(teamC), 'C');
        if (article) {
            articles.push(article);
        } else {
            articles.push({
                title: `記事生成エラー (${teamC})`,
                body: "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                isTopicArticle: true, 
                context: { teamName: teamC, theme: 'C' } 
            });
        }
    }

    // 4. Bランク校の記事 (テーマ: 打倒Aランクへ)
    const teamB = teamsByRank['B'][0];
    if (teamB) {
        const article = await createTopicArticle(teamB, getTeamRank(teamB), 'B');
        if (article) {
            articles.push(article);
        } else {
            articles.push({
                title: `記事生成エラー (${teamB})`,
                body: "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                isTopicArticle: true, 
                context: { teamName: teamB, theme: 'B' } 
            });
        }
    }

    // 5. Aランク校の記事 (テーマ: 王者の道)
    const teamA = teamsByRank['A'][0];
    if (teamA) {
        const article = await createTopicArticle(teamA, getTeamRank(teamA), 'A');
        if (article) {
            articles.push(article);
        } else {
            articles.push({
                title: `記事生成エラー (${teamA})`,
                body: "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                isTopicArticle: true, 
                context: { teamName: teamA, theme: 'A' } 
            });
        }
    }

    // 失敗した記事(エラーオブジェクト)もそのまま返すため、.filter(Boolean) は削除
    return articles;
}

/**
 * generateTopicSchoolArticles のヘルパー関数。
 * 1校を選び、ランクに応じたテーマで記事を生成する。
 * (★ A/Bランクでも、ノーシード校の場合はAIの指示を変更する最終版 ★)
 * @param {string} teamName - 選ばれたチーム名
 * @param {string} rank - チームランク (A, B, C, D, E)
 * @param {'E' | 'D' | 'C' | 'B' | 'A'} theme - 記事のテーマ
 * @returns {Promise<object|null>} - 生成された記事オブジェクト
 */
async function createTopicArticle(teamName, rank, theme) {
    const teamData = TEAM_DATA[teamName];
    const teamRecord = tournamentState.teamRecords[teamName];
    const detailedData = DETAILED_TEAM_DATA[teamName];
    const lore = PREFECTURE_LORE; 

    // ▼▼▼ ここからが今回の修正箇所 ▼▼▼
    
    // 1. ランク記号を日本語の説明に変換 (例: 'A' -> '名門校')
    const rankDescription = getRankDescription(rank); 
    
    // 2. ★このチームが「今大会の」シード校か判定★
    const isSeed = tournamentState.seeds.some(s => s.team === teamName);
    
    // 3. ★シード校の場合のみ、シード情報を取得★
    const seedRankString = isSeed ? getSeedRankString(teamName, tournamentState.seeds) : '';

    // 4. AIに渡すための詳細情報を作成 (シードランクは isSeed が true の場合のみ表示)
    let contextInfo = `
- **チーム名:** ${teamName} ${seedRankString} (${rankDescription})
- **チーム背景(info):** ${teamData.info || '情報なし'}
- **監督:** ${teamData.coach.name} (${teamData.coach.style})
- **昨年の成績:** ${getRankString(teamRecord.lastFinish)}
`;
    if (detailedData) {
        contextInfo += `- **注目選手:** ${detailedData.players.map(p => `${p.name}(${p.year}年, ${p.pos}) - ${p.desc}`).join('、 ')}\n`;
    }

    // チームの初戦情報を検索 (変更なし)
    const firstMatch = Object.values(tournamentState.matches).find(m => 
        m.id.includes('-R1-') && (m.team1 === teamName || m.team2 === teamName)
    );
    
    let firstMatchInfo = '';
    if (firstMatch) {
        const opponentName = firstMatch.team1 === teamName ? firstMatch.team2 : firstMatch.team1;
        const opponentRankDesc = getRankDescription(calculateRank(opponentName, tournamentState)); 
        const opponentSeedRank = getSeedRankString(opponentName, tournamentState.seeds);
        
        let scheduleInfo = '日程・球場未定';
        if (firstMatch.schedule) {
            const gameNumIcon = ['①', '②', '③', '④'][firstMatch.schedule.game - 1] || `(第${firstMatch.schedule.game}試合)`;
            scheduleInfo = `${firstMatch.schedule.date} ${firstMatch.schedule.stadiumFull} ${gameNumIcon}`;
        }
        
        firstMatchInfo = `
- **初戦情報:**
  - **対戦相手:** ${opponentName} ${opponentSeedRank} (${opponentRankDesc})
  - **日程:** ${scheduleInfo}
`;
    }
    contextInfo += firstMatchInfo;
    
    // ▲▲▲ 修正ここまで ▲▲▲

    // テーマに応じたプロンプトを作成
    let prompt = `あなたは「スポーツ報知」の高校野球担当記者です。
夏の静岡大会の組み合わせが決定しました。
あなたは今、ピックアップした「話題校」の紹介記事を執筆しています。
以下の【取材データ】と【執筆テーマ】に基づき、情景や選手の背景（物語）が目に浮かぶようなリアルな紹介記事を生成してください。

### 取材データ
${contextInfo}

### 静岡県の常識（あなたの知識）
${lore}

`;

    // ▼▼▼ 各テーマの指示文を (ランク説明) + (シード/ノーシード分岐) に修正 ▼▼▼
    if (theme === 'E') {
        prompt += `
### 執筆テーマ：「悲願の初戦突破へ」
- このチーム（${rankDescription}）の目標は、まず「夏に1勝」することです。
- そのチームが抱える**特有の事情**（例：浜松特支の創部背景、新居の0勝32敗、川根の最後の夏、虎府島の離島ハンデなど）を**記事の中心**に据えてください。
`;
    } else if (theme === 'D') {
        prompt += `
### 執筆テーマ：「躍進のベスト8を目指して」
- このチーム（${rankDescription}）の目標は、強豪を倒して「ベスト8」に進出し、大会のダークホースになることです。
- チームの**歴史**や、注目選手（いなければ架空の注目選手を創作）の**成長物語**に焦点を当ててください。
- 監督や主将の「今年こそは」という、**下剋上（ジャイアントキリング）**にかける意気込みを描写してください。
`;
    } else if (theme === 'C') {
        prompt += `
### 執筆テーマ：「甲子園出場という悲願へ」
- このチーム（${rankDescription}）の目標は、静岡県の「戦国時代」を勝ち抜き、甲子園に出場することです。
- チームの中心となる**エースや主軸選手**に焦点を当て、その選手の**苦悩、成長、そして決意**を深く掘り下げてください。
`;
    } 
    
    // ★★★ ここからが分岐の核心 ★★★
    
    else if (theme === 'B') {
        // ★ Bランク用の指示を、シード校とノーシード校で分岐 ★
        if (isSeed) {
            prompt += `
### 執筆テーマ：「悲願の甲子園出場へ！そして聖地１勝を」
- このチーム（${rankDescription}, ${seedRankString}）は、優勝候補に次ぐ「強豪シード校」です。最大の目標は、Aランク校を倒し、まずは「甲子園出場」の切符を掴むことです。`;
        } else {
            // ノーシードBランクの場合
            prompt += `
### 執筆テーマ：「ノーシードの強豪、下剋上なるか」
- このチーム（${rankDescription}）は、Bランクの力を持つにも関わらず、「ノーシード」で今大会に臨みます。
- 序盤からシード校と激突する可能性があり、大会の「ダークホース」または「波乱要因」として注目されています。`;
        }
        // (共通の指示)
        prompt += `
- チームの強み（例：強力打線）に焦点を当て、それが甲子園出場にどう繋がるかを分析してください。
- チームのキーマン（例：4番、エース）を取り上げ、彼/彼女の決意を語らせてください。`;
    
    } else if (theme === 'A') {
        // ★ Aランク用の指示を、シード校とノーシード校で分岐 ★
        if (isSeed) {
            prompt += `
### 執筆テーマ：「全国制覇へ、王者のプレッシャー」
- このチーム（${rankDescription}, ${seedRankString}）は、今大会の「優勝候補筆頭」です。最終目標は「全国制覇」ですが、そのためにはまず「甲子園出場」という最大の関門を突破しなければなりません。`;
        } else {
            // ノーシードAランクの場合 (例: 765総合)
            prompt += `
### 執筆テーマ：「最強のノーシード、死のブロックの主役」
- このチーム（${rankDescription}）は、Aランクの力を持つにも関わらず、「ノーシード」で今大会に臨みます。
- 彼らが入ったブロックは、自動的に「死のブロック」となります。彼らがどのシード校を倒して勝ち上がってくるのか、その「下剋上」の軌跡に焦点を当ててください。`;
        }
        // (共通の指示)
        prompt += `
- **「勝って当然」というプレッシャー**（シード校の場合）または**「シード校を食う」という挑戦**（ノーシードの場合）とどう戦っているか、主将や監督のコメントを通じて描写してください。
- チームの圧倒的な戦力（例：プロ注目選手）を紹介してください。`;
    }
    // ★★★ 分岐ここまで ★★★

    prompt += `
### 追加指示：初戦の情報【最重要】
- 記事の最後（締めくくり）に、**【取材データ】にある「初戦情報」**（対戦相手、日程、球場）に必ず言及し、大会への期待感を高めてください。
- （例：「${seedRankString || ''}${teamName}の初戦は〇〇日、△△球場での${firstMatchInfo ? (firstMatch.team1 === teamName ? firstMatch.team2 : firstMatch.team1) : '□□高校'}戦。彼らの夏が、いよいよ幕を開ける。」）

### 出力形式【厳守】
- **【最重要】** あなたの応答は、必ず単一のJSONオブジェクト"のみ"でなければなりません。
- **絶対に**、JSONの前後に「はい、記事です」や「\`\`\`json」などのテキストを付け加えてはいけません。
{"title": "（例：【高校野球】${seedRankString || ''}${teamName}、初戦は${firstMatchInfo ? (firstMatch.team1 === teamName ? firstMatch.team2 : firstMatch.team1) : 'XX'}と激突）", "body": "（ここにスポーツ報知風の記事本文）"}
`;

    // --- AIへのリクエスト ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
            const rawTextFromAi = result.candidates[0].content?.parts[0]?.text;
            const article = parseJsonFromText(rawTextFromAi);
            
            if (article && article.title && article.body) {
                // 成功：記事に署名を追加して返す
                article.body += "\n\n　（スポーツ報知 記者）"; // 署名
                return { 
                    ...article, 
                    timestamp: Date.now(),
                    isTopicArticle: true, // 話題校紹介フラグ
                    context: { teamName: teamName, theme: theme, isTopicArticle: true } 
                };
            } else {
                 console.error("parseJsonFromText failed for TopicArticle:", rawTextFromAi);
                 throw new Error("AI response format error after parsing (TopicArticle).");
            }
        } else {
             console.error("Unexpected AI response structure (TopicArticle):", result);
             throw new Error("AI response structure is missing expected parts (TopicArticle).");
        }
    } catch (error) {
        console.error(`話題校紹介記事（${teamName}）の生成に失敗しました:`, error);
        return null; // 失敗した場合は null を返す
    }
}

/**
 * AIに組み合わせ抽選結果の詳細分析に基づいた展望ニュース記事を生成させる
 * (★大会の文脈(夏/秋/春)をAIプロンプトに追加)
 */
async function generateBracketAnalysisNewsArticle(state) {
    const { teams, seeds, currentTournament, tournamentYear } = state;
    const tournamentName = tournamentNameMap[currentTournament] || '大会';
    if (teams.length < 128) return null;

    // ★★★ 大会の文脈（AI用）を追加 ★★★
    let tournamentContextPrompt = "";
    let seedContext = "前大会ベスト8";
    if (currentTournament === 'summer') {
        tournamentContextPrompt = "3年生にとっては最後の夏であり、甲子園出場をかけた最も熱い戦いです。";
    } else if (currentTournament === 'autumn') {
        tournamentContextPrompt = "1,2年生による新チームが始動する最初の公式戦であり、来春のセンバツ出場校選考にも影響する重要な大会です。";
    } else if (currentTournament === 'spring') {
        tournamentContextPrompt = "春のセンバツ（選抜）出場校も決まり、夏の大会のシード権をかけた前哨戦です。";
        seedContext = "前回の秋季大会ベスト8";
    }
    // ★★★ 追加ここまで ★★★

    // (分析ロジックは変更なし)
    const numBlocks = 4;
    const blockSize = 32;
    const blockData = [];
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    const getTeamRank = (teamName) => calculateRank(teamName, state);
    let crushR1 = []; 
    let goodCardsR5 = []; 
    let blockSummary = "";

    for (let i = 0; i < numBlocks; i++) {
        const blockName = String.fromCharCode(65 + i);
        const startIdx = i * blockSize;
        const endIdx = (i + 1) * blockSize;
        const blockTeams = teams.slice(startIdx, endIdx);
        if (blockTeams.length === 0) continue;
        const strongTeamsInBlock = blockTeams.filter(team => {
            const rank = getTeamRank(team);
            return seeds.some(s => s.team === team) || ['A', 'B'].includes(rank); 
        });
        const matchupsR1 = [];
        const potentialR5 = [];
        for (let j = 0; j < blockTeams.length; j += 2) {
            const team1 = blockTeams[j]; const team2 = blockTeams[j + 1];
            if (!team1 || !team2) continue;
            const rank1 = getTeamRank(team1); const rank2 = getTeamRank(team2);
            const matchup = { team1, rank1, team2, rank2 };
            matchupsR1.push(matchup);
            if ((seeds.some(s => s.team === team1) || ['A', 'B'].includes(rank1)) && (seeds.some(s => s.team === team2) || ['A', 'B'].includes(rank2))) {
                matchup.isCrush = true;
            }
        }
        let winnersR1 = [];
        matchupsR1.forEach(m => { winnersR1.push(rankValues[m.rank1] >= rankValues[m.rank2] ? m.team1 : m.team2); });
        let winnersR2 = [];
        for (let j = 0; j < winnersR1.length; j += 2) { winnersR2.push(rankValues[getTeamRank(winnersR1[j])] >= rankValues[getTeamRank(winnersR1[j+1])] ? winnersR1[j] : winnersR1[j+1]); }
        let winnersR3 = [];
        for (let j = 0; j < winnersR2.length; j += 2) { winnersR3.push(rankValues[getTeamRank(winnersR2[j])] >= rankValues[getTeamRank(winnersR2[j+1])] ? winnersR2[j] : winnersR2[j+1]); }
        let winnersR4 = [];
        for (let j = 0; j < winnersR3.length; j += 2) { winnersR4.push(rankValues[getTeamRank(winnersR3[j])] >= rankValues[getTeamRank(winnersR3[j+1])] ? winnersR3[j] : winnersR3[j+1]); }
        if (winnersR4.length >= 2) { potentialR5.push(`${winnersR4[0]} vs ${winnersR4[1]} (予想)`); }
        blockData.push({ name: blockName, strongTeams: strongTeamsInBlock, matchupsR1: matchupsR1, potentialR5: potentialR5 });
    }
    blockData.forEach(block => {
        const strongTeamNames = block.strongTeams.map(team => `${team} ${getSeedRankString(team, state.seeds)}`).join(', ');
        blockSummary += `- ${block.name}ブロック: 有力校 ${block.strongTeams.length} (${strongTeamNames || 'なし'})\n`;
        block.matchupsR1.forEach(m => {
            if (m.isCrush) {
                const team1Info = `${m.team1}${getSeedRankString(m.team1, state.seeds)}(${m.rank1})`;
                const team2Info = `${m.team2}${getSeedRankString(m.team2, state.seeds)}(${m.rank2})`;
                crushR1.push(`${block.name}: ${team1Info} vs ${team2Info}`);
            }
        });
        goodCardsR5.push(...block.potentialR5.map(card => `${block.name}: ${card}`));
    });
    blockData.sort((a, b) => b.strongTeams.length - a.strongTeams.length);
    const deathBlock = blockData[0];
    const blessedBlock = blockData[blockData.length - 1];
    let analysisText = `各ブロックの有力校:\n${blockSummary}`;
    analysisText += `死のブロック: ${deathBlock.name} (${deathBlock.strongTeams.length}校)\n`;
    analysisText += `恵まれたブロック: ${blessedBlock.name} (${blessedBlock.strongTeams.length}校)\n`;
    if (crushR1.length > 0) analysisText += `1回戦での有力校潰し合い:\n  - ${crushR1.join('\n  - ')}\n`;
    if (goodCardsR5.length > 0) analysisText += `準々決勝(R5)での注目カード(予想):\n  - ${goodCardsR5.join('\n  - ')}\n`;

    const prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。
${tournamentYear}年度 ${tournamentName}の組み合わせ抽選会が終了しました。
以下の詳細な分析結果に基づき、読者の期待感を高めるような展望記事を作成してください。

### 大会の文脈 (最重要)
${tournamentContextPrompt}
シード校は「${seedContext}」の8校です。

### 参考情報：静岡県高校野球の「常識」（勢力図）
${PREFECTURE_LORE}
---
### 組み合わせ分析結果 (★シードランク付き)
${analysisText}

### 執筆指示
- 【大会の文脈を反映】: 記事全体で、${tournamentName}ならではの視点（例：夏の3年生の想い、秋の新チームの試金石、春のシード権争い）を必ず反映させてください。
- 【★シードランク言及】: 「第1シードの283学園は〜」や「前大会ベスト8の静岡が入ったCブロックは〜」のように、シードランクにも具体的に言及し、記事に深みを与えてください。
- タイトル: 「${tournamentName} 組み合わせ決定！${deathBlock.name}ブロックは激戦区か？」のように、大会名と抽選結果のポイントが伝わるものにしてください。
- 本文構成:
    1. 組み合わせが決定したことを伝える導入。
    2. 各ブロックの有力校に触れつつ、特に「死のブロック (${deathBlock.name})」と「恵まれたブロック (${blessedBlock.name})」について、シードランクも交えて詳しく解説してください。
    3. Cランクの実力校がどのブロックでシード校を脅かす存在（ダークホース）になりそうか、具体的な校名を挙げて分析してください。
    4. 勝ち上がりを予想し、準々決勝(R5)で実現しそうな好カードについても触れてください。
    5. 【AI記者の注目株】: あなたが「今大会の一押しチーム（推し）」を1校選び、そのチームが持つドラマ性（例：「逆境」「最後の夏」「古豪復活」など）を熱く語るコラム欄を設けてください。
    6. 最後に、大会（${tournamentName}）への期待を述べて締めくくってください。
- 文体: 熱意が伝わる、ややドラマチックなスポーツ記事の文体で記述してください。

### 出力形式
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            
            if (article && article.title && article.body) {
                return { 
                    ...article, 
                    timestamp: Date.now(), 
                    context: { isBracketAnalysis: true } 
                }; 
            }
        }
        throw new Error("AIからの応答が、正しい記事形式ではありません。");
    } catch (error) {
        console.error("AI組み合わせ分析記事の生成に失敗しました:", error);
        return {
            title: "組み合わせ分析記事 生成エラー",
            body: "AI記者との通信に失敗し、記事を生成できませんでした。",
            timestamp: Date.now(),
            error: true,
            errorId: `bracket-analysis-${Date.now()}`,
            context: { isBracketAnalysis: true }
        };
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲


// --- Tournament Animation Logic ---

let currentAnimation = null; // 再生中のアニメーションの種類 (null, 'autumn', 'spring')
let currentStep = -1;       // 現在のステップ番号
let animationSteps = [];    // 現在のアニメーションの全ステップ関数

const stage = document.getElementById('animation-stage');
const narrationEl = document.getElementById('animation-narration');
const prevBtn = document.getElementById('prev-step-btn');
const nextBtn = document.getElementById('next-step-btn');
const animPlaceholder = document.getElementById('anim-placeholder');
const showAutumnBtn = document.getElementById('show-autumn-anim-btn');
const showSpringBtn = document.getElementById('show-spring-anim-btn');

/**
 * アニメーション要素を作成するヘルパー
 */
function createAnimElement(type, text, options = {}) {
    const el = document.createElement('div');
    el.className = `anim-${type}`;
    el.textContent = text;
    if (options.id) el.id = options.id;
    if (options.children) options.children.forEach(child => el.appendChild(child));
    if (options.style) Object.assign(el.style, options.style);
    return el;
}

/**
 * 要素を表示（フェードイン）させるヘルパー
 */
async function showElement(element, delay = 50) {
    if (!element) return;
    await sleep(delay);
    element.classList.add('show');
}

/**
 * 要素を非表示（フェードアウト）させるヘルパー
 */
async function hideElement(element, delay = 0) {
    if (!element) return;
    await sleep(delay);
    element.classList.remove('show', 'anim-highlight');
    await sleep(500); // Wait for fade out
}

/**
 * 要素をハイライトするヘルパー
 */
function highlightElement(element, clearOthers = true) {
    if (clearOthers) {
        stage.querySelectorAll('.anim-highlight').forEach(el => el.classList.remove('anim-highlight'));
    }
    if (element) {
        element.classList.add('anim-highlight');
    }
}

/**
 * ナレーションを設定し、タイプライター風に表示するヘルパー
 */
async function setNarration(text) {
    narrationEl.textContent = '';
    for (const char of text) {
        narrationEl.textContent += char;
        await sleep(30); // 文字間のウェイト
    }
}

/**
 * ステップ実行とボタン制御
 */
async function runStep(stepIndex) {
    if (stepIndex < 0 || stepIndex >= animationSteps.length) return;
    currentStep = stepIndex;
    stage.innerHTML = ''; // ステージをクリア
    animPlaceholder.classList.add('hidden'); // プレースホルダー非表示
    await animationSteps[currentStep](); // 現在のステップ関数を実行
    updateButtons();
}

function updateButtons() {
    prevBtn.disabled = currentStep <= 0;
    nextBtn.disabled = currentStep >= animationSteps.length - 1;
}

// --- 秋季大会アニメーションステップ ---
const autumnAnimation = [
    // Step 0: Introduction
    async () => {
        await setNarration("🍂 秋季大会は新チーム最初の公式戦！センバツ甲子園出場に繋がります。");
        const title = createAnimElement('bracket', '秋季大会システム', { style: { fontSize: '1.2rem', fontWeight: 'bold' } });
        stage.appendChild(title);
        await showElement(title);
    },
    // Step 1: Regional Qualifiers Overview
    async () => {
        await setNarration("まず、県内を4地区（東部・中部・西部・伊豆）に分けて地区予選を行います。");
        const regions = ['東部(20)', '中部(20)', '西部(20)', '伊豆(4)'].map(r => createAnimElement('region', r));
        const container = createAnimElement('bracket', '', { children: regions, style: { display: 'flex', justifyContent: 'center' } });
        stage.appendChild(container);
        for (const region of regions) await showElement(region);
    },
    // Step 2: Main 3 Regions - Blocks
    async () => {
        await setNarration("東・中・西地区では、20チームが4ブロックに分かれ、各ブロック優勝を目指します。");
        const region = createAnimElement('region', '東部地区 (20チーム)', { id: 'main-region', style: { width: '80%' } });
        const blocks = ['A (5)', 'B (5)', 'C (5)', 'D (5)'].map(b => createAnimElement('block', `ブロック ${b}`));
        region.append(...blocks);
        stage.appendChild(region);
        await showElement(region);
        for (const block of blocks) await showElement(block, 100);
        highlightElement(region);
    },
    // Step 3: Block Winner
    async () => {
        await setNarration("各ブロックの優勝チーム (計4チーム) は県大会へ進出決定！🏆");
        const region = document.getElementById('main-region');
        if (!region) { // 要素がなければ再生成 (Prevボタン対策)
            await autumnAnimation[2](); // 前のステップを再実行
            await sleep(500);
        }
        const blockA = stage.querySelector('.anim-block'); // 例としてAブロック
        const winner = createAnimElement('team', 'A優勝', { classList: ['winner'] });
        blockA.appendChild(winner);
        await showElement(winner, 200);
        highlightElement(winner);
        // TODO: 矢印で「県大会へ」を示す
    },
    // Step 4: Block Runner-up & Repechage
    async () => {
        await setNarration("各ブロックの準優勝チーム (計4チーム) は、最後の1枠を賭けた敗者復活戦へ。");
        await autumnAnimation[3](); // 前のステップの表示をベースにする
        const blocks = stage.querySelectorAll('.anim-block');
        const runnersUp = [];
        blocks.forEach((block, i) => {
            const runnerUp = createAnimElement('team', `${String.fromCharCode(65 + i)}準優勝`, { classList: ['loser'] });
            block.appendChild(runnerUp);
            runnersUp.push(runnerUp);
        });
        for (const ru of runnersUp) await showElement(ru, 100);

        const repechage = createAnimElement('bracket', '第5代表決定戦 (敗者復活)', { id: 'repechage', style: { marginTop: '15px' } });
        stage.appendChild(repechage);
        await showElement(repechage);
        highlightElement(repechage);
        // TODO: 準優勝チームから敗者復活戦への矢印
    },
    // Step 5: Repechage Winner
    async () => {
        await setNarration("敗者復活戦の勝者 (1チーム) も県大会へ進出！これで各地区5チーム。");
        await autumnAnimation[4]();
        const repechage = document.getElementById('repechage');
        const repWinner = createAnimElement('team', '復活優勝', { classList: ['winner'] });
        repechage.appendChild(repWinner);
        await showElement(repWinner, 200);
        highlightElement(repWinner);
        // TODO: 矢印で「県大会へ」を示す
    },
    // Step 6: Izu Region
    async () => {
        await setNarration("伊豆地区は4チームのトーナメント。優勝した1チームのみ県大会へ。");
        const region = createAnimElement('region', '伊豆地区 (4チーム)', { id: 'izu-region' });
        const winner = createAnimElement('team', '伊豆優勝', { classList: ['winner'] });
        region.appendChild(winner);
        stage.appendChild(region);
        await showElement(region);
        await showElement(winner, 200);
        highlightElement(region);
    },
    // Step 7: Prefectural Tournament
    async () => {
        await setNarration("全代表16チーム (東5+中5+西5+伊豆1) が集結し、県大会本戦 (トーナメント)！");
        const bracket = createAnimElement('bracket', '県大会本戦 (16チーム)', { id: 'main-bracket' });
        const teams = ['東1', '中1', '西1', '伊1', '東2', '中2', '...', '西5(敗復)'].map(t => createAnimElement('team', t));
        bracket.append(...teams);
        stage.appendChild(bracket);
        await showElement(bracket);
        for (const team of teams) await showElement(team, 30);
        highlightElement(bracket);
    },
    // Step 8: Rewards
    async () => {
        await setNarration("県大会の優勝・準優勝はセンバツ有力！ベスト8以上で春季大会のシード権獲得！✨");
        await autumnAnimation[7]();
        const bracket = document.getElementById('main-bracket');
        const rewards = createAnimElement('bracket', '🏆優勝/準優勝 → センバツへ<br>🏅ベスト8 → 春シード権', { style: { marginTop: '15px', borderColor: 'gold' } });
        stage.appendChild(rewards);
        await showElement(rewards, 200);
        highlightElement(rewards);
    }
];

// --- 春季大会アニメーションステップ ---
const springAnimation = [
    // Step 0: Introduction
    async () => {
        await setNarration("🌸 春季大会は夏の大会の前哨戦！夏のシード権獲得を目指します。");
        const title = createAnimElement('bracket', '春季大会システム', { style: { fontSize: '1.2rem', fontWeight: 'bold' } });
        stage.appendChild(title);
        await showElement(title);
    },
    // Step 1: Seed Teams
    async () => {
        await setNarration("秋季大会ベスト8のチームはシード校となり、県大会2回戦から登場します。");
        const seeds = Array.from({ length: 8 }).map((_, i) => createAnimElement('team', `秋Best8-${i+1}`, { classList: ['seed'] }));
        const container = createAnimElement('bracket', 'シード校 (8チーム)', { children: seeds, id: 'seeds', style: { borderColor: 'orange' } });
        stage.appendChild(container);
        await showElement(container);
        for (const seed of seeds) await showElement(seed, 50);
        highlightElement(container);
    },
    // Step 2: Regional Qualifiers (Non-seeds)
    async () => {
        await setNarration("シード校以外のチームは、再び地区予選へ。秋と同様に代表枠を争います。");
        const others = createAnimElement('region', 'シード以外の全チーム (56チーム)', { id: 'others' });
        const qualifiers = createAnimElement('bracket', '地区予選 (秋と同じ形式)', { id: 'qualifiers' });
        stage.appendChild(others);
        stage.appendChild(qualifiers);
        await showElement(others);
        await showElement(qualifiers, 200);
        highlightElement(qualifiers);
        // TODO: othersからqualifiersへの矢印
    },
    // Step 3: Qualifier Winners
    async () => {
        await setNarration("地区予選を突破した16チームが県大会1回戦へ進出します。");
        await springAnimation[2](); // 前のステップ表示
        const qualifiers = document.getElementById('qualifiers');
        const winners = Array.from({ length: 16 }).map((_, i) => createAnimElement('team', `予選突破-${i+1}`, { classList: ['winner'] }));
        const winnerContainer = createAnimElement('bracket', '予選突破 (16チーム)', { children: winners, id: 'q-winners' });
        qualifiers.appendChild(winnerContainer);
        await showElement(winnerContainer, 200);
        highlightElement(winnerContainer);
    },
    // Step 4: Prefectural Round 1
    async () => {
        await setNarration("県大会1回戦は、予選突破校同士の対決です。");
        await springAnimation[3]();
        const qWinners = document.getElementById('q-winners');
        const r1Bracket = createAnimElement('bracket', '県大会1回戦 (8試合)', { id: 'r1-bracket', style: { marginTop: '15px' } });
        // 代表として4チーム表示
        const teamsR1 = ['予選A', '予選B', '予選C', '予選D'].map(t => createAnimElement('team', t));
        r1Bracket.append(...teamsR1);
        stage.appendChild(r1Bracket);
        await showElement(r1Bracket, 200);
        highlightElement(r1Bracket);
        // TODO: q-winnersからr1-bracketへの矢印
    },
    // Step 5: Prefectural Round 2 (Seeds Join)
    async () => {
        await setNarration("1回戦の勝者8チームが、シード校8チームと2回戦で激突！ここから本戦！");
        const seeds = Array.from({ length: 8 }).map((_, i) => createAnimElement('team', `秋Best8-${i+1}`, { classList: ['seed'] }));
        const seedContainer = createAnimElement('bracket', 'シード校 (8チーム)', { children: seeds, id: 'seeds', style: { borderColor: 'orange' } });

        const r1Winners = Array.from({ length: 8 }).map((_, i) => createAnimElement('team', `1回戦勝者-${i+1}`, { classList: ['winner'] }));
        const r1WinnerContainer = createAnimElement('bracket', '1回戦勝者 (8チーム)', { children: r1Winners, id: 'r1-winners' });

        const r2Bracket = createAnimElement('bracket', '県大会2回戦 (16チーム)', { id: 'r2-bracket', style: { borderColor: 'red' } });

        stage.append(seedContainer, r1WinnerContainer, r2Bracket);
        await showElement(seedContainer);
        await showElement(r1WinnerContainer);
        await showElement(r2Bracket, 200);
        highlightElement(r2Bracket);
        // TODO: seedContainerとr1WinnerContainerからr2Bracketへの矢印
    },
    // Step 6: Reward (Summer Seed)
    async () => {
        await setNarration("この大会でベスト8以上に入ると、夏の選手権大会のシード権獲得！🔥");
        await springAnimation[5]();
        const r2Bracket = document.getElementById('r2-bracket');
        const reward = createAnimElement('bracket', '🏅ベスト8 → 夏のシード権', { style: { marginTop: '15px', borderColor: 'gold' } });
        stage.appendChild(reward);
        await showElement(reward, 200);
        highlightElement(reward);
    }
];

// --- Event Listeners for Animation Control ---

showAutumnBtn.addEventListener('click', () => {
    currentAnimation = 'autumn';
    animationSteps = autumnAnimation;
    runStep(0);
});

showSpringBtn.addEventListener('click', () => {
    currentAnimation = 'spring';
    animationSteps = springAnimation;
    runStep(0);
});

prevBtn.addEventListener('click', () => {
    if (currentStep > 0) {
        runStep(currentStep - 1);
    }
});

nextBtn.addEventListener('click', () => {
    if (currentStep < animationSteps.length - 1) {
        runStep(currentStep + 1);
    }
});

// Helper for delays
// function sleep(ms) { // 既存のsleep関数があれば不要
//     return new Promise(resolve => setTimeout(resolve, ms));
// }

/**
 * AIに組み合わせ抽選結果に基づいた、なんJ風の掲示板スレッド（タイトル＋コメント群）を生成させる
 * (★大会の文脈(夏/秋/春)をAIプロンプトに追加)
 */
async function generateBracketBbsThread(state) {
    const { teams, seeds, currentTournament, tournamentYear } = state;
    const tournamentName = tournamentNameMap[currentTournament] || '大会';
    if (!teams || teams.length < 128) return null; 

    // (分析ロジックは変更なし)
    const numBlocks = 4; const blockSize = 32; const blockData = [];
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 }; 
    const getTeamRank = (teamName) => calculateRank(teamName, state); 
    const getTeamRegion = (teamName) => TEAM_DATA[teamName]?.region || '不明'; 
    let nicheMatchups = []; let crushR1 = []; let goodCardsR5 = []; let blockSummary = "";
    for (let i = 0; i < numBlocks; i++) {
        const blockName = String.fromCharCode(65 + i);
        const startIdx = i * blockSize; const endIdx = (i + 1) * blockSize;
        const blockTeams = teams.slice(startIdx, endIdx); if (blockTeams.length === 0) continue;
        const strongTeamsInBlock = blockTeams.filter(team => { const rank = getTeamRank(team); return seeds.some(s => s.team === team) || ['A', 'B'].includes(rank); });
        const matchupsR1 = []; const potentialR5 = [];
        for (let j = 0; j < blockTeams.length; j += 2) {
            const team1 = blockTeams[j]; const team2 = blockTeams[j + 1];
            if (!team1 || !team2) continue;
            const rank1 = getTeamRank(team1); const rank2 = getTeamRank(team2);
            const region1 = getTeamRegion(team1); const region2 = getTeamRegion(team2);
            const matchup = { team1, rank1, region1, team2, rank2, region2 }; 
            matchupsR1.push(matchup);
            if ((seeds.some(s => s.team === team1) || ['A', 'B'].includes(rank1)) && (seeds.some(s => s.team === team2) || ['A', 'B'].includes(rank2))) { matchup.isCrush = true; }
            if (nicheMatchups.length < 3 && !matchup.isCrush && ((rankValues[rank1] >= 4 && rankValues[rank2] === 3) || (rankValues[rank1] === 3 && rankValues[rank2] >= 4))) {
                nicheMatchups.push({ block: blockName, match: `${team1}(${rank1}) vs ${team2}(${rank2})`, reason: `Cランクが強豪に挑む注目カード` });
            }
        }
        let winnersR1 = [];
        matchupsR1.forEach(m => { winnersR1.push(rankValues[m.rank1] >= rankValues[m.rank2] ? m.team1 : m.team2); });
        let winnersR2 = [];
        for (let j = 0; j < winnersR1.length; j += 2) { winnersR2.push(rankValues[getTeamRank(winnersR1[j])] >= rankValues[getTeamRank(winnersR1[j+1])] ? winnersR1[j] : winnersR1[j+1]); }
        let winnersR3 = [];
        for (let j = 0; j < winnersR2.length; j += 2) { winnersR3.push(rankValues[getTeamRank(winnersR2[j])] >= rankValues[getTeamRank(winnersR2[j+1])] ? winnersR2[j] : winnersR2[j+1]); }
        let winnersR4 = [];
        for (let j = 0; j < winnersR3.length; j += 2) { winnersR4.push(rankValues[getTeamRank(winnersR3[j])] >= rankValues[getTeamRank(winnersR3[j+1])] ? winnersR3[j] : winnersR3[j+1]); }
        if (winnersR4.length >= 2) { potentialR5.push(`${winnersR4[0]} vs ${winnersR4[1]} (予想)`); }
        blockData.push({ name: blockName, strongTeams: strongTeamsInBlock, matchupsR1: matchupsR1, potentialR5: potentialR5 });
    }
    blockData.forEach(block => {
        const strongTeamNames = block.strongTeams.map(team => `${team} ${getSeedRankString(team, state.seeds)}`).join(', ');
        blockSummary += `- ${block.name}ブロック: 有力校 ${block.strongTeams.length} (${strongTeamNames || 'なし'})\n`;
        block.matchupsR1.forEach(m => {
            if (m.isCrush) {
                const team1Info = `${m.team1}${getSeedRankString(m.team1, state.seeds)}(${m.rank1})`;
                const team2Info = `${m.team2}${getSeedRankString(m.team2, state.seeds)}(${m.rank2})`;
                crushR1.push(`${block.name}: ${team1Info} vs ${team2Info}`);
            }
        });
        goodCardsR5.push(...block.potentialR5.map(card => `${block.name}: ${card}`));
    });
    blockData.sort((a, b) => b.strongTeams.length - a.strongTeams.length);
    const deathBlock = blockData[0]; 
    const blessedBlock = blockData[blockData.length - 1]; 
    let analysisText = `各ブロックの有力校:\n${blockSummary}`;
    analysisText += `死のブロック: ${deathBlock.name} (${deathBlock.strongTeams.length}校)\n`;
    analysisText += `恵まれたブロック: ${blessedBlock.name} (${blessedBlock.strongTeams.length}校)\n`;
    if (crushR1.length > 0) analysisText += `1回戦での有力校潰し合い:\n  - ${crushR1.join('\n  - ')}\n`;
    if (goodCardsR5.length > 0) analysisText += `準々決勝(R5)での注目カード(予想):\n  - ${goodCardsR5.join('\n  - ')}\n`;
    if (nicheMatchups.length > 0) analysisText += `その他の注目1回戦カード:\n${nicheMatchups.map(nm => `  - ${nm.block}ブロック: ${nm.match} (${nm.reason})`).join('\n')}\n`;

    // ★★★ 大会の文脈（AI用）を追加 ★★★
    let tournamentContextPrompt = "";
    let seedContext = "前大会ベスト8";
    if (currentTournament === 'summer') {
        tournamentContextPrompt = "3年生にとってはガチで最後の夏や。";
    } else if (currentTournament === 'autumn') {
        tournamentContextPrompt = "新チームの初陣やな。ここでの結果がセンバツ選考に響くで。";
    } else if (currentTournament === 'spring') {
        tournamentContextPrompt = "夏のシード権がかかった前哨戦や。";
        seedContext = "秋季大会ベスト8";
    }
    // ★★★ 追加ここまで ★★★

    const prompt = `あなたは、匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは高校野球に詳しく、煽りやユーモアを交えながら会話を盛り上げます。
${tournamentYear}年度 ${tournamentName}の組み合わせ抽選会が終わりました。
以下の詳細な分析結果を基に、**なんJらしいスレッドタイトル**と、そのスレッド内での**リアルタイムな反応コメントを20〜25個**生成してください。

### 大会の文脈 (最重要)
${tournamentContextPrompt}
シード校は「${seedContext}」の8校や。

### 参考情報：静岡県高校野球の「常識」（勢力図）
${PREFECTURE_LORE}
---
### 組み合わせ分析結果サマリー (★シードランク付き)
${analysisText}

### あなたが生成するコメントの方向性
- **【★大会の文脈を反映】**: ${tournamentName}ならではの視点（例：「夏は3年生最後やな」「秋の新チームの仕上がり見れるな」「春でシード取れよ」）をコメントに含めること。
- 【★シードランク言及】: **「第1シードの283、余裕のブロックで草」「第3シードの静岡、いきなりノーシードの強豪と当たってて可哀想」**のように、シードランクにも具体的に言及してください。
- **分析結果への反応:**
    - 「死のブロック (${deathBlock.name})」に入ったチームへの同情や煽り。
    - 「恵まれたブロック (${blessedBlock.name})」への反応。
    - 1回戦での有力校潰し合い (${crushR1.length}件) について。「初戦からこれとか勿体ねえ」
    - 準々決勝(R5)で実現しそうな好カード予想について。「〇〇ブロックは準々決勝が事実上の決勝だな」
- **★マニアックな視点 (超重要)】:**
    - 「その他の注目1回戦カード」に挙げられているような、**下位・中堅校同士の対決**についてコメントすること。
- **なんJらしさ:**
    - 短い煽りレス。「は？」「雑魚w」「ファーwww」
    - 他のコメントへの安価 (>>) 付きの返信やツッコミ。

### 出力形式
{"title": "（例：【${tournamentName}】組み合わせ決定www 死のブロックは〇〇！）", "comments": [...]}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const bbsJson = parseJsonFromText(rawText);
            if (bbsJson && bbsJson.threadTitle && Array.isArray(bbsJson.comments)) {
                return {
                    id: `bracket-thread-${Date.now()}`, 
                    title: bbsJson.threadTitle,
                    matchId: 'bracket', 
                    comments: bbsJson.comments.map((c, index) => ({ 
                        id: crypto.randomUUID(),
                        personality: c.personality || `${index + 1}: 風吹けば名無し`, 
                        text: c.comment,
                        timestamp: Date.now() + index * 10, 
                        replies: [] 
                    })),
                    timestamp: Date.now() 
                };
            }
        }
        throw new Error("AIからの応答が、正しいスレッド形式ではありません。");
    } catch (error) {
        console.error("AI組み合わせ反応スレッドの生成に失敗しました:", error);
        return {
            error: true,
            title: "組み合わせスレッド生成エラー",
            body: "AIによるスレッド生成に失敗しました。", 
            timestamp: Date.now(),
            errorId: `bracket-thread-error-${Date.now()}` 
        };
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 大会終了時に、全チームの最終順位をteamRecordsに記録し、履歴を更新する
 * (★128チーム制＝7ラウンド制に対応)
 */
function updateTournamentFinishRecords() {
    const { matches, teams } = tournamentState;
    if (!teams || teams.length === 0) return;

    const numTeams = teams.length; // 128
    const finalRound = Math.log2(numTeams); // 7

    // 最終順位を決定する
    const getRoundLosers = (round, side) => {
        const losers = [];
        // ★ 128チーム制 (R1=64試合) に対応
        const numMatches = (numTeams / 2) / Math.pow(2, round - 1); 
        for (let m = 1; m <= numMatches; m++) {
            const match = matches[`${side}-R${round}-M${m}`];
            if (match && match.winner) {
                const loser = match.winner === match.team1 ? match.team2 : match.team1;
                // ★ 不戦勝(BYE)は集計しない
                if (loser && loser !== '(BYE)') losers.push(loser);
            }
        }
        return losers;
    };

    const finalMatch = matches['F-R1-M1'];
    if (finalMatch && finalMatch.winner) {
        const winner = finalMatch.winner;
        const runnerUp = finalMatch.winner === finalMatch.team1 ? finalMatch.team2 : finalMatch.team1;
        if (winner && tournamentState.teamRecords[winner]) tournamentState.teamRecords[winner].lastFinish = 1;
        if (runnerUp && tournamentState.teamRecords[runnerUp]) tournamentState.teamRecords[runnerUp].lastFinish = 2;
    }

    // ★★★ 修正箇所 ★★★
    // 準決勝(R6)以前の敗退順位を記録
    for (let r = finalRound - 1; r >= 1; r--) { // R6 から R1 までループ
        // 敗退したラウンドの順位を計算 (例: R1敗退 -> 128位, R6敗退 -> 4位)
        const finishRank = Math.pow(2, finalRound - r); 
        
        getRoundLosers(r, 'L').concat(getRoundLosers(r, 'R')).forEach(t => {
            if (t && tournamentState.teamRecords[t]) {
                tournamentState.teamRecords[t].lastFinish = finishRank;
            }
        });
    }
    // ★★★ 修正ここまで ★★★

    // 戦績履歴と最高成績の更新 (変更なし)
    Object.keys(tournamentState.teamRecords).forEach(team => {
        const record = tournamentState.teamRecords[team];
        if(!record.lastFinish) return;

        const newHistoryRecord = {
            year: tournamentState.tournamentYear,
            tournament: tournamentState.currentTournament,
            rank: record.lastFinish
        };

        if (!record.history) record.history = [];
        record.history.unshift(newHistoryRecord);

        if (!record.best || newHistoryRecord.rank < record.best.rank) {
            record.best = newHistoryRecord;
        }
    });
}
// ▲▲▲ 置き換えここまで ▲▲▲

 /**
     * 現在のトーナメント状態に基づいてUI全体を再描画する
     * (★夏・秋・春 すべて128チーム制のメインブラケットを描画するよう統一)
     */
    function renderTournament(data) {
        let tournamentNameString = tournamentNameMap[data.currentTournament] || '大会';

        // UI要素を一度すべて非表示に初期化
        mainBracketWrapper.classList.add('hidden');
        autumnRegionalContainer.classList.add('hidden');
        autumnRankingContainer.classList.add('hidden');
        autumnControls.classList.add('hidden');
        [skipAutumnBlocksBtn, skipAutumnRankingBtn, skipAutumnMainBtn, skipSpringQualifiersBtn, skipSpringRound1Btn, skipSpringMainBtn, startRankingPlayoffsBtn, startMainTournamentBtn].forEach(btn => btn?.classList.add('hidden'));
        
        // ★★★ ここからが新ロジック ★★★
        // 大会の種類に関わらず、常にメインブラケットを描画
        mainBracketWrapper.classList.remove('hidden');
        renderMainBracket(data);
        // ★★★ 新ロジックここまで ★★★

        // --- 共通の描画処理 (変更なし) ---
        tournamentYearDisplay.textContent = `${data.tournamentYear}年度 ${tournamentNameString}`;
        renderRegionMap(data);
        renderNews(data.news || []);
        renderBbsComments(data.bbsComments || []);
        renderDaiyaBbsComments(data.daiyaBbsComments || []);
        renderNamcoNews(data.namcoNews);
        checkTournamentProgress(); // 夏・秋・春 共通のスキップボタン表示制御
        updateTicker();
    }
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * [秋季大会] 地区ブロック予選をスキップする
 */
async function skipAutumnRegionalBlocks() {
    skipAutumnBlocksBtn.disabled = true;
    skipAutumnBlocksBtn.textContent = '進行中...';

    // 全ての地区の全ブロックの試合を処理
    for (const region of ['東部', '中部', '西部', '伊豆']) {
        const regionData = tournamentState.autumnData.regions[region];
        
        const blocks = regionData.izuBracket ? [regionData.izuBracket] : regionData.blocks;

        for (const block of blocks) {
            // ブロック内の全試合IDを取得
            const matchIds = Object.keys(block.matches);
            for (const matchId of matchIds) {
                const match = block.matches[matchId];
                // チームがセットされていて、まだ勝者が決まっていない試合を処理
                if (match.team1 && match.team2 && !match.winner) {
                    const { team1, team2 } = match;
                    const rank1 = calculateRank(team1, tournamentState);
                    const rank2 = calculateRank(team2, tournamentState);
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    
                    const winnerName = (rankValues[rank1] >= rankValues[rank2]) ? team1 : team2;
                    const loserName = winnerName === team1 ? team2 : team1;

                    const [winnerScore, loserScore] = generateAutoScore(rank1, rank2);
                    match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
                    match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;
                    
                    // processMatchWinを呼び出して勝者を次に進める
                    await processMatchWin(matchId, winnerName);
                }
            }
        }
    }
    
    // 全て終わったら、自動で次のステージへ
    await setupAutumnRankingTournaments();
    skipAutumnBlocksBtn.disabled = false;
    skipAutumnBlocksBtn.textContent = '地区ブロック予選をスキップ';
}

/**
 * [秋季大会] 地区順位決定戦（敗者復活戦）をスキップする
 */
async function skipAutumnRankingTournaments() {
    skipAutumnRankingBtn.disabled = true;
    skipAutumnRankingBtn.textContent = '進行中...';

    for (const region of ['東部', '中部', '西部']) {
        const repBracket = tournamentState.autumnData.regions[region].repechageBracket;
        if (!repBracket) continue;
        
        const matchIds = Object.keys(repBracket.matches);
        for (const matchId of matchIds) {
            const match = repBracket.matches[matchId];
            if (match.team1 && match.team2 && !match.winner) {
                const { team1, team2 } = match;
                const rank1 = calculateRank(team1, tournamentState);
                const rank2 = calculateRank(team2, tournamentState);
                const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                
                const winnerName = (rankValues[rank1] >= rankValues[rank2]) ? team1 : team2;
                
                const [winnerScore, loserScore] = generateAutoScore(rank1, rank2);
                match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
                match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;

                await processMatchWin(matchId, winnerName);
            }
        }
    }

    // 自動で県大会本戦へ
    await setupAutumnMainTournament();
    skipAutumnRankingBtn.disabled = false;
    skipAutumnRankingBtn.textContent = '地区順位決定戦をスキップ';
}

/**
 * [秋季大会] 県大会本戦をスキップする
 */
async function skipAutumnMainTournament() {
    skipAutumnMainBtn.disabled = true;
    skipAutumnMainBtn.textContent = '進行中...';

    // 秋季県大会は16チームトーナメント（4ラウンド）
    await skipRound(1); // 1回戦 (ベスト8決定)
    await skipRound(2); // 準々決勝 (ベスト4決定)
    await skipRound(3); // 準決勝 (決勝進出決定)
    await skipFinal();  // 決勝

    skipAutumnMainBtn.disabled = false;
    skipAutumnMainBtn.textContent = '県大会本戦をスキップ';
}

/**
 * [春季大会] 地区予選をスキップする
 */
async function skipSpringQualifiers() {
    skipSpringQualifiersBtn.disabled = true;
    skipSpringQualifiersBtn.textContent = '進行中...';

    const allQualifierMatches = Object.values(tournamentState.springData.allMatches);

    // 予選の全試合をループ処理
    for (const match of allQualifierMatches) {
        // チームがまだセットされていない試合はスキップ
        if (!match.team1 || !match.team2 || match.winner) continue;
        
        const { team1, team2 } = match;
        const rank1 = calculateRank(team1, tournamentState);
        const rank2 = calculateRank(team2, tournamentState);
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        
        const winnerName = (rankValues[rank1] >= rankValues[rank2]) ? team1 : team2;
        
        const [winnerScore, loserScore] = generateAutoScore(rank1, rank2);
        match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
        match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;

        await processMatchWin(match.id, winnerName);
    }

    // 自動で県大会1回戦へ
    await setupSpringMainTournament_Round1();
    skipSpringQualifiersBtn.disabled = false;
    skipSpringQualifiersBtn.textContent = '春季地区予選をスキップ';
}

/**
 * [春季大会] 県大会1回戦をスキップする
 */
async function skipSpringMainRound1() {
    skipSpringRound1Btn.disabled = true;
    skipSpringRound1Btn.textContent = '進行中...';

    // 1回戦は8試合
    await skipRound(1); 
    
    // 自動で県大会2回戦へ
    await setupSpringMainTournament_Round2();
    skipSpringRound1Btn.disabled = false;
    skipSpringRound1Btn.textContent = '春季県大会1回戦をスキップ';
}

/**
 * [春季大会] 県大会2回戦以降をスキップする
 */
async function skipSpringMainTournament() {
    skipSpringMainBtn.disabled = true;
    skipSpringMainBtn.textContent = '進行中...';

    // 2回戦以降はベスト16トーナメントと同じ
    await skipRound(1); // 2回戦 (ベスト8決定)
    await skipRound(2); // 準々決勝 (ベスト4決定)
    await skipRound(3); // 準決勝 (決勝進出決定)
    await skipFinal();  // 決勝

    skipSpringMainBtn.disabled = false;
    skipSpringMainBtn.textContent = '春季県大会2回戦以降をスキップ';
}

   /**
     * メインのトーナメント表（128, 32, 16チーム制に対応）を描画する
     * (★32チーム制＝左右8試合ずつに振り分けるよう修正)
     */
    function renderMainBracket(data) {
        if (!data.teams || data.teams.length === 0) {
             mainBracketContainer.innerHTML = '';
             return;
        };

        const { matches, teams, seeds } = data;
        const numTeams = teams.length; // 128 (夏), 32 (秋), 16 (春)

        const bracketContentWrapper = document.createElement('div');
        bracketContentWrapper.className = 'flex flex-row';

        const leftBracketEl = document.createElement('div');
        leftBracketEl.className = 'bracket-half left';

        const rightBracketEl = document.createElement('div');
        rightBracketEl.className = 'bracket-half right';
        
        const finalRound = Math.log2(numTeams); // 128->7, 32->5, 16->4
        const semiFinalRound = finalRound - 1; // 準決勝のラウンド番号 (R6, R4, R3)
        
        const leftChampion = data.matches[`L-R${semiFinalRound}-M1`]?.winner ?? null;
        const rightChampion = data.matches[`R-R${semiFinalRound}-M1`]?.winner ?? null;
        
        const finalMatch = data.matches['F-R1-M1'] || {};
        const finalTeam1 = finalMatch.team1 ?? leftChampion;
        const finalTeam2 = finalMatch.team2 ?? rightChampion;

        const finalEl = document.createElement('div');
        finalEl.className = 'bracket-final';
        finalEl.innerHTML = `<div class="final-title">決勝</div><div class="final-matchup" data-match-id="F-R1-M1">${createMatchHTML('F-R1-M1', finalTeam1, finalTeam2, finalMatch, seeds)}</div><div class="winner-box" id="tournament-winner">${finalMatch.winner ? `🏆 ${finalMatch.winner} 🏆` : '🏆'}</div>`;

        // 1回戦の全試合を生成 (128->64試合, 32->16試合, 16->8試合)
        const round1Setup = teams.reduce((acc, team, i) => {
            if (i % 2 === 0) acc.push({ team1: team, team2: null });
            else acc[acc.length - 1].team2 = team;
            return acc;
        }, []);
        
        // ★★★ ここからが修正箇所 (全試合を半分に分割) ★★★
        const halfMatches = round1Setup.length / 2; // 64->32, 16->8, 8->4
        
        const leftHalfSetup = round1Setup.slice(0, halfMatches);
        const rightHalfSetup = round1Setup.slice(halfMatches);
        // ★★★ 修正ここまで ★★★

        generateHalf(leftBracketEl, leftHalfSetup, 'L', matches, seeds);
        generateHalf(rightBracketEl, rightHalfSetup, 'R', matches, seeds);

        mainBracketContainer.innerHTML = '';
        bracketContentWrapper.append(leftBracketEl, finalEl, rightBracketEl);
        mainBracketContainer.appendChild(bracketContentWrapper);

        if (finalMatch.winner) {
            nextTournamentBtn.classList.remove('hidden');
        } else {
            nextTournamentBtn.classList.add('hidden');
        }
    }
// ▲▲▲ 置き換えここまで ▲▲▲

   /**
     * トーナメント表の片側（レフトまたはライト）を描画するヘルパー関数
     * (★128チーム制＝7ラウンド制のラウンド名に固定)
     */
    function generateHalf(containerEl, setup, side, allMatches, seeds) {
        containerEl.innerHTML = '';
        const numMatchesInFirstRound = setup.length; // 32
        const numTeamsOnSide = numMatchesInFirstRound * 2; // 64
        const numRounds = Math.log2(numTeamsOnSide); // 6 (R1...R6)

        // ★★★ ここからが修正箇所 (128チーム制のラウンド名に固定) ★★★
        const roundNameMap = { 1: "1回戦", 2: "2回戦", 3: "3回戦", 4: "4回戦", 5: "準々決勝", 6: "準決勝" };
        // ★★★ 修正ここまで ★★★

        const roundElements = [];
        for (let i = 0; i < numRounds; i++) {
            const roundEl = document.createElement('div');
            roundEl.className = 'round';
            if (i > 0) roundEl.classList.add('subsequent-round');

            const roundTitle = document.createElement('h3');
            roundTitle.className = 'text-center font-bold mb-2';
            roundTitle.textContent = roundNameMap[i + 1] || `${i + 1}回戦`;
            roundEl.appendChild(roundTitle);

            containerEl.appendChild(roundEl);
            roundElements.push(roundEl);
        }

        // (以降の描画ロジックは変更なし)
        setup.forEach((matchSetup, index) => {
            const matchId = `${side}-R1-M${index + 1}`;
            let dbMatch = allMatches[matchId] || {};
            const team1 = dbMatch.team1 || matchSetup.team1;
            const team2 = dbMatch.team2 || matchSetup.team2;
            roundElements[0].insertAdjacentHTML('beforeend', createMatchHTML(matchId, team1, team2, dbMatch, seeds));
        });
        
        for (let r = 2; r <= numRounds; r++) {
            const numMatchesInRound = numMatchesInFirstRound / Math.pow(2, r - 1);
            for (let m = 1; m <= numMatchesInRound; m++) {
                const matchId = `${side}-R${r}-M${m}`;
                const dbMatch = allMatches[matchId] || {};
                const prevMatch1Id = `${side}-R${r - 1}-M${(m * 2) - 1}`;
                const prevMatch2Id = `${side}-R${r - 1}-M${m * 2}`;
                const prevWinner1 = allMatches[prevMatch1Id]?.winner || null;
                const prevWinner2 = allMatches[prevMatch2Id]?.winner || null;
                const team1 = dbMatch.team1 || prevWinner1;
                const team2 = dbMatch.team2 || prevWinner2;
                roundElements[r - 1].insertAdjacentHTML('beforeend', createMatchHTML(matchId, team1, team2, dbMatch, seeds));
            }
        }
    }
// ▲▲▲ 置き換えここまで ▲▲▲

 // ▼▼▼ 既存の「createMatchHTML」関数 (12489行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * 1試合分のHTMLを生成する
 * (★選手の「調子」アイコン表示を追加した最終版)
 */
function createMatchHTML(matchId, team1, team2, dbMatch, seeds = []) {
    // --- (内部ヘルパー関数 createSpecialButtons は変更なし) ---
    const createSpecialButtons = (teamName) => {
        if (!teamName || (tournamentState.documentary && tournamentState.documentary.target)) return '';
        let buttonHTML = '';
        if (UNDERDOG_TEAMS.includes(teamName)) {
            buttonHTML += `<button class="underdog-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の逆境に密着取材する">📹</button>`;
        }
        if (POWERHOUSE_TEAMS.includes(teamName)) {
            buttonHTML += `<button class="powerhouse-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の王者の苦悩に密着取材する">👑</button>`;
        }
        if (POWERHOUSE_REVIVAL_TEAMS.includes(teamName)) {
            buttonHTML += `<button class="powerhouse-revival-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の古豪復活に密着取材する">🏰</button>`;
        }
        if (ONE_MAN_TEAMS.includes(teamName)) {
            buttonHTML += `<button class="one-man-team-doc-btn text-lg ml-2" data-team-name="${teamName}" title="絶対的エースとその仲間たちに密着取材する">🌟</button>`;
        }
        return buttonHTML;
    };
    
    const t1Empty = !team1;
    const t2Empty = !team2;

    let specialMatchClass = '';
    if (dbMatch.rivalryType) {
        specialMatchClass = 'rivalry-match';
    } 
    else if (!t1Empty && !t2Empty) {
        const feud = tournamentState.feuds?.find(f => f.teams.includes(team1) && f.teams.includes(team2));
        if (feud) {
            specialMatchClass = 'feud-match';
        } else {
            const rivalry = tournamentState.rivalries?.find(r => r.teams.includes(team1) && r.teams.includes(team2));
            if (rivalry) {
                specialMatchClass = 'rivalry-match';
            }
        }
    }
    const rank1 = calculateRank(team1, tournamentState);
    const rank2 = calculateRank(team2, tournamentState);
    const rankColor = (rank) => {
        switch (rank) {
            case 'A': return 'rank-A'; case 'B': return 'rank-B'; case 'C': return 'rank-C';
            case 'D': return 'rank-D'; case 'E': return 'rank-E'; default: return '';
        }
    };

    const seedInfo1 = seeds.find(s => s.team === team1);
    const seedInfo2 = seeds.find(s => s.team === team2);
    const isSeed1 = !!seedInfo1;
    const isSeed2 = !!seedInfo2;

    const showInputs = !t1Empty && !t2Empty;

    let atmosphereInputs = '';
    if (showInputs) {
        atmosphereInputs = `
        <div class="team-atmosphere-container mt-1">
            <input type-="text" class="team-atmosphere-input w-full text-xs p-1 border rounded-t" data-match-id="${matchId}" data-team-key="team1" placeholder="[${team1}] 試合前の雰囲気/公約 (任意)" value="${dbMatch.atmosphere_team1 || ''}">
            <input type-="text" class="team-atmosphere-input w-full text-xs p-1 border rounded-b border-t-0" data-match-id="${matchId}" data-team-key="team2" placeholder="[${team2}] 試合前の雰囲気/公約 (任意)" value="${dbMatch.atmosphere_team2 || ''}">
        </div>
        `;
    }

    let scheduleInfo = '';
    if (dbMatch.schedule) { 
        const gameNumIcon = ['①', '②', '③', '④'][dbMatch.schedule.game - 1] || `(${dbMatch.schedule.game})`;
        scheduleInfo = `
        <div class="match-schedule" title="${dbMatch.schedule.stadiumFull}球場 ${dbMatch.schedule.date} 第${dbMatch.schedule.game}試合">
            ${dbMatch.schedule.date}・${dbMatch.schedule.stadium}${gameNumIcon}
        </div>
        `;
    }

    // ★★★ ここからが修正箇所 ★★★
    // 選手の調子アイコンを取得するヘルパー
    const getConditionIconForTeam = (teamName) => {
        // (注: この関数は「試合前」に描画されます。アイコンは「前の試合」の結果です)
        if (!teamName) return ""; 
        
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord || !teamRecord.playerStats) return "";

        let icons = [];

        // 1. 打者の調子
        if (teamRecord.playerStats.batting) {
            for (const playerName in teamRecord.playerStats.batting) {
                const flag = teamRecord.playerStats.batting[playerName].narrative_flag;
                const icon = getPlayerConditionIcon(flag);
                if (icon) icons.push(icon);
            }
        }
        // 2. 投手の調子
        if (teamRecord.playerStats.pitching) {
            for (const playerName in teamRecord.playerStats.pitching) {
                const flag = teamRecord.playerStats.pitching[playerName].narrative_flag;
                const icon = getPlayerConditionIcon(flag);
                if (icon) icons.push(icon);
            }
        }
        
        // 重複を除去して返す (例: 姫川が打者/投手両方で🔥でも1つだけ表示)
        return [...new Set(icons)].join('');
    };

    const team1ConditionIcons = getConditionIconForTeam(team1);
    const team2ConditionIcons = getConditionIconForTeam(team2);
    // ★★★ 修正ここまで ★★★

    // ▼▼▼ チームスロットのHTMLを差し替え ▼▼▼
    const content = `
        <div class="team-slot ${t1Empty ? 'empty' : ''} ${dbMatch.winner === team1 && !t1Empty ? 'winner' : ''} ${dbMatch.winner && dbMatch.winner !== team1 && dbMatch.winner !== null ? 'loser' : ''}" data-team-name="${team1 || ''}">
            <span class="team-name clickable-team-name ${isSeed1 ? 'seed' : ''}" title="${team1 || ''}" data-team-name="${team1 || ''}">
                ${team1 ? `<span class="rank ${rankColor(rank1)}">[${rank1}]</span>` : ''}
                ${isSeed1 ? `[${seedInfo1.rank}] ` : ''}${team1 || '---'}
                ${team1ConditionIcons}
            </span>
            ${createSpecialButtons(team1)} 
            ${!t1Empty ? `<button class="show-team-stats-btn text-lg p-1 text-blue-600 hover:bg-blue-100 rounded" data-team-name="${team1}" title="${team1} の通算成績を見る">📊</button>` : ''}
            
            <input type="text" class="score-input ${showInputs ? '' : 'hidden'}" value="${dbMatch.score1 ?? ''}" data-team-pos="1">
            <button class="win-btn ${showInputs ? '' : 'hidden'}">▶</button>
            ${!showInputs ? `<span class="score-input font-bold">${dbMatch.score1 ?? ''}</span>` : ''}
        </div>
        
        <div class="team-slot ${t2Empty ? 'empty' : ''} ${dbMatch.winner === team2 && !t2Empty ? 'winner' : ''} ${dbMatch.winner && dbMatch.winner !== team2 && dbMatch.winner !== null ? 'loser' : ''}" data-team-name="${team2 || ''}">
            <span class="team-name clickable-team-name ${isSeed2 ? 'seed' : ''}" title="${team2 || ''}" data-team-name="${team2 || ''}">
                ${team2 ? `<span class="rank ${rankColor(rank2)}">[${rank2}]</span>` : ''}
                ${isSeed2 ? `[${seedInfo2.rank}] ` : ''}${team2 || '---'}
                ${team2ConditionIcons}
            </span>
            ${createSpecialButtons(team2)}
            ${!t2Empty ? `<button class="show-team-stats-btn text-lg p-1 text-blue-600 hover:bg-blue-100 rounded" data-team-name="${team2}" title="${team2} の通算成績を見る">📊</button>` : ''}
            
            <input type="text" class="score-input ${showInputs ? '' : 'hidden'}" value="${dbMatch.score2 ?? ''}" data-team-pos="2">
            <button class="win-btn ${showInputs ? '' : 'hidden'}">▶</button>
            ${!showInputs ? `<span class="score-input font-bold">${dbMatch.score2 ?? ''}</span>` : ''}
        </div>
        ${scheduleInfo} 
        ${atmosphereInputs}
        <div class="match-summary-container ${showInputs ? '' : 'hidden'}">
            <textarea class="match-summary-input w-full text-xs p-1 mt-1 border rounded" data-match-id="${matchId}" placeholder="試合の決め手（任意）">${dbMatch.summary || ''}</textarea>
        </div>
    `;

    // ▲▲▲ 差し替えここまで ▲▲▲

    let calledGameInfo = '';
    if (dbMatch.calledGame) {
        calledGameInfo = `<div class="text-center text-xs text-red-600 font-bold mt-1">(${dbMatch.calledInning}回コールド)</div>`;
    }

    let footer = '';
    if (dbMatch.winner && dbMatch.boxScoreHtml) {
        footer = `<div class="matchup-footer">
                    <button class="boxscore-btn text-sm bg-blue-600 text-white font-bold px-4 py-1 rounded hover:bg-blue-700" data-match-id="${matchId}">
                        一球速報
                    </button>
                    <button class="details-btn text-xs bg-gray-500 text-white px-2 py-1 rounded hover:bg-gray-600" data-match-id="${matchId}" title="詳細入力（修正）">
                        詳細
                    </button>
                  </div>`;
    }
     else if (!t1Empty && !t2Empty && !dbMatch.winner) {
        footer = `<div class="matchup-footer">
                    <button class="details-btn" data-match-id="${matchId}">詳細入力</button>
                    <button class="scorecard-open-btn text-sm bg-green-600 text-white font-bold px-3 py-1 rounded hover:bg-green-700" data-match-id="${matchId}">
                        🎮 簡易入力
                    </button>
                    <button class="quick-sim-btn text-lg" data-match-id="${matchId}" title="このスコアでおまかせ入力">🎲</button>
                    <button class="pre-game-cheer-btn text-xs bg-green-500 text-white px-2 py-1 rounded hover:bg-green-600" data-match-id="${matchId}">応援</button>
                  </div>`;
    }
        
    return `<div class="matchup ${specialMatchClass}" data-match-id="${matchId}">
                ${content}
                ${calledGameInfo} 
                ${footer}
            </div>`;
}
// ▲▲▲ 置き換えここまで ▲▲▲

    
/**
 * UIの各種コンテンツエリア（ニュース）を描画する（全機能対応・最終版）
 */
function renderNews(news) {
    if (!news || news.length === 0) {
        newsContainer.innerHTML = `<p class="text-gray-500 text-center">まだニュースはありません。</p>`;
        return;
    }
    newsContainer.innerHTML = '';
    
    news.slice().reverse().forEach((article, reversedIndex) => {
        const articleEl = document.createElement('div');
        const originalIndex = news.length - 1 - reversedIndex;

        if (article.isScandalRumor) {
            articleEl.className = 'bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg shadow';
            articleEl.innerHTML = `
                <h3 class="font-bold">${article.title}</h3>
                <p class="text-sm mt-2">${article.body}</p>
                <div class="mt-4 border-t pt-3 text-center">
                    <p class="text-sm font-bold mb-2">あなたはこの疑惑をどうしますか？</p>
                    <button class="report-scandal-btn bg-red-600 text-white px-4 py-1 rounded text-sm hover:bg-red-700">大会運営に報告する</button>
                    <button class="ignore-scandal-btn bg-gray-500 text-white px-4 py-1 rounded text-sm hover:bg-gray-600 ml-2">見て見ぬふりをする</button>
                </div>
            `;
        } else if (article.error) {
            articleEl.className = 'article-error';
            const regenerateButtonHTML = article.context ? `<button class="regenerate-btn" data-index="${originalIndex}">再生成</button>` : '';
            articleEl.innerHTML = `<span>${article.title}</span>${regenerateButtonHTML}`;
        } else {
            articleEl.className = 'bg-white p-4 rounded-lg shadow';
            let buttonsHTML = '';

            if (article.isAnalysisArticle) {
                buttonsHTML = `<button class="text-sm bg-cyan-500 text-white font-bold px-4 py-2 rounded hover:bg-cyan-600 view-analysis-btn">勢力図をアニメーションで見る</button>`;
            } else {
                const regenerateButtonHTML = article.context ? `<button class="text-sm bg-yellow-100 text-yellow-800 px-3 py-1 rounded hover:bg-yellow-200 ml-2 regenerate-btn" data-index="${originalIndex}">再生成</button>` : '';
                const newspaperButtonHTML = article.isNewspaper ? `<button class="text-sm bg-red-100 text-red-700 px-3 py-1 rounded hover:bg-red-200 ml-2 newspaper-view-btn" data-index="${originalIndex}">新聞を読む</button>` : '';
                buttonsHTML = `
                    <button class="text-sm bg-gray-200 px-3 py-1 rounded hover:bg-gray-300 news-article-btn" data-index="${originalIndex}">本文</button>
                    ${newspaperButtonHTML}
                    ${regenerateButtonHTML}
                `;
            }

            articleEl.innerHTML = `
                <div class="flex justify-between items-center">
                    <div>
                        <h3 class="font-bold text-lg text-blue-600">${article.title}</h3>
                        <p class="text-xs text-gray-400 mt-1">${new Date(article.timestamp).toLocaleDateString('ja-JP')}</p>
                    </div>
                    <div class="flex items-center space-x-2">
                        ${buttonsHTML}
                    </div>
                </div>
            `;
        }
        newsContainer.appendChild(articleEl);
    });
}
    



/**
 * 掲示板のコメント（スレッド形式と個別コメント形式の両方に対応）を描画する
 */
function renderBbsComments(items) { // 引数名を items に変更
    if (!items || items.length === 0) {
        bbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">まだ反応はありません。</p>`;
        return;
    }
    bbsCommentsContainer.innerHTML = ''; // コンテナをクリア

    // 新しいアイテムが上に来るように逆順で処理
    items.slice().reverse().forEach((item, reversedIndex) => {
        const originalIndex = items.length - 1 - reversedIndex;

        // A. エラーオブジェクトの場合
        if (item.error && item.title) {
            const errorEl = document.createElement('div');
            errorEl.className = 'article-error mb-4'; // マージン追加, ニュース記事のエラースタイルを流用
            // ★★★ 再生成ボタンのdata属性を修正 ★★★
            const regenerateButtonHTML = item.context ? `<button class="retry-bbs-btn bg-red-600 text-white px-3 py-1 rounded text-sm hover:bg-red-700" data-index="${originalIndex}" data-type="${item.context.isBracketThread ? 'bracket-thread' : 'match-comments'}">再生成</button>` : '';
            errorEl.innerHTML = `<span>${item.title}</span>${regenerateButtonHTML}`;
            bbsCommentsContainer.appendChild(errorEl);
        }
        // B. スレッドオブジェクトの場合 (組み合わせ決定スレなど title と comments を持つ)
        else if (item.comments && Array.isArray(item.comments) && item.title) {
            const threadWrapper = document.createElement('div');
            threadWrapper.className = 'mb-6 p-4 border rounded-lg bg-white shadow';

            const titleEl = document.createElement('h3');
            titleEl.className = 'text-lg font-bold text-gray-800 mb-3 border-b pb-2';
            titleEl.textContent = `【${item.matchId === 'bracket' ? '組み合わせ決定' : '試合結果'}】${item.title}`;
            threadWrapper.appendChild(titleEl);

            const commentsContainer = document.createElement('div');
            commentsContainer.className = 'space-y-3';

            // スレッド内のコメントを描画
            item.comments.forEach(comment => {
                renderCommentThread(comment, commentsContainer, 'general');
            });

            threadWrapper.appendChild(commentsContainer);
            bbsCommentsContainer.appendChild(threadWrapper);
        }
        // C. 個別のコメントオブジェクトの場合 (試合後の反応など personality と text を持つ)
        else if (item.personality && item.text) {
            // 個別コメントはスレッド枠なしで直接描画
            renderCommentThread(item, bbsCommentsContainer, 'general');
            // 個別コメント間に区切り線などを入れても良いかも
            const hr = document.createElement('hr');
            hr.className = 'my-3 border-gray-200';
            bbsCommentsContainer.appendChild(hr);
        }
        // D. その他の予期せぬデータ
        else {
             console.warn("Unknown item type in bbsComments:", item);
             const unknownEl = document.createElement('div');
             unknownEl.className = 'text-red-500 text-sm my-2';
             unknownEl.textContent = '[不明な掲示板データ]';
             bbsCommentsContainer.appendChild(unknownEl);
        }
    });

     // 最後の区切り線を削除 (個別コメントが最後だった場合)
     const lastElement = bbsCommentsContainer.lastElementChild;
     if (lastElement && lastElement.tagName === 'HR') {
         bbsCommentsContainer.removeChild(lastElement);
     }
}

// renderCommentThread 関数は個別のコメントを描画するため、基本変更不要
// function renderCommentThread(comment, container, bbsType) { ... }

    function renderDaiyaBbsComments(comments) {
        if (!comments || comments.length === 0) {
            daiyaBbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">まだ反応はありません。</p>`;
            return;
        }
        daiyaBbsCommentsContainer.innerHTML = '';
        comments.slice().reverse().forEach(comment => {
            renderCommentThread(comment, daiyaBbsCommentsContainer, 'daiya');
        });
    }

    function renderNamcoNews(news) {
        if (!news) {
            namcoNewsSection.classList.add('hidden');
            return;
        }
        namcoNewsSection.classList.remove('hidden');
        namcoNewsContent.innerHTML = '';
        const newsItem = document.createElement('div');
        newsItem.className = 'namco-news-item p-2 hover:bg-orange-50 rounded';
        newsItem.innerHTML = `<p class="font-semibold text-gray-700">${news.title}<span class="namco-news-tag">野球部</span></p>`;
        newsItem.addEventListener('click', () => {
            document.getElementById('modal-title').textContent = news.title;
            document.getElementById('modal-body').textContent = news.body;
            document.getElementById('modal-meta').innerHTML = `<p>${new Date(news.timestamp).toLocaleDateString('ja-JP')}</p><p class="font-bold text-gray-500">野球部</p>`;
            newsModal.classList.remove('hidden');
            newsModal.classList.add('flex');
        });
        namcoNewsContent.appendChild(newsItem);
    }

    function renderCommentThread(comment, container, bbsType) {
        const threadContainer = document.createElement('div');
        if (container.id === `replies-to-${comment.id}` || (container.id.includes('bbs-comments') && container.children.length > 0)) {
            threadContainer.className = 'ml-4 border-l-2 pl-4 mt-2';
        } else {
            threadContainer.className = 'mt-2';
        }

        const personalityClass = comment.personality === 'あなた' ? 'text-blue-600 font-bold' : 'text-gray-600';
        const commentEl = document.createElement('div');
        commentEl.className = 'bbs-comment';
        commentEl.innerHTML = `
            <div class="flex justify-between items-center">
                <p class="font-semibold ${personalityClass} text-sm">${comment.personality || '名無しさん'}</p>
                <button class="reply-btn text-xs text-blue-500 hover:underline" data-comment-id="${comment.id}" data-bbs-type="${bbsType}">返信する</button>
            </div>
            <p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>
            <p class="text-xs text-gray-400 text-right">${new Date(comment.timestamp).toLocaleString('ja-JP')}</p>
            <div id="reply-form-container-${comment.id}" class="hidden mt-2">
                <form class="reply-form" data-comment-id="${comment.id}" data-bbs-type="${bbsType}">
                    <textarea class="w-full p-2 border rounded text-sm" placeholder="返信を入力..." required></textarea>
                    <button type="submit" class="mt-1 bg-blue-500 text-white px-3 py-1 text-xs rounded hover:bg-blue-600">送信</button>
                </form>
            </div>
        `;
        threadContainer.appendChild(commentEl);

        const repliesContainer = document.createElement('div');
        repliesContainer.id = `replies-to-${comment.id}`;
        threadContainer.appendChild(repliesContainer);

        container.appendChild(threadContainer);

        if (comment.replies && comment.replies.length > 0) {
            comment.replies.slice().reverse().forEach(reply => {
                renderCommentThread(reply, repliesContainer, bbsType);
            });
        }
    }

   // ▼▼▼ 既存の「renderRegionMap」関数 (8459行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * Renders the regional survival status with a new card-based, scrollable layout.
 * (★ 全大会128チーム制統一に対応。autumnData/springData への参照を削除)
 */
function renderRegionMap(data) {
    const regionMapSection = document.getElementById('region-map-section');
    const finalMatch = data.matches['F-R1-M1'];
    if ((!data.matches || Object.keys(data.matches).length === 0) && !finalMatch) {
        regionMapSection.classList.add('hidden');
        return;
    }
    regionMapSection.classList.remove('hidden');

    const container = document.getElementById('region-map-container');
    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    INITIAL_TEAM_POOL.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region && teamsByRegion[region]) {
            teamsByRegion[region].push(teamName);
        }
    });

    const eliminatedTeams = new Set();
    
    // ★★★ 修正箇所 ★★★
    // 参照する試合を tournamentState.matches のみに統一
    const allMatches = data.matches; 
    // ★★★ 修正ここまで ★★★

    Object.values(allMatches).filter(match => match.winner).forEach(match => {
        const loser = match.team1 === match.winner ? match.team2 : match.team1;
        if (loser && loser !== '(BYE)') eliminatedTeams.add(loser); // BYEは除外
    });

    if (finalMatch?.winner) {
        const tournamentWinner = finalMatch.winner;
        eliminatedTeams.forEach(team => {
            if (team === tournamentWinner) eliminatedTeams.delete(team);
        });
    }
    
    let html = '<div class="region-map-scroll-container">';
    for (const region in teamsByRegion) {
        const teams = teamsByRegion[region];
        if (teams.length === 0) continue;
        
        const survivingCount = teams.filter(team => !eliminatedTeams.has(team)).length;

        html += `
        <div class="region-column">
            <div class="region-header">
                <h3 class="region-title">${region}地区</h3>
                <p class="region-stats">${survivingCount} / ${teams.length} チーム生存</p>
            </div>
            <ul class="region-team-list">
                ${teams.sort((a, b) => {
                    const aElim = eliminatedTeams.has(a);
                    const bElim = eliminatedTeams.has(b);
                    if (aElim === bElim) return a.localeCompare(b, 'ja');
                    return aElim ? 1 : -1;
                }).map(team => `
                    <li class="region-team ${eliminatedTeams.has(team) ? 'team-eliminated' : 'team-surviving'}">
                        ${team}
                    </li>
                `).join('')}
            </ul>
        </div>
        `;
    }
    html += '</div>';
    container.innerHTML = html;
}
// ▲▲▲ 置き換えここまで ▲▲▲
    
    /**
     * スキップボタンの表示・非表示を制御する
     * (★変数宣言を削除し、グローバル変数を参照するよう修正)
     */
    function checkTournamentProgress() {
        // ★★★ 修正箇所 (const をすべて削除) ★★★
        skipR1Btn = document.getElementById('skip-r1-btn');
        skipR2Btn = document.getElementById('skip-r2-btn');
        skipR3Btn = document.getElementById('skip-r3-btn');
        skipR4Btn = document.getElementById('skip-r4-btn');
        skipR5Btn = document.getElementById('skip-r5-btn');
        skipR6Btn = document.getElementById('skip-r6-btn'); 
        skipFinalBtn = document.getElementById('skip-final-btn');
        generateSummaryBtn = document.getElementById('generate-summary-btn');
        // ★★★ 修正ここまで ★★★
        
        const allSkipButtons = [skipR1Btn, skipR2Btn, skipR3Btn, skipR4Btn, skipR5Btn, skipR6Btn, skipFinalBtn, generateSummaryBtn];

        if (!tournamentState.matches || Object.keys(tournamentState.matches).length === 0) {
            allSkipButtons.forEach(btn => btn?.classList.add('hidden'));
            return;
        }

        const matchIds = Object.keys(tournamentState.matches);
        const numTeams = tournamentState.teams.length; // 128
        const finalRound = Math.log2(numTeams); // 7

        const getRoundStatus = (roundNumber) => {
            const played = matchIds.filter(id => id.includes(`-R${roundNumber}-M`) && tournamentState.matches[id]?.winner).length;
            const total = numTeams / Math.pow(2, roundNumber); // R1=64, R2=32...
            return { total, played };
        };
        
        const r1_status = getRoundStatus(1);
        const r2_status = getRoundStatus(2);
        const r3_status = getRoundStatus(3);
        const r4_status = getRoundStatus(4);
        const r5_status = getRoundStatus(5);
        const r6_status = getRoundStatus(6);
        const finalMatch = tournamentState.matches['F-R1-M1'];

        skipR1Btn.classList.toggle('hidden', r1_status.played === r1_status.total);
        skipR2Btn.classList.toggle('hidden', !(r1_status.played === r1_status.total && r2_status.played !== r2_status.total));
        skipR3Btn.classList.toggle('hidden', !(r2_status.played === r2_status.total && r3_status.played !== r3_status.total));
        skipR4Btn.classList.toggle('hidden', !(r3_status.played === r3_status.total && r4_status.played !== r4_status.total));
        skipR5Btn.classList.toggle('hidden', !(r4_status.played === r4_status.total && r5_status.played !== r5_status.total));
        skipR6Btn.classList.toggle('hidden', !(r5_status.played === r5_status.total && r6_status.played !== r6_status.total));
        skipFinalBtn.classList.toggle('hidden', !(r6_status.played === r6_status.total && (!finalMatch || !finalMatch.winner)));
        
        const summaryGenerated = tournamentState.news.some(n => n.summaryType === 'best8');
        generateSummaryBtn.classList.toggle('hidden', !(r4_status.played === r4_status.total && r5_status.played === 0 && !summaryGenerated));
    }
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 決勝戦を自動でスキップする
 */
async function skipFinal() {
    const finalMatch = tournamentState.matches['F-R1-M1'];
    if (!finalMatch || !finalMatch.team1 || !finalMatch.team2 || finalMatch.winner) return;

    const btn = document.getElementById('skip-final-btn');
    if(btn) btn.disabled = true;
    
    const { team1, team2 } = finalMatch;
    const rank1 = calculateRank(team1, tournamentState);
    const rank2 = calculateRank(team2, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    
    let winnerName, loserName;
    // ランク差が2以上ある場合、95%の確率でランク上位が勝利
    const upsetChance = Math.abs(rankValues[rank1] - rankValues[rank2]) >= 2 ? 0.05 : 0.45;

    if (Math.random() < upsetChance) { // 番狂わせ
        winnerName = rankValues[rank1] < rankValues[rank2] ? team1 : team2;
    } else { // 順当
        winnerName = rankValues[rank1] >= rankValues[rank2] ? team1 : team2;
    }
    loserName = winnerName === team1 ? team2 : team1;

    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const [winnerScore, loserScore] = generateAutoScore(winnerRank, loserRank);

    finalMatch.score1 = (finalMatch.team1 === winnerName) ? winnerScore : loserScore;
    finalMatch.score2 = (finalMatch.team2 === winnerName) ? winnerScore : loserScore;

    await processMatchWin('F-R1-M1', winnerName);

    if(btn) btn.classList.add('hidden');
}

    function checkBest8Decided(){} // checkTournamentProgressに統合
// --- 試合詳細モーダル関連の関数（高機能版） ---

   /**
     * 【修正版】新しい試合詳細モーダルを開き、各種テーブルを生成する
     */
    /**
     * イニングスコアのテーブルHTMLを生成する
     */
    /**
 * イニングスコアのテーブルHTMLを生成する（★列幅クラスを適用した最終版）
 */
/**
/**
 * イニングスコアのテーブルHTMLを生成する（0点表示バグ修正版）
 * @param {string} team1Name - チーム1の名前
 * @param {string} team2Name - チーム2の名前
 * @param {object} details - 試合の詳細データ
 * @returns {string} - 生成されたHTML
 */
function createInningScoreTable(team1Name, team2Name, details) {
    const inningData = details.inningScore || { team1: [], team2: [] };
    const numInnings = (inningData.team1 && inningData.team1.length > 0) ? inningData.team1.length : 9;
    
    let header = '';
    for (let i = 1; i <= numInnings; i++) {
        header += `<th class="col-inning-score">${i}</th>`;
    }

    const createRow = (teamKey, teamName) => {
        let cells = '';
        for (let i = 0; i < numInnings; i++) {
            // ▼▼▼【重要修正】ここがバグの原因でした▼▼▼
            // 保存された値が0の場合でも、''（空文字）ではなく0と表示されるように修正
            const scoreValue = inningData[teamKey]?.[i] ?? ''; // nullかundefinedの場合のみ''にする
            cells += `<td class="col-inning-score"><input type="number" value="${scoreValue}"></td>`;
            // ▲▲▲
        }
        return `<tr>
                    <th class="col-team text-left font-semibold pl-2">${teamName}</th>
                    ${cells}
                    <td class="total-score col-total"></td>
                </tr>`;
    };

    return `
        <div class="mb-6 overflow-x-auto">
            <h4 class="font-bold mb-2">イニングスコア</h4>
            <table class="details-table" id="inning-score-table">
                <thead>
                    <tr>
                        <th class="col-team">チーム</th>${header}<th class="col-total">計</th><th class="col-add-inning"><button id="add-inning-score-btn" class="text-xs font-bold">+</button></th>
                    </tr>
                </thead>
                <tbody>${createRow('team1', team1Name)}${createRow('team2', team2Name)}</tbody>
            </table>
        </div>`;
}


// ▼▼▼ 既存の「openDetailsModal」関数 (10563行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する
 * (★283学園のロスター<datalist>自動生成機能を追加した最終版)
 */
function openDetailsModal(matchId) {
    currentMatchIdForDetails = matchId;
    const match = findMatchById(matchId);
    if (!match) {
        console.error(`[openDetailsModal] エラー: ID ${matchId} の試合が見つかりません。`);
        return;
    }

    console.log("--- [モーダル表示 開始] ---", { matchId: matchId, 既存データ: match.details });

    let details = JSON.parse(JSON.stringify(match.details || {}));

// ▼▼▼ このブロックをまるごと置き換え ▼▼▼
    // --- 【新機能】前回のロスター情報を引き継ぐ ---
    // (まだこの試合の詳細入力(details.batting)が空の場合のみ実行)
    if ((!details.batting || !details.batting.team1 || details.batting.team1.length === 0)) {
        console.log("[ロスター引継] この試合の詳細は空です。前回のロスターを探します...");
        for (const teamKey of ['team1', 'team2']) {
            const teamName = match[teamKey];
            const teamRecord = tournamentState.teamRecords[teamName];
            
            // (A) 前回のロスター情報(roster)があるか？
            if (teamRecord && teamRecord.roster && teamRecord.roster.length > 0) {
                console.log(`[ロスター引継] ${teamName} の前回のロスター (${teamRecord.roster.length}人) を読み込みます。`);
                
                // (B) details.batting に、打席結果(results)を空にしてコピーする
                details.batting = details.batting || { team1: [], team2: [] };
                
                // ★★★ ここが修正点 ★★★
                // 交代選手(orderに'sub'が含まれる)を除外し、スタメン9名だけを抽出する
                details.batting[teamKey] = teamRecord.roster
                    .filter(playerData => playerData.order && !playerData.order.toString().includes('sub'))
                    .map(playerData => ({
                        ...playerData, // order, name, number, pos, throwBat を引き継ぐ
                        sub_type: null, // 2回戦では「スタメン」なので sub_type はリセット
                        results: []     // 打席結果は空にする
                    }));
                // ★★★ 修正ここまで ★★★

            }
            // (B) 念のため、古いスタメン情報(previousStarters)もチェック (古いセーブデータ用)
            else if (teamRecord && teamRecord.previousStarters && teamRecord.previousStarters.length > 0) {
                 console.log(`[ロスター引継] ${teamName} の前回のスタメン (${teamRecord.previousStarters.length}人) を読み込みます。`);
                 
                 details.batting = details.batting || { team1: [], team2: [] };
                 details.batting[teamKey] = teamRecord.previousStarters.map(playerData => ({
                    ...playerData, // order, name, pos を引き継ぐ
                    results: [] // 打席結果は空にする
                }));
            }
        }
    }
    // ▲▲▲ 置き換えここまで ▲▲▲    
    const numInnings = Math.max(9, ...Object.values(tournamentState.matches)
        .filter(m => m.details?.inningScore?.team1)
        .map(m => m.details.inningScore.team1.length));

    console.log(`[モーダル表示] 現在の最大イニング数を ${numInnings} と判断しました。`);

    // データ構造の初期化
    details.inningScore = details.inningScore || { team1: [], team2: [] };
    details.batting = details.batting || { team1: [], team2: [] };
    details.pitching = details.pitching || { team1: [], team2: [] };
    details.fielding = details.fielding || { team1: [], team2: [] }; // ★追加
    details.inningEvents = details.inningEvents || { team1: [], team2: [] };
    details.positionChanges = details.positionChanges || [];
    
// ▼▼▼ このブロックをまるごと置き換え ▼▼▼
    // --- 守備交代の「履歴（変遷）」を文字列として生成し、battingデータに付与 ---
    const allChanges = details.positionChanges || [];
    // 交代をイニング順（と表/裏）にソート
    const sortedChanges = allChanges.sort((a, b) => {
        const inningA = parseInt(a.inning) || 0;
        const inningB = parseInt(b.inning) || 0;
        if (inningA !== inningB) return inningA - inningB;
        return (a.topBottom === '裏' ? 1 : 0) - (b.topBottom === '裏' ? 1 : 0);
    });

    for (const teamKey of ['team1', 'team2']) {
        const teamBattingData = details.batting[teamKey];
        if (teamBattingData) {
            teamBattingData.forEach(player => {
                if (!player.name) {
                    player.posHistoryDisplay = ''; // 履歴なし
                    player.currentPos = ''; // 現在のポジション
                    return;
                }
                
                // 1. 履歴配列を初期化
                let history = [];
                
                // 2. ★★★ 修正点 ★★★
                // 「スタメン」か「交代出場」かに関わらず、
                // `details.batting` に記録されている `player.pos` を「最初のポジション」として履歴に追加する
                if (player.pos) {
                    let initialTiming = "スタメン";
                    if (player.order.includes('sub')) {
                        // 交代選手の場合、交代タイプからタイミングを推測
                        if (player.sub_type === 'PH') initialTiming = "代打出場";
                        else if (player.sub_type === 'PR') initialTiming = "代走出場";
                        else initialTiming = "途中出場"; // DEF, PITCHER
                    }
                    history.push({ pos: player.pos, timing: initialTiming });
                }

                // 3. この選手の交代履歴（positionChanges）を抽出して追加
                sortedChanges.forEach(change => {
                    if (change.teamKey === teamKey && change.playerName === player.name) {
                        
                        // タイミング文字列を生成
                        let timingStr = `${change.inning || '?'}回${change.topBottom || ''}`;
                        if (change.timing === 'mid') {
                            timingStr += ` ${change.outs || '0'}死`;
                        } else {
                            timingStr += ` 0死`; // イニング開始時
                        }
                        
                        history.push({ pos: change.newPos, timing: timingStr });
                    }
                });
                
                // 4. 重複を削除 (例: [投, 投, 一] -> [投, 一])
                const uniqueHistory = history.filter((entry, index) => {
                    return entry.pos && (index === 0 || entry.pos !== history[index - 1].pos);
                });
                
                // 5. 最終的な表示文字列と、現在のポジションを保存
                if (uniqueHistory.length > 1) {
                    // ★ 変遷文字列に (タイミング) を追加
                    player.posHistoryDisplay = uniqueHistory.map((entry, index) => {
                        if (index === 0) return entry.pos; // 最初のポジション (スタメン/途中出場)
                        return `→ (${entry.timing}) ${entry.pos}`; // 例: → (7回表 2死) 一
                    }).join(' ');
                    
                    player.currentPos = uniqueHistory[uniqueHistory.length - 1].pos; // 最後のポジション
                } else if (uniqueHistory.length === 1) {
                    player.posHistoryDisplay = uniqueHistory[0].pos; // 例: "投"
                    player.currentPos = uniqueHistory[0].pos;
                } else {
                    player.posHistoryDisplay = ''; // 守備記録なし
                    player.currentPos = player.pos || ''; // 履歴がなくても元のposがあればそれを使う
                }
            });
        }
    }
    // ▲▲▲ 置き換えここまで ▲▲▲
    // 配列の長さを現在のイニング数に合わせる
    for(const teamKey of ['team1', 'team2']) {
        if (!details.inningEvents[teamKey]) details.inningEvents[teamKey] = [];
        while (details.inningScore[teamKey].length < numInnings) details.inningScore[teamKey].push('');
        while (details.inningEvents[teamKey].length < numInnings) details.inningEvents[teamKey].push('');
        if (details.batting[teamKey]) {
            details.batting[teamKey].forEach(player => {
                if (!player.results) player.results = [];
                while (player.results.length < numInnings) player.results.push('');
            });
        }
    }
    console.log("[モーダル表示] 表示用に準備したデータ:", JSON.parse(JSON.stringify(details)));


    // もし試合データが空で、かつチームの選手名簿(roster)が存在すれば、それを読み込む
    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (details.batting[teamKey].length === 0 && teamRecord && teamRecord.roster) {
            details.batting[teamKey] = teamRecord.roster.map(p => ({ ...p, results: Array(numInnings).fill('') }));
        }
    }
    
// ★ 選手リストをここで取得 ★
    const playersTeam1 = details.batting.team1.filter(p => p.name).map(p => ({name: p.name}));
    const playersTeam2 = details.batting.team2.filter(p => p.name).map(p => ({name: p.name}));

    const detailsBody = document.getElementById('details-modal-body');
    detailsBody.innerHTML = `
        <div class="space-y-4">
            ${createInningScoreTable(match.team1, match.team2, details)}
            <div class="text-center py-2 border-t border-b">
                <button id="swap-teams-btn" data-match-id="${matchId}" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded">先攻・後攻を入れ替え</button>
            </div>
            
            <div class="space-y-4">
                <h4 class="font-bold text-lg">${match.team1} 打撃成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPlayerBattingTable(match.team1, 'team1', details)}</div>
                <h4 class="font-bold text-lg mt-4">${match.team2} 打撃成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPlayerBattingTable(match.team2, 'team2', details)}</div>
            </div>
            
            <div class="space-y-4 mt-4">
                
                <h4 class="font-bold text-lg flex justify-between items-center">
                    <span>${match.team1} 投手成績</span>
                    <button class="calc-pitcher-stats-btn text-xs bg-purple-100 text-purple-700 px-2 py-1 rounded hover:bg-purple-200 ml-2"
                            data-pitching-team="team1" data-batting-team="team2">
                        ${match.team2}の打撃から自動計算
                    </button>
                    <button class="copy-pitchers-from-batting-btn text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded hover:bg-blue-200 ml-2" data-team-key="team1">
                        打順からコピー
                    </button>
                </h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPitchingStatsTable('team1', details)}</div>
                
                <h4 class="font-bold text-lg flex justify-between items-center mt-4">
                    <span>${match.team2} 投手成績</span>
                    <button class="calc-pitcher-stats-btn text-xs bg-purple-100 text-purple-700 px-2 py-1 rounded hover:bg-purple-200 ml-2"
                            data-pitching-team="team2" data-batting-team="team1">
                        ${match.team1}の打撃から自動計算
                    </button>
                    <button class="copy-pitchers-from-batting-btn text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded hover:bg-blue-200 ml-2" data-team-key="team2">
                        打順からコピー
                    </button>
                </h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPitchingStatsTable('team2', details)}</div>
            </div>

            <div class="space-y-4 mt-4">
                <h4 class="font-bold text-lg">${match.team1} 守備ハイライト</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">
                    ${createFieldingTable('team1', details, playersTeam1)}
                </div>
                 <h4 class="font-bold text-lg mt-4">${match.team2} 守備ハイライト</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">
                    ${createFieldingTable('team2', details, playersTeam2)}
                </div>
            </div>
            </div>
    `;

    // --- ★ 283学園用の自動入力<datalist>を生成・紐付け ---
    const roster283 = TEAM_ROSTER_MASTER["283学園"];
    if (roster283) {
        const rosterOptionsHTML = roster283.map(p => `<option value="${p.name}"></option>`).join('');

        if (match.team1 === "283学園") {
            const datalistId = "roster-datalist-team1";
            const datalist = document.createElement('datalist');
            datalist.id = datalistId;
            datalist.innerHTML = rosterOptionsHTML;
            detailsBody.appendChild(datalist); // モーダル本体にdatalistを追加
            // team1テーブルの全選手名入力欄にdatalistを紐付け
            document.querySelectorAll('#batting-table-team1 .player-name').forEach(input => input.setAttribute('list', datalistId));
        }
        if (match.team2 === "283学園") {
            const datalistId = "roster-datalist-team2";
            const datalist = document.createElement('datalist');
            datalist.id = datalistId;
            datalist.innerHTML = rosterOptionsHTML;
            detailsBody.appendChild(datalist); // モーダル本体にdatalistを追加
            // team2テーブルの全選手名入力欄にdatalistを紐付け
            document.querySelectorAll('#batting-table-team2 .player-name').forEach(input => input.setAttribute('list', datalistId));
        }
    }
    // --- ★ 自動入力<datalist>の紐付けここまで ---

    detailsModal.classList.remove('hidden');
    updateTotalScores();
}
// ▲▲▲ 置き換えここまで ▲▲▲ 

/**
 * 投手成績のテーブルHTMLを生成する
 * (★全クラス名を付与した最終修正版★)
 * @param {string} teamKey - 'team1' または 'team2'
 * @param {object} details - 試合の詳細データ
 * @returns {string} - 生成されたHTML
 */
function createPitchingStatsTable(teamKey, details) {
    const pitchingData = details.pitching[teamKey] || [];
    
    // プルダウン選択肢の定義 (変更なし)
    const throwStyleOptions = [
        { val: "over", label: "オーバー" }, { val: "three_quarter", label: "スリークォーター" },
        { val: "side", label: "サイド" }, { val: "under", label: "アンダー" }
    ];
    const pitcherTypeOptions = [
        { val: "honkaku", label: "本格派" }, { val: "sokkyu", label: "速球派" },
        { val: "giko", label: "技巧派" }, { val: "nanto", label: "軟投派" }
    ];
    const velocityOptions = [];
    for (let v = 120; v <= 165; v += 5) {
        velocityOptions.push({ val: `${v}km`, label: `${v}km帯` });
    }
    const throwBatOptions = [
        { val: "R/R", label: "右/右" }, { val: "R/L", label: "右/左" }, { val: "R/S", label: "右/両" },
        { val: "L/L", label: "左/左" }, { val: "L/R", label: "左/右" }, { val: "L/S", label: "左/両" }
    ];

    let bodyRows = pitchingData.map((player, index) => {
        const tbOptionsHtml = throwBatOptions.map(opt => `<option value="${opt.val}" ${player.throwBat === opt.val ? 'selected' : ''}>${opt.label}</option>`).join('');
        const styleOptionsHtml = throwStyleOptions.map(opt => `<option value="${opt.val}" ${player.throwStyle === opt.val ? 'selected' : ''}>${opt.label}</option>`).join('');
        const typeOptionsHtml = pitcherTypeOptions.map(opt => `<option value="${opt.val}" ${player.pitcherType === opt.val ? 'selected' : ''}>${opt.label}</option>`).join('');
        const velocityOptionsHtml = velocityOptions.map(opt => `<option value="${opt.val}" ${player.velocity === opt.val ? 'selected' : ''}>${opt.label}</option>`).join('');

        // ▼▼▼ この行全体を修正（全要素にクラスを追加） ▼▼▼
        return `
        <tr data-pitcher-index="${index}">
            <td class="col-pitcher-result">
                <select class="pitcher-result"> 
                    <option value="" ${!player.result ? 'selected' : ''}>-</option>
                    <option value="W" ${player.result === 'W' ? 'selected' : ''}>○</option>
                    <option value="L" ${player.result === 'L' ? 'selected' : ''}>●</option>
                    <option value="S" ${player.result === 'S' ? 'selected' : ''}>S</option>
                    <option value="H" ${player.result === 'H' ? 'selected' : ''}>H</option>
                </select>
            </td>
            <td class="col-pitcher-name"><input type="text" class="pitcher-name" value="${player.name || ''}"></td> 
            <td class="col-pitcher-throw-bat"><select class="pitcher-throw-bat w-full bg-transparent"><option value="">-投/打-</option>${tbOptionsHtml}</select></td>
            <td class="col-pitcher-style"><select class="pitcher-throw-style w-full bg-transparent"><option value="">-投げ方-</option>${styleOptionsHtml}</select></td>
            <td class="col-pitcher-type"><select class="pitcher-type w-full bg-transparent"><option value="">-タイプ-</option>${typeOptionsHtml}</select></td>
            <td class="col-pitcher-velocity"><select class="pitcher-velocity w-full bg-transparent"><option value="">-球速帯-</option>${velocityOptionsHtml}</select></td>
            <td class="col-stat"><input type="text" class="pitcher-innings" value="${player.innings || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-batters" value="${player.battersFaced || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-pitches" value="${player.pitches || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-hits" value="${player.hits || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-so" value="${player.strikeouts || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-walks" value="${player.walks || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-runs" value="${player.runs || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-er" value="${player.earnedRuns || ''}"></td> 
        </tr>
        `;
        // ▲▲▲ 修正ここまで ▲▲▲
    }).join('');

    // もし投手が一人もいなければ、空の行を1つ追加しておく
    if (pitchingData.length === 0) {
        const tbOptionsHtml = throwBatOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const styleOptionsHtml = throwStyleOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const typeOptionsHtml = pitcherTypeOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const velocityOptionsHtml = velocityOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        // ▼▼▼ 空行にも全クラスを追加 ▼▼▼
        bodyRows = `
            <tr data-pitcher-index="0">
                <td class="col-pitcher-result"><select class="pitcher-result"><option value="" selected>-</option><option value="W">○</option><option value="L">●</option><option value="S">S</option><option value="H">H</option></select></td>
                <td class="col-pitcher-name"><input type="text" class="pitcher-name" value=""></td>
                <td class="col-pitcher-throw-bat"><select class="pitcher-throw-bat w-full bg-transparent"><option value="">-投/打-</option>${tbOptionsHtml}</select></td>
                <td class="col-pitcher-style"><select class="pitcher-throw-style w-full bg-transparent"><option value="">-投げ方-</option>${styleOptionsHtml}</select></td>
                <td class="col-pitcher-type"><select class="pitcher-type w-full bg-transparent"><option value="">-タイプ-</option>${typeOptionsHtml}</select></td>
                <td class="col-pitcher-velocity"><select class="pitcher-velocity w-full bg-transparent"><option value="">-球速帯-</option>${velocityOptionsHtml}</select></td>
                <td class="col-stat"><input type="text" class="pitcher-innings" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-batters" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-pitches" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-hits" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-so" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-walks" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-runs" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-er" value=""></td>
            </tr>
        `;
        // ▲▲▲ 修正ここまで ▲▲▲
    }

    return `
        <div class="overflow-x-auto">
            <table class="details-table" id="pitching-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="col-pitcher-result">勝敗</th>
                        <th class="col-pitcher-name">選手名</th>
                        <th class="col-pitcher-throw-bat">投/打</th>
                        <th class="col-pitcher-style">投げ方</th>
                        <th class="col-pitcher-type">タイプ</th>
                        <th class="col-pitcher-velocity">球速帯</th>
                        <th class="col-stat">回数</th>
                        <th class="col-stat">打者</th><th class="col-stat">球数</th><th class="col-stat">被安打</th>
                        <th class="col-stat">奪三振</th><th class="col-stat">与四球</th><th class="col-stat">失点</th>
                        <th class="col-stat">自責点</th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            <button class="add-row-btn text-xs mt-2" data-table-id="pitching-table-${teamKey}">+ 投手を追加</button>
        </div>
    `;
}

function createFieldingTable(teamKey, details, playersOnField) {
    const fieldingData = details.fielding?.[teamKey] || [];
    
    // 選手名を選択するための <option> タグを生成
    const playerOptions = playersOnField.map(p => `<option value="${p.name}">${p.name}</option>`).join('');

    let bodyRows = fieldingData.map((play, index) => `
        <tr data-fielding-index="${index}">
            <td class="w-16"><input type="number" class="fielding-inning" value="${play.inning || ''}" min="1"></td>
            <td>
                <select class="player-name w-full">
                    <option value="">- 選手 -</option>
                    ${playersOnField.map(p => `<option value="${p.name}" ${p.name === play.player ? 'selected' : ''}>${p.name}</option>`).join('')}
                </select>
            </td>
            <td><input type="text" class="fielding-play" value="${play.play || ''}" placeholder="例: ダイビングキャッチ、レーザービームで補殺"></td>
            <td class="w-12 text-center">
                <button class="remove-fielding-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </td>
        </tr>
    `).join('');
    
    return `
        <div class="overflow-x-auto">
            <table class="details-table" id="fielding-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="w-16">イニング</th>
                        <th>選手名</th>
                        <th>ファインプレーの内容</th>
                        <th class="w-12">削除</th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            <button class="add-fielding-play-btn text-xs mt-2" data-team-key="${teamKey}">+ ファインプレーを追加</button>
        </div>
    `;
}

// ▼▼▼ 既存の「createPlayerBattingTable」関数 (10675行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * 個人別打席結果のテーブルHTMLを生成する
 * (★「個人成績モーダル」ボタンを追加)
 * (★★「調子」アイコンを追加★★)
 */
function createPlayerBattingTable(teamName, teamKey, details) {
    const battingData = details.batting[teamKey] || [];
    const numInnings = details.inningScore?.[teamKey]?.length || 9;
    
    // 選手リスト（代走/守備固めも含む）
    const playersOnField = battingData.filter(p => p.name).map(p => ({name: p.name}));

    // 「投/打」プルダウン用の選択肢
    const throwBatOptionsList = [
        { val: "R/R", label: "右/右" }, { val: "R/L", label: "右/左" }, { val: "R/S", label: "右/両" },
        { val: "L/L", label: "左/左" }, { val: "L/R", label: "左/右" }, { val: "L/S", label: "左/両" }
    ];
    const createThrowBatOptions = (selectedVal) => {
        return throwBatOptionsList.map(opt => 
            `<option value="${opt.val}" ${selectedVal === opt.val ? 'selected' : ''}>${opt.label}</option>`
        ).join('');
    };

    // 背番号と守備位置の選択肢
    let numberOptions = '<option value=""></option>';
    for (let i = 1; i <= 20; i++) { numberOptions += `<option value="${i}">${i}</option>`; }
    const posOptions = ['投', '捕', '一', '二', '三', '遊', '左', '中', '右'].map(p => `<option value="${p}">${p}</option>`).join('');
    
    // イニングヘッダー
    let inningsHeader = '';
    for (let i = 1; i <= numInnings; i++) {
        inningsHeader += `<th class="col-inning">${i}</th>`;
    }

    let bodyRows = '';
    const teamRecord = tournamentState.teamRecords[teamName]; // ★調子取得用

    // --- 1. スタメン (1〜9番) の行を生成 ---
    for (let i = 1; i <= 9; i++) {
        let starterData = battingData.find(p => p.order && parseInt(p.order) === i) || { order: i, results: Array(numInnings).fill('') };
        if (!starterData.results) starterData.results = Array(numInnings).fill('');
        const pName = starterData.name || ''; 

        // ★★★ ここからが修正箇所 ★★★
        let conditionIcon = '';
        if (pName && teamRecord?.playerStats?.batting[pName]) {
            const flag = teamRecord.playerStats.batting[pName].narrative_flag;
            conditionIcon = getPlayerConditionIcon(flag);
        }
        // ★★★ 修正ここまで ★★★

        const starterNumberSelect = `<select class="player-number w-full bg-transparent">${numberOptions.replace(`value="${starterData.number}"`, `value="${starterData.number}" selected`)}</select>`;
        const starterThrowBatSelect = `<select class="player-throw-bat w-full bg-transparent"><option value="">-投/打-</option>${createThrowBatOptions(starterData.throwBat)}</select>`;
        const starterPosSelect = `<select class="player-pos w-full bg-transparent"><option value=""></option>${posOptions.replace(`value="${starterData.currentPos || starterData.pos}"`, `value="${starterData.currentPos || starterData.pos}" selected`)}</select>`;
        const posHistoryHtml = `<span class="text-xs text-gray-500 truncate" title="${starterData.posHistoryDisplay || ''}">${starterData.posHistoryDisplay || ''}</span>`;
        
        let resultInputs = '';
        for (let j = 0; j < numInnings; j++) {
            const resultString = starterData.results[j] || '';
            const atBats = (resultString && resultString.split('、').length > 0) ? resultString.split('、') : [''];
            const atBatBlocksHTML = atBats.map(atBatString => createBattingResultDropdowns(playersOnField, atBatString)).join('');
            
            const changeBtnHTML = `
                <button class="inning-add-sub-btn text-xs mt-1 bg-gray-200 px-2 py-1 rounded hover:bg-gray-300 w-auto font-semibold" 
                        data-team-key="${teamKey}" 
                        data-order="${starterData.order}"
                        data-inning="${j}" 
                        title="${j + 1}回に代打を送る">
                    代打
                </button>`;

            resultInputs += `
                <td class="col-inning batting-result-cell align-top p-1">
                    ${atBatBlocksHTML}
                    <div class="flex justify-between items-center mt-1 pt-1 border-t">
                        <button class="add-at-bat-btn text-xs bg-blue-100 px-2 py-1 rounded hover:bg-blue-200 font-semibold">＋ 2打席</button>
                        ${changeBtnHTML}
                    </div>
                 </td>`;
        }
        
        bodyRows += `
            <tr data-order="${starterData.order}">
                <td class="col-order">${i}</td>
                <td class="col-number">${starterNumberSelect}</td>
                <td class="col-throw-bat">${starterThrowBatSelect}</td>
                <td class="col-player">
                    <div class="flex items-center gap-1">
                        <input type="text" class="player-name w-full" value="${pName}">
                        ${conditionIcon} <button class="show-player-stats-btn text-lg p-1 text-blue-600 hover:bg-blue-100 rounded" 
                                data-team-name="${teamName}" 
                                data-player-order-key="${starterData.order}" 
                                title="通算成績を表示">📊</button>
                    </div>
                </td>
                <td class="col-pos">
                    <div class="flex items-center justify-between">${starterPosSelect}<button class="text-xs bg-gray-200 px-1 ml-1 rounded pos-change-btn" data-team-key="${teamKey}">変更</button></div>
                    ${posHistoryHtml}
                </td>
                <td class="col-sub-type align-middle">
                    <button class="add-sub-row-btn text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300 w-full" data-order="${starterData.order}" data-team-key="${teamKey}">
                        + 交代
                    </button>
                </td>
                ${resultInputs}
            </tr>
        `;
        
        // --- 2. 交代選手 (スタメンの直下) の行を生成 ---
        const substitutes = battingData.filter(p => p.order && p.order.toString().startsWith(`${i}-sub`));
        substitutes.forEach(subData => {
            if (!subData.results) subData.results = Array(numInnings).fill('');
            const subName = subData.name || '';

            // ★★★ 交代選手の調子アイコンも取得 ★★★
            let subConditionIcon = '';
            if (subName && teamRecord?.playerStats?.batting[subName]) {
                const flag = teamRecord.playerStats.batting[subName].narrative_flag;
                subConditionIcon = getPlayerConditionIcon(flag);
            }
            // ★★★ 修正ここまで ★★★

            const subNumberSelect = `<select class="player-number w-full bg-transparent">${numberOptions.replace(`value="${subData.number}"`, `value="${subData.number}" selected`)}</select>`;
            const subThrowBatSelect = `<select class="player-throw-bat w-full bg-transparent"><option value="">-投/打-</option>${createThrowBatOptions(subData.throwBat)}</select>`;
            const subPosSelect = `<select class="player-pos w-full bg-transparent"><option value=""></option>${posOptions.replace(`value="${subData.currentPos || subData.pos}"`, `value="${subData.currentPos || subData.pos}" selected`)}</select>`;
            const subPosHistoryHtml = `<span class="text-xs text-gray-500 truncate" title="${subData.posHistoryDisplay || ''}">${subData.posHistoryDisplay || ''}</span>`;

            let subResultInputs = '';
            for (let j = 0; j < numInnings; j++) {
                const resultString = subData.results[j] || '';
                const atBats = (resultString && resultString.split('、').length > 0) ? resultString.split('、') : [''];
                const atBatBlocksHTML = atBats.map(atBatString => createBattingResultDropdowns(playersOnField, atBatString)).join('');

                const changeBtnHTML = `
                    <button class="inning-add-sub-btn text-xs mt-1 bg-gray-200 px-2 py-1 rounded hover:bg-gray-300 w-auto font-semibold" 
                            data-team-key="${teamKey}" 
                            data-order="${subData.order}"
                            data-inning="${j}"
                            title="${j + 1}回に代打を送る">
                        代打
                    </button>`;
                
                subResultInputs += `
                    <td class="col-inning batting-result-cell align-top p-1">
                        ${atBatBlocksHTML}
                        <div class="flex justify-between items-center mt-1 pt-1 border-t">
                            <button class="add-at-bat-btn text-xs bg-blue-100 px-2 py-1 rounded hover:bg-blue-200 font-semibold">＋ 2打席</button>
                            ${changeBtnHTML}
                        </div>
                     </td>`;
            }
            
            bodyRows += `
                <tr data-order="${subData.order}">
                    <td class="col-order"></td>
                    <td class="col-number">${subNumberSelect}</td>
                    <td class="col-throw-bat">${subThrowBatSelect}</td>
                    <td class="col-player pl-4">
                        <div class="flex items-center gap-1">
                            <input type="text" class="player-name w-full" value="${subName}">
                            ${subConditionIcon} <button class="show-player-stats-btn text-lg p-1 text-blue-600 hover:bg-blue-100 rounded" 
                                    data-team-name="${teamName}" 
                                    data-player-order-key="${subData.order}" 
                                    title="通算成績を表示">📊</button>
                        </div>
                    </td>
                    <td class="col-pos">
                        <div class="flex items-center justify-between">${subPosSelect}<button class="text-xs bg-gray-200 px-1 ml-1 rounded pos-change-btn" data-team-key="${teamKey}">変更</button></div>
                        ${subPosHistoryHtml}
                    </td>
                    <td class="col-sub-type align-top">
                        <select class="sub-type-select w-full bg-transparent mb-1">
                            <option value="" ${!subData.sub_type ? 'selected' : ''}>-</option>
                            <option value="PH" ${subData.sub_type === 'PH' ? 'selected' : ''}>代打</option>
                            <option value="PR" ${subData.sub_type === 'PR' ? 'selected' : ''}>代走</option>
                            <option value="DEF" ${subData.sub_type === 'DEF' ? 'selected' : ''}>守備</option>
                            <option value="PITCHER" ${subData.sub_type === 'PITCHER' ? 'selected' : ''}>投手</option>
                        </select>
                        <button class="add-sub-row-btn text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300 w-full" data-order="${subData.order}" data-team-key="${teamKey}">
                            + 交代
                        </button>
                    </td>
                    ${subResultInputs}
                </tr>
            `;
        });
    }

    return `
        <div class="overflow-x-auto">
            <table class="details-table batting-table" id="batting-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="col-order">打順</th>
                        <th class="col-number">#</th>
                        <th class="col-throw-bat">投/打</th>
                        <th class="col-player">選手名</th>
                        <th class="col-pos">守備</th>
                        <th class="col-sub-type">出場</th>
                        ${inningsHeader}
                        <th class="w-10"><button class="add-inning-btn text-xs" data-team-key="${teamKey}">+ 回</button></th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            </div>
    `;
}
// ▲▲▲ 置き換えここまで ▲▲▲



// ▼▼▼ 既存の「saveDetailedStats」関数 (10815行目あたり) を、以下で「まるごと置き換え」 ▼▼▼

// ▼▼▼ 既存の「saveDetailedStats」関数 (10815行目あたり) を、以下で「まるごと置き換え」 ▼▼▼

// ▼▼▼ 既存の「saveDetailedStats」関数 (10815行目あたり) を、以下で「まるごと置き換え」 ▼▼▼

/**
 * 詳細データを保存し、通算成績を更新する
 * (★「軽傷[🩹]」の起用もブロックするよう修正)
 */
function saveDetailedStats() {
    if (!currentMatchIdForDetails) return;
    const match = findMatchById(currentMatchIdForDetails);
    if (!match) return;

    // ★★★ ここからが「起用ブロック」の修正箇所 ★★★
    let injuredPlayerFound = null;

    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord || !teamRecord.playerStats) continue;

        // 1. 打撃テーブルをスキャン
        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (battingTable) {
            battingTable.querySelectorAll('tbody tr').forEach(row => {
                const nameInput = row.querySelector('.player-name');
                if (nameInput && nameInput.value.trim() !== '') {
                    const playerName = nameInput.value.trim();
                    const bStats = teamRecord.playerStats.batting[playerName];
                    // ★「minor_injury」を追加
                    if (bStats && (bStats.narrative_flag === 'injured' || bStats.narrative_flag === 'sick' || bStats.narrative_flag === 'minor_injury')) {
                        injuredPlayerFound = playerName;
                    }
                }
            });
        }
        if (injuredPlayerFound) break;

        // 2. 投手テーブルをスキャン
        const pitchingTable = document.getElementById(`pitching-table-${teamKey}`);
        if (pitchingTable) {
            pitchingTable.querySelectorAll('tbody tr').forEach(row => {
                const nameInput = row.querySelector('.pitcher-name');
                if (nameInput && nameInput.value.trim() !== '') {
                    const playerName = nameInput.value.trim();
                    const pStats = teamRecord.playerStats.pitching[playerName];
                    // ★「minor_injury」を追加
                    if (pStats && (pStats.narrative_flag === 'injured' || pStats.narrative_flag === 'sick' || pStats.narrative_flag === 'minor_injury')) {
                        injuredPlayerFound = playerName;
                    }
                }
            });
        }
        if (injuredPlayerFound) break;
    }

    // 3. もし故障者が見つかったら、アラートを出して保存を「中断」
    if (injuredPlayerFound) {
        // ★ アラート文言を修正
        alert(`[起用不可] 選手が起用できません。\n\n選手名: ${injuredPlayerFound}\n理由: 故障(🏥)・軽傷(🩹)・体調不良のため、試合に出場させられません。`);
        return; // ★ここで処理を中断
    }
    // ★★★ 「起用ブロック」ロジックここまで ★★★


    // --- 1. 古い成績を一度リセット ---
    if (match.details && match.details.playerGameStats) {
        for (const teamKey of ['team1', 'team2']) {
            const teamName = match[teamKey];
            const teamRecord = tournamentState.teamRecords[teamName];
            if (!teamRecord || !teamRecord.playerStats) continue;

            // (Step 1) 打撃成績のリセット
            const previousBattingStats = match.details.playerGameStats[teamKey];
            if (previousBattingStats) {
                for (const playerName in previousBattingStats) {
                    const careerStats = teamRecord.playerStats.batting[playerName];
                    const prevGameStats = previousBattingStats[playerName]; 
                    if (careerStats && prevGameStats) {
                        if(prevGameStats.played) careerStats.games = (careerStats.games || 1) - 1;
                        for (const key of ['pa', 'ab', 'h', 'hr', 'rbi', 'sb', 'bb', 'hbp', 'sf', 'tb', 'r', 'so']) {
                            careerStats[key] = (careerStats[key] || 0) - (prevGameStats[key] || 0);
                        }
                        careerStats.narrative_flag = null;
                    }
                } 
            } 
            const previousBattingData = match.details.batting?.[teamKey];
            if (previousBattingData) {
                previousBattingData.forEach(prevPlayerData => {
                    const playerName = prevPlayerData.name;
                    if (!playerName || !teamRecord.playerStats.batting[playerName]) return;
                    const bStats = teamRecord.playerStats.batting[playerName];
                    if (bStats.gamelogs) {
                        bStats.gamelogs = bStats.gamelogs.filter(log => log.matchId !== currentMatchIdForDetails);
                    }
                });
            }
            // (Step 2) チーム今大会成績のリセット
            if (teamRecord.tournamentStats && previousBattingStats) {
                let totals = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0 };
                for (const playerName in previousBattingStats) {
                    const prevGameStats = previousBattingStats[playerName]; 
                    if (prevGameStats) {
                        for (const key in totals) { totals[key] += prevGameStats[key] || 0; }
                    }
                }
                for (const key in totals) {
                     teamRecord.tournamentStats[key] = (teamRecord.tournamentStats[key] || 0) - totals[key];
                }
            } 
            // (Step 3) 投手成績のリセット
            const previousPitchingStats = match.details.pitching?.[teamKey];
            if (previousPitchingStats) {
                previousPitchingStats.forEach(prevGameStats => { 
                    const playerName = prevGameStats.name;
                    if (!playerName || !teamRecord.playerStats.pitching[playerName]) return;
                    const pStats = teamRecord.playerStats.pitching[playerName];
                    const careerStats = pStats.career;
                    if (careerStats && prevGameStats) {
                        careerStats.games = (careerStats.games || 1) - 1;
                        if (parseInt(prevGameStats.battersFaced || 0) > 0) {
                            if (prevGameStats.result === 'W') careerStats.w--;
                            if (prevGameStats.result === 'L') careerStats.l--;
                            careerStats.ip -= parseFloat(prevGameStats.innings || 0);
                            careerStats.so -= parseInt(prevGameStats.strikeouts || 0);
                            careerStats.er -= parseInt(prevGameStats.earnedRuns || 0);
                            careerStats.h = (careerStats.h || 0) - parseInt(prevGameStats.hits || 0);
                            careerStats.bb = (careerStats.bb || 0) - parseInt(prevGameStats.walks || 0);
                        }
                    }
                    if (pStats.gamelogs) {
                        pStats.gamelogs = pStats.gamelogs.filter(log => log.matchId !== currentMatchIdForDetails);
                    }
                    pStats.narrative_flag = null;
                });
            }
        }
    }
    // --- (リセット処理 ここまで) ---

    // (以降、保存処理ロジックは変更なし)
    const details = { 
        inningScore: { team1: [], team2: [] }, 
        batting: { team1: [], team2: [] }, 
        pitching: { team1: [], team2: [] }, 
        fielding: { team1: [], team2: [] },
        playerGameStats: { team1: {}, team2: {} },
        positionChanges: match.details?.positionChanges || []
    };
    const scoreTable = document.getElementById('inning-score-table');
    if (scoreTable) {
        const rows = scoreTable.querySelectorAll('tbody tr');
        const team1Row = Array.from(rows).find(row => row.querySelector('th')?.textContent.trim() === match.team1);
        const team2Row = Array.from(rows).find(row => row.querySelector('th')?.textContent.trim() === match.team2);
        if (team1Row) details.inningScore.team1 = Array.from(team1Row.querySelectorAll('input')).map(input => parseInt(input.value) || 0);
        if (team2Row) details.inningScore.team2 = Array.from(team2Row.querySelectorAll('input')).map(input => parseInt(input.value) || 0);
    }
    match.score1 = details.inningScore.team1.reduce((sum, score) => sum + score, 0);
    match.score2 = details.inningScore.team2.reduce((sum, score) => sum + score, 0);
    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord) continue;
        if (!teamRecord.playerStats) teamRecord.playerStats = { batting: {}, pitching: {} };
        if (!teamRecord.tournamentStats) teamRecord.tournamentStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0 }; 
        const playersAppearedThisGame = new Set();
        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (battingTable) {
            battingTable.querySelectorAll('tbody tr').forEach(row => {
                const nameInput = row.querySelector('.player-name');
                if (nameInput && nameInput.value.trim() !== '') {
                    const playerName = nameInput.value.trim();
                    const resultCells = Array.from(row.querySelectorAll('td.col-inning'));
                    const results = resultCells.map(cell => {
                        const atBatBlocks = Array.from(cell.querySelectorAll('.at-bat-block'));
                        const atBatsString = atBatBlocks.map(block => {
                            const container = block.querySelector('.batting-result-container');
                            if (!container) return ''; 
                            const batterPlay = [
                                (block.querySelector('.mark-at-bat-btn')?.dataset.marked === 'true') ? '★:' : '',
                                container.querySelector('.result-strength').value,
                                container.querySelector('.result-direction').value,
                                container.querySelector('.result-type').value,
                                container.querySelector('.result-rbi').value,
                                container.querySelector('.result-runner-play').value
                            ].filter(Boolean).join('');
                            const runnerPlays = Array.from(block.querySelectorAll('.runner-play-input')).map(rpContainer => {
                                const name = rpContainer.querySelector('.runner-name').value;
                                const play = rpContainer.querySelector('.runner-play').value;
                                const base = rpContainer.querySelector('.runner-base').value;
                                if (!name || !play) return '';
                                return [name, play, base].filter(Boolean).join(' ');
                            }).filter(Boolean).join(','); 
                            return [batterPlay, runnerPlays].filter(Boolean).join(';');
                        }).join('、');
                        return atBatsString;
                    });
                    const playerData = {
                        order: row.dataset.order, name: playerName,
                        number: row.querySelector('.player-number').value,
                        throwBat: row.querySelector('.player-throw-bat')?.value,
                        pos: row.querySelector('.player-pos').value,
                        currentPos: row.querySelector('.player-pos').value, // ★ currentPos を保存
                        posHistoryDisplay: row.querySelector('.text-xs.text-gray-500')?.title || '', // ★ 履歴表示を保存
                        sub_type: row.querySelector('.sub-type-select') ? row.querySelector('.sub-type-select').value : null,
                        results: results
                    };
                    details.batting[teamKey].push(playerData);
                    if (!teamRecord.playerStats.batting[playerName]) {
                        teamRecord.playerStats.batting[playerName] = { games: 0, pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0 };
                    }
                    const careerStats = teamRecord.playerStats.batting[playerName];
                    const isNonBattingSub = playerData.sub_type === 'DEF' || playerData.sub_type === 'PR';
                    const gameStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0, played: false, strongHits: 0, weakHits: 0, strongOuts: 0, weakOuts: 0 };
                    playerData.results.forEach(inningResultString => {
                        (inningResultString || '').split('、').forEach(atBatString => {
                            if (!atBatString) return;
                            const [batterPlay, runnerPlaysString] = atBatString.split(';');
                            if (batterPlay && batterPlay.trim() !== '') {
                                let cleanBatterPlay = batterPlay.trim().replace(/^★:/, '');
                                const isHit = BATTING_RESULTS.hits.some(h => cleanBatterPlay.includes(h));
                                const isOut = BATTING_RESULTS.outs.some(o => cleanBatterPlay.includes(o)) || BATTING_RESULTS.sacrifices.some(s => cleanBatterPlay.includes(s));
                                if (cleanBatterPlay.startsWith('S:')) {
                                    if (isHit) gameStats.strongHits++; if (isOut) gameStats.strongOuts++;
                                    cleanBatterPlay = cleanBatterPlay.substring(2);
                                } else if (cleanBatterPlay.startsWith('W:')) {
                                    if (isHit) gameStats.weakHits++; if (isOut) gameStats.weakOuts++;
                                    cleanBatterPlay = cleanBatterPlay.substring(2);
                                }
                                gameStats.played = true; gameStats.pa++;
                                const isWalk = ['四球', '死球', '敬遠'].some(w => cleanBatterPlay.includes(w));
                                const isSac = ['犠飛', '犠打', '犠失'].some(w => cleanBatterPlay.includes(w));
                                if (!isWalk && !isSac && !cleanBatterPlay.includes('妨害')) { gameStats.ab++; }
                                if (cleanBatterPlay.includes('四球') || cleanBatterPlay.includes('敬遠')) gameStats.bb++;
                                if (cleanBatterPlay.includes('死球')) gameStats.hbp++;
                                if (cleanBatterPlay.includes('犠飛')) gameStats.sf++;
                                if (cleanBatterPlay.includes('本塁打')) { gameStats.h++; gameStats.tb += 4; gameStats.hr++; }
                                else if (cleanBatterPlay.includes('三塁打')) { gameStats.h++; gameStats.tb += 3; }
                                else if (cleanBatterPlay.includes('二塁打')) { gameStats.h++; gameStats.tb += 2; }
                                else if (cleanBatterPlay.includes('安')) { gameStats.h++; gameStats.tb += 1; }
                                if (cleanBatterPlay.includes('点')) { 
                                    const rbiValue = (cleanBatterPlay.match(/(\d+)点/) || [0, 0])[1];
                                    gameStats.rbi += parseInt(rbiValue, 10);
                                }
                                if (cleanBatterPlay.includes('三振')) gameStats.so++;
                            }
                            (runnerPlaysString || '').split(',').forEach(runnerPlay => {
                                const parts = runnerPlay.split(' ');
                                if (parts[0] === playerName && parts[1] === '盗塁') { gameStats.sb++; }
                                if (parts[0] === playerName && (parts[1] === '生還' || (parts[1] === '進塁' && parts[2] === '本塁へ(生還)'))) {
                                    gameStats.r++;
                                }
                            });
                        });
                    });
                    if((gameStats.played || isNonBattingSub) && !playersAppearedThisGame.has(playerName)) { 
                        careerStats.games++; 
                        playersAppearedThisGame.add(playerName);
                    }
                    for (const key of ['pa', 'ab', 'h', 'hr', 'rbi', 'sb', 'bb', 'hbp', 'sf', 'tb', 'r', 'so']) {
                        careerStats[key] = (careerStats[key] || 0) + gameStats[key];
                        if (teamRecord.tournamentStats) {
                            teamRecord.tournamentStats[key] = (teamRecord.tournamentStats[key] || 0) + gameStats[key];
                        }
                    }
                    details.playerGameStats[teamKey][playerName] = gameStats;
                    if (!careerStats.gamelogs) careerStats.gamelogs = [];
                    const opponentName = teamKey === 'team1' ? match.team2 : match.team1;
                    const opponentRank = opponentName ? calculateRank(opponentName, tournamentState) : 'E';
                    careerStats.gamelogs.push({
                        matchId: currentMatchIdForDetails,
                        date: match.schedule?.date || '不明',
                        round: getRoundNameFromMatchId(currentMatchIdForDetails),
                        opponent: opponentName,
                        opponentRank: opponentRank,
                        order: playerData.order, 
                        sub_type: playerData.sub_type,
                        stats: gameStats 
                    });
                }
            });
        }
        const pitchingTable = document.getElementById(`pitching-table-${teamKey}`);
        if (pitchingTable) {
            pitchingTable.querySelectorAll('tbody tr').forEach(row => {
                const pitcherName = row.querySelector('.pitcher-name')?.value.trim(); 
                if (pitcherName && pitcherName !== '') {
                    const pitcherData = {
                        result: row.querySelector('.pitcher-result').value,
                        name: pitcherName, 
                        throwBat: row.querySelector('.pitcher-throw-bat').value,
                        throwStyle: row.querySelector('.pitcher-throw-style').value,
                        pitcherType: row.querySelector('.pitcher-type').value,
                        velocity: row.querySelector('.pitcher-velocity').value,
                        innings: row.querySelector('.pitcher-innings').value,
                        battersFaced: row.querySelector('.pitcher-batters').value,
                        pitches: row.querySelector('.pitcher-pitches').value,
                        hits: row.querySelector('.pitcher-hits').value, 
                        strikeouts: row.querySelector('.pitcher-so').value,
                        walks: row.querySelector('.pitcher-walks').value, 
                        runs: row.querySelector('.pitcher-runs').value,
                        earnedRuns: row.querySelector('.pitcher-er').value,
                    };
                    details.pitching[teamKey].push(pitcherData);
                    if (!teamRecord.playerStats.pitching[pitcherName]) {
                        teamRecord.playerStats.pitching[pitcherName] = { 
                            career: { games: 0, w: 0, l: 0, ip: 0, so: 0, er: 0, h: 0, bb: 0 },
                            gamelogs: []
                        };
                    }
                    const pStats = teamRecord.playerStats.pitching[pitcherName];
                    const careerStats = pStats.career;
                    if (pitcherData.name && !playersAppearedThisGame.has(pitcherName)) {
                        careerStats.games = (careerStats.games || 0) + 1;
                        playersAppearedThisGame.add(pitcherName);
                    }
                    if (pitcherData.battersFaced && parseInt(pitcherData.battersFaced) > 0) {
                        if (pitcherData.result === 'W') careerStats.w++;
                        if (pitcherData.result === 'L') careerStats.l--;
                        careerStats.ip += parseFloat(pitcherData.innings) || 0;
                        careerStats.so += parseInt(pitcherData.strikeouts) || 0;
                        careerStats.er += parseInt(pitcherData.earnedRuns) || 0;
                        careerStats.h = (careerStats.h || 0) + parseInt(pitcherData.hits || 0);
                        careerStats.bb = (careerStats.bb || 0) + parseInt(pitcherData.walks || 0);
                        const opponentName = teamKey === 'team1' ? match.team2 : match.team1;
                        const opponentRank = opponentName ? calculateRank(opponentName, tournamentState) : 'E';
                        pStats.gamelogs.push({
                            matchId: currentMatchIdForDetails,
                            date: match.schedule?.date || '不明', 
                            round: getRoundNameFromMatchId(currentMatchIdForDetails),
                            opponent: opponentName,
                            opponentRank: opponentRank, 
                            result: pitcherData.result,
                            ip: pitcherData.innings,
                            h: pitcherData.hits,
                            bb: pitcherData.walks,
                            so: pitcherData.strikeouts,
                            r: pitcherData.runs,
                            er: pitcherData.earnedRuns
                        });
                    }
                }
            });
        }
    }
    for (const teamKey of ['team1', 'team2']) {
        const fieldingTable = document.getElementById(`fielding-table-${teamKey}`);
        if (fieldingTable) {
            fieldingTable.querySelectorAll('tbody tr').forEach(row => {
                const inning = row.querySelector('.fielding-inning')?.value;
                const player = row.querySelector('.player-name')?.value;
                const play = row.querySelector('.fielding-play')?.value;
                if (player && play) { 
                    details.fielding[teamKey].push({
                        inning: inning ? parseInt(inning) : null,
                        player: player,
                        play: play
                    });
                }
            });
        }
    }
    match.details = details;
    saveState();
    detailsModal.classList.add('hidden');
    renderTournament(tournamentState);
    alert('詳細を保存しました。');
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * [NEW] 準々決勝(R5)進出の8チームを分析し、展望記事をAIに生成させる
 * (★「ベスト8決定」とテキストを修正)
 * @returns {Promise<object>} - 生成された記事オブジェクト
 */
async function generateBest16PreviewArticle() {
    const state = tournamentState;
    if (!state.matches) return null;

    const roundNum = 5; // R5 (準々決勝)
    const matchIdsInRound = Object.keys(state.matches).filter(id => 
        id.includes(`-R${roundNum}-M`)
    );
    
    if (matchIdsInRound.length === 0) return null;

    let matchupsText = "";
    let cinderellaTeams = [];
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };

    // --- 1. 全カード(R5)を分析 ---
    for (const matchId of matchIdsInRound) {
        const match = state.matches[matchId];
        if (!match.team1 || !match.team2) continue;

        const team1 = match.team1;
        const team2 = match.team2;
        const rank1 = calculateRank(team1, state);
        const rank2 = calculateRank(team2, state);
        
        matchupsText += `\n### ${getRoundNameFromMatchId(matchId)} カード: ${team1} vs ${team2}\n`;
        
        [team1, team2].forEach(teamName => {
            const teamRecord = state.teamRecords[teamName];
            if (!teamRecord) return;
            
            const rank = calculateRank(teamName, state);
            const journey = getCurrentTournamentPerformance(teamName, matchId);
            const dynamicInfo = generateDynamicTeamInfo(teamName, TEAM_DATA[teamName], teamRecord);
            
            matchupsText += `- **${teamName}** (${rank}ランク)\n`;
            matchupsText += `  - 勝ち上がり: ${journey}\n`;
            matchupsText += `  - チーム状況: ${dynamicInfo}\n`;
            
            if (rank === 'C' || rank === 'D' || rank === 'E') {
                cinderellaTeams.push(`${teamName}(${rank})`);
            }
            
            let conditions = [];
            if (teamRecord.playerStats?.batting) {
                Object.values(teamRecord.playerStats.batting).forEach(p => {
                    if (p.narrative_flag && p.narrative_flag !== 'normal') {
                        conditions.push(`${p.name} (${getPlayerConditionIcon(p.narrative_flag)})`);
                    }
                });
            }
            if (teamRecord.playerStats?.pitching) {
                Object.values(teamRecord.playerStats.pitching).forEach(p => {
                    if (p.narrative_flag && p.narrative_flag !== 'normal') {
                        conditions.push(`${p.name} (${getPlayerConditionIcon(p.narrative_flag)})`);
                    }
                });
            }
            if (conditions.length > 0) {
                matchupsText += `  - 主な選手の調子: ${[...new Set(conditions)].join(', ')}\n`;
            }
        });
    }

    // ★★★ ここからが修正箇所 ★★★
    const prompt = `あなたは「静岡 熱闘スタジアム」のベテラン解説AIです。
${state.tournamentYear}年度 夏季大会は4回戦までが終了し、ついに【ベスト8】が決定しました。
以下の【準々決勝(R5)】の組み合わせデータに基づき、全4試合の見どころを解説する、ドラマチックな「展望記事」を執筆してください。

### 参考：静岡県の常識（勢力図）
${PREFECTURE_LORE}

### 準々決勝(R5) 全4試合の対戦データ
${matchupsText}

### 執筆指示
1.  **タイトル:** 「ベスト8激突！準々決勝(R5)の注目カードをAIが徹底分析！」のような、期待感を煽るタイトルにしてください。
2.  **導入:** まず、**ベスト8が決定**したことへの興奮と、ここからが甲子園をかけた本当の戦いであることを宣言してください。
3.  **【快進撃への言及】:**
    - もし ${cinderellaTeams.length > 0 ? `快進撃を続けるチーム（${cinderellaTeams.join(', ')}）` : '快進撃のチーム'} がいる場合、彼らの健闘を「今大会最大のサプライズ」として**必ず**称賛してください。
    - 彼らの「勝ち上がり」データを引用し、彼らがどうやって格上を倒してきたかをドラマチックに描写してください。
4.  **各カード分析 (全4試合):**
    - ${matchupsText.split('###')[1]} (最初のカード) から順に、全4試合の見どころを解説してください。
    - **データ活用:** 各チームの「今大会のチーム打率」や「選手の調子（🔥, ❄️）」を分析データとして引用してください。
    - **展開予想:** （例：「打率4割超えの283学園打線が、疲労の見える静岡のエースを捉えるか」「ロースコアの投手戦が予想される」など）
5.  **締めくくり:** **準決勝(R6)**に進むのはどのチームか、読者に問いかける形で記事を締めくくってください。

### 出力形式 (JSON)
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
    // ★★★ 修正ここまで ★★★

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                return { 
                    ...article, 
                    timestamp: Date.now(),
                    summaryType: 'best8',
                    context: { isBracketAnalysis: true }
                };
            }
        }
        throw new Error("AI best8 preview response format error.");
    } catch (error) {
        console.error(`AI準々決勝展望記事の生成に失敗しました:`, error);
        return { 
            title: "準々決勝 展望記事生成エラー", body: "AI記者との通信に失敗しました。", 
            timestamp: Date.now(), error: true, errorId: `best8-preview-${Date.now()}`,
            summaryType: 'best8',
            context: { isBracketAnalysis: true }
        };
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

// ▲▲▲ 置き換えここまで ▲▲▲
/**
 * [NEW] 相手チームの打撃成績テーブルをスキャンし、
 * 味方チームの投手テーブルの「イニング数」に基づき、成績を自動で振り分ける
 * @param {string} pitchingTeamKey - 成績を入力される投手側 (例: 'team1')
 * @param {string} battingTeamKey - スキャン対象の打者側 (例: 'team2')
 */
async function fillPitcherStatsFromBatting(pitchingTeamKey, battingTeamKey) {
    const battingTable = document.getElementById(`batting-table-${battingTeamKey}`);
    const pitchingTable = document.getElementById(`pitching-table-${pitchingTeamKey}`);
    const pitchingTableBody = pitchingTable?.querySelector('tbody');
    
    if (!battingTable || !pitchingTableBody) {
        alert("エラー: 必要なテーブルが見つかりません。");
        return;
    }

    // --- 1. 投手テーブルから「全投手」の「イニング数」を取得 ---
    const pitcherRows = Array.from(pitchingTableBody.querySelectorAll('tr'));
    const pitchersData = pitcherRows.map(row => {
        const name = row.querySelector('.pitcher-name')?.value.trim();
        const inningsStr = row.querySelector('.pitcher-innings')?.value.trim();
        const innings = parseFloat(inningsStr) || 0;
        
        // 6.1回 -> 19アウト, 6.2回 -> 20アウト, 6.0回 -> 18アウト
        const totalOuts = Math.floor(innings) * 3 + (innings % 1) * 10;
        
        return { rowElement: row, name, innings, totalOuts, stats: { bf: 0, h: 0, so: 0, walks: 0, r: 0 } };
    }).filter(p => p.name && p.innings); // 名前とイニングが入力されている投手のみ

    if (pitchersData.length === 0) {
        alert("先に投手テーブルに「選手名」と「回数」（例: 6.1 や 9）を正確に入力してください。");
        return;
    }

    // 累計アウトカウントを計算 (例: A投手が19, B投手が5なら -> A: 19, B: 24)
    let cumulativeOuts = 0;
    pitchersData.forEach(p => {
        cumulativeOuts += p.totalOuts;
        p.cumulativeOuts = cumulativeOuts;
    });

    // --- 2. 相手打撃テーブルの全打席を「時系列順」に並べ替える ---
    // (A) まずHTMLから一時的な `battingData` オブジェクトを構築
    const tempBattingData = [];
    battingTable.querySelectorAll('tbody tr').forEach(row => {
        const nameInput = row.querySelector('.player-name');
        if (nameInput && nameInput.value.trim() !== '') {
            tempBattingData.push({
                order: row.dataset.order,
                name: nameInput.value.trim(),
                results: Array.from(row.querySelectorAll('td.col-inning')).map(cell => {
                    return Array.from(cell.querySelectorAll('.at-bat-block')).map(block => {
                        const container = block.querySelector('.batting-result-container');
                        if (!container) return '';
                        return [
                            (block.querySelector('.mark-at-bat-btn')?.dataset.marked === 'true') ? '★:' : '',
                            container.querySelector('.result-strength').value,
                            container.querySelector('.result-direction').value,
                            container.querySelector('.result-type').value,
                            container.querySelector('.result-rbi').value,
                            container.querySelector('.result-runner-play').value
                        ].filter(Boolean).join('');
                    }).filter(Boolean).join('、');
                })
            });
        }
    });

    // (B) `createHighlightsText` と同じロジックで「時系列順」のプレーリストを作成
    const sortedBattingOrder = tempBattingData.sort((a,b) => parseFloat(a.order.replace('-sub','.')) - parseFloat(b.order.replace('-sub','.')));
    const numInnings = battingTable.querySelector('thead tr').children.length - 7;
    let batterIndices = {}; // この処理専用のインデックス
    const allChronologicalPlays = []; // 全打席を時系列順に格納
    
    // (B-1) batterIndices を初期化 (打順の最初の選手を0番目とする)
    sortedBattingOrder.forEach((player, index) => {
        batterIndices[player.order] = index;
    });

    // (B-2) イニング × 打順でループし、時系列リストを作成
    for (let i = 0; i < numInnings; i++) { // イニング (0=1回)
        const startingBatterIndex = batterIndices[battingTeamKey] || 0;
        let currentBatterIndex = startingBatterIndex;
        let outsThisInning = 0;
        let playsInThisInning = 0;

        const playsInHalfInning = [];
        sortedBattingOrder.forEach(player => {
            const resultString = player.results?.[i];
            if (resultString) {
                resultString.split('、').forEach(atBat => {
                    if(atBat) playsInHalfInning.push({ player, atBat });
                });
            }
        });
        if (playsInHalfInning.length === 0) continue;

        // (B-3) 打順の並べ替えロジック
        const orderedPlays = [];
        let playsCount = 0;
        const atBatsTempCount = {};
        const processedFlags = new Array(playsInHalfInning.length).fill(false);
        while (orderedPlays.length < playsInHalfInning.length && playsCount < playsInHalfInning.length * 2) {
             const currentPlayer = sortedBattingOrder[currentBatterIndex];
             const playerOrderKey = currentPlayer.order;
             const currentAtBatOrdinal = atBatsTempCount[playerOrderKey] || 0;
             let foundPlayIndex = -1;
             let searchCount = 0;
             for(let k=0; k < playsInHalfInning.length; k++){
                 if(playsInHalfInning[k].player.order === playerOrderKey && !processedFlags[k]) {
                     if(searchCount === currentAtBatOrdinal) {
                         foundPlayIndex = k;
                         break;
                     }
                     searchCount++;
                 }
             }
             if (foundPlayIndex !== -1) {
                 orderedPlays.push(playsInHalfInning[foundPlayIndex]);
                 processedFlags[foundPlayIndex] = true;
                 atBatsTempCount[playerOrderKey] = currentAtBatOrdinal + 1;
                 currentBatterIndex = (currentBatterIndex + 1) % sortedBattingOrder.length;
             } else {
                 currentBatterIndex = (currentBatterIndex + 1) % sortedBattingOrder.length;
             }
             playsCount++;
        }
        const finalOrderedPlays = orderedPlays.length === playsInHalfInning.length ? orderedPlays : playsInHalfInning;
        
        // (B-4) 確定した時系列リストから、アウトをカウントし、次のイニングの先頭打者を決定
        finalOrderedPlays.forEach(play => {
            allChronologicalPlays.push(play); // メインのリストに追加
            const [batterPlay] = play.atBat.split(';');
            const result = translatePlay(batterPlay);
            if (result.out) outsThisInning++;
            if (result.type === 'dp') outsThisInning++;
        });

        if (outsThisInning < 3 && finalOrderedPlays.length > 0) {
            const lastPlayer = finalOrderedPlays[finalOrderedPlays.length - 1].player;
            const lastBatterIndexInLineup = sortedBattingOrder.findIndex(p => p.order === lastPlayer.order);
            if (lastBatterIndexInLineup !== -1) {
                batterIndices[battingTeamKey] = (lastBatterIndexInLineup + 1) % sortedBattingOrder.length;
            }
        } else {
             batterIndices[battingTeamKey] = currentBatterIndex; // 3アウトになった時点の次の打者
        }
    }

    // --- 3. 時系列リストを処理し、成績を振り分ける ---
    let currentOuts = 0;
    
    allChronologicalPlays.forEach(play => {
        const [batterPlay, runnerPlaysString] = play.atBat.split(';');
        
        // (A) この打席を担当した投手を見つける
        // (注: currentOutsは「この打席が始まる前」のアウトカウント)
        let currentPitcher = pitchersData.find(p => currentOuts < p.cumulativeOuts);
        if (!currentPitcher) {
            // 全ての投手が投げ終わった後の打席（例: 9回裏サヨナラ）
            currentPitcher = pitchersData[pitchersData.length - 1]; 
        }
        
        const stats = currentPitcher.stats;
        stats.bf++; // 打者 +1
        
        // (B) saveDetailedStatsのロジックを流用して成績を集計
        if (batterPlay && batterPlay.trim() !== '') {
            let cleanBatterPlay = batterPlay.trim().replace(/^★:/, '').replace(/^[SW]:/, '');
            
            // アウト
            const result = translatePlay(batterPlay);
            if (result.out) currentOuts++;
            if (result.type === 'dp') currentOuts++;

            // 被安打
            if (BATTING_RESULTS.hits.includes(result.type)) stats.h++;
            // 奪三振
            if (result.type === 'so') stats.so++;
            // 与四死球
            if (BATTING_RESULTS.walks.includes(result.type)) stats.walks++;
            
            // 失点 (打点から)
            if (cleanBatterPlay.includes('点')) {
                const rbiValue = (cleanBatterPlay.match(/(\d+)点/) || [0, 0])[1];
                stats.r += parseInt(rbiValue, 10);
            }
        }
        
        // 失点 (走塁プレーから)
        (runnerPlaysString || '').split(',').forEach(runnerPlay => {
            const parts = runnerPlay.split(' ');
            if (parts.length < 2) return;
            const playType = parts[1];
            const base = parts[2] || '';
            
            if (playType === '生還' || (playType === '進塁' && base === '本塁へ(生還)')) {
                // 打点と重複しないかチェック
                if (!batterPlay.includes('点') && !batterPlay.includes('本塁打') && !batterPlay.includes('犠飛')) {
                    stats.r++;
                }
            }
        });
    });

    // --- 4. 確認アラートを表示 ---
    let confirmMessage = "以下の内容で投手成績を自動入力しますか？\n\n";
    pitchersData.forEach(p => {
        confirmMessage += 
            `▼ ${p.name} (${p.innings}回)\n` +
            `  打者: ${p.stats.bf}人\n` +
            `  被安打: ${p.stats.h}本\n` +
            `  奪三振: ${p.stats.so}個\n` +
            `  与四死球: ${p.stats.walks}個\n` +
            `  失点: ${p.stats.r}点\n\n`;
    });
    confirmMessage += "（注：自責点(ER)と球数は手動で入力してください）";

    const confirmed = confirm(confirmMessage);

    // --- 5. 投手テーブルの入力欄に値を設定 ---
    if (confirmed) {
        pitchersData.forEach(p => {
            const row = p.rowElement;
            row.querySelector('.pitcher-batters').value = p.stats.bf;
            row.querySelector('.pitcher-hits').value = p.stats.h;
            row.querySelector('.pitcher-so').value = p.stats.so;
            row.querySelector('.pitcher-walks').value = p.stats.walks;
            row.querySelector('.pitcher-runs').value = p.stats.r;
            // 自責点(ER)は失点(R)と同じ値を入れておく
            row.querySelector('.pitcher-er').value = p.stats.r; 
        });
        
        alert("投手成績を自動入力しました。\n自責点(ER)と球数は手動で確認・入力してください。");
    }
}

/**
 * [修正版] 詳細入力の打席結果文字列を、ボックススコア用の短い文字列に翻訳する
 * (★文字数順にソートして「犠飛」が「飛」に誤判定されるのを防ぐ)
 */
function translateResultForBoxScore(atBatString) {
    if (!atBatString) return "-";
    let tempRes = atBatString.trim();
    
    // 1. 注目フラグと勢いフラグを除去
    if (tempRes.startsWith('★:')) tempRes = tempRes.substring(3);
    if (tempRes.startsWith('S:')) tempRes = tempRes.substring(2);
    if (tempRes.startsWith('W:')) tempRes = tempRes.substring(2);

    // 2. 打点と走塁プレーを除去
    tempRes = tempRes.replace(/(\d+点)/, '');
    tempRes = tempRes.replace('好走塁', '');
    
    // 3. 方向+結果 (例: 中安, 遊ゴ) を抽出
    // ★★★ 修正: 文字数の多い順 (.sort((a, b) => b.length - a.length)) に並べ替えてから判定する
    const allResultTypes = [ 
        ...BATTING_RESULTS.hits, 
        ...BATTING_RESULTS.outs, 
        ...BATTING_RESULTS.walks, 
        ...BATTING_RESULTS.sacrifices, 
        ...BATTING_RESULTS.other, 
        '振り逃げ', '打撃妨害' 
    ].sort((a, b) => b.length - a.length);

    let foundResult = null;
    let foundDirection = '';

    for (const type of allResultTypes) {
        if (tempRes.includes(type)) {
            foundResult = type;
            tempRes = tempRes.replace(type, '').trim();
            break;
        }
    }
    
    if (tempRes.length > 0 && DIRECTIONS.includes(tempRes)) {
        foundDirection = tempRes;
    }

    if (foundResult) {
        if(foundResult === "安") foundResult = "安";
        return (foundDirection + foundResult).trim();
    }
    
    return "-";
}

/**
 * [NEW] 試合データから「一球速報」風のHTMLボックススコアを自動生成する
 * @param {object} dbMatch - 試合オブジェクト (detailsを内包)
 * @returns {string} - ボックススコア全体のHTML文字列
 */
function generateBoxScoreHTML(dbMatch) {
    if (!dbMatch || !dbMatch.details) return "<p>詳細データがありません。</p>";
    
    const { details } = dbMatch;
    const team1Name = dbMatch.team1;
    const team2Name = dbMatch.team2;
    const score1 = dbMatch.score1;
    const score2 = dbMatch.score2;

    // --- 1. チームの総ヒット数(H)と総エラー数(E)を集計 ---
    let totalHits1 = 0;
    let totalHits2 = 0;
    if (details.playerGameStats) {
        Object.values(details.playerGameStats.team1 || {}).forEach(stats => totalHits1 += (stats.h || 0));
        Object.values(details.playerGameStats.team2 || {}).forEach(stats => totalHits2 += (stats.h || 0));
    }
    // (エラー(E)は現在集計していないため '0' とする)
    const totalErrors1 = 0;
    const totalErrors2 = 0;

    // --- 2. イニングスコアボードHTML ---
    const inningScores1 = details.inningScore?.team1 || [];
    const inningScores2 = details.inningScore?.team2 || [];
    const numInnings = Math.max(9, inningScores1.length, inningScores2.length);
    
    let inningHeaders = '';
    let inningRow1 = '';
    let inningRow2 = '';
    for (let i = 1; i <= numInnings; i++) {
        inningHeaders += `<th>${i}</th>`;
        // 9回裏サヨナラなどで、片方のイニングデータがない場合も考慮
        const score1_inning = (i-1 < inningScores1.length) ? inningScores1[i-1] : '';
        const score2_inning = (i-1 < inningScores2.length) ? inningScores2[i-1] : '';
        
        // 9回裏サヨナラ (X表示)
        const isSayonara = (i === 9 && score1 < score2 && inningScores2[i-1] > 0);
        
        inningRow1 += `<td class="score-cell">${score1_inning}</td>`;
        inningRow2 += `<td class="score-cell">${isSayonara ? 'X' : score2_inning}</td>`;
    }

    const scoreBoardHtml = `
        <table class="boxscore-table">
            <thead class="inning-header">
                <tr><th></th>${inningHeaders}<th>計</th><th>H</th><th>E</th></tr>
            </thead>
            <tbody>
                <tr>
                    <td class="team-name">${team1Name}</td>
                    ${inningRow1}
                    <td class="total-score">${score1}</td>
                    <td class="total-score">${totalHits1}</td>
                    <td class="total-score">${totalErrors1}</td>
                </tr>
                <tr>
                    <td class="team-name">${team2Name}</td>
                    ${inningRow2}
                    <td class="total-score">${score2}</td>
                    <td class="total-score">${totalHits2}</td>
                    <td class="total-score">${totalErrors2}</td>
                </tr>
            </tbody>
        </table>
    `;

    // --- 3. 打撃・投手成績HTML (ヘルパー関数) ---
    const generateStatsTables = (teamKey) => {
        const teamName = dbMatch[teamKey];
        const battingData = details.batting?.[teamKey] || [];
        const gameStats = details.playerGameStats?.[teamKey] || {};
        const pitchingData = details.pitching?.[teamKey] || [];

        // 打順 > 交代順 でソート
        const sortedBatters = battingData.sort((a, b) => {
            const orderA = parseFloat(a.order.replace('-sub', '.'));
            const orderB = parseFloat(b.order.replace('-sub', '.'));
            return orderA - orderB;
        });

        // 打撃テーブル
        let battingRows = '';
        let totalAB = 0, totalR = 0, totalH = 0, totalRBI = 0, totalSO = 0, totalBB = 0;
        
        sortedBatters.forEach(player => {
            if (!player.name) return;
            const stats = gameStats[player.name];
            // 試合に出ていない選手 (打席0, 代走/守備固めのみ) は表示
            if (!stats || (!stats.played && (stats.sb || 0) === 0 && player.sub_type !== 'DEF' && player.sub_type !== 'PR')) return;

            const isSub = player.order.includes('sub');
            const rowClass = isSub ? 'sub-player' : '';
            const playerName = player.name;
            const playerPos = player.currentPos || player.pos || '?'; // 守備変更後の最終位置
            
            // この試合の成績 (saveDetailedStatsで集計済み)
            const ab = stats.ab || 0;
            const r = stats.r || 0;
            const h = stats.h || 0;
            const rbi = stats.rbi || 0;
            const so = stats.so || 0;
            const bb = (stats.bb || 0) + (stats.hbp || 0); // 四死球
            
            totalAB += ab; totalR += r; totalH += h; totalRBI += rbi; totalSO += so; totalBB += bb;

            // 打席結果を翻訳
            const resultsText = player.results.map(inningResults => 
                inningResults.split('、').map(atBat => translateResultForBoxScore(atBat)).filter(res => res !== '-')
            ).flat().join(', ');

            let orderDisplay = '';
            if (isSub) {
                if (player.sub_type === 'PH') orderDisplay = '打';
                else if (player.sub_type === 'PR') orderDisplay = '走';
                else orderDisplay = '守';
            } else {
                orderDisplay = player.order;
            }

            battingRows += `
                <tr class="${rowClass}">
                    <td class="pos">${orderDisplay} ${playerPos}</td>
                    <td class="player">${playerName}</td>
                    <td class="at-bat">${ab}</td>
                    <td class="runs">${r}</td>
                    <td class="hits">${h}</td>
                    <td class="rbi">${rbi}</td>
                    <td class="so">${so}</td>
                    <td class="walks">${bb}</td>
                    <td class="results">${resultsText || '-'}</td>
                </tr>
            `;
        });
        
        const battingTableHtml = `
            <h3 class="text-xl font-bold mt-6 mb-2 text-gray-800">${teamName}</h3>
            <table class="batting-stats-table">
                <thead>
                    <tr>
                        <th class="pos"></th><th class="player">選手名</th>
                        <th class="at-bat">打</th><th class="runs">得</th><th class="hits">安</th><th class="rbi">点</th>
                        <th class="so">三</th><th class="walks">四</th><th class="results">打席結果</th>
                    </tr>
                </thead>
                <tbody>
                    ${battingRows}
                    <tr class="team-totals">
                        <td class="player" colspan="2">合計</td>
                        <td class="at-bat">${totalAB}</td>
                        <td class="runs">${totalR}</td>
                        <td class="hits">${totalH}</td>
                        <td class="rbi">${totalRBI}</td>
                        <td class="so">${totalSO}</td>
                        <td class="walks">${totalBB}</td>
                        <td class="results"></td>
                    </tr>
                </tbody>
            </table>
        `;

        // 投手テーブル
        let pitchingRows = '';
        if (pitchingData.length > 0) {
            pitchingData.forEach(p => {
                if (!p.name || !p.innings) return;
                const ip = parseFloat(p.innings) || 0;
                const er = parseInt(p.earnedRuns) || 0;
                const era = (ip > 0) ? ((er * 9) / ip).toFixed(2) : "0.00";
                const resultMark = {'W': '○', 'L': '●', 'S': 'Ｓ', 'H': 'Ｈ'}[p.result] || '';
                
                pitchingRows += `
                    <tr>
                        <td class="result">${resultMark}</td>
                        <td class="player">${p.name}</td>
                        <td class="ip">${p.innings}</td>
                        <td class="bf">${p.battersFaced || '-'}</td>
                        <td class="hits">${p.hits || '0'}</td>
                        <td class="so">${p.strikeouts || '0'}</td>
                        <td class="walks">${p.walks || '0'}</td>
                        <td class="runs">${p.runs || '0'}</td>
                        <td class="er">${p.earnedRuns || '0'}</td>
                        <td class="era">${era}</td>
                    </tr>
                `;
            });
        }
        
        const pitchingTableHtml = `
            <table class="pitching-stats-table">
                <thead><tr><th class="result"></th><th class="player">投手名</th><th class="ip">回</th><th class="bf">打者</th><th class="hits">安</th><th class="so">三</th><th class="walks">四</th><th class="runs">失</th><th class="er">自</th><th class="era">防御率</th></tr></thead>
                <tbody>${pitchingRows}</tbody>
            </table>
        `;

        return battingTableHtml + pitchingTableHtml;
    };

    // --- 4. 最終的なHTMLを組み立て ---
    return scoreBoardHtml + generateStatsTables('team1') + generateStatsTables('team2');
}
// ▲▲▲ 新規追加ここまで ▲▲▲

/**
 * [新機能] あるチームの、指定された試合ID「以前」の
 * 全試合のスタメン履歴を時系列で取得する
 * @param {string} teamName - チーム名
 * @param {string} currentMatchId - 現在の試合ID (これより前の履歴を取得する)
 * @returns {Array<object>} - [{ matchId, roundName, starters: [...] }, ...]
 */
function getStarterHistory(teamName, currentMatchId) {
    const history = [];
    
    // 1. 全試合データをスキャン
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };
    
    const targetMatch = allMatches[currentMatchId];
    // 現在の試合のラウンドキーを取得 (例: 1, 2, 100)
    const currentRoundSortKey = targetMatch?.roundSortKey || getRoundSortKey(currentMatchId);

    // 2. チームが関わり、かつ「現在より前」の試合を収集
    for (const matchId in allMatches) {
        // 現在の試合自体は除外
        if (matchId === currentMatchId) continue;
        
        const match = allMatches[matchId];
        const teamKey = match.team1 === teamName ? 'team1' : (match.team2 === teamName ? 'team2' : null);
        
        // 条件：チームが関わっている AND 勝者が決まっている AND 詳細入力がある
        if (teamKey && match.winner && match.details && match.details.batting && match.details.batting[teamKey]) {
            
            const matchRoundSortKey = getRoundSortKey(matchId);
            
            // ★現在の試合のラウンドキーより「小さい」試合のみを履歴に追加
            if (matchRoundSortKey < currentRoundSortKey) {
                const starters = match.details.batting[teamKey]
                    .filter(p => p.order && !p.order.toString().includes('sub') && parseInt(p.order) >= 1 && parseInt(p.order) <= 9)
                    .map(p => p.name); // 名前だけの配列にする
                
                history.push({
                    matchId: matchId,
                    roundSortKey: matchRoundSortKey,
                    roundName: getRoundNameFromMatchId(matchId),
                    starters: starters
                });
            }
        }
    }
    
    // 3. ラウンド順にソートして返す
    history.sort((a, b) => a.roundSortKey - b.roundSortKey);
    return history;
}

/**
 * 試合IDからソート用の数値キーを取得する (getStarterHistoryのヘルパー)
 */
function getRoundSortKey(matchId) {
    if (!matchId) return 999;
    if (matchId.includes('-R')) {
        // 'L-R1-M1' -> 1
        return parseInt(matchId.split('-R')[1].split('-')[0]);
    }
    if (matchId.startsWith('F-')) {
        return 100; // 決勝
    }
    if (matchId.includes('-SB') || matchId.includes('-SREP') || matchId.includes('-SIZU') || matchId.includes('AUTUMN')) {
        return -1; // 地区予選は本戦より前
    }
    return 999;
}
// ▲▲▲ 貼り付けここまで ▲▲▲

/**
     * 【修正版】スキップ機能関連
     */
    function generateAutoScore(rankWinner, rankLoser) {
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        const diff = rankValues[rankWinner] - rankValues[rankLoser];
        let winnerScore, loserScore;

        if (diff >= 3) { // 大差
            winnerScore = 7 + Math.floor(Math.random() * 4);
            loserScore = Math.floor(Math.random() * 3);
        } else if (diff >= 2) { // 中差
            winnerScore = 5 + Math.floor(Math.random() * 3);
            loserScore = Math.max(0, winnerScore - (3 + Math.floor(Math.random() * 2)));
        } else if (diff >= 1) { // 小差
            winnerScore = 3 + Math.floor(Math.random() * 4);
            loserScore = Math.max(0, winnerScore - (1 + Math.floor(Math.random() * 2)));
        } else { // 同ランク
            winnerScore = 2 + Math.floor(Math.random() * 5);
            loserScore = winnerScore - 1;
        }
        return [winnerScore, loserScore];
    }

    /**
     * 【重要修正】ラウンドを自動でスキップする
     * (★128チーム制、BYE対応版)
     */
    async function skipRound(roundNumber) {



        const btnId = `skip-r${roundNumber}-btn`;
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.disabled = true;
            btn.textContent = `進行中...(${roundNumber}回戦)`;
        }
        skipLoader.classList.remove('hidden');

        // ★ 128チーム制に対応
        const numTeams = tournamentState.teams.length;
        const numMatchesInRoundSide = (numTeams / 2) / Math.pow(2, roundNumber - 1); // R1=32, R2=16...

        const matchIds = [];
        ['L', 'R'].forEach(side => {
            for (let i = 1; i <= numMatchesInRoundSide; i++) {
                matchIds.push(`${side}-R${roundNumber}-M${i}`);
            }
        });

        // --- ステップ1：ラウンドの全試合の勝敗を決定 ---
        for (const matchId of matchIds) {
            const match = tournamentState.matches[matchId];
            
            if (!match || match.winner || !match.team1 || !match.team2) {
                continue;
            }

            // ★★★ BYE(不戦勝)の処理 ★★★
            if (match.team1 === '(BYE)') {
                await processMatchWin(matchId, match.team2); // team2の不戦勝
                continue;
            }
            if (match.team2 === '(BYE)') {
                await processMatchWin(matchId, match.team1); // team1の不戦勝
                continue;
            }
            // ★★★ BYE処理ここまで ★★★

            const { team1, team2 } = match;
            const rank1 = calculateRank(team1, tournamentState);
            const rank2 = calculateRank(team2, tournamentState);
            const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
            let winnerName, loserName;
            
            const upsetChance = 0.15 - (Math.abs(rankValues[rank1] - rankValues[rank2]) * 0.03);

            if (Math.random() < upsetChance) { // 番狂わせ
                winnerName = rankValues[rank1] < rankValues[rank2] ? team1 : team2;
            } else { // 順当
                winnerName = rankValues[rank1] >= rankValues[rank2] ? team1 : team2;
            }
            loserName = winnerName === team1 ? team2 : team1;
            
            const winnerRank = calculateRank(winnerName, tournamentState);
            const loserRank = calculateRank(loserName, tournamentState);

            const [winnerScore, loserScore] = generateAutoScore(winnerRank, loserRank);

            match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
            match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;
            
            await processMatchWin(matchId, winnerName);
        }
        
        renderTournament(tournamentState);
        renderNews(tournamentState.news); 
        saveState();
        
        if (btn) {
            btn.classList.add('hidden');
            btn.disabled = false;
            btn.textContent = `${roundNumber}回戦スキップ`;
        }
        skipLoader.classList.add('hidden');
    }
// ▲▲▲ 置き換えここまで ▲▲▲

// --- NEW Autumn Tournament System ---

 /**
 * [秋季大会 ステージ1] 地区ブロック予選を開始する
 * (★新仕様: 3地区 大規模トーナメント + 敗者復活戦 方式)
 */
async function setupAutumnRegionalBlocks() {
    tournamentState.autumnPhase = 'regional_blocks';
    
    // 1. 全チームを地区別に振り分け
    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    INITIAL_TEAM_POOL.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region && teamsByRegion[region]) {
            teamsByRegion[region].push(teamName);
        }
    });

    // ★★★ ここからが新ロジック ★★★
    // 2. 「東部・伊豆」を「東部」に統合
    teamsByRegion['東部'] = teamsByRegion['東部'].concat(teamsByRegion['伊豆']);
    delete teamsByRegion['伊豆']; // 旧伊豆地区を削除
    tournamentState.autumnData.regions['伊豆'] = { blocks: [], finalReps: [] }; // 互換性のため空で残す

    // 3. 主要3地区（東部・中部・西部）の大規模トーナメントを生成
    for (const region of ['東部', '中部', '西部']) {
        let regionalTeams = shuffleArray(teamsByRegion[region]);
        if (regionalTeams.length === 0) continue;

        // (A) メイントーナメント (例: 43チーム -> 64枠トーナメント)
        const mainBracketId = `${region}-MAIN`;
        const mainMatches = createDynamicBracketMatches(mainBracketId, regionalTeams);
        
        // (B) 敗者復活トーナメント (8枠)
        const repechageBracketId = `${region}-REP`;
        const repechageMatches = createDynamicBracketMatches(repechageBracketId, Array(8).fill(null)); // 8チーム用の空の箱
        
        // (C) 州データに保存
        tournamentState.autumnData.regions[region] = {
            blocks: [], // 旧ブロックは廃止
            mainBracket: { // ★新設
                id: mainBracketId,
                teams: regionalTeams,
                matches: mainMatches,
                size: Math.pow(2, Math.ceil(Math.log2(regionalTeams.length))) // 64, 64, 64
            },
            repechageBracket: { // ★新設
                id: repechageBracketId,
                teams: Array(8).fill(null), // 8枠
                matches: repechageMatches
            },
            finalReps: [], // 最終的な代表 (12枠)
            best8: [], // ベスト8 (8枠)
            repechageTeams: [] // 敗者復活に進むチーム (8枠)
        };
        
        // (D) 全試合をマスターリストに追加
        if (!tournamentState.autumnData.allMatches) tournamentState.autumnData.allMatches = {};
        Object.assign(tournamentState.autumnData.allMatches, mainMatches, repechageMatches);
    }
    // ★★★ 新ロジックここまで ★★★

    renderTournament(tournamentState);
    saveState();
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * [NEW HELPER] 任意のチーム数でトーナメントの試合オブジェクトを自動生成する
 * (★prevMatchId (子試合ID) を保存し、描画と進行を可能にする修正版)
 * @param {string} bracketId - '東部-B1' や '伊豆-AUTUMN' などのプレフィックス
 * @param {Array<string>} teams - そのブロックに参加する全チームの配列
 * @returns {object} - 全試合の matches オブジェクト
 */
function createDynamicBracketMatches(bracketId, teams) {
    const numTeams = teams.length;
    if (numTeams === 0) return {};
    if (numTeams === 1) return {};

    const matches = {};
    const rounds = [];
    
    const tournamentSize = Math.pow(2, Math.ceil(Math.log2(numTeams)));
    const numRounds = Math.log2(tournamentSize);
    const numByes = tournamentSize - numTeams;
    const numFirstRoundTeams = numTeams - numByes;
    
    let teamsInNextRound = [];
    let teamIndex = 0;

    // --- 4. 1回戦 (R1) を生成 ---
    if (numFirstRoundTeams > 0) {
        const round1Matches = [];
        const numMatchesR1 = numFirstRoundTeams / 2;
        for (let i = 0; i < numMatchesR1; i++) {
            const matchId = `${bracketId}-R1-M${i + 1}`;
            const team1 = teams[teamIndex++];
            const team2 = teams[teamIndex++];
            matches[matchId] = { 
                id: matchId, team1: team1, team2: team2, winner: null, score1: '', score2: '',
                prevMatch1Id: null, prevMatch2Id: null, nextMatchId: null // R1は子なし
            };
            round1Matches.push(matchId);
            teamsInNextRound.push(`winner_of_${matchId}`);
        }
        rounds.push(round1Matches);
    }
    
    // --- 5. 1回戦免除(シード)のチームを次ラウンドに追加 ---
    for (let i = 0; i < numByes; i++) {
        teamsInNextRound.push(teams[teamIndex++]);
    }

    // --- 6. 2回戦 (R2) から決勝 (Final) までを自動生成 ---
    for (let r = 2; r <= numRounds; r++) {
        const roundMatches = [];
        const teamsInThisRound = shuffleArray(teamsInNextRound);
        teamsInNextRound = [];
        
        const numMatchesInRound = teamsInThisRound.length / 2;
        for (let i = 0; i < numMatchesInRound; i++) {
            const matchId = `${bracketId}-R${r}-M${i + 1}`;
            const team1_str = teamsInThisRound[i * 2];
            const team2_str = teamsInThisRound[i * 2 + 1];
            
            const resolvedTeam1 = team1_str.startsWith('winner_of_') ? null : team1_str;
            const resolvedTeam2 = team2_str.startsWith('winner_of_') ? null : team2_str;
            
            // ★★★ ここからが修正箇所 ★★★
            // この試合 (R2) に進出する、前の試合 (R1) のIDを保存する
            const prevMatch1Id = team1_str.startsWith('winner_of_') ? team1_str.replace('winner_of_', '') : null;
            const prevMatch2Id = team2_str.startsWith('winner_of_') ? team2_str.replace('winner_of_', '') : null;

            matches[matchId] = { 
                id: matchId, 
                team1: resolvedTeam1, 
                team2: resolvedTeam2, 
                winner: null, score1: '', score2: '', 
                prevMatch1Id: prevMatch1Id, // ★ 左の子 (team1側) のID
                prevMatch2Id: prevMatch2Id, // ★ 右の子 (team2側) のID
                nextMatchId: null // ★ この時点では「次」は不明
            };
            // ★★★ 修正ここまで ★★★

            roundMatches.push(matchId);
            teamsInNextRound.push(`winner_of_${matchId}`);
            
            // ★ 前の試合の「nextMatchId」に、今作った試合IDをリンクする
            if (prevMatch1Id) matches[prevMatch1Id].nextMatchId = matchId;
            if (prevMatch2Id) matches[prevMatch2Id].nextMatchId = matchId;
        }
        rounds.push(roundMatches);
    }
    
    return matches;
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * [秋季大会 ステージ1 UI] 地区予選を描画する
 * (★新仕様: 3地区 大規模T + 敗者復活T 方式)
 */
function renderAutumnRegionalBlocks() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">秋季大会 地区予選</h2>`;
    html += '<div class="space-y-8">';

    // 東部・中部・西部
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.mainBracket) continue;

        const quota = 12; // 各地区12枠

        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">${region}地区 (${quota}枠)</h3>
                
                <h4 class="font-bold text-center text-lg mb-2">県大会出場決定トーナメント (ベスト8が決定)</h4>
                <p class="text-sm text-center text-gray-600 mb-2">
                    ${regionData.mainBracket.teams.length}チームによるトーナメント。ベスト8 (準々決勝) に進出した8校が県大会出場決定！<br>
                    ベスト16で敗退した8校は、下の「敗者復活トーナメント」に進みます。
                </p>
                <div class="p-3 border rounded-lg bg-gray-50 overflow-x-auto">
                    <div class="flex items-center justify-start space-x-2 text-xs" style="min-width: ${regionData.mainBracket.size * 50}px;">
                        ${createDynamicBracketHTML(regionData.mainBracket.id, regionData.mainBracket.matches)}
                    </div>
                </div>

                <h4 class="font-bold text-center text-lg mb-2 mt-8">敗者復活トーナメント (残り4枠)</h4>
                <p class="text-sm text-center text-gray-600 mb-2">
                    上記のベスト16で敗退した8校が、残り4枠をかけて戦います。
                </p>
                <div class="p-3 border rounded-lg bg-gray-50 overflow-x-auto">
                    <div class="flex items-center justify-center space-x-2 text-xs">
                        ${createDynamicBracketHTML(regionData.repechageBracket.id, regionData.repechageBracket.matches)}
                    </div>
                </div>
            </div>
        `;
    }
    // (伊豆地区は東部に統合されたため描画ロジックを削除)

    html += '</div>';
    autumnRegionalContainer.innerHTML = html;
    checkAutumnRegionalBlocksComplete();
}
// ▲▲▲ 置き換えここまで ▲▲▲

  
    /**
     * [秋季大会 ステージ2] 地区内順位決定戦を開始する
     */
    async function setupAutumnRankingTournaments() {
    tournamentState.autumnPhase = 'regional_ranking';

    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        
        // 重要な変更：上位校トーナメントは廃止し、敗者復活戦のみを行う
        regionData.champBracket = null; // 不要になったのでクリア

        // ブロック準優勝したチームで、第5代表決定トーナメントを組む
        const repechageBracketId = `${region}-REP`;
        const repTeams = shuffleArray(regionData.blockRunnersUp);
        regionData.repechageBracket = {
            id: repechageBracketId,
            teams: repTeams,
            matches: {
                [`${repechageBracketId}-R1-M1`]: { id: `${repechageBracketId}-R1-M1`, team1: repTeams[0], team2: repTeams[1], winner: null, score1: '', score2: '', summary: '' },
                [`${repechageBracketId}-R1-M2`]: { id: `${repechageBracketId}-R1-M2`, team1: repTeams[2], team2: repTeams[3], winner: null, score1: '', score2: '', summary: '' },
                [`${repechageBracketId}-R2-M1`]: { id: `${repechageBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '', summary: '' } // 5位決定戦
            }
        };
    }
    
    renderTournament(tournamentState);
    saveState();
}
    /**
     * [秋季大会 ステージ2 UI] 地区内順位決定戦を描画する
     */
   // 【修正対象3】
function renderAutumnRankingTournaments() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">秋季大会 地区 第5代表決定トーナメント</h2>`;
    html += '<div class="space-y-8">';
    
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.repechageBracket) continue;

        const rep = regionData.repechageBracket;
        
        const repSemi1 = rep.matches[`${rep.id}-R1-M1`];
        const repSemi2 = rep.matches[`${rep.id}-R1-M2`];
        rep.matches[`${rep.id}-R2-M1`].team1 = repSemi1.winner;
        rep.matches[`${rep.id}-R2-M1`].team2 = repSemi2.winner;
        
        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">${region}地区</h3>
                <div class="flex items-center justify-center space-x-4">
                    <div class="space-y-4">
                        ${createMatchHTML(repSemi1.id, repSemi1.team1, repSemi1.team2, repSemi1, [])}
                        
                        ${createMatchHTML(repSemi2.id, repSemi2.team1, repSemi2.team2, repSemi2, [])}
                        </div>
                    <div>
                        <p class="text-center font-semibold">代表決定戦</p>
                        ${createMatchHTML(rep.matches[`${rep.id}-R2-M1`].id, rep.matches[`${rep.id}-R2-M1`].team1, rep.matches[`${rep.id}-R2-M1`].team2, rep.matches[`${rep.id}-R2-M1`], [])}
                    </div>
                </div>
            </div>
        `;
    }
    html += '</div>';
    autumnRankingContainer.innerHTML = html;
    checkAutumnRankingTournamentsComplete();
}
    

/**
 * [秋季大会 ステージ3] 県大会本戦を開始する
 * (★新仕様: 36チーム制 (24 BYE + 12 R1) に対応)
 */
async function setupAutumnMainTournament() {
    tournamentState.autumnPhase = 'main';
    tournamentState.is16team = false; // 16チーム制ではない

    // --- 1. 代表チームのリストを作成 (36チーム) ---
    const best8_winners = []; // 24校 (2回戦から)
    const repechage_winners = []; // 12校 (1回戦から)

    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        
        // (A) メイントーナメントのベスト8 (8校) を集計
        const mainMatches = regionData.mainBracket.matches;
        const mainSize = regionData.mainBracket.size; // 64, 64, 64
        const quarterFinalRound = Math.log2(mainSize) - 1; // 準々決勝 (R5)
        
        const quarterFinalIds = Object.keys(mainMatches).filter(id => id.includes(`-R${quarterFinalRound}-M`)); // R5の試合
        quarterFinalIds.forEach(matchId => {
            const match = mainMatches[matchId];
            if (match.team1) best8_winners.push(match.team1);
            if (match.team2) best8_winners.push(match.team2);
        });

        // (B) 敗者復活トーナメントのベスト4 (4校) を集計
        const repMatches = regionData.repechageBracket.matches;
        const repSemiFinalRound = Math.log2(8) - 1; // 準決勝 (R2)
        
        const repSemiFinalIds = Object.keys(repMatches).filter(id => id.includes(`-R${repSemiFinalRound}-M`)); // R2の試合
        repSemiFinalIds.forEach(matchId => {
            const match = repMatches[matchId];
            if (match.team1) repechage_winners.push(match.team1);
            if (match.team2) repechage_winners.push(match.team2);
        });
    }

    // --- 2. 予選敗退チームの成績を記録 ---
    const repTeamNames = [...best8_winners, ...repechage_winners];
    INITIAL_TEAM_POOL.forEach(teamName => {
        if (TEAM_DATA[teamName]?.region && !repTeamNames.includes(teamName)) {
            if(tournamentState.teamRecords[teamName]) tournamentState.teamRecords[teamName].lastFinish = 64;
        }
    });

    // --- 3. 64チーム制トーナメントを生成 (36校 + 28 BYE) ---
    const numTeamsInTournament = 64;
    const finalRound = 6;
    tournamentState.teams = Array(numTeamsInTournament).fill(null);
    tournamentState.matches = {};
    tournamentState.seeds = []; // 秋季県大会はシードなし

    const shuffledRepechageTeams = shuffleArray(repechage_winners); // 12校
    const shuffledBest8Teams = shuffleArray(best8_winners); // 24校
    const byes = Array(28).fill('(BYE)'); // 28枠
    
    let teamsForR1 = []; // 1回戦を戦うチーム (36チーム)
    
    // (A) 敗者復活12校を、1回戦の6試合に配置
    for (let i = 0; i < 12; i++) {
        teamsForR1.push(shuffledRepechageTeams[i]);
    }
    
    // (B) ベスト8の24校と、BYEの28枠をペアリング
    // 24校 + 28BYE = 52チーム -> 26試合
    // このうち、(28-24)=4つのBYEがBYE同士で当たる (2試合)
    const combinedRest = shuffleArray([...shuffledBest8Teams, ...byes]);
    for (let i = 0; i < 52; i++) {
        teamsForR1.push(combinedRest[i]);
    }
    
    // (C) 1回戦の枠 (36チーム) がシャッフルされていないのでシャッフル
    teamsForR1 = shuffleArray(teamsForR1);
    
    // (D) 最終的な 64スロットを生成
    let r1Index = 0;
    let byeIndex = 0;
    const finalTeamsArray = [];
    
    // 12校(敗者復活)が6試合 = 12スロット
    for(let i=0; i<12; i++) {
        finalTeamsArray.push(shuffledRepechageTeams[i]);
    }
    // 24校(ベスト8) + 28BYE = 52スロット
    const rest = shuffleArray([...shuffledBest8Teams, ...byes]);
    finalTeamsArray.push(...rest);
    
    tournamentState.teams = finalTeamsArray; // 64枠にセット

    // --- 4. R1 (32試合) の試合オブジェクトを作成 ---
    const round1Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    round1Setup.forEach((match, index) => {
        const side = index < 16 ? 'L' : 'R'; // 32試合 / 2 = 16
        const matchNum = index < 16 ? index + 1 : index - 15;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

    // --- 5. R2, R3, R4, R5, F の「空の箱」を作成 ---
    for (let r = 2; r < finalRound; r++) { // R2, R3, R4, R5
        const numMatchesInRound = numTeamsInTournament / Math.pow(2, r); // 16, 8, 4, 2
        for (let m = 1; m <= numMatchesInRound / 2; m++) {
            const matchIdL = `L-R${r}-M${m}`;
            tournamentState.matches[matchIdL] = { id: matchIdL, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
            const matchIdR = `R-R${r}-M${m}`;
            tournamentState.matches[matchIdR] = { id: matchIdR, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
        }
    }
    tournamentState.matches['F-R1-M1'] = { id: 'F-R1-M1', team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
    
    // --- 6. スケジュールを割り当て (64チーム・6ラウンド制) ---
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R1-')), 
        ["9/15", "9/16", "9/17"], STADIUM_DATA, 2 // R1(32試合) -> 10球場*3日*2試合=60スロット (十分)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R2-')), 
        ["9/19", "9/20"], ROUND_3_STADIUMS, 2 // R2(16試合) -> 4球場*2日*2試合=16スロット
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R3-')), 
        ["9/22"], ROUND_3_STADIUMS, 2 // R3(8試合) -> 4球場*1日*2試合=8スロット
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R4-')), 
        ["9/24"], FINAL_STAGE_STADIUMS, 4 // R4(準々 4試合) -> 1球場*1日*4試合
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R5-')), 
        ["9/26"], FINAL_STAGE_STADIUMS, 2 // R5(準決 2試合) -> 1球場*1日*2試合
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('F-R1-')), 
        ["9/28"], FINAL_STAGE_STADIUMS, 1 // 決勝 (1試合)
    );
    
    renderTournament(tournamentState);
    saveState();
    
    // --- 7. 不戦勝(BYE)の自動処理 ---
    processByes(tournamentState);

    // --- 8. 記事生成 ---
    const currentTournamentName = "秋季県大会本戦";
    newsContainer.innerHTML = `<div class="loader">AI記者が${currentTournamentName}の展望記事を執筆中...</div>`;
    bbsCommentsContainer.innerHTML = `<div class="loader">AIが組み合わせを分析中...</div>`;

    const [previewArticle, bracketBbsResult] = await Promise.all([
        generateBracketAnalysisNewsArticle(tournamentState), // 64チーム制の分析を呼ぶ
        generateBracketBbsThread(tournamentState) // 64チーム制のBBSを呼ぶ
    ]);

    if (previewArticle && !previewArticle.error) {
         tournamentState.news.unshift(previewArticle);
    } else if (previewArticle && previewArticle.error) {
        tournamentState.news.unshift(previewArticle);
    }
    if (bracketBbsResult && !bracketBbsResult.error) {
        tournamentState.bbsComments.push(bracketBbsResult); 
    } else if (bracketBbsResult && bracketBbsResult.error) {
        tournamentState.bbsComments.push({ ...bracketBbsResult, context: { isBracketThread: true } });
    }
    
    renderNews(tournamentState.news);
    renderBbsComments(tournamentState.bbsComments);
    saveState();
}
// ▲▲▲ 置き換えここまで ▲▲▲


/**
     * 秋季地区ブロック予選がすべて終了したかチェックする
     * (★新仕様: 3地区 大規模T + 敗者復活T の終了を監視)
     */
    function checkAutumnRegionalBlocksComplete() {
    let allFinished = true;
    
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData || !regionData.mainBracket || !regionData.repechageBracket) {
            allFinished = false; break;
        }
        
        // 1. メイントーナメントの決勝戦 (優勝決定)
        const mainMatches = regionData.mainBracket.matches;
        const mainFinalId = Object.keys(mainMatches).find(id => !mainMatches[id].nextMatchId);
        if (!mainFinalId || !mainMatches[mainFinalId].winner) {
            allFinished = false; break;
        }

        // 2. 敗者復活トーナメントの決勝戦 (4試合)
        const repMatches = regionData.repechageBracket.matches;
const semi1 = repMatches[`${regionData.repechageBracket.id}-R2-M1`];
        const semi2 = repMatches[`${regionData.repechageBracket.id}-R2-M2`];
        
        if (!semi1 || !semi2 || !semi1.team1 || !semi1.team2 || !semi2.team1 || !semi2.team2) {
             allFinished = false; break;
        }
        // (敗者復活戦は準決勝まで進めばOK。決勝(R3-M1)までやる必要はない)
        // ★★★ 新ロジックここまで ★★★
    }

    if (allFinished) {
        autumnControls.classList.remove('hidden');
        startRankingPlayoffsBtn.classList.add('hidden');
        startMainTournamentBtn.classList.remove('hidden'); // ★ 県大会本戦ボタンを表示
        skipAutumnBlocksBtn.classList.add('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startRankingPlayoffsBtn.classList.add('hidden');
        startMainTournamentBtn.classList.add('hidden');
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲
 
   /**
     * 秋季地区内順位決定戦がすべて終了したかチェックする
     */
    /**
     * 【修正版】秋季地区内順位決定戦がすべて終了したかチェックする
     */
    function checkAutumnRankingTournamentsComplete() {
    let allRankingsFinished = true;
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.repechageBracket) {
            allRankingsFinished = false;
            break;
        }

        const repechageFinal = regionData.repechageBracket.matches[`${region}-REP-R2-M1`]; // 5位決定戦

        // 敗者復活戦の決勝がすべて終わっているかチェック
        if (!repechageFinal.winner) {
            allRankingsFinished = false;
            break;
        }
    }
    
    if (allRankingsFinished) {
        autumnControls.classList.remove('hidden');
        startRankingPlayoffsBtn.classList.add('hidden');
        startMainTournamentBtn.classList.remove('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startMainTournamentBtn.classList.add('hidden');
    }
}
// --- NEW Spring Tournament System ---

/**
 * [春季大会 ステージ1] 地区予選を開始する（3校トーナメント対応・最終版）
 */
async function setupSpringRegionalQualifiers() {
    tournamentState.springPhase = 'regional_qualifiers';
    const { qualifierTeams } = tournamentState.springData;

    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    qualifierTeams.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region && teamsByRegion[region]) {
            teamsByRegion[region].push(teamName);
        }
    });
    
    // 東部・中部・西部地区の予選設定
    for (const region of ['東部', '中部', '西部']) {
        let regionalTeams = shuffleArray(teamsByRegion[region]);
        const blockCount = 4;
        const regionBlocks = [];
        
        for (let i = 0; i < blockCount; i++) {
            const blockTeams = regionalTeams.splice(0, Math.ceil(regionalTeams.length / (blockCount - i)));
            if(blockTeams.length === 0) continue;
            
            const blockId = `${region}-SB${i+1}`; // Spring Block
            const blockMatches = {};
            
            // チーム数に応じてトーナメント形式を決定
            if (blockTeams.length <= 4) { // 4チーム以下
                const semi1Id = `${blockId}-R1-M1`;
                const semi2Id = `${blockId}-R1-M2`;
                const finalId = `${blockId}-R2-M1`;
                Object.assign(blockMatches, {
                    [semi1Id]: { id: semi1Id, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '' },
                    [semi2Id]: { id: semi2Id, team1: blockTeams[2] || null, team2: blockTeams[3] || null, winner: null, score1: '', score2: '' },
                    [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '' }
                });
            } else { // 5チーム
                 const playInMatchId = `${blockId}-R0-M1`;
                 const semi1Id = `${blockId}-R1-M1`;
                 const semi2Id = `${blockId}-R1-M2`;
                 const finalId = `${blockId}-R2-M1`;
                 Object.assign(blockMatches, {
                    [playInMatchId]: { id: playInMatchId, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '' },
                    [semi1Id]: { id: semi1Id, team1: null, team2: blockTeams[2], winner: null, score1: '', score2: '' },
                    [semi2Id]: { id: semi2Id, team1: blockTeams[3], team2: blockTeams[4], winner: null, score1: '', score2: '' },
                    [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '' }
                 });
            }
            regionBlocks.push({ id: blockId, teams: blockTeams, matches: blockMatches });
            Object.assign(tournamentState.springData.allMatches, blockMatches);
        }
        tournamentState.springData.regions[region].blocks = regionBlocks;

        // 第5代表決定トーナメントの器を準備
        const repBracketId = `${region}-SREP`;
        tournamentState.springData.regions[region].repechageBracket = {
            id: repBracketId,
            teams: [], // ブロック準優勝校がここに入る
            matches: {
                [`${repBracketId}-R1-M1`]: { id: `${repBracketId}-R1-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' },
                [`${repBracketId}-R1-M2`]: { id: `${repBracketId}-R1-M2`, team1: null, team2: null, winner: null, score1: '', score2: '' },
                [`${repBracketId}-R2-M1`]: { id: `${repBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' }
            }
        };
        Object.assign(tournamentState.springData.allMatches, tournamentState.springData.regions[region].repechageBracket.matches);
    }
    
    // 伊豆地区の予選設定
    const izuTeams = shuffleArray(teamsByRegion['伊豆']);
    const izuBracketId = '伊豆-SIZU'; // IDを'SIZU'に変更
    const izuBracket = { id: izuBracketId, teams: izuTeams, matches: {} };

    if (izuTeams.length === 3) {
        // --- 3校トーナメントの場合 ---
        const semiId = `${izuBracketId}-R1-M1`;
        const finalId = `${izuBracketId}-R2-M1`;
        // 1チームが不戦勝（bye）で決勝へ
        Object.assign(izuBracket.matches, {
            [semiId]: { id: semiId, team1: izuTeams[0], team2: izuTeams[1], winner: null, score1: '', score2: '' },
            [finalId]: { id: finalId, team1: null, team2: izuTeams[2], winner: null, score1: '', score2: '' }
        });
    } else if (izuTeams.length >= 2) {
        // --- 4校（または2校）トーナメントの場合 ---
        const semi1Id = `${izuBracketId}-R1-M1`;
        const semi2Id = `${izuBracketId}-R1-M2`;
        const finalId = `${izuBracketId}-R2-M1`;
        Object.assign(izuBracket.matches, {
            [semi1Id]: { id: semi1Id, team1: izuTeams[0], team2: izuTeams[1], winner: null, score1: '', score2: '' },
            [semi2Id]: { id: semi2Id, team1: izuTeams[2] || null, team2: izuTeams[3] || null, winner: null, score1: '', score2: '' },
            [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '' }
        });
    }
    tournamentState.springData.regions['伊豆'].izuBracket = izuBracket;
    Object.assign(tournamentState.springData.allMatches, izuBracket.matches);

    renderTournament(tournamentState);
    saveState();
}

/**
 * [春季大会 ステージ1 UI] 地区予選を描画する
 */
function renderSpringRegionalQualifiers() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">春季大会 地区予選</h2>`;
    html += '<div class="space-y-8">';

    // 東部・中部・西部
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.springData.regions[region];
        if (!regionData.blocks) continue;

        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-green-700">${region}地区 (5枠)</h3>
                <h4 class="font-bold text-center text-lg mb-2">代表決定ブロック</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    ${regionData.blocks.map(block => `
                        <div class="p-3 border rounded-lg bg-gray-50">
                            <h4 class="font-bold text-center mb-2">ブロック ${block.id.split('-')[1].slice(1)}</h4>
                            ${block.teams.length <= 4 ? create4TeamBlockHTML(block) : create5TeamBlockHTML(block)}
                        </div>
                    `).join('')}
                </div>
                <h4 class="font-bold text-center text-lg mb-2">第5代表決定トーナメント</h4>
                <div class="flex justify-center">
                   ${create4TeamBlockHTML(regionData.repechageBracket, true)}
                </div>
            </div>
        `;
    }

    // 伊豆
    const izuData = tournamentState.springData.regions['伊豆'];
    if (izuData.izuBracket) {
        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-green-700">伊豆地区 (1枠)</h3>
                <div class="flex justify-center">
                    ${create4TeamBlockHTML(izuData.izuBracket)}
                </div>
            </div>
        `;
    }
    
    html += '</div>';
    autumnRegionalContainer.innerHTML = html; // 秋のコンテナを流用
    checkSpringQualifiersComplete();
}

/**
 * [NEW HELPER] matchesオブジェクトからトーナメント表のHTMLを再帰的に生成する
 * (★「prevMatchId」を正しく辿って描画する修正版)
 * @param {string} bracketId - '東部-B1' など
 * @param {object} matches - このブロックの全試合 matches オブジェクト
 * @returns {string} - トーナメント表のHTML
 */
function createDynamicBracketHTML(bracketId, matches) {
    const finalMatchId = Object.keys(matches).find(id => !matches[id].nextMatchId);
    if (!finalMatchId) return "（試合なし）";

    // 再帰的にHTMLを構築する内部関数
    function buildMatchHTML(matchId) {
        const match = matches[matchId];
        if (!match) return "（エラー）";

        // ★★★ ここからが修正箇所 ★★★
        // 1. データベースに保存された子IDを直接参照
        const prevMatch1Id = match.prevMatch1Id;
        const prevMatch2Id = match.prevMatch2Id;
        
        // 2. （左側）前の試合がある場合は、再帰的に呼び出す
        const leftHtml = prevMatch1Id ? buildMatchHTML(prevMatch1Id) : '';
        // 3. （右側）前の試合がある場合は、再帰的に呼び出す
        const rightHtml = prevMatch2Id ? buildMatchHTML(prevMatch2Id) : '';

        // 4. チーム名を解決
        // (processMatchWinが勝者名を team1/team2 に入れるため、
        //  R1以外は prevMatch.winner を見る必要がなくなった)
        const team1 = match.team1 || (prevMatch1Id ? (matches[prevMatch1Id]?.winner || '---') : '---');
        const team2 = match.team2 || (prevMatch2Id ? (matches[prevMatch2Id]?.winner || '---') : '---');
        // ★★★ 修正ここまで ★★★
        
        // 5. この試合自身のHTMLを生成
        const currentMatchHtml = createMatchHTML(matchId, team1, team2, match, []);

        if (leftHtml || rightHtml) {
            // 前の試合(子)がある場合 (2回戦以降)
            return `
                <div class="flex items-center justify-center space-x-2">
                    <div class="flex flex-col justify-around space-y-4">
                        ${leftHtml}
                        ${rightHtml}
                    </div>
                    <div class="w-40">${currentMatchHtml}</div>
                </div>
            `;
        } else {
            // これが1回戦の場合 (子がない)
            return `<div class="w-40">${currentMatchHtml}</div>`;
        }
    }

    return buildMatchHTML(finalMatchId);
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 春季地区予選がすべて終了したかチェックする
 */
function checkSpringQualifiersComplete() {
    let allFinished = true;
    for (const match of Object.values(tournamentState.springData.allMatches)) {
        // チームがセットされていて、まだ勝者が決まっていない試合があるか
        if (match.team1 && match.team2 && !match.winner) {
            allFinished = false;
            break;
        }
    }

    if (allFinished) {
        autumnControls.classList.remove('hidden');
        startMainTournamentBtn.classList.remove('hidden'); // 県大会へ進むボタン
        startRankingPlayoffsBtn.classList.add('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startMainTournamentBtn.classList.add('hidden');
    }
}/**
 * [春季大会 ステージ2-1] 県大会本戦1回戦を開始する
 */
async function setupSpringMainTournament_Round1() {
    tournamentState.springPhase = 'main_round1';
    
    // 各地区の代表校をfinalRepsから集計
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.springData.regions[region];
        // ブロック優勝校
        regionData.blocks.forEach(block => {
            const finalMatch = block.matches[`${block.id}-R2-M1`] || block.matches[`${block.id}-R1-M1`]; // 2,3チームブロック対応
            if(finalMatch && finalMatch.winner) regionData.finalReps.push(finalMatch.winner);
        });
        // 第5代表
        const repFinal = regionData.repechageBracket.matches[`${regionData.repechageBracket.id}-R2-M1`];
        if (repFinal.winner) regionData.finalReps.push(repFinal.winner);
    }
    const izuFinal = tournamentState.springData.regions['伊豆'].izuBracket.matches[`伊豆-SIZU-R2-M1`];
    if (izuFinal.winner) tournamentState.springData.regions['伊豆'].finalReps.push(izuFinal.winner);

    const qualifiedTeams = Object.values(tournamentState.springData.regions).flatMap(r => r.finalReps);
    
    // 予選敗退チームの成績を記録
    tournamentState.springData.qualifierTeams.forEach(team => {
        if (!qualifiedTeams.includes(team)) {
            tournamentState.teamRecords[team].lastFinish = 64; // 予選敗退
        }
    });

    tournamentState.teams = shuffleArray(qualifiedTeams); // 予選突破16校で1回戦
    tournamentState.matches = {};
    tournamentState.is16team = true; // 16チームトーナメントとして描画
    tournamentState.seeds = []; // 1回戦はシードなし

    const round1Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    round1Setup.forEach((match, index) => {
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

// ▼▼▼ このブロックをまるごと追加 ▼▼▼
    // --- 1回戦のスケジュールを割り当て (16チーム) ---
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R1-')), 
        ["4/10", "4/11"], MAJOR_STADIUMS, 2 // 1回戦 (8試合) -> 4球場*2日*2試合=16スロット
    );
    // ▲▲▲ 追加ここまで ▲▲▲

    renderTournament(tournamentState);
    saveState();
    
    // 展望記事などを生成...
    newsContainer.innerHTML = `<div class="loader">AI記者が県大会1回戦の展望記事を執筆中...</div>`;
    // ★展望記事用の簡易contextを作成して渡す
    const previewContext = { matchId: 'preview' };
    const previewArticle = await generateNewsArticle(previewContext);
    if (previewArticle) tournamentState.news.unshift(previewArticle);

    renderNews(tournamentState.news);
    saveState();
}

/**
 * [春季大会 ステージ2-2] 県大会本戦2回戦を開始する
 */
async function setupSpringMainTournament_Round2() {
    tournamentState.springPhase = 'main_round2_onwards';
    
    const round1Winners = [];
    Object.values(tournamentState.matches).forEach(match => {
        if(match.id.includes('-R1-') && match.winner) {
            round1Winners.push(match.winner);
        }
    });

    const seedTeams = tournamentState.springData.seedTeams;
    const shuffledSeeds = shuffleArray(seedTeams);
    const shuffledWinners = shuffleArray(round1Winners);

    // 2回戦の組み合わせを作成 (シード vs 1回戦勝者)
    let newTeamsForRound2 = [];
    for (let i = 0; i < 8; i++) {
        newTeamsForRound2.push(shuffledSeeds[i]);
        newTeamsForRound2.push(shuffledWinners[i]);
    }
    newTeamsForRound2 = shuffleArray(newTeamsForRound2); // 組み合わせをシャッフル

    tournamentState.teams = newTeamsForRound2;
    tournamentState.matches = {};
    tournamentState.is16team = true;
    tournamentState.seeds = seedTeams; // 2回戦からシード校として表示

    const round2Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    // R1として試合IDを生成するが、これは大会の「2回戦」にあたる
    round2Setup.forEach((match, index) => {
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });
    
    // 敗退チームの成績を記録
    Object.values(tournamentState.teamRecords).forEach(record => {
        if (record.lastFinish > 16 && record.lastFinish <=32) record.lastFinish = 32; // 1回戦敗退はベスト32扱い
    });
    
// ▼▼▼ このブロックをまるごと置き換え ▼▼▼
    // --- 2回戦以降のスケジュールを割り当て (16チーム・新ルール版) ---
    const finalRoundSpring = 4;
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R1-')), // (R1 = 2回戦)
        ["4/15", "4/16"], ROUND_3_STADIUMS, 2 // 2回戦 (主要4球場) ※3回戦用球場を流用
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R2-')), 
        ["4/18"], FINAL_STAGE_STADIUMS, 4 // 準々決勝 (草薙で4試合)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R3-')), 
        ["4/21"], FINAL_STAGE_STADIUMS, 2 // 準決勝 (草薙で2試合)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('F-R1-')), 
        ["4/23"], FINAL_STAGE_STADIUMS, 1 // 決勝 (草薙で1試合)
    );
    // ▲▲▲ 置き換えここまで ▲▲▲
    renderTournament(tournamentState);
    saveState();

    // 2回戦の展望記事を生成
    newsContainer.innerHTML = `<div class="loader">AI記者が県大会2回戦の展望記事を執筆中...</div>`;
    // ★展望記事用の簡易contextを作成して渡す
    const previewContext = { matchId: 'preview' };
    const previewArticle = await generateNewsArticle(previewContext);
    if (previewArticle) tournamentState.news.unshift(previewArticle);
    if(previewArticle) 
        tournamentState.news.unshift(previewArticle);
    

    renderNews(tournamentState.news);
    saveState();
}


// --- AI Content Generation & Helpers (Part A: Main Generators) ---

/**
 * 試合の全情報を集約した「matchContext」オブジェクトを生成する司令塔
 * (★「故障者リスト(injuryReport)」の情報を追加)
 */
function createMatchContext(matchId, winnerName, team1QualityText, team2QualityText) {
    const dbMatch = findMatchById(matchId);
    if (!dbMatch) return null;

    const loserName = dbMatch.team1 === winnerName ? dbMatch.team2 : dbMatch.team1;
    const nextOpponentInfo = findNextOpponent(winnerName, matchId);
    let nextOpponentJourney = null;
    if (nextOpponentInfo && nextOpponentInfo.opponentName && !['（未定）', '優勝'].includes(nextOpponentInfo.opponentName)) {
        nextOpponentJourney = getCurrentTournamentPerformance(nextOpponentInfo.opponentName, matchId);
    }

    const { highlights, keyPlayerNames } = createHighlightsText(dbMatch, winnerName);
    
    // (Gamelog収集ロジックは変更なし)
    let pitcherGamelogInfo = "\n### 参考情報：今大会の主な投手登板履歴 (この試合より前)\n";
    let relevantLogsFound = false;
    const parseDate = (dateStr) => {
        if (!dateStr || !dateStr.includes('/')) return null;
        const [month, day] = dateStr.split('/').map(Number);
        const year = tournamentState.tournamentYear + (month <= 3 ? 1 : 0);
        return new Date(year, month - 1, day);
    };
    const today = parseDate(dbMatch.schedule?.date);
    if (dbMatch.details && dbMatch.details.pitching) {
        for (const teamKey of ['team1', 'team2']) {
            const pitchingData = dbMatch.details.pitching[teamKey] || [];
            pitchingData.forEach(pitcher => {
                const playerName = pitcher.name;
                if (!playerName) return;
                const teamRecord = tournamentState.teamRecords[dbMatch[teamKey]];
                const pStats = teamRecord?.playerStats?.pitching[playerName];
                if (pStats && pStats.gamelogs && pStats.gamelogs.length > 0) {
                    const currentTournamentKey = tournamentState.currentTournament;
                    const previousLogs = pStats.gamelogs.filter(log => {
                        if (log.matchId === matchId) return false;
                        const logRound = log.round || '';
                        if (currentTournamentKey === 'summer') return logRound.includes('回戦') || logRound.includes('決勝');
                        if (currentTournamentKey === 'autumn') return logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                        if (currentTournamentKey === 'spring') return logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                        return false;
                    });
                    if (previousLogs.length > 0) {
                        relevantLogsFound = true;
                        pitcherGamelogInfo += `- ${playerName} (${dbMatch[teamKey]}):\n`;
                        previousLogs.sort((a, b) => (parseDate(a.date) || 0) - (parseDate(b.date) || 0));
                        previousLogs.forEach(log => {
                            let dateInfo = log.date || '日付不明';
                            if (today) {
                                const logDate = parseDate(log.date);
                                if (logDate) {
                                    const diffDays = Math.ceil(Math.abs(today - logDate) / (1000 * 60 * 60 * 24)) - 1;
                                    if (diffDays === 0) dateInfo = `${log.date} (連投)`;
                                    else if (diffDays === 1) dateInfo = `${log.date} (中1日)`;
                                    else if (diffDays > 0) dateInfo = `${log.date} (中${diffDays - 1}日)`;
                                }
                            }
                            const opponentRank = log.opponentRank || 'E';
                            const resultMark = {'W': '○', 'L': '●', 'S': 'Ｓ', 'H': 'Ｈ'}[log.result] || '';
                            pitcherGamelogInfo += `  - ${log.round} (${dateInfo}) (対 ${log.opponent} [${opponentRank}]): ${resultMark}${log.ip}回 ${log.h}被安打 ${log.bb}四球 ${log.so}奪三振 ${log.r}失点(自責${log.er})\n`;
                        });
                    }
                }
            });
        }
    }
    if (!relevantLogsFound) {
        pitcherGamelogInfo = "\n### 参考情報：今大会の主な投手登板履歴\n- この試合に出場した投手は、全員今大会これが初登板です。\n";
    }
    let batterGamelogInfo = "\n### 参考情報：今大会の主な打者成績履歴 (この試合より前)\n";
    let relevantBatterLogsFound = false;
    const today_batter = parseDate(dbMatch.schedule?.date);
    if (dbMatch.details && dbMatch.details.batting) {
        for (const teamKey of ['team1', 'team2']) {
            const battingData = dbMatch.details.batting[teamKey] || [];
            battingData.forEach(batter => {
                const playerName = batter.name;
                if (!playerName) return;
                const teamRecord = tournamentState.teamRecords[dbMatch[teamKey]];
                const bStats = teamRecord?.playerStats?.batting[playerName];
                if (bStats && bStats.gamelogs && bStats.gamelogs.length > 0) {
                    const currentTournamentKey = tournamentState.currentTournament;
                    const previousLogs = bStats.gamelogs.filter(log => {
                        if (log.matchId === matchId) return false;
                        const logRound = log.round || '';
                        if (currentTournamentKey === 'summer') return logRound.includes('回戦') || logRound.includes('決勝');
                        if (currentTournamentKey === 'autumn') return logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                        if (currentTournamentKey === 'spring') return logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                        return false;
                    });
                    if (previousLogs.length > 0) {
                        relevantBatterLogsFound = true;
                        batterGamelogInfo += `- ${playerName} (${dbMatch[teamKey]}):\n`;
                        previousLogs.sort((a, b) => (parseDate(a.date) || 0) - (parseDate(b.date) || 0));
                        previousLogs.forEach(log => {
                            let dateInfo = log.date || '日付不明';
                            const opponentRank = log.opponentRank || 'E';
                            const stats = log.stats || { ab: 0, h: 0, hr: 0, rbi: 0, sb: 0 };
                            let role = "";
                            if (log.sub_type === 'PH') role = "代打";
                            else if (log.order && log.order.includes('sub')) role = "途中出場";
                            else if (log.order) role = `${log.order}番`;
                            else role = "出場";
                            const statsLine = `${stats.ab}打数${stats.h}安打 ${stats.hr}HR ${stats.rbi}打点 ${stats.sb}盗塁`;
                            batterGamelogInfo += `  - ${log.round} (${dateInfo}) (対 ${log.opponent} [${opponentRank}]) (${role}): ${statsLine}\n`;
                        });
                    }
                }
            });
        }
    }
    if (!relevantBatterLogsFound) {
        batterGamelogInfo = "\n### 参考情報：今大会の主な打者成績履歴\n- この試合に出場した打者は、全員今大会これが初出場です。\n";
    }

    // ★★★ ここからが新ロジック (故障者リストの生成) ★★★
    let injuryReportText = "\n### 参考情報：主な欠場者\n";
    let injuriesFound = false;
    for (const teamName of [winnerName, loserName]) {
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord || !teamRecord.playerStats) continue;
        
        let injuredPlayers = [];
        
        // 1. 打撃名簿をスキャン
        if (teamRecord.playerStats.batting) {
            for (const playerName in teamRecord.playerStats.batting) {
                const flag = teamRecord.playerStats.batting[playerName].narrative_flag;
                if (flag === 'injured' || flag === 'sick') {
                    injuredPlayers.push(playerName);
                }
            }
        }
        // 2. 投手名簿をスキャン
        if (teamRecord.playerStats.pitching) {
            for (const playerName in teamRecord.playerStats.pitching) {
                const flag = teamRecord.playerStats.pitching[playerName].narrative_flag;
                if (flag === 'injured' || flag === 'sick') {
                    injuredPlayers.push(playerName);
                }
            }
        }
        
        // 重複を削除し、テキストに追加
        if (injuredPlayers.length > 0) {
            injuryReportText += `- **${teamName}**: ${[...new Set(injuredPlayers)].join(', ')} (故障/体調不良 🏥)\n`;
            injuriesFound = true;
        }
    }
    if (!injuriesFound) {
        injuryReportText += "両チームともに、特筆すべき故障者や体調不良者はいません。\n";
    }
    // ★★★ 新ロジックここまで ★★★

    const context = {
        winnerName,
        loserName,
        dbMatch,
        matchId,
        winnerData: TEAM_DATA[winnerName],
        loserData: TEAM_DATA[loserName],
        winnerDetailedData: DETAILED_TEAM_DATA[winnerName],
        loserDetailedData: DETAILED_TEAM_DATA[loserName],
        playerStatsText: dbMatch.details ? formatPlayerStatsForPrompt(dbMatch) : null,
        winnerJourney: getCurrentTournamentPerformance(winnerName, matchId),
        loserJourney: getCurrentTournamentPerformance(loserName, matchId),
        winnerLineupChanges: dbMatch.details ? analyzeLineupChanges(winnerName, dbMatch) : "比較データなし",
        loserLineupChanges: dbMatch.details ? analyzeLineupChanges(loserName, dbMatch) : "比較データなし",
        nextOpponent: nextOpponentInfo,
        nextOpponentJourney: nextOpponentJourney,
        highlights: highlights,
        keyPlayerNames: keyPlayerNames,
        calledGame: dbMatch.calledGame,
        calledInning: dbMatch.calledInning,
        rivalryType: dbMatch.rivalryType || null,
        atmosphere_team1: dbMatch.atmosphere_team1 || null,
        atmosphere_team2: dbMatch.atmosphere_team2 || null,
        schedule: dbMatch.schedule || null,
        team1BallQuality: team1QualityText || "（打球品質データなし）",
        team2BallQuality: team2QualityText || "（打球品質データなし）",
        pitcherGamelogInfo: pitcherGamelogInfo,
        batterGamelogInfo: batterGamelogInfo,
        injuryReport: injuryReportText // ★ 新しいプロパティとして追加
    };
    return context;
}
// ▲▲▲ 置き換えここまで ▲▲▲


/**
 * [新ロジック] 前試合とのスタメンを比較し、「復帰」「初スタメン」「スタメン落ち」を分析する
 * @param {string} teamName - 分析対象のチーム名
 * @param {object} dbMatch - 現在の試合オブジェクト
 * @returns {string} - 変更点をまとめた短いテキスト (例: "鈴木がスタメン復帰、田中が今大会初スタメン")
 */
function analyzeLineupChanges(teamName, dbMatch) {
    const teamKey = dbMatch.team1 === teamName ? 'team1' : 'team2';
    if (!dbMatch.details || !dbMatch.details.batting || !dbMatch.details.batting[teamKey]) {
        return "比較データなし";
    }

    // 1. 現在のスタメンを取得
    const currentStarters = dbMatch.details.batting[teamKey]
        .filter(p => p.name && p.order && !p.order.toString().includes('sub'))
        .map(p => p.name);
    
    // 2. 「これまでの全試合」のスタメン履歴を取得
    const history = getStarterHistory(teamName, dbMatch.id);

    // 3. 履歴がない場合 (今大会初戦)
    if (history.length === 0) {
        return "今大会初スタメン。";
    }

    // 4. 履歴から「直前の試合のスタメン」と「過去に一度でもスタメンだったか」のリストを作成
    const lastGameStarters = new Set(history[history.length - 1].starters);
    const allPastStarters = new Set(history.flatMap(game => game.starters));

    const changes = [];

    // 5. 現在のスタメンを分析
    currentStarters.forEach(playerName => {
        if (!lastGameStarters.has(playerName)) {
            // 直前の試合にいなかった
            if (allPastStarters.has(playerName)) {
                // ...でも過去にはスタメンだった → 復帰
                changes.push(`${playerName}がスタメン復帰`);
            } else {
                // ...かつ過去にも一度もスタメンでない → 今大会初
                changes.push(`${playerName}が今大会初スタメン`);
            }
        }
    });

    // 6. 直前のスタメンを分析
    lastGameStarters.forEach(playerName => {
        if (!currentStarters.includes(playerName)) {
            // 直前の試合にいたのに、現在はいない → スタメン落ち
            changes.push(`${playerName}がスタメン落ち`);
        }
    });

    if (changes.length === 0) {
        return "前試合からスタメン変更なし。";
    }
    
    // 変更点を「復帰」→「初スタメン」→「落ち」の順に並べ替えて分かりやすくする
    changes.sort((a, b) => {
        if (a.includes('復帰')) return -1;
        if (b.includes('復帰')) return 1;
        if (a.includes('初スタメン')) return -1;
        if (b.includes('初スタメン')) return 1;
        return 0;
    });

    return `主な変更点: ${changes.join('、')}。`;
}
// ▲▲▲ 置き換えここまで ▲▲▲
/**
 * 打席結果の文字列を、シミュレーションで使える日本語とデータに変換する
 */
function translatePlay(atBatString) {
    if (!atBatString) return { description: "記録なし", type: "none", out: false, base: 0 };
    
    const s = atBatString;
    if (s.includes('本塁打')) return { description: `ホームラン`, type: "hr", out: false, base: 4 };
    if (s.includes('三塁打')) return { description: `三塁打`, type: "triple", out: false, base: 3 };
    if (s.includes('二塁打')) return { description: `二塁打`, type: "double", out: false, base: 2 };
    if (s.includes('安')) return { description: `ヒット`, type: "single", out: false, base: 1 };
    
    if (s.includes('四球') || s.includes('死球') || s.includes('敬遠')) return { description: `四死球`, type: "walk", out: false, base: 1 };
    if (s.includes('エラー') || s.includes('野選') || s.includes('犠失')) return { description: `エラー/野選`, type: "error", out: false, base: 1 };

    if (s.includes('犠飛')) return { description: `犠牲フライ`, type: "sac_fly", out: true, base: 0 };
    if (s.includes('犠打')) return { description: `犠牲バント`, type: "sac_bunt", out: true, base: 0 };
    if (s.includes('併殺')) return { description: `併殺打`, type: "dp", out: true, base: 0 }; // 2アウトは別途処理

    if (s.includes('三振')) return { description: `三振`, type: "so", out: true, base: 0 };

// ▼▼▼ この if ブロックをまるごと追加 ▼▼▼
    if (s.includes('邪')) return { description: `ファウルフライ`, type: "ff", out: true, base: 0 };
    // ▲▲▲ 追加ここまで ▲▲▲

    if (s.includes('ゴロ')) return { description: `ゴロ`, type: "go", out: true, base: 0 };
    if (s.includes('飛')) return { description: `フライ`, type: "fo", out: true, base: 0 };
    if (s.includes('直')) return { description: `ライナー`, type: "lo", out: true, base: 0 };
    
    return { description: `その他`, type: "other", out: false, base: 0 };
}

/**
 * 1イニング分の試合経過をシミュレートし、テキストを生成する
 */
function processHalfInning(dbMatch, teamKey, inningIndex, batterIndices) {
    let halfInningText = "";
    let outs = 0;
    let bases = [null, null, null]; // [1B, 2B, 3B]
    
    const battingOrder = dbMatch.details.batting[teamKey].filter(p => p.name).sort((a,b) => a.order - b.order);
    if (battingOrder.length === 0) return "";
    
    let batterIndex = batterIndices[teamKey];
    let atBatsInInning = 0;

    while (outs < 3) {
        const batter = battingOrder[batterIndex];
        const resultString = batter.results[inningIndex] || "";
        const atBatsForPlayer = resultString.split('、');

        // このイニングでこの打者がまだ打席に立っていない場合はループを抜ける
        if (atBatsForPlayer.length <= atBatsInInning) break; 
        
        const currentAtBatString = atBatsForPlayer[atBatsInInning];
        if(!currentAtBatString) break;

        const play = translatePlay(currentAtBatString);
        
        // 1. 打席結果をテキストに追加
        halfInningText += `${batter.order}番 ${batter.name} (${batter.pos}): ${play.description}\n`;

        // 2. アウトカウントを更新
        if(play.out) outs++;
        if(play.type === 'dp') outs++; // 併殺打

        if (outs >= 3) {
            halfInningText += `  → ${outs}アウト\n`;
            batterIndex = (batterIndex + 1) % battingOrder.length;
            break;
        }
        
        // 3. ランナーを進塁させる（簡易ロジック）
        const newBases = [null, null, null];
        let batterOnBase = false;

        // まずランナーを進める (3塁から)
        if (bases[2]) { // 3塁ランナー
            if (play.base >= 1 || play.type === 'sac_fly' || play.type === 'walk') newBases[2] = null; // 生還
            else newBases[2] = bases[2];
        }
        if (bases[1]) { // 2塁ランナー
            if (play.base >= 2) newBases[1] = null; // 生還
            else if (play.base === 1 || play.type === 'sac_bunt') newBases[2] = bases[1];
            else newBases[1] = bases[1];
        }
        if (bases[0]) { // 1塁ランナー
            if (play.base >= 3) newBases[0] = null; // 生還
            else if (play.base === 2) newBases[2] = bases[0];
            else if (play.base === 1 || play.type === 'sac_bunt' || play.type === 'walk') newBases[1] = bases[0];
            else newBases[0] = bases[0];
        }
        
        // 打者走者を塁に出す
        if (!play.out && play.base > 0) {
            newBases[play.base - 1] = batter.name;
        }

        bases = newBases;
        
        // 4. 現在の状況をテキストに追加
        const runners = [];
        if(bases[0]) runners.push("1塁");
        if(bases[1]) runners.push("2塁");
        if(bases[2]) runners.push("3塁");
        const runnerText = runners.length > 0 ? `ランナー${runners.join(', ')}` : "ランナーなし";
        halfInningText += `  → ${outs}アウト, ${runnerText}\n`;
        
        batterIndex = (batterIndex + 1) % battingOrder.length;
        atBatsInInning++;
    }

    batterIndices[teamKey] = batterIndex; // 次のイニングの先頭打者を記憶
    
    if (outs < 3) {
      halfInningText += `(${outs}アウトでイニング終了)\n`;
    }
    
    halfInningText += "チェンジ\n";
    return halfInningText;
}

/**
 * 全イニングの試合経過テキストを生成するマスター関数
 */
function generatePlayByPlayText(dbMatch) {
    if (!dbMatch || !dbMatch.details) return "詳細な試合データがありません。";

    let playByPlay = "";
    const numInnings = dbMatch.details.inningScore?.team1?.length || 9;
    // 各チームの次の先頭打者を記録するオブジェクト
    let batterIndices = { team1: 0, team2: 0 };

    for (let i = 0; i < numInnings; i++) {
        // 表の攻撃
        playByPlay += `\n【${i + 1}回表】${dbMatch.team1}の攻撃\n`;
        playByPlay += processHalfInning(dbMatch, 'team1', i, batterIndices);
        
        // サヨナラゲームの判定
        if (i >= 8) { // 9回表以降
            const score1 = (dbMatch.details.inningScore.team1 || []).slice(0, i + 1).reduce((a, b) => a + (b || 0), 0);
            const score2 = (dbMatch.details.inningScore.team2 || []).slice(0, i + 1).reduce((a, b) => a + (b || 0), 0);
            if (dbMatch.team2 === dbMatch.winner && score2 > score1) {
                 break;
            }
        }

        // 裏の攻撃
        playByPlay += `\n【${i + 1}回裏】${dbMatch.team2}の攻撃\n`;
        playByPlay += processHalfInning(dbMatch, 'team2', i, batterIndices);
    }

    playByPlay += "\n--- 試合終了 ---\n";
    return playByPlay;
}

/**
 * Finds a specific team's final result in the tournament.
 */
function getTeamFateSummary(teamName) {
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            if (match.winner !== teamName) {
                const opponent = match.winner;
                const score1 = match.team1 === teamName ? match.score1 : match.score2;
                const score2 = match.team1 === teamName ? match.score2 : match.score1;
                const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 1;
                return `${roundNum}回戦で${opponent}に${score1}-${score2}で敗退した。`;
            }
        }
    }
    
    // Check if the team is still in the tournament
    const isStillIn = Object.values(allMatches).some(match => !match.winner && (match.team1 === teamName || match.team2 === teamName));
    if(isStillIn) {
        return "まだ勝ち残っている。";
    }

    return "（今大会には出場していないか、情報がありません）";
}
   



/**
     * チームの紹介文を動的に生成する最終進化版。
     * TEAM_DATAの固定情報に、最新の成績情報を付け加える。
     * (★ チームの「通算」打率・盗塁数の集計を追加 ★)
     * @param {string} teamName - チーム名
     * @param {object} teamData - TEAM_DATAから取得したそのチームの基本情報
     * @param {object} teamRecord - tournamentState.teamRecordsから取得したそのチームの成績記録
     * @returns {string} - 生成された最新の紹介文
     */
    function generateDynamicTeamInfo(teamName, teamData, teamRecord) {
        if (!teamData) {
            console.error(`TEAM_DATAにチーム「${teamName}」が見つかりません。名前のタイプミスがないか確認してください。`);
            return `${teamName}のチーム情報が見つかりませんでした。`;
        }
        
        const baseInfo = teamData.info || `${teamName}の情報は不明です。`;

        // チームの成績記録がまだない（＝1年目の途中など）場合は、基本情報だけを返す
        if (!teamRecord || !teamRecord.history || teamRecord.history.length === 0) {
            return baseInfo;
        }

        const history = teamRecord.history;

        // --- ここからが追加情報の生成 ---
        let additionalNarrative = []; // 追加情報を入れる配列

        // 創部年数を計算 (2年目以降に意味を持つ情報)
        if (history.length > 0) {
            const establishedYear = history[history.length - 1].year;
            const yearsPassed = tournamentState.tournamentYear - establishedYear + 1;
            if (yearsPassed > 1) {
                additionalNarrative.push(`創部${yearsPassed}年目。`);
            }
        }
        
        // 直近の大会の成績
        const prevRankLabel = teamRecord.previousRank ? getRankString(teamRecord.previousRank) : null;
        if (prevRankLabel && prevRankLabel !== 'なし') {
            additionalNarrative.push(`前大会は${prevRankLabel}。`);
        }

        // 過去最高成績
        const bestFinishLabel = teamRecord.best?.rank ? getRankString(teamRecord.best.rank) : null;
        if (bestFinishLabel && bestFinishLabel !== 'なし') {
            additionalNarrative.push(`過去最高は${bestFinishLabel}。`);
        }

        // 称号（Traits）
        if (teamRecord.teamTraits && teamRecord.teamTraits.length > 0) {
            teamRecord.teamTraits.forEach(traitId => {
                const trait = Object.values(TITLES).find(t => t.id === traitId);
                if (trait) {
                    additionalNarrative.push(`「${trait.name}」。`);
                }
            });
        }

        // 今大会のチーム打率を追加
        const tourneyStats = teamRecord.tournamentStats;
        if (tourneyStats && tourneyStats.ab > 5) { 
            const avg = (tourneyStats.h / tourneyStats.ab).toFixed(3);
            additionalNarrative.push(`今大会のチーム打率は${avg}。`);
        }

        // ▼▼▼ このブロックをまるごと追加 ▼▼▼
        // (今大会とは別に)「通算」のチーム成績も集計
        const careerBattingStats = teamRecord.playerStats?.batting;
        if (careerBattingStats) {
            let totalCareerAb = 0;
            let totalCareerH = 0;
            let totalCareerSb = 0;
            
            for (const playerName in careerBattingStats) {
                const stats = careerBattingStats[playerName];
                totalCareerAb += stats.ab || 0;
                totalCareerH += stats.h || 0;
                totalCareerSb += stats.sb || 0; // ★通算盗塁を集計
            }

            if (totalCareerAb > 10) { // チーム通算打数がある程度ある場合
                const careerAvg = (totalCareerH / totalCareerAb).toFixed(3);
                // ★通算盗塁も情報に追加
                additionalNarrative.push(`(参考: チーム通算打率 ${careerAvg}, 通算 ${totalCareerSb} 盗塁)`); 
            }
        }
        // ▲▲▲ 追加ここまで ▲▲▲

        // --- 最終的な紹介文の組み立て ---
        if (additionalNarrative.length > 0) {
            return `${baseInfo} ${additionalNarrative.join(' ')}`;
        } 
        else {
            return baseInfo;
        }
    }
 
/**
 * 選手の出場形式コードを、記事で使える自然な日本語に変換する（翻訳機）
 * @param {object} player - 選手のデータオブジェクト
 * @returns {string} - 出場形式を説明する文章
 */
function getSubstitutionDescription(player) {
    // 交代選手でない（スタメン）場合は "スタメン出場" とする
    if (!player.sub_type) {
        return 'スタメン出場';
    }

    // sub_typeの値に応じて、返す文章を切り替える
    switch (player.sub_type) {
        case 'PH':
            return '代打で出場';
        case 'PR':
            return '代走で出場';
        case 'DEF':
            return '守備固めで出場';
        // ▼▼▼ ADD THIS CASE ▼▼▼
        case 'PITCHER': return 'リリーフとして登板';
        // ▲▲▲ END OF ADDITION ▲▲▲
        default:
            return '途中出場'; // 何らかの理由でsub_typeが上記以外の場合
    }
}

/**
 * 試合の個人成績をAIプロンプト用のテキスト形式にフォーマットする
 * (★選手の「今大会の通算成績」サマリーを追加した最終版)
 * @param {object} dbMatch - 試合オブジェクト
 * @returns {string} - フォーマットされたテキスト
 */
function formatPlayerStatsForPrompt(dbMatch) {
    if (!dbMatch || !dbMatch.details || !dbMatch.details.playerGameStats) {
        return '詳細な個人成績データはありません。';
    }

    const { details, winner } = dbMatch;

    const formatTeamStats = (teamKey) => {
        const teamName = dbMatch[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName]; 
        const isWinner = teamName === winner;
        const battingOrder = details.batting?.[teamKey] || [];
        const gameStats = details.playerGameStats?.[teamKey] || {};
        const pitchingData = details.pitching?.[teamKey] || [];

        let output = `\n**${teamName} (${isWinner ? '勝者' : '敗者'})**\n`;

        const sortedBatters = battingOrder.sort((a, b) => {
            const orderA = parseFloat(a.order.replace('-sub', '.'));
            const orderB = parseFloat(b.order.replace('-sub', '.'));
            return orderA - orderB;
        });

        sortedBatters.forEach(player => {
            if (!player.name) return;
            const stats = gameStats[player.name]; // この試合の成績
            
            // ★ (stats.played=true) だけでなく、盗塁(sb>0)や守備交代(DEF)なども含める
            const isNonBattingSub = player.sub_type === 'DEF' || player.sub_type === 'PR';
            if (!stats || (!stats.played && (stats.sb || 0) === 0 && !isNonBattingSub)) return; 

            const careerStats = teamRecord?.playerStats?.batting[player.name]; // 通算/Gamelog保持オブジェクト
            let statusText = "";
            if (careerStats && careerStats.narrative_flag) {
                const flagMap = {
                    "hot_streak": "絶好調", "powered_up": "一発警戒",
                    "clutch_hitter": "勝負強さ◎", "slumping": "不振"
                };
                statusText = ` (状態: ${flagMap[careerStats.narrative_flag] || careerStats.narrative_flag})`;
            }

            let batHandText = "";
            if (player.throwBat) {
                if (player.throwBat.endsWith('/R')) batHandText = "（右打）";
                else if (player.throwBat.endsWith('/L')) batHandText = "（左打）";
                else if (player.throwBat.endsWith('/S')) batHandText = "（両打）";
            }            

            // ★★★ ここからが修正箇所 ★★★
            // 選手の「今大会」の通算成績を Gamelog から集計する
            let tournamentTotalStatsText = "";
            if (careerStats && careerStats.gamelogs && careerStats.gamelogs.length > 0) {
                let tourneyStats = { sb: 0, hr: 0, h: 0, ab: 0 };
                const currentTournamentKey = tournamentState.currentTournament;
                
                careerStats.gamelogs.forEach(log => {
                    // このトーナメントのGamelogだけを抽出 (この試合(dbMatch.id)は除く)
                    const logRound = log.round || '';
                    let isInThisTournament = false;
                    if (currentTournamentKey === 'summer') isInThisTournament = logRound.includes('回戦') || logRound.includes('決勝');
                    else if (currentTournamentKey === 'autumn') isInThisTournament = logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                    else if (currentTournamentKey === 'spring') isInThisTournament = logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                    
                    if (isInThisTournament && log.matchId !== dbMatch.id) { // この試合より「前」の成績
                        tourneyStats.sb += log.stats?.sb || 0;
                        tourneyStats.hr += log.stats?.hr || 0;
                        tourneyStats.h += log.stats?.h || 0;
                        tourneyStats.ab += log.stats?.ab || 0;
                    }
                });
                
                // 「この試合」の成績(stats)を加算
                const thisGameSB = stats.sb || 0;
                const thisGameHR = stats.hr || 0;
                
                const finalTourneySB = tourneyStats.sb + thisGameSB;
                const finalTourneyHR = tourneyStats.hr + thisGameHR;
                const finalTourneyH = tourneyStats.h + (stats.h || 0);
                const finalTourneyAB = tourneyStats.ab + (stats.ab || 0);
                const finalTourneyAvg = finalTourneyAB > 0 ? (finalTourneyH / finalTourneyAB).toFixed(3) : ".---";

                // AIに渡すためのテキストを作成
                tournamentTotalStatsText = ` (今大会: ${finalTourneyAvg}, ${finalTourneyHR}本, ${finalTourneySB}盗)`;
            }
            // ★★★ 修正ここまで ★★★

            const orderDisplay = player.order.includes('sub') ? `  - ${player.sub_type || '代'}` : `${player.order}.`;
            const playerIdentifier = `[#${player.number}] ${player.name}`; 
            
            const statsLine = `${stats.ab}打数${stats.h}安打 ${stats.rbi}打点` + 
                              (stats.hr > 0 ? ` ${stats.hr}本塁打` : '') + 
                              (stats.sb > 0 ? ` ${stats.sb}盗塁` : '');
            
            // ★ tournamentTotalStatsText を末尾に追加
            output += `${orderDisplay} ${playerIdentifier}${batHandText}${statusText}: ${statsLine}${tournamentTotalStatsText}\n`; 
        });
        
        pitchingData.forEach(pitcher => {
            // (投手成績のフォーマットは変更なし)
            if (!pitcher.name || !pitcher.innings) return;
            let statusText = "";
            const careerStats = teamRecord?.playerStats?.pitching[pitcher.name];
            if (careerStats && careerStats.narrative_flag) {
                 const flagMap = { "dominant": "圧巻", "seeking_redemption": "要修正", "tough_loss": "不運", "crafty_pitcher": "技巧派", "unlucky": "不運" };
                statusText = ` (状態: ${flagMap[careerStats.narrative_flag] || careerStats.narrative_flag})`;
            }
            let pitcherDesc = "";
            if (pitcher.throwBat) {
                if (pitcher.throwBat.startsWith('R')) pitcherDesc += "右";
                if (pitcher.throwBat.startsWith('L')) pitcherDesc += "左";
            }
            if (pitcher.throwStyle) {
                const styleMap = { "over": "オーバー", "three_quarter": "スリークォーター", "side": "サイド", "under": "アンダー" };
                pitcherDesc += `/${styleMap[pitcher.throwStyle] || pitcher.throwStyle}`;
            }
            if (pitcher.pitcherType) {
                const typeMap = { "honkaku": "本格派", "sokkyu": "速球派", "giko": "技巧派", "nanto": "軟投派" };
                pitcherDesc += `/${typeMap[pitcher.pitcherType] || pitcher.pitcherType}`;
            }
            if (pitcher.velocity) { pitcherDesc += `/${pitcher.velocity}`; }
            if (pitcherDesc) pitcherDesc = `（${pitcherDesc}）`;
            const pitcherData = sortedBatters.find(b => b.name === pitcher.name);
            const pitcherIdentifier = pitcherData ? `[#${pitcherData.number}] ${pitcher.name}` : pitcher.name;
            output += `- 投手: ${pitcherIdentifier}${pitcherDesc}${statusText} (${pitcher.innings}回 ${pitcher.runs}失点 ${pitcher.strikeouts}奪三振 ${pitcher.walks}四死球)\n`;
        });

        return output;
    };

    return formatTeamStats('team1') + formatTeamStats('team2');
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 試合の詳細データから、AIプロンプト用の個人成績ハイライトを生成する（★投手分析強化版）
 * @param {object} dbMatch - 試合オブジェクト
 * @returns {string} - "勝者・〇〇: 鈴木(4安打), 投手・田中(9回1失点, HQS達成). // 敗者・△△: ..."
 */
function extractKeyPerformances(dbMatch) {
    if (!dbMatch || !dbMatch.details || !dbMatch.details.playerGameStats) {
        return '詳細な個人成績データはありません。';
    }

    const { details, winner } = dbMatch;
    const winnerName = winner;
    const loserName = dbMatch.team1 === winner ? dbMatch.team2 : dbMatch.team1;

    const winnerKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
    const loserKey = dbMatch.team1 === loserName ? 'team1' : 'team2';

    const formatTeamPerformances = (teamKey) => {
        const teamName = dbMatch[teamKey];
        const performances = [];
        
        // 打撃成績の分析 (変更なし)
        const battingStats = details.playerGameStats?.[teamKey] || {};
        for (const playerName in battingStats) {
            const stats = battingStats[playerName];
            const playerHighlights = [];
            if (stats.h >= 3) playerHighlights.push(`${stats.h}安打`);
            if (stats.hr > 0) playerHighlights.push(`${stats.hr}本塁打`);
            if (stats.rbi >= 3) playerHighlights.push(`${stats.rbi}打点`);

            if (playerHighlights.length > 0) {
                const battingData = details.batting[teamKey].find(p => p.name === playerName);
                const order = battingData ? `${battingData.order}番` : '';
                performances.push(`${order}${playerName}(${playerHighlights.join(', ')})`);
            }
        }

        // ★★★ ここからが強化された投手分析ロジック ★★★
        const pitchingData = details.pitching?.[teamKey] || [];
        const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
        const opponentBattingData = details.batting?.[opponentTeamKey] || [];

        pitchingData.forEach(pitcher => {
            if (!pitcher.name) return;
            const pitcherHighlights = [];

            // 1. 基本的な投球結果を分析
            const innings = parseFloat(pitcher.innings || 0);
            const runs = parseInt(pitcher.runs || 0);
            const earnedRuns = parseInt(pitcher.earnedRuns || 0);
            const strikeouts = parseInt(pitcher.strikeouts || 0);
            const walks = parseInt(pitcher.walks || 0);
            const pitches = parseInt(pitcher.pitches || 0);

            // 従来の分析
            if (pitcher.result === 'W') {
                 if (innings >= 9 && earnedRuns === 0) pitcherHighlights.push('完封勝利');
                 else if (innings >= 9) pitcherHighlights.push('完投勝利');
            }
            if (strikeouts >= 10) pitcherHighlights.push(`${strikeouts}奪三振`);
            if (pitcher.result === 'L' && runs >= 5) pitcherHighlights.push(`${runs}失点炎上`);

            // 2. 新しい詳細分析
            if (pitches > 120) pitcherHighlights.push(`${pitches}球の熱投`);
            if (walks >= 5) pitcherHighlights.push(`与四球${walks}と制球難`);

            // 3. イニングごとの内容分析（主に先発投手を対象）
            if (innings >= 6 && opponentBattingData.length > 0) {
                let walksByInning = Array(9).fill(0);
                for (let i = 0; i < 9; i++) {
                    opponentBattingData.forEach(batter => {
                        const result = batter.results[i] || '';
                        if (result.includes('四球') || result.includes('死球')) {
                            walksByInning[i]++;
                        }
                    });
                }

                const earlyInningWalks = walksByInning.slice(0, 5).reduce((a, b) => a + b, 0);
                const lateInningWalks = walksByInning.slice(5, 9).reduce((a, b) => a + b, 0);

                if (lateInningWalks > earlyInningWalks && lateInningWalks >= 3) {
                    pitcherHighlights.push('終盤に制球を乱した');
                } else if (innings >= 7 && earnedRuns <= 2 && pitcher.result !== 'L') {
                    // 良い内容だった場合の評価
                    pitcherHighlights.push('試合を作った'); 
                }
            }
            
            if (pitcherHighlights.length > 0) {
                performances.push(`投手・${pitcher.name}(${pitcherHighlights.join(', ')})`);
            }
        });
        // ★★★ 投手分析ロジックはここまで ★★★

        return performances.length > 0 ? `${teamName}: ${performances.join(', ')}` : '';
    };

    const winnerPerf = formatTeamPerformances(winnerKey);
    const loserPerf = formatTeamPerformances(loserKey);

    return [winnerPerf, loserPerf].filter(Boolean).join(' // ');
}

/**
 * 密着取材型記者「羽田 雄平」のコラム記事を生成する
 * (★シードランク認識 最終版)
 * @param {object} matchContext - 試合の全コンテキストデータ
 * @returns {Promise<object|null>} 生成された記事オブジェクト
 */
async function generateHadaReport(matchContext) {
    // --- 1. contextから必要な情報を取り出す ---
    const { 
        winnerName, loserName, dbMatch, matchId, 
        playerStatsText, highlights, nextOpponent
    } = matchContext;

    const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const winnerData = TEAM_DATA[winnerName];
    const loserData = TEAM_DATA[loserName];
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);

    // ▼▼▼ シードランク取得を追加 ▼▼▼
    const winnerSeedRank = getSeedRankString(winnerName, tournamentState.seeds);
    const loserSeedRank = getSeedRankString(loserName, tournamentState.seeds);
    // ▲▲▲

    // --- 2. ラウンド名と次の相手を特定 ---
    let roundName = getRoundNameFromMatchId(matchId);

    // ▼▼▼ ここからが今回の修正箇所 ▼▼▼
    let nextOpponentText = '次戦の相手はまだ決まっていません。';
    if (nextOpponent) {
        if (nextOpponent.opponentName === '優勝') {
            nextOpponentText = (tournamentState.currentTournament === 'summer')
                ? '夏の甲子園出場が決定しました。'
                : '今大会、見事優勝を果たしました。';
        }
        else if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            const nextOpponentSeed = getSeedRankString(nextOpponent.opponentName, tournamentState.seeds);
            const rankText = nextOpponent.opponentRank ? `(${nextOpponent.opponentRank}ランク)` : '';
            nextOpponentText = `次戦は${nextOpponent.roundName}、${nextOpponent.opponentName}${nextOpponentSeed}${rankText}と対戦します。`;
        }
        else if (nextOpponent.decidingMatch) {
            const dm = nextOpponent.decidingMatch;
            nextOpponentText = `次戦は${nextOpponent.roundName}、${dm.team1}と${dm.team2}の勝者と対戦します。`;
        }
    }
    // ▲▲▲ 修正ここまで ▲▲▲
    // --- 3. ハイライトをテキスト化 ---
    const highlightsText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');

    // ... (scheduleText, ballQualityText の準備は変更なし) ...
    let scheduleText = '';
    let scheduleInstruction = '';
    if (matchContext.schedule) {
        const sched = matchContext.schedule;
        const team1Region = TEAM_DATA[dbMatch.team1]?.region || '不明';
        const team2Region = TEAM_DATA[dbMatch.team2]?.region || '不明';
        
        scheduleText = `\n- **試合会場:** ${sched.stadiumFull} (${sched.region}地区)\n`;
        
        if (sched.region === team1Region && sched.region !== team2Region) {
            scheduleText += `- **地の利:** ${dbMatch.team1}にとって地元球場での試合。`;
            scheduleInstruction = `**【地の利の分析】**: ${dbMatch.team1}にとって「地元球場」であったことが、試合にどう影響したか（例：大応援団の後押し、慣れたマウンドなど）を、あなたの視点で分析してください。`;
        } else if (sched.region !== team1Region && sched.region === team2Region) {
            scheduleText += `- **地の利:** ${dbMatch.team2}にとって地元球場での試合。`;
            scheduleInstruction = `**【地の利の分析】**: ${dbMatch.team2}にとって「地元球場」であったことが、試合にどう影響したか（例：大応援団の後押し、慣れたマウンドなど）を、あなたの視点で分析してください。`;
        }
    }
    let ballQualityText = '';
    if (matchContext.team1BallQuality && matchContext.team2BallQuality) {
        ballQualityText = `\n### データ3：チーム別 打球品質レポート\n- ${matchContext.team1BallQuality}\n- ${matchContext.team2BallQuality}\n`;
    }

    // ▼▼▼ 4. AIへのプロンプト（指示書）を修正 ▼▼▼
    const prompt = `あなたは「東海スポーツ」所属のスポーツライター「羽田 雄平」です。
あなたは今、${roundName}「${winnerName} vs ${loserName}」の試合を取材し終え、興奮冷めやらぬまま署名入りのコラム記事を執筆しています。
以下のデータに基づき、あなたの主観と分析を交えた「羽田 雄平スタイル」のナラティブな記事を生成してください。

### 参考情報：静岡県高校野球の「常識」（勢力図）
${PREFECTURE_LORE}
---
### 羽田 雄平の取材メモ
- **大会:** ${tournamentState.tournamentYear}年度 ${tournamentNameMap[tournamentState.currentTournament]} ${roundName}
- **対戦カード:** ${winnerName} ${winnerSeedRank} (ランク: ${winnerRank}) vs ${loserName} ${loserSeedRank} (ランク: ${loserRank})
- **結果:** ${winnerScore} - ${loserScore} で ${winnerName} が勝利。
${scheduleText} 
- **${winnerName}の背景:** ${winnerData.info}
- **${loserName}の背景:** ${loserData.info}
- **試合の決め手(ユーザー入力):** ${dbMatch.summary || '特になし'}
- **次の試合:** ${nextOpponentText}

### データ1：試合の主な出来事 (ハイライト)
${highlightsText}

### データ2：主な選手の個人成績 (ボックススコア)
${playerStatsText}


// ▼▼▼ このブロックを挿入 ▼▼▼
### データ3：今大会の主な投手登板履歴 (この試合より前)
${matchContext.pitcherGamelogInfo || '今大会、これが初登板です。'}
// ▲▲▲ 挿入ここまで ▲▲▲

### データ4：今大会の主な打者成績履歴 (この試合より前)
${matchContext.batterGamelogInfo || '打者の試合履歴データはありません。'}
// ▲▲▲
${ballQualityText.replace('データ3', 'データ5').replace('データ4', 'データ5')}

### 執筆指示
1.  **一人称で書く:** 必ず「私」を主語にし、個人的な感想（～驚きました、～でしょうね）を交えてください。
2.  **現場の空気感:** 試合当日の球場の雰囲気（観客の多さ、天候など）を描写してください。
    ${scheduleInstruction}
3.  **両チームの紹介:** 両チームの背景（「王者」「進学校」など）を紹介し、試合の位置づけを明確にしてください。
4.  **【★シードランク言及】**: **「第1シードの〇〇」**や**「シード校の△△が苦戦」**のように、シードランクにも具体的に言及し、試合の文脈を明確にしてください。
5.  **【囲み取材】**: 記事の本文中に、あなたが試合後に直接取材した選手（例：ヒーローとなった〇〇くんや、敗れた△△くん）の**「生々しいコメント」**を必ず含めてください。
6.  **ターニングポイントの特定:** 試合が動いたイニング（例：3回）やプレーを特定し、そこを詳細に描写してください。
7.  **選手への言及**: 「データ2」の選手名を引用し、「〇〇くん」と呼称してください。**もしその選手の背番号（[#X]）が戦術や物語の上で重要だとあなたが判断した場合**、その背番号にも触れてください。#は背番号と言い換えてください。(例S1→背番号1)
8.  **【投手の詳細分析】**: 「データ2（ボックススコア）」に記載されている**投手の詳細属性（例：右/オーバー/本格派/150km帯）**にも注目し、その投手のタイプが試合にどう影響したかを分析してください。
9.  **試合後の情報:** 試合後の選手のコメント（例：「コントロールを重視した」）を（架空で）挿入してください。
10. **次戦への言及:** 記事の最後に、次の対戦相手（${nextOpponentText}）に触れて締めくってください。
11. **【選手の背景創作】**: もし詳細な選手プロフィールがない無名の選手について書く場合、あなたが長年の取材でその選手を知っているという記者視点で、**それらしい架空の経歴や特徴を自由に付け加えてください。**
12. **【常識の反映】**: あなたが熟知している「常識」（例：ナムコグループの台頭、公立の砦・静岡の苦戦）を、目の前の試合結果と関連付けて分析してください。
13. **【打球の質の分析】**: 「データ1（ハイライト）」や「データ2（ボックススコア）」、「データ3（打球品質レポート）」にある**打球の質**（「鋭い当たり」「詰まった当たり」など）を重視し、結果と内容が一致しない（例：4タコだが全部鋭い当たり）選手の評価にも言及してください。
14. **【打順の役割】**: **打順の役割**も重視してください。4番が4番の仕事をしたのか、あるいは9番が意外な活躍でラッキーボーイとなったのか、といった戦術的な分析をコラムに含めてください。
15. **【投手の左右】**: ボックススコアに「（右腕）」「（左腕）」の表記がある場合、それを記事に反映させること。
16. **【★注目の打席（最重要）】**:
        - 「データ1（ハイライト）」に「（★注目）」というマークが付いている打席があります。これは**ユーザー（監督）が『試合の分水嶺』だと判断した**、最も重要な打席です。
        - あなたのコラムでは、**この記事の中心的なハイライト**として、この「★注目」の打席の前後を、最もドラマチックに描写してください。
17. **【★盗塁への言及 (重要)】**:
    - 「データ2（ボックススコア）」に**盗塁(SB)**が記録されている選手がいた場合、その選手の機動力（例：「〇〇が足でチャンスを広げ」）に言及してください。
    - さらに、その選手の**「今大会の通算盗塁数」**（例：(今大会: ... 4盗)）も必ず参照し、**「〇〇はこれで今大会4個目の盗塁。彼の足は本物だ」**といった具体的な数字を記事に含めてください。
    - **盗塁が0だった場合、それについて批判的な言及（例：「なぜ走らない」）は不要です。**18.  **【★スタメン復帰】**: 「スタメン変更」情報（取材メモ外の別データとして提供）に「〇〇がスタメン復帰」とあった場合、**「監督の賭けが当たった」**という視点で、その選手の活躍（あるいは不振）をあなたの主観で分析してください。
19.  **【★登板履歴への言及】**: 「データ3：今大会の主な投手登板履歴」が提供されている場合、その情報（例：連投の疲れ、前回の雪辱）もあなたの分析に加えてください。
// ▼▼▼ この 2 つの指示ブロックを追加 (番号は 10, 11 になります) ▼▼▼
20. **【連投・酷使の分析】**: 「データ3：登板履歴」を見て、もし投手が「連投」や「中1日」であったり、今大会で「投げすぎ（酷使）」の状態であったりした場合、それが今日の投球にどう影響したか、あなたの鋭い視点で分析してください。（例：「昨日120球を投げた腕で、今日も140km/hを計測するとは…彼の肩は一体どうなっているんだ」）
21. **【雪辱と真価】**: もし投手が「登板履歴」で「前回炎上」していた場合、今日の投球が「雪辱」のマウンドであったことに触れてください。逆に、これまで「格下相手」にしか投げていなかった場合、今日の試合が「真価を問うマウンド」であったと分析してください。
// ▲▲▲ 追加ここまで ▲▲▲
// ▼▼▼ 挿入 ▼▼▼
22. **【★打者の好不調の波】**: 「データ4：打者成績履歴」を熟読し、選手の**連続ヒット**や**連続無安打**の「波」に言及してください。（例：「1回戦で4タコだった〇〇くんが、今日はまるで別人のようだった」「△△くんはこれで3試合連続ヒット。完全に掴んだようだね」）
23. **【★打者の役割分析】**: もし選手が**「代打」**で結果を出し続けていたり、**「打順変更」**で調子を上げていたりする場合、その采配と選手の適応力をあなたの視点で分析してください。
// ▲▲▲
24. **【★今大会の成績 (最重要)】**:
    - 「データ5：チーム別 打球品質」の**『今大会のチーム打率は.XXX』**（※これはチーム背景情報の間違い）...
    - （※プロンプトの記述ミスはAIが自己修正するので、ここではgenerateDynamicTeamInfoの情報を指していると解釈します）
    - （※この指示はgenerateNewsArticleのものとほぼ同じなので、AIはplayerStatsTextにある今大会:のサマリーも参照します）
### 出力形式【厳守】
- **【最重要】** あなたの応答は、必ず単一のJSONオブジェクト"のみ"でなければなりません。
- **絶対に**、JSONの前後に「はい、記事です」や「\`\`\`json」などのテキストを付け加えてはいけません。
{"title": "（例：王者283学園、圧巻のコールド発進！ 羽田雄平が見た『格の違い』）", "body": "（ここに羽田 雄平スタイルの記事本文）"}
`;
    // ▲▲▲ プロンプト修正ここまで ▲▲▲

    // --- 5. AIへのリクエスト ---
    try {
        // ... (try-catchブロックは変更なし) ...
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
            const rawTextFromAi = result.candidates[0].content.parts[0].text;
            const article = parseJsonFromText(rawTextFromAi);
            
            if (article && article.title && article.body) {
                article.body += "\n\n　東海スポーツ　羽田雄平";
                return { 
                    ...article, 
                    timestamp: Date.now(), 
                    context: matchContext, 
                    isHadaReport: true 
                };
            } else {
                 console.error("parseJsonFromText failed for HadaReport:", rawTextFromAi);
                 throw new Error("AI response format error after parsing (HadaReport).");
            }
        } else {
             console.error("Unexpected AI response structure (HadaReport):", result);
             throw new Error("AI response structure is missing expected parts (HadaReport).");
        }
    } catch (error) {
        console.error("羽田レポートの生成に失敗しました:", error);
        return { 
            title: "羽田コラム 生成エラー", body: "羽田記者が取材中に負傷したため、記事を生成できませんでした。", 
            timestamp: Date.now(), error: true, errorId: `hada-${matchId}`,
            context: matchContext 
        };
    }
}

/**
 * AI記者にニュース記事を執筆させるメイン関数
 * (★「isNewspaperWorthy」のバグを修正し、R4以降のみ新聞ボタンを表示)
 */
async function generateNewsArticle(matchContext, userFeedback = null) {
    const {
        winnerName, loserName, dbMatch, matchId,
        winnerData, loserData, winnerDetailedData, loserDetailedData,
        winnerLineupChanges, loserLineupChanges,
        winnerJourney, loserJourney,
        nextOpponent, pitcherGamelogInfo, batterGamelogInfo,
        injuryReport
    } = matchContext || {};
    
    let prompt = '';
    
    const tournamentName = tournamentNameMap[tournamentState.currentTournament] || '大会';
    const tournamentYear = tournamentState.tournamentYear;
    let tournamentContextPrompt = "";
    let seedContext = "前大会ベスト8";
    if (tournamentState.currentTournament === 'summer') {
        tournamentContextPrompt = "3年生にとっては最後の夏であり、甲子園出場をかけた最も熱い戦いです。";
    } else if (tournamentState.currentTournament === 'autumn') {
        tournamentContextPrompt = "1,2年生による新チームが始動する最初の公式戦であり、来春のセンバツ出場校選考にも影響する重要な大会です。";
    } else if (tournamentState.currentTournament === 'spring') {
        tournamentContextPrompt = "春のセンバツ（選抜）出場校も決まり、夏の大会のシード権をかけた前哨戦です。";
        seedContext = "前回の秋季大会ベスト8";
    }

    // --- 1. 大会展望記事の生成ロジック ---
    if (matchId === 'preview') {
        // ... (展望記事ロジックは変更なし) ...
        const { seeds, teams } = tournamentState;
        const blockAnalyses = [];
        const numBlocks = 4; const blockSize = 32;
        const getTeamRank = (teamName) => calculateRank(teamName, tournamentState);
        for (let i = 0; i < numBlocks; i++) {
            const blockName = String.fromCharCode(65 + i);
            const start = i * blockSize; const end = (i + 1) * blockSize;
            const blockTeams = teams.slice(start, end);
            if (blockTeams.length === 0) continue;
            const promisingInBlock = blockTeams.filter(team => {
                const rank = getTeamRank(team);
                return seeds.some(s => s.team === team) || ['A', 'B'].includes(rank);
            }).map(team => `${team} ${getSeedRankString(team, seeds)}`);
            blockAnalyses.push(`- ${blockName}ブロック (${blockTeams.length}校): ${promisingInBlock.join(', ')}`);
        }
        const blockAnalysis = blockAnalyses.join('\n');
        let notablePlayersText = '';
        const promisingSchools = teams.filter(team => {
            const rank = getTeamRank(team);
            return seeds.some(s => s.team === team) || ['A', 'B'].includes(rank);
        });
        const notablePlayers = promisingSchools.filter(team => DETAILED_TEAM_DATA[team]);
        if (notablePlayers.length > 0) {
            notablePlayersText += '### 今大会の注目選手\n';
            notablePlayers.forEach(team => {
                const players = DETAILED_TEAM_DATA[team]?.players.slice(0, 2) || [];
                notablePlayersText += `- **${team}**: ${players.map(p => `${p.name}(${p.year}年)`).join(', ')}\n`;
            });
        }
        const seedText = seeds.map(s => `${s.team}(第${s.rank}シード)`).join(', ');
        prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。
間もなく開幕する「${tournamentYear}年度 ${tournamentName}」の展望記事を作成してください。
### 大会の文脈 (最重要)
${tournamentContextPrompt}
シード校は「${seedContext}」の8校です。
### 参考情報：静岡県高校野球の「常識」（勢力図）
${PREFECTURE_LORE}
---
### シード校 (前大会ベスト8)
${seedText}
### 各ブロックの有力校
${blockAnalysis}
${notablePlayersText}
### 執筆指示
- 【★大会の文脈を反映】: 記事全体で、${tournamentName}ならではの視点（例：夏の3年生の想い、秋の新チームの試金石、春のシード権争い）を必ず反映させてください。
- 【★シードランク言及】: 「第1シードの〇〇」や「前大会ベスト8の△△」のように、シードランクにも触れて分析してください。
- どのシード校が最も厳しいブロックに入ったか、逆に最も楽なブロックはどこかを分析してください。
- ノーシードの実力校の中から、大会の「ダークホース」となりそうなチームを挙げてみてください。
- 記事のタイトルと本文をJSON形式で出力してください。
### 出力形式
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
                if (article) return { ...article, timestamp: Date.now() };
            }
            throw new Error("AI preview response format error.");
        } catch (error) {
            console.error("AI preview article generation failed:", error);
            return { title: "展望記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true, errorId: `preview-${Date.now()}` };
        }
    }

    // --- 2. 試合後記事の生成ロジック ---
    const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
    const loserRank = calculateRank(loserName, tournamentState);
    const loserRankDesc = getRankDescription(loserRank);
    const winnerSeedRank = getSeedRankString(winnerName, tournamentState.seeds);
    const loserSeedRank = getSeedRankString(loserName, tournamentState.seeds);
    const winnerRecord = tournamentState.teamRecords[winnerName];
    const loserRecord = tournamentState.teamRecords[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, winnerRecord);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, loserRecord);
    const winnerCoach = winnerData.coach;
    const loserCoach = loserData.coach;
    const roundName = getRoundNameFromMatchId(matchId); 
    
    let nextOpponentText = '次の対戦相手は未定。'; 
    if (nextOpponent) {
        if (nextOpponent.opponentName === '優勝') {
            nextOpponentText = (tournamentState.currentTournament === 'summer')
                ? '夏の甲子園出場が決定した。'
                : (tournamentState.currentTournament === 'autumn' ? 'センバツ出場が有力となった。' : '今大会、見事優勝を果たした。');
        }
        else if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            const nextOpponentSeed = getSeedRankString(nextOpponent.opponentName, tournamentState.seeds);
            const rankText = nextOpponent.opponentRank ? `(${nextOpponent.opponentRank}ランク)` : '';
            nextOpponentText = `次の${nextOpponent.roundName}では、${nextOpponent.opponentName}${nextOpponentSeed}${rankText}と対戦する。`;
        } 
        else if (nextOpponent.decidingMatch) {
            const dm = nextOpponent.decidingMatch;
            const team1Seed = getSeedRankString(dm.team1, tournamentState.seeds);
            const team2Seed = getSeedRankString(dm.team2, tournamentState.seeds);
            nextOpponentText = `次の${nextOpponent.roundName}では、${dm.team1}${team1Seed}(${dm.rank1}ランク)と${dm.team2}${team2Seed}(${dm.rank2}ランク)の勝者と対戦する。`;
        }
    }
    const calledGameText = matchContext.calledGame ? `\n- **【重要】** この試合は ${matchContext.calledInning}回コールド (${winnerScore}-${loserScore}) で ${winnerName} が勝利しました。` : '';
    const rivalryText = matchContext.rivalryType ? `\n- **【最重要】** この試合は「${matchContext.rivalryType}」という特別な因縁の対決でした。` : '';
    let scheduleText = '';
    if (matchContext.schedule) {
        const sched = matchContext.schedule;
        const team1Region = TEAM_DATA[dbMatch.team1]?.region || '不明';
        const team2Region = TEAM_DATA[dbMatch.team2]?.region || '不明';
        scheduleText = `\n- **試合会場:** ${sched.stadiumFull} (${sched.region}地区)\n`;
        if (sched.region === team1Region && sched.region !== team2Region) { scheduleText += `- **地の利:** ${dbMatch.team1}にとって地元球場での試合となった。\n`; }
        else if (sched.region !== team1Region && sched.region === team2Region) { scheduleText += `- **地の利:** ${dbMatch.team2}にとって地元球場での試合となった。\n`; }
    }
    let atmosphereText = '';
    if (matchContext.atmosphere_team1 || matchContext.atmosphere_team2) {
        atmosphereText = '\n--- ### **参考情報：試合前の雰囲気・公約**\n';
        if (matchContext.atmosphere_team1) atmosphereText += `- ${dbMatch.team1}: ${matchContext.atmosphere_team1}\n`;
        if (matchContext.atmosphere_team2) atmosphereText += `- ${dbMatch.team2}: ${matchContext.atmosphere_team2}\n`;
    }
    let ballQualityText = '';
    if (matchContext.team1BallQuality && matchContext.team2BallQuality) {
        ballQualityText = `\n--- ### **参考情報：チーム別 打球品質**\n- ${matchContext.team1BallQuality}\n- ${matchContext.team2BallQuality}\n`;
    }
    
    // ★★★ ここからが「快進撃」判定 ★★★
    let cinderellaPraiseInstruction = ""; // AIへの追加指示
    const idParts = matchId.split('-');
    let roundNum = 0;
    if (idParts[0] === 'F') {
        roundNum = Math.log2(tournamentState.teams.length); // 7
    } else if (idParts[1] && idParts[1].startsWith('R')) {
        roundNum = parseInt(idParts[1].slice(1));
    }
    
    if (roundNum > 0) {
        // 2. 敗者のランクとラウンドをチェック
        if ( (loserRank === 'E' && roundNum >= 3) || // EランクがR3(3回戦)以降で敗退
             (loserRank === 'D' && roundNum >= 4) || // DランクがR4(4回戦)以降で敗退
             (loserRank === 'C' && roundNum >= 5) )  // CランクがR5(準々決勝)以降で敗退
        {
            // 3. AIへの指示テキストを作成
            cinderellaPraiseInstruction = `
- **【★快進撃への言及】**: 敗北した${loserName}は${loserRankDesc}(${loserRank}ランク)でしたが、今大会は「${loserJourney}」と見事な快進撃を見せ、${roundName}まで勝ち上がりました。この記事では、${loserName}の健闘を称える一文（例：「${loserRankDesc}ながら${roundName}まで勝ち進んだ彼らに、球場全体から拍手が送られた」）を**必ず**含めてください。`;
        }
    }
    // ★★★ 判定ここまで ★★★

    if (dbMatch.details) {
        // (Aルート：詳細入力あり)
        const { highlights, keyPlayerNames } = createHighlightsText(dbMatch, winnerName);
        const factListText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
        const winnerKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
        const winnerPlayersInGame = new Set( (dbMatch.details.batting?.[winnerKey] || []).map(p => p.name).concat((dbMatch.details.pitching?.[winnerKey] || []).map(p => p.name)) );
        const winnerKeyPlayers = keyPlayerNames.filter(name => winnerPlayersInGame.has(name));
        const loserKeyPlayers = keyPlayerNames.filter(name => !winnerPlayersInGame.has(name));
        const formatPlayerList = (playerNames, teamName, detailedTeamData) => {
            if (playerNames.length === 0) return '特になし';
            return playerNames.map(playerName => {
                const detailedInfo = detailedTeamData?.players.find(p => p.name === playerName);
                return detailedInfo ? `- **${detailedInfo.name} (${detailedInfo.year}年・${detailedInfo.position})**: ${detailedInfo.desc}` : `- **${playerName}**`;
            }).join('\n');
        };
        const winnerPlayersPrompt = formatPlayerList(winnerKeyPlayers, winnerName, winnerDetailedData);
        const loserPlayersPrompt = formatPlayerList(loserKeyPlayers, loserName, loserDetailedData);
        const lineupChangesText = `- ${winnerName}: ${winnerLineupChanges}\n- ${loserName}: ${loserLineupChanges}`;
        
        prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。
あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。
---
### **参考情報：静岡県高校野球の「常識」（勢力図）**
${PREFECTURE_LORE}
---
### **現在の試合状況**
- **大会:** ${tournamentYear}年度 ${tournamentName}
- **文脈:** ${tournamentContextPrompt}
- **ラウンド:** ${roundName}
${scheduleText}
${calledGameText}
### **試合結果サマリー**
- ${winnerName} ${winnerSeedRank}が ${loserName} ${loserSeedRank}に ${winnerScore} - ${loserScore} で勝利。
${rivalryText} 
${injuryReport || ''}
### **【最重要】この記事の唯一の事実情報源 (★背番号・盗塁付きボックススコア)**
${matchContext.playerStatsText} 
---
${atmosphereText}
${ballQualityText}
### **【最重要】この記事の唯一の事実情報源 (ハイライト)**
${factListText}
---
### **今大会の主な投手登板履歴 (この試合より前)**
${pitcherGamelogInfo || '今大会、これが初登板です。'}
---
### **今大会の主な打者成績履歴 (この試合より前)**
${batterGamelogInfo || '打者の試合履歴データはありません。'}
---
### **参考情報：補足**
- **前試合からのスタメン変更**:
${lineupChangesText}
- **ユーザーによる試合の決め手**: ${dbMatch.summary || 'なし'}
---
### **参考情報：チームと選手のプロフィール (★チーム打率・通算盗塁含む)**
- **${winnerName} ${winnerSeedRank}**: ${winnerDynamicInfo}
  - **今大会の軌跡**: ${winnerJourney}
  - **監督**: ${winnerCoach ? `${winnerCoach.name} (${winnerCoach.style})` : '情報なし'}
  - **主な選手プロフィール**:\n${winnerPlayersPrompt}
- **${loserName} ${loserSeedRank}**: ${loserDynamicInfo}
  - **今大会の軌跡**: ${loserJourney}
  - **監督**: ${loserCoach ? `${loserCoach.name} (${loserCoach.style})` : '情報なし'}
  - **主な選手プロフィール**:\n${loserPlayersPrompt}
---
### **執筆指示**
${cinderellaPraiseInstruction} {/* ★ 快進撃の指示を挿入 */}
- **【★大会の文脈を反映】**: 記事全体で、${tournamentName}ならではの視点（例：夏の3年生の想い、秋の新チームの試金石、春のシード権争い）を必ず反映させてください。
- **【★欠場者への言及】**: もし「参考情報：主な欠場者」に選手名がある場合、その主力が欠場したことが試合にどう影響したか（例：「エース姫川[🏥]を欠いた283学園は、投手陣が踏ん張りきれなかった」）を必ず記事に含めてください。
- **【次戦への展望】**: 記事の最後に、次の対戦相手（${nextOpponentText}）に簡潔に触れ、今後の戦いへの展望を記述して締めくくること。
- 「事実リスト」を厳密に基に、試合の物語を再構築してください。
- **【★シードランク言及】**: **「第1シードの〇〇」**や**「シード校の△△が苦戦」**のように、シードランクにも具体的に言及し、試合の文脈を明確にしてください。
- **【監督の采配】**: 「スタメン変更」があった場合、その采配が試合にどう影響したかに触れること。
- **【物語の連続性】**: 「今大会の軌跡」情報を参考に、これまでの戦いと繋がりのある物語を描写すること。
- 試合後の両チーム監督のコメントを、試合内容やチームの背景を反映させて生成すること。
- **【次戦への展望】**: 記事の最後に、次の対戦相手（${nextOpponentText}）に簡潔に触れ、今後の戦いへの展望を記述して締めくくること。
- **【背番号の意味（裁量）】**: 記事中で選手に言及する際、**もしその背番号が物語上重要であれば**（例：エース[#1]の快投・不振、レギュラー番号[#2-9]の責任、または控え番号[#10以降]の選手が予想外の活躍をした場合など）、その背番号が持つ意味に触れてください#は背番号と言い換えてください。(例S1→背番号1)。
- **【コールドゲームの場合】**: もし試合がコールドで終了した場合、その旨を記事の冒頭やタイトルで明確に記述し、大差がついた理由にも触れること。
- **【因縁の対決】**: もし試合が「因縁の対決」であった場合、そのドラマ性を記事の中心に据え、熱く描写してください。
- **【選手の状態と打球の質（打者）】**: ボックススコアに「(状態: 〇〇)」という記述がある選手に注目し、**前回の試合からの連続性**を描写してください。
- **【試合前の雰囲気】**: もし「試合前の雰囲気・公約」が提供されている場合、その情報（例：「監督がエース温存を公言」）を**試合結果と関連付け**、記事の重要なテーマとして扱ってください。
- **【常識の反映】**: あなたが熟知している「常識」（勢力図）を**背景知識として**利用してください。
- **【球場の地の利】**: もし「地の利」情報がある場合、その**地元のアドバンテージ**が試合にどう影響したかに触れてください。
- **【ヒーローインタビュー】**: 記事の最後に「今日のヒーロー」というセクションを設けてください。ボックススコアや事実リストから**最も活躍した勝利チームの選手1名**を選び出し、その選手への架空のインタビューと、それに対するヒーローらしい回答を生成してください。
- **【監督・主将コメント】**: ヒーローインタビューの後、「両チームの声」セクションを設け、**勝利チーム**と**敗北チーム**の「監督」および「主将」の試合後の総括コメントを、それぞれ簡潔に生成してください。
- **【★注目の打席（最重要）】**:
    - 「事実リスト」（ハイライト）に「（★注目）」マークが付いている打席があります。これが**ユーザー（監督）が『試合の分水嶺』だと判断した**、最も重要な打席です。
    - あなたの記事では、**この記事の中心的なハイライト**として、この「★注目」の打席の前後を、最もドラマチックに描写してください。
- **【★今大会の成績 (最重要)】**:
    - 「参考情報：チームと選手のプロフィール」に**『今大会のチーム打率は.XXX』**という情報が含まれています。
    - この情報を**必ず記事に含め**、チームの好調・不振の文脈として描写してください。
- **【★盗塁への言及 (重要)】**:
    - 「ボックススコア」に**盗塁(SB)**が記録されている選手がいた場合、その選手の機動力（例：「〇〇が足でチャンスを広げ」）にも言及すること。
    - さらに、その選手の**「今大会の通算盗塁数」**（例：(今大会: ... 4盗)）も必ず参照し、**「〇〇はこれで今大会4個目の盗塁」**といった具体的な数字を記事に含めてください。
- **【★通算成績への言及 (裁量)】**:
    - 「参考情報」に**『(参考: チーム通算打率 .XXX, 通算 Y 盗塁)』**という情報が含まれている場合、必要に応じてそのチームの機動力にも言及すること。
- **【★登板履歴への言及 (最重要)】**: 「今大会の主な投手登板履歴」の情報を必ず確認し、以下の点をコメントに含めること。
    - **連投/登板間隔**: 「〇〇、連投じゃん」「中1日でこれはキツイ」
    - **酷使**: 「エース投げすぎだろ」「監督は鈴木を壊す気か」
    - **好不調の波**: 「前回炎上したのによう立ち直ったな」「こないだは良かったのに今日はアカンか」
- **【★打者履歴への言与 (最重要)】**: 「今大会の主な打者成績履歴」も必ず確認し、以下の点をコメントに含めること。
    - **好不調の波**: 「〇〇、今日で3試合連続ヒットやん！」「△△、10打数ノーヒットとかもう終わりだろ…」
    - **役割**: 「こいつ代打成功率100%じゃね？」「1番に上げたら打ち出したな」
---
### 編集長からの追加指示
${(userFeedback && userFeedback.include) ? `- **【最重要指示】** ${userFeedback.include}\n` : ''}
${(userFeedback && userFeedback.exclude) ? `- **【厳禁事項】** ${userFeedback.exclude}\n` : '特になし'}
---
### 出力形式【厳守】
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}
`;

   } else {
        // (Bルート：詳細入力なし)
        prompt = `あなたは、高校野球専門のAI記者です。
以下の試合結果に基づき、簡潔で分かりやすいニュース記事を作成してください。
---
### **参考情報：静岡県高校野球の「常識」（勢力図）**
${PREFECTURE_LORE}
---
### **現在の試合状況**
- **大会:** ${tournamentYear}年度 ${tournamentName}
- **文脈:** ${tournamentContextPrompt}
- **ラウンド:** ${roundName} 
${scheduleText} 
### 試合情報
- **勝利チーム**: ${winnerName} ${winnerSeedRank} (${winnerRankDesc})
- **敗北チーム**: ${loserName} ${loserSeedRank} (${loserRankDesc})
- **スコア**: ${winnerScore} - ${loserScore}
- **ユーザーによる試合の決め手**: ${dbMatch.summary || 'なし'}
${calledGameText} 
${rivalryText} 
${injuryReport || ''}
### **参考情報：チームの背景 (★チーム打率・通算盗塁含む)**
- **${winnerName} ${winnerSeedRank}**: ${winnerDynamicInfo}
  - **今大会の軌跡**: ${winnerJourney}
- **${loserName} ${loserSeedRank}**: ${loserDynamicInfo}
  - **今大会の軌跡**: ${loserJourney}
---
### 執筆指示
- **【★大会の文脈を反映】**: 記事全体で、${tournamentName}ならではの視点（例：夏の3年生の想い、秋の新チームの試金石、春のシード権争い）を必ず反映させてください。
- **【★シードランク言及】**: **「第1シードの〇〇が順当に勝利」**や**「ノーシードの△△が第8シードを破る波乱」**のように、シードランクにも具体的に言及してください。
- **【★欠場者への言及】**: もし「主な欠場者」に選手名がある場合、その主力が欠場したことが試合にどう影響したか（例：「エース姫川[🏥]を欠いた283学園は〜」）を必ず記事に含めてください。
${cinderellaPraiseInstruction} {/* ★ 快進撃の指示を挿入 */}
- **【★今大会の成績 (最重要)】**: 「チームの背景」にある『今大会のチーム打率は.XXX』という情報を**必ず記事に含め**、チームの好調・不振の文脈として描写してください。
- 記事の最後に、勝利チームの監督または主将の喜びのコメント（例：『〇〇監督「選手たちがよく頑張ってくれた」』）を一行追加してください。
- **記事の最後に、次の対戦相手（${nextOpponentText}）に簡潔に触れて締めくくってください。**
- 記事のタイトルと本文をJSON形式で出力してください。`;
    }

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json(); 
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
            const rawTextFromAi = result.candidates[0].content.parts[0].text; 
            const article = parseJsonFromText(rawTextFromAi); 
            if (article && !article.body && article.article) { article.body = article.article; }
            if (article && article.title && article.body) { 
                
                // ★★★ ここからが修正箇所 ★★★
                // 「詳細入力」があり、かつ「AI生成がON」の場合のみ新聞を生成
                const isNewspaperWorthy = (
                    dbMatch.details && 
                    tournamentState.settings.enableArticleGeneration
                    // ★ラウンド数(roundNum >= 4)の制限を削除★
                );
                // ★★★ 修正ここまで ★★★

                const newspaperHtml = isNewspaperWorthy ? createNewspaperHtml(article, { winnerName, loserName, dbMatch, matchId }) : null;
                
                return { 
                    ...article, 
                    isNewspaper: isNewspaperWorthy, // ★ 修正されたフラグ
                    timestamp: Date.now(), 
                    newspaperHtml: newspaperHtml, // ★ 修正されたHTML
                    context: matchContext
                };
            } else {
                 console.error("parseJsonFromText failed or keys (title/body/article) missing for raw text:", rawTextFromAi);
                 throw new Error("AI response format error after parsing."); 
            }
        } else {
             console.error("Unexpected AI response structure:", result);
             throw new Error("AI response structure is missing expected parts."); 
        }
    } catch (error) {
        console.error("AI記事の生成に失敗しました:", error);
        return { 
            title: "記事生成エラー", body: "AI記者との通信に失敗しました。", 
            timestamp: Date.now(), error: true, errorId: matchId,
            context: matchContext 
        };
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
     * AIにスキップしたラウンドのダイジェスト記事を生成させる
     */
    async function generateSkipRoundSummaryArticle(roundNumber, results) {
        // 最も番狂わせが大きかった試合を1つ選出
        const biggestUpset = results.filter(r => r.rankDiff >= 2).sort((a,b) => b.rankDiff - a.rankDiff)[0];
        
        let highlightText = "シード校や有力校が順当に勝ち進みました。";
        if (biggestUpset) {
            highlightText = `最大の波乱は${biggestUpset.winnerName}が強豪${biggestUpset.loserName}を${biggestUpset.winnerScore}-${biggestUpset.loserScore}で破った一戦でした。`;
        }

        const prompt = `あなたは高校野球専門のAI記者です。
現在、${tournamentState.tournamentYear}年度${tournamentNameMap[tournamentState.currentTournament]}が進行中です。
${roundNumber}回戦の全試合が終了しました。以下のハイライトを元に、簡潔なダイジェスト記事を生成してください。

### ${roundNumber}回戦ハイライト
- ${highlightText}
- 次のラウンドでは、勝ち上がった猛者たちによる更なる激戦が期待されます。

### 執筆指示
- 上記のハイライトを自然な文章にまとめてください。
- タイトルは「${roundNumber}回戦が終了！波乱は起きるか？」のように、次への期待感を煽るものにしてください。

### 出力形式
JSON形式で出力してください: {"title": "記事のタイトル", "body": "記事の本文"}`;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
                if (article) return { ...article, timestamp: Date.now() };
            }
            throw new Error("AI summary response format error.");
        } catch (error) {
            console.error("AI summary article generation failed:", error);
            return { title: "ダイジェスト記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true, errorId: `skip-summary-${roundNumber}` };
        }
    }


/**
 * 試合直前の「応援コメント」をAIに生成させる
 * (★Gamelog, DynamicInfo, 会場, 因縁の情報を追加した最終版)
 * @param {object} context - 試合とチームの全コンテキスト
 * @param {number} numComments - 生成するコメント数
 * @returns {Promise<Array<object>>} - 生成されたコメントオブジェクトの配列
 */
async function generatePreGameCheerComments(context, numComments) {
    
    // --- 1. コンテキストを分解 ---
    const {
        name: teamName,
        rank: teamRank,
        opponent: opponentName,
        opponentRank: opponentRank,
        round: roundName,
        path: tournamentPath, // (getCurrentTournamentPerformance の結果)
        detailed: detailedData, // (静的な注目選手情報)
        info: teamInfo,         // (generateDynamicTeamInfo の結果)
        playerGamelogs,       // (formatPlayerGamelogsForPrompt の結果)
        schedule,             // (試合会場・日程)
        rivalry               // (因縁情報)
    } = context;

    // --- 2. AIへのペルソナ指示 ---
    let personaInstructions = `
あなたは「${teamName}」の熱狂的な応援団、または試合に期待するファンです。以下のペルソナ（役割）になりきって、試合直前の応援コメントを合計 ${numComments} 個生成してください。

### ペルソナ（役割）と、あなたが語るべき視点
- **OB (OB・OG):**
    - **視点:** あなたの在籍時代（例：5年前、20年前）の思い出と、現在のチームを比較してください。
    - **（重要）:** もし応援するチームが「283学園」や「765総合」のような**創部数年の新しい学校**の場合、「40年前」といった矛盾した発言は**絶対にせず**、「創部まもないのに, ここまで来るとは…」「俺が1期生だった頃は…」といった、**新しい学校のOBらしい**コメントを生成してください。

- **在校生 (ブラスバンド部員や友人など):**
    - **視点:** 今の学校の雰囲気や、応援練習の様子、クラスメイトとしての選手の素顔（架空でOK）を語ってください。
    - **（例）:** 「〇〇くん、いつもは教室で静かなのにグラウンドだと凄い！」「ブラバンも気合入ってます！」

- **地元ファン (その地域に住むファン):**
    - **視点:** 地域の期待（例：「今年こそ甲子園へ」「〇〇（地名）の誇りだ」）を語ってください。

- **選手の家族 (架空の親や兄弟):**
    - **視点:** 選手の個人的な努力（架空でOK）や、家庭での様子を語ってください。
    - **（例）:** 「息子がベンチ入りできただけで奇跡です」「あの子、毎朝5時に起きて素振りしてましたから…」
`;

    if (teamRank === 'A' || teamRank === 'B') {
        personaInstructions += `
- **（無関係の）高校野球ファン:**
    - **視点:** あなたは、この試合が ${teamName}（${getRankDescription(teamRank)}）の試合だから観に来た「無関係の野球好き」です。学校関係者ではありません。
    - **（例）:** 「今日の目当てはこのカード。ハイレベルな試合を期待してる」「〇〇（注目選手）のピッチング/バッティングが見たくて有休とったわ」「どっちが勝ってもいいから熱い試合を見せてくれ」
`;
    }
    
    // --- 3. AIへのプロンプト (★新情報追加版) ---
    const prompt = `
${personaInstructions}

### 試合情報
- **応援するチーム:** ${teamName} (ランク: ${teamRank})
- **対戦相手:** ${opponentName} (ランク: ${opponentRank})
- **ラウンド:** ${roundName}
- **試合会場:** ${schedule || '未定'}
${rivalry ? `- **${rivalry}**` : ''}

### 参考情報：応援するチームの最新データ
- **チームの背景(info):** ${teamInfo || '特になし'}
- **今大会の軌跡:** ${tournamentPath || '今大会初戦'}
- **注目選手 (静的):** ${detailedData ? detailedData.players.map(p => p.name).join(', ') : '情報なし'}
- **今大会の選手成績履歴 (Gamelog):**
${playerGamelogs || '今大会の試合履歴はありません。'}

### 指示
1.  **ペルソナになりきる:** 上記のペルソナ（OB、在校生、地元ファン、家族、無関係のファン等）に完全になりきり、その立場からの応援コメントを生成してください。
2.  **文脈を反映:** 試合情報（相手が格上か、歴史的な快進撃か、注目選手は誰か）をコメントに反映させてください。
3.  **★【最重要】背景(info)の活用:** 「チームの背景(info)」を熟読してください。
    - （例：もし「川根」なら「最後の夏」や「閉校」に触れる）
    - （例：もし「浜松特支」なら「創部一年目」「52-0の大敗」の記憶に触れる）
    - （例：もし「283学園」なら「王者としてのプレッシャー」に触れる）
    - （例：もし「今大会のチーム打率は.350」とあれば、「打線好調！」に触れる）
    - この背景情報に基づいた、**具体的で解像度の高い**コメントを必ず生成してください。
4.  **★【重要】Gamelogの活用:** 「選手成績履歴(Gamelog)」を読み、具体的な選手の**好不調の波**にも言及してください。
    - （例：「〇〇くん、1回戦は3タコだったけど、2回戦はホームラン！今日が大事だぞ！」）
    - （例：「エースの△△、前回登板は中1日だったから心配してたんだ…今日は頼む！」）
5.  **★試合会場と因縁:** もし試合が「草薙球場」など**地元開催**であったり、「因縁の対決」であったりする場合、その点にも言及して期待感を高めてください。
6.  **創作を許可:** 選手や監督との（架空の）個人的な思い出や、過去の歴史（例：40年前の初勝利）を**自由に創作して**、コメントに深みを与えてください。

### 出力形式【厳守】
必ず以下のJSON配列形式"のみ"で出力してください。
[
    {"personality": "（例：〇〇高校OB）", "comment": "（生成したコメント1）"},
    {"personality": "（例：在校生）", "comment": "（生成したコメント2）"},
    {"personality": "（例：地元のファン）", "comment": "（生成したコメント3）"}
    // ... (指定されたコメント数だけ続ける) ...
]
`;

    // --- 4. AIへのリクエスト (変更なし) ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson;
            }
        }
        throw new Error("AI response format error (PreGameComments).");
    } catch (error) {
        console.error("AI応援コメントの生成に失敗しました:", error);
        return [{ personality: "システムエラー", comment: "応援コメントの生成に失敗しました..." }];
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲
// ▲▲▲ 貼り付けはここまで ▲▲
// ▲▲▲ 貼り付けはここまで ▲▲


/**
 * AIに試合結果の掲示板の反応を生成させる
 * (★敗退したC/D/Eランクの「快進撃」にも言及するよう修正)
 */
async function generateBbsComments(matchContext) {
    const { 
        winnerName, loserName, dbMatch, matchId, 
        winnerData, loserData, winnerDynamicInfo, loserDynamicInfo,
        nextOpponent, winnerSeedRank, loserSeedRank,
        loserJourney, // ★ 敗者の軌跡
        injuryReport
    } = matchContext;
    
    const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
    const loserRank = calculateRank(loserName, tournamentState); // ★ 敗者のランク(Eなど)
    const loserRankDesc = getRankDescription(loserRank); // ★ 敗者のランク説明 (例: 挑戦者)
    
    const tournamentName = tournamentNameMap[tournamentState.currentTournament] || '大会';
    const tournamentYear = tournamentState.tournamentYear;
    let tournamentBbsContext = "";
    if (tournamentState.currentTournament === 'summer') {
        tournamentBbsContext = "3年生にとってはガチで最後の夏や。";
    } else if (tournamentState.currentTournament === 'autumn') {
        tournamentBbsContext = "新チームの初陣やな。ここでの結果がセンバツ選考に響くで。";
    } else if (tournamentState.currentTournament === 'spring') {
        tournamentBbsContext = "夏のシード権がかかった前哨戦や。";
    }

    const roundName = getRoundNameFromMatchId(matchId); 
    
    let nextOpponentText = '次の相手は未定。'; 
    if (nextOpponent) {
        if (nextOpponent.opponentName === '優勝') {
            nextOpponentText = (tournamentState.currentTournament === 'summer')
                ? '夏の甲子園出場決定！'
                : (tournamentState.currentTournament === 'autumn' ? 'センバツ出場が有力となった。' : '今大会、見事優勝を果たした。');
        }
        else if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            const nextOpponentSeed = getSeedRankString(nextOpponent.opponentName, tournamentState.seeds);
            const rankText = nextOpponent.opponentRank ? `(${nextOpponent.opponentRank}ランク)` : '';
            nextOpponentText = `次の${nextOpponent.roundName}では、${nextOpponent.opponentName}${nextOpponentSeed}${rankText}と対戦する。`;
        } 
        else if (nextOpponent.decidingMatch) {
            const dm = nextOpponent.decidingMatch;
            const team1Seed = getSeedRankString(dm.team1, tournamentState.seeds);
            const team2Seed = getSeedRankString(dm.team2, tournamentState.seeds);
            nextOpponentText = `次の${nextOpponent.roundName}では、${dm.team1}${team1Seed}(${dm.rank1}ランク)と${dm.team2}${team2Seed}(${dm.rank2}ランク)の勝者と対戦する。`;
        }
    }
    const calledGameText = matchContext.calledGame ? `\n- **特記事項:** ${matchContext.calledInning}回コールドゲーム` : '';
    const rivalryText = matchContext.rivalryType ? `\n- **特記事項:** この試合は「${matchContext.rivalryType}」という特別な因縁の対決でした。` : '';
    let scheduleText = '';
    if (matchContext.schedule) {
        const sched = matchContext.schedule;
        const team1Region = TEAM_DATA[dbMatch.team1]?.region || '不明';
        const team2Region = TEAM_DATA[dbMatch.team2]?.region || '不明';
        scheduleText = `\n- **試合会場:** ${sched.stadiumFull} (${sched.region}地区)\n`;
        if (sched.region === team1Region && sched.region !== team2Region) { scheduleText += `- **地の利:** ${dbMatch.team1}にとって地元球場での試合となった。\n`; }
        else if (sched.region !== team1Region && sched.region === team2Region) { scheduleText += `- **地の利:** ${dbMatch.team2}にとって地元球場での試合となった。\n`; }
    }
    let atmosphereText = '';
    if (matchContext.atmosphere_team1 || matchContext.atmosphere_team2) {
        atmosphereText = '\n--- ### **参考情報：試合前の雰囲気・公約**\n';
        if (matchContext.atmosphere_team1) atmosphereText += `- ${dbMatch.team1}: ${matchContext.atmosphere_team1}\n`;
        if (matchContext.atmosphere_team2) atmosphereText += `- ${dbMatch.team2}: ${matchContext.atmosphere_team2}\n`;
    }
    let ballQualityText = '';
    if (matchContext.team1BallQuality && matchContext.team2BallQuality) {
        ballQualityText = `\n--- ### **参考情報：チーム別 打球品質**\n- ${matchContext.team1BallQuality}\n- ${matchContext.team2BallQuality}\n`;
    }

    // ★★★ ここからが「快進撃」判定 ★★★
    let cinderellaPraiseInstruction = ""; // AIへの追加指示
    const idParts = matchId.split('-');
    let roundNum = 0;
    if (idParts[0] !== 'F' && idParts[1] && idParts[1].startsWith('R')) {
        roundNum = parseInt(idParts[1].slice(1));
    }
    
    // ユーザー指定のロジック (E >= R3, D >= R4, C >= R5)
    if ( (loserRank === 'E' && roundNum >= 3) ||
         (loserRank === 'D' && roundNum >= 4) ||
         (loserRank === 'C' && roundNum >= 5) )
    {
        cinderellaPraiseInstruction = `
- **【★快進撃への言及】**: 敗北した${loserName}は${loserRankDesc}(${loserRank}ランク)だったが、${roundName}まで勝ち上がった。この「快進撃」を**「${loserName}、ようやっとる」「来年が楽しみなチーム」**のように、必ず称賛すること。`;
    }
    // ★★★ 判定ここまで ★★★

    if (dbMatch.details) {
        // (Aルート：詳細入力あり)
        const { highlights } = createHighlightsText(dbMatch, winnerName);
        const highlightsText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
        
        prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下の試合結果と詳細なハイライトに基づき、各キャラクターになりきって、辛辣でリアルな短いコメントを10つ生成してください。
---
### **参考情報：静岡県高校野球の「常識」（勢力図）**
${PREFECTURE_LORE}
---
### 試合情報
- **大会:** ${tournamentYear}年度 ${tournamentName} (${tournamentBbsContext})
- **ラウンド:** ${roundName}
- **勝利チーム**: ${winnerName} ${winnerSeedRank} (${winnerRankDesc})
- **敗北チーム**: ${loserName} ${loserSeedRank} (${loserRankDesc})
- **スコア**: ${winnerScore} - ${loserScore}
${calledGameText} 
${rivalryText}
${injuryReport || ''}
### 次の試合情報
- **${winnerName}の次の試合**: ${nextOpponentText}
- ユーザーが語る試合の決め手: ${dbMatch.summary || '特になし'}
${ballQualityText} 
### 試合の主なハイライト
${highlightsText}
### 今大会の主な投手登板履歴 (この試合より前)
${matchContext.pitcherGamelogInfo || '今大会、これが初登板です。'}
### 今大会の主な打者成績履歴 (この試合より前)
${matchContext.batterGamelogInfo || '打者の試合履歴データはありません。'}
### チームの背景 (★チーム打率・通算盗塁含む)
- **${winnerName} ${winnerSeedRank}**: ${winnerDynamicInfo}
- **${loserName} ${loserSeedRank}**: ${loserDynamicInfo}
  - **軌跡**: ${loserJourney}

### あなたがなりきるべきキャラクターと指示
- **【★大会の文脈を反映】**: ${tournamentName}ならではの視点（例：「夏は3年生最後やな」「秋の新チームの仕上がり見えてきたな」）をコメントに含めること。
- **【★シードランク言及】**: **「第1シードさすがやな」「第5シードが負けたンゴwww」**のように、シードランクにも具体的に言及してください。
- **【★欠場者への言及】**: もし「主な欠場者」に名前がある場合、その選手がいないこと（例：「エースの姫川[🏥]抜きでよく勝ったわ」）について必ずコメントすること。
${cinderellaPraiseInstruction} {/* ★ 快進撃の指示を挿入 */}
- **【★登板履歴への言及】**: 「今大会の主な投手登板履歴」に情報がある場合、**「〇〇、連投じゃん」**のように、登板履歴を踏まえたコメントをすること。
- **【★今大会の成績 (最重要)】**: 「チームの背景」にある『今大会のチーム打率は.XXX』という情報を**必ずコメントに含め**、チームの好調・不振にも言及してください。
- **【★盗塁への言及 (重要)】**: 「ハイライト」や「ボックススコア」に**盗塁**が記録されていたら、その選手の足（機動力）を褒めること。
- **【★注目の打席（最重要）】**: 「試合のハイライト」に「（★注目）」マークが付いている打席があります。これが**試合のターニングポイント**です。その打席が決定的な瞬間であったとコメントしてください。
- **【次戦への言及】**: 勝者チームの「次の試合情報」（${nextOpponentText}）に触れ、「次は〇〇か…」といったコメントを必ず含めてください。`;

    } else {
        // (Bルート：詳細入力なし)
        prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下の試合結果について、それぞれのキャラクターになりきって、辛辣でリアルな短いコメントを10つ生成してください。
---
### **参考情報：静岡県高校野球の「常識」（勢力図）**
${PREFECTURE_LORE}
---
### 試合情報
- **大会:** ${tournamentYear}年度 ${tournamentName} (${tournamentBbsContext})
- **ラウンド:** ${roundName} 
- **勝利チーム**: ${winnerName} ${winnerSeedRank} (${winnerRankDesc})
- **敗北チーム**: ${loserName} ${loserSeedRank} (${loserRankDesc})
- **スコア**: ${winnerScore} - ${loserScore}
${calledGameText} 
${rivalryText} 
${injuryReport || ''}
### 次の試合情報
- **${winnerName}の次の試合**: ${nextOpponentText}
- ユーザーが語る試合の決め手: ${dbMatch.summary || 'なし'}
### チームの背景 (★チーム打率・通算盗塁含む)
- **${winnerName} ${winnerSeedRank}**: ${winnerDynamicInfo}
- **${loserName} ${loserSeedRank}**: ${loserDynamicInfo}
  - **軌跡**: ${loserJourney}

### あなたがなりきるべきキャラクターと指示
- **【★大会の文脈を反映】**: ${tournamentName}ならではの視点（例：「夏は3年生最後やな」「秋の新チームの仕上がり見えてきたな」）をコメントに含めること。
- **【★シードランク言及】**: **「第1シードさすがやな」「第5シードが負けたンゴwww」**のように、シードランクにも具体的に言及してください。
- **【★欠場者への言及】**: もし「主な欠場者」に名前がある場合、その選手がいないこと（例：「エースの姫川[🏥]抜きでよく勝ったわ」）について必ずコメントすること。
${cinderellaPraiseInstruction} {/* ★ 快進撃の指示を挿入 */}
- **【★今大会の成績 (最重要)】**: 「チームの背景」にある『今大会のチーム打率は.XXX』という情報を**必ずコメントに含め**、チームの好調・不振（例：「〇〇、今大会打率.150とかマジ？」）にも言及してください。
- **【次戦への言及】**: 勝者チームの「次の試合情報」（${nextOpponentText}）に触れ、「次は〇〇か…」といったコメントを必ず含めてください。`;
    }

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AIからの応答が、正しい配列形式ではありません。");
    } catch (error) {
        console.error("AI掲示板コメントの生成に失敗しました:", error);
        return [{
            id: `error-${matchId}-bbs`,
            error: true,
            title: `掲示板コメント生成エラー`,
            context: matchContext 
        }];
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
     * AIに代矢東応援掲示板のコメントを生成させる
     */
    async function generateDaiyaBbsComments(winnerName, loserName, dbMatch, nextOpponentInfo) {
        const isDaiyaWinner = winnerName === '静岡';
        const opponentName = isDaiyaWinner ? loserName : winnerName;
        const opponentRank = calculateRank(opponentName, tournamentState);
        const resultContext = isDaiyaWinner ? '勝利' : '敗北';
        const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
        const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;
        const score = `${winnerScore} - ${loserScore}`;
        
        const prompt = `あなたは、静岡の古豪「静岡」高校野球部の熱狂的なファンです。あなたは野球に非常に詳しく、常に冷静に試合を分析し、どうすればチームが甲子園に行けるかを考えています。
以下の試合結果について、あなたらしいコメントを5つ生成してください。

### 試合情報
- 試合結果: 静岡の${resultContext}
- 対戦相手: ${opponentName} (${getRankDescription(opponentRank)})
- スコア: ${score}

### あなたのキャラクターと指示
- あなたは生粋の野球好きで、静岡のファンが集う特設掲示板の常連です。
- **もし代矢東が勝利した場合:**
  - 喜びつつも、冷静に勝因を分析してください（例：「今日の勝因は継投のタイミングだな」「あの場面のスクイズは見事だった」）。
  - すぐに次の対戦相手に目を向け、どうすれば勝てるかの戦略を語ってください（例：「次は〇〇か…キーマンは相手の3番打者だ。徹底的にインコースを攻めるべき」）。
  - 決して浮かれず、常に甲子園への道を冷静に見据えてください。
- **もし代矢東が敗北した場合:**
  - 非常に落胆し、性格の悪さを露呈してください。
  - 敗因を厳しく追及してください（例：「なぜあの場面でピッチャーを変えなかったんだ」「監督の采配ミスだろ」）。
  - 「【悲報】静岡、今年も甲子園いけず…」のような、絶望的なスレッドタイトルを必ず一つ生成してください。
  - 来年に向けての不安や、チームの課題を辛辣に指摘してください。

### 出力形式
必ず以下のJSON配列形式で出力してください。
[
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"}
]`;
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const commentsJson = parseJsonFromText(rawText);
                if (Array.isArray(commentsJson)) {
                    return commentsJson.map(c => ({
                        id: crypto.randomUUID(),
                        personality: c.personality,
                        text: c.comment,
                        timestamp: Date.now(),
                        replies: []
                    }));
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("代矢東 掲示板コメントの生成に失敗しました:", error);
            return [];
        }
    }

   /**
 * AIに組み合わせ決定時の掲示板の反応を生成させる
 * ★★★ 詳細な組み合わせ分析を追加した完成版 ★★★
 */
async function generateBracketReactionComments(state) {
    const { teams, seeds } = state;
    // チーム数が少ない場合はコメントを生成しない
    if (teams.length < 8) return [];

    let analysis = ''; // 組み合わせ分析を入れる変数
    let commentDirections = ''; // AIへの指示を入れる変数

    // --- トーナメント表の詳細分析ロジック ---
    const numBlocks = Math.max(1, Math.ceil(teams.length / 16)); // 64チームなら4ブロック、16チームなら1ブロック
    const blockSize = Math.floor(teams.length / numBlocks);
    const blockData = []; // 各ブロックの情報を格納 [{ name: 'A', teams: [...], strongTeams: [...], matchupsR1: [...], potentialR2: [], potentialR3: [] }, ...]
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 }; // ランクの強さ

    const getTeamRank = (teamName) => calculateRank(teamName, state); // チームランク取得関数

    for (let i = 0; i < numBlocks; i++) {
        const blockName = String.fromCharCode(65 + i);
        const startIdx = i * blockSize;
        const endIdx = (i + 1) * blockSize;
        const blockTeams = teams.slice(startIdx, endIdx);
        if (blockTeams.length === 0) continue;

        const strongTeamsInBlock = blockTeams.filter(team => {
            const rank = getTeamRank(team);
            return seeds.includes(team) || ['A', 'B'].includes(rank);
        });

        const matchupsR1 = []; // 1回戦のカード
        const potentialR2 = []; // 2回戦で当たりそうなカード
        const potentialR3 = []; // 3回戦で当たりそうなカード (64チーム時)

        // 1回戦の分析
        for (let j = 0; j < blockTeams.length; j += 2) {
            const team1 = blockTeams[j];
            const team2 = blockTeams[j + 1];
            if (!team1 || !team2) continue;
            const rank1 = getTeamRank(team1);
            const rank2 = getTeamRank(team2);
            const matchup = { team1, rank1, team2, rank2 };
            matchupsR1.push(matchup);
            // 1回戦での有力校潰し合いチェック
            if ((seeds.includes(team1) || ['A', 'B'].includes(rank1)) && (seeds.includes(team2) || ['A', 'B'].includes(rank2))) {
                matchup.isCrush = true; // 潰し合いフラグ
            }
        }

        // 2回戦以降の有力カード予測 (簡易版)
        if (blockTeams.length >= 4) {
            for (let j = 0; j < matchupsR1.length; j += 2) {
                const winner1Match = matchupsR1[j];
                const winner2Match = matchupsR1[j + 1];
                if (!winner1Match || !winner2Match) continue;
                // 各1回戦で有力な方が勝ち上がると仮定
                const potentialWinner1 = rankValues[winner1Match.rank1] >= rankValues[winner1Match.rank2] ? winner1Match.team1 : winner1Match.team2;
                const potentialWinner2 = rankValues[winner2Match.rank1] >= rankValues[winner2Match.rank2] ? winner2Match.team1 : winner2Match.team2;
                // 両方とも有力校なら2回戦の注目カード候補
                if (strongTeamsInBlock.includes(potentialWinner1) && strongTeamsInBlock.includes(potentialWinner2)) {
                    potentialR2.push(`${potentialWinner1} vs ${potentialWinner2}`);
                }
            }
        }
        // 3回戦 (64チームトーナメントの場合のみ)
        if (teams.length === 64 && blockTeams.length >= 8) {
             // 簡易的にブロック内のシード校同士が当たる可能性などをリストアップ (より詳細な予測も可能)
             const blockSeeds = strongTeamsInBlock.filter(t => seeds.includes(t));
             if (blockSeeds.length >= 2) {
                 potentialR3.push(`${blockSeeds[0]} vs ${blockSeeds[1]} (予想)`); // 例: ブロック内のシード上位2校
             }
        }


        blockData.push({
            name: blockName,
            teams: blockTeams,
            strongTeams: strongTeamsInBlock,
            matchupsR1: matchupsR1,
            potentialR2: potentialR2,
            potentialR3: potentialR3
        });
    }

    // 分析結果をテキストにまとめる
    let blockSummary = '';
    let crushR1 = []; // 1回戦潰し合いリスト
    let goodCardsR2 = []; // 2回戦好カードリスト
    let goodCardsR3 = []; // 3回戦好カードリスト

    blockData.forEach(block => {
        blockSummary += `- ${block.name}ブロック: 有力校 ${block.strongTeams.length}チーム (${block.strongTeams.join(', ') || 'なし'})\n`;
        block.matchupsR1.forEach(m => {
            if (m.isCrush) {
                crushR1.push(`${block.name}ブロック: ${m.team1}(${m.rank1}) vs ${m.team2}(${m.rank2})`);
            }
        });
        if (block.potentialR2.length > 0) {
            goodCardsR2.push(...block.potentialR2.map(card => `${block.name}ブロック: ${card}`));
        }
         if (block.potentialR3.length > 0) {
            goodCardsR3.push(...block.potentialR3.map(card => `${block.name}ブロック: ${card}`));
        }
    });

    // 死のブロックと恵まれたブロックを判定
    blockData.sort((a, b) => b.strongTeams.length - a.strongTeams.length);
    const deathBlock = blockData[0];
    const blessedBlock = blockData[blockData.length - 1];

    analysis = `夏の選手権、組み合わせ決定！ 各ブロックの有力校:\n${blockSummary}`;
    analysis += `\n--- 詳細分析 ---\n`;
    analysis += `◆ 死のブロック: ${deathBlock.name}ブロック (有力校 ${deathBlock.strongTeams.length}チーム)\n`;
    analysis += `◆ 恵まれたブロック: ${blessedBlock.name}ブロック (有力校 ${blessedBlock.strongTeams.length}チーム)\n`;
    if (crushR1.length > 0) {
        analysis += `◆ 1回戦での有力校潰し合い:\n${crushR1.map(c => `  - ${c}`).join('\n')}\n`;
    } else {
        analysis += `◆ 1回戦での有力校同士の直接対決はなし。\n`;
    }
    if (goodCardsR2.length > 0) {
        analysis += `◆ 勝ち上がれば2回戦で実現しそうな好カード:\n${goodCardsR2.map(c => `  - ${c}`).join('\n')}\n`;
    }
     if (goodCardsR3.length > 0) {
        analysis += `◆ 勝ち上がれば3回戦で実現しそうな好カード:\n${goodCardsR3.map(c => `  - ${c}`).join('\n')}\n`;
    }

    commentDirections = `
- 分析結果に基づき、「死のブロック」に入ったチームへの同情や、「恵まれたブロック」への羨望コメント。
- 「1回戦の潰し合い」カードについて、「もったいない」「初戦から熱い」などの反応。
- 「2回戦・3回戦の好カード」予想について、「〇〇ブロックは3回戦が事実上の決勝だな」「△△ vs □□が見たい！」などの期待コメント。
- 自分の応援するチームがどのブロックに入り、勝ち上がりはどうなりそうか、という個人的な視点でのコメント。
- シード校が順当に勝ち上がるのか、ノーシードのダークホースが波乱を起こすのか、といった大会全体の展望。`;
    // --- ここまでが分析ロジック ---

    // --- プロンプトの組み立て (分析結果を反映) ---
    const prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下のトーナメントの組み合わせ分析を読んで、ファンらしいリアルな短いコメントを**7～10個**生成してください。

### 組み合わせ分析結果
${analysis}

### コメントの方向性 (上記の分析結果を踏まえて)
${commentDirections}

### 出力形式
必ず以下のJSON配列形式で出力してください。
[
  {"personality": "匿名ファンA", "comment": "（コメント本文）"},
  {"personality": "野球通B", "comment": "（コメント本文）"},
  {"personality": "悲観的なファンC", "comment": "（コメント本文）"}
]`; // personalityは適当に変えてOK

    // --- AIへのリクエストと結果の処理 (変更なし) ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                // 順序を保持しつつ、personalityを少しランダムにする
                const personalities = ["風吹けば名無し", "＠実況は実況板で", "甲子園大好き芸人", "データ厨", "OBのおっちゃん"];
                return commentsJson.map((c, index) => ({
                    id: crypto.randomUUID(),
                    // 元の personality を使いつつ、少しバリエーションを加える
                    personality: `${index + 1}: ${c.personality || personalities[Math.floor(Math.random() * personalities.length)]}`,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI組み合わせ反応コメントの生成に失敗しました:", error);
        return []; // エラー時は空配列を返す
    }
}
    
/**
 * ユーザーのコメント一つに対して、複数のAIファンからの返信を一度に生成する
 * (★チーム「通算」盗塁への言及指示を追加した最終版)
 */
async function generateMultipleReplies(userCommentText) {
    const conversationHistory = `あなた: 「${userCommentText}」`;

    // --- AIに与える「知識」の部分を作成（完全版） ---
    const mentionedTeams = new Set();
    const mentionedPlayers = new Set(); 

    INITIAL_TEAM_POOL.forEach(team => {
        if (userCommentText.includes(team)) {
            mentionedTeams.add(team);
            const detailedData = DETAILED_TEAM_DATA[team];
            if (detailedData) {
                detailedData.players.forEach(p => mentionedPlayers.add({name: p.name, team: team}));
            }
        } else {
            const detailedData = DETAILED_TEAM_DATA[team];
            if(detailedData) {
                detailedData.players.forEach(p => {
                    if (userCommentText.includes(p.name)) {
                        mentionedPlayers.add({name: p.name, team: team});
                    }
                });
            }
        }
    });

    let teamInfoPromptPart = '### 参考情報：関連チームと選手の状況\n';
    
    // チーム全体の状況 (★ここでチーム打率・通算盗塁が取得される)
    mentionedTeams.forEach(teamName => {
        const teamData = TEAM_DATA[teamName];
        const teamRecord = tournamentState.teamRecords[teamName];
        const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord); 
        const fate = getTeamFateSummary(teamName);
        teamInfoPromptPart += `- **${teamName}**: ${dynamicInfo} (今大会の状況: ${fate})\n`;
    });

    // ▼▼▼ ★★★ Gamelog取得ロジックに置き換え ★★★ ▼▼▼
    // 言及された全選手のGamelogを取得
    teamInfoPromptPart += formatPlayerGamelogsForPrompt(mentionedTeams, userCommentText);
    // ▲▲▲

    // --- プロンプト作成 ---
    const prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
ユーザー「あなた」の投稿した以下のコメントに対し、4人の異なるキャラクターとして返信してください。
### **ユーザーのコメント**: 「${userCommentText}」
### **現在の大会状況**: ${getTournamentStatusSummary()}
${teamInfoPromptPart}
### **指示**:
- 各キャラクターの返信は、必ずユーザーのコメント内容に直接関連していること。
- **【重要】**: あなたの知識である「参考情報」を最大限に活用し、具体的なチーム状況や**個人成績**に触れながら、的確な返信をすること。
- **【★Gamelogの活用 (最重要)】**:
    - 「参考情報：今大会の主な選手成績履歴」に、言及された選手の**試合ごとの詳細な履歴 (Gamelog)** が含まれています。
    - あなたの返信は、この**Gamelog**を基に、以下の点を分析してください。
    - **好不調の波**: 「3試合連続ヒット中」「10打数ノーヒット」など、選手の**「調子の波」**を分析すること。
    - **対戦相手の質**: 「格下[E]相手にしか打ってない」「Aランク[A]投手から打った」など、**「相手の質」**を分析すること。
    - **役割**: 「代打で結果を出している」「1番に抜擢されてから好調」など、**「役割」**を分析すること。
    - **登板間隔**: 「連投」「中1日」など、**「投手のコンディション」**を分析すること。
- **【★今大会の成績 (重要)】**:
    - 「参考情報」に**『今大会のチーム打率は.XXX』**という情報が含まれている場合、それにも触れ、チーム全体の好調・不振について言及すること。
- **【★通算盗塁への言及 (裁量)】**:
    - 「参考情報」に**『(参考: ... 通算 Y 盗塁)』**という情報が含まれている場合、必要に応じてそのチームの機動力にも言及すること。
// ▲▲▲ 置き換えここまで ▲▲▲
- **【注意】**: まだ大会序盤である（例：2試合しか終わっていない）ことを考慮し、「本塁打が少ない」といった早計な批判は避けること。
---
---### **ステップ4：出力形式**
【最重要】必ず以下のJSON配列形式"のみ"で出力すること。
[
    {"personality": "熱狂的なファン", "comment": "（コメント本文）"},
    {"personality": "上から目線の解説者", "comment": "（コメント本文）"},
    {"personality": "アンチ", "comment": "（コメント本文）"},
    {"personality": "ライバル校のファン", "comment": "（コメント本文）"}
]`;
    
    // --- 4. Call AI and Process Response ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI multi-reply generation failed:", error);
        return [];
    }
}

/**
 * (ホームページ用) 2024年決勝 (283 vs 菊川) の架空ボックススコアHTMLを生成する
 */
function generate2024FinalBoxScore() {
    const team1 = "常葉菊川"; // 先攻
    const team2 = "283学園";  // 後攻
    const score1 = 2;
    const score2 = 5;

    // --- 1. イニングスコアボード ---
    const scoreBoardHtml = `
        <table class="boxscore-table">
            <thead class="inning-header">
                <tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>計</th><th>H</th><th>E</th></tr>
            </thead>
            <tbody>
                <tr>
                    <td class="team-name">${team1}</td>
                    <td class="score-cell">1</td><td class="score-cell">0</td><td class="score-cell">1</td>
                    <td class="score-cell">0</td><td class="score-cell">0</td><td class="score-cell">0</td>
                    <td class="score-cell">0</td><td class="score-cell">0</td><td class="score-cell">0</td>
                    <td class="total-score">${score1}</td>
                    <td class="total-score">6</td>
                    <td class="total-score">1</td>
                </tr>
                <tr>
                    <td class="team-name">${team2}</td>
                    <td class="score-cell">0</td><td class="score-cell">0</td><td class="score-cell">2</td>
                    <td class="score-cell">0</td><td class="score-cell">1</td><td class="score-cell">0</td>
                    <td class="score-cell">2</td><td class="score-cell">0</td><td class="score-cell">X</td>
                    <td class="total-score">${score2}</td>
                    <td class="total-score">10</td>
                    <td class="total-score">0</td>
                </tr>
            </tbody>
        </table>
    `;

    // --- 2. 常葉菊川 (先攻) ---
    const team1Html = `
        <h3 class="text-xl font-bold mt-6 mb-2 text-gray-800">${team1}</h3>
        <table class="batting-stats-table">
            <thead>
                <tr>
                    <th class="pos"></th><th class="player">選手名</th>
                    <th class="at-bat">打</th><th class="runs">得</th><th class="hits">安</th><th class="rbi">点</th>
                    <th class="so">三</th><th class="walks">四</th><th class="results">打席結果</th>
                </tr>
            </thead>
            <tbody>
                <tr><td class="pos">遊</td><td class="player">1. 坂本 [3年]</td><td class="at-bat">4</td><td class="runs">1</td><td class="hits">1</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">中安, 三振, 遊ゴ, 二飛</td></tr>
                <tr><td class="pos">中</td><td class="player">2. 森 [2年]</td><td class="at-bat">4</td><td class="runs">1</td><td class="hits">1</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">投ゴ, 左安, 中飛, 三ゴ</td></tr>
                <tr><td class="pos">右</td><td class="player">3. 岡田 [3年]</td><td class="at-bat">4</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">1</td><td class="so">1</td><td class="walks">0</td><td class="results">中安①, 三ゴ, 三振, 左飛</td></tr>
                <tr><td class="pos">三</td><td class="player">4. 近藤 [3年]</td><td class="at-bat">4</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">二ゴ, 遊ゴ, 中安, 二飛</td></tr>
                <tr><td class="pos">捕</td><td class="player">5. 土方 [3年]</td><td class="at-bat">4</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">2</td><td class="walks">0</td><td class="results">三振, 二ゴ, 三振, 一ゴ</td></tr>
                <tr><td class="pos">一</td><td class="player">6. 宮本 [3年]</td><td class="at-bat">4</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">1</td><td class="so">1</td><td class="walks">0</td><td class="results">三振, 中安①, 遊ゴ, 一ゴ</td></tr>
                <tr><td class="pos">左</td><td class="player">7. 上泉 [3年]</td><td class="at-bat">3</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">二ゴ, 左飛, 遊ゴ</td></tr>
                <tr class="sub-player"><td class="pos">打</td><td class="player">└ 疋田 [2年]</td><td class="at-bat">1</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">三振</td></tr>
                <tr><td class="pos">二</td><td class="player">8. 柳生 [2年]</td><td class="at-bat">3</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">左飛, 遊安, 二ゴ</td></tr>
                <tr><td class="pos">投</td><td class="player">9. 沖田 [3年]</td><td class="at-bat">2</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">投ゴ, 一ゴ</td></tr>
                <tr class="sub-player"><td class="pos">投</td><td class="player">└ 拝 [3年]</td><td class="at-bat">1</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">二ゴ</td></tr>
                <tr class="team-totals"><td class="player" colspan="2">合計</td><td class="at-bat">34</td><td class="runs">2</td><td class="hits">6</td><td class="rbi">2</td><td class="so">6</td><td class="walks">0</td><td class="results"></td></tr>
            </tbody>
        </table>
        <table class="pitching-stats-table">
            <thead><tr><th class="result"></th><th class="player">投手名</th><th class="ip">回</th><th class="bf">打者</th><th class="hits">安</th><th class="so">三</th><th class="walks">四</th><th class="runs">失</th><th class="er">自</th><th class="era">防御率</th></tr></thead>
            <tbody>
                <tr><td class="result">●</td><td class="player">沖田 (3年)</td><td class="ip">6.0</td><td class="bf">28</td><td class="hits">7</td><td class="so">5</td><td class="walks">1</td><td class="runs">3</td><td class="er">2</td><td class="era">3.00</td></tr>
                <tr><td class="result"></td><td class="player">拝 (3年)</td><td class="ip">2.0</td><td class="bf">8</td><td class="hits">3</td><td class="so">1</td><td class="walks">0</td><td class="runs">2</td><td class="er">2</td><td class="era">9.00</td></tr>
            </tbody>
        </table>
    `;

    // --- 3. 283学園 (後攻) ---
    const team2Html = `
        <h3 class="text-xl font-bold mt-6 mb-2 text-gray-800">${team2}</h3>
        <table class="batting-stats-table">
            <thead>
                <tr>
                    <th class="pos"></th><th class="player">選手名</th>
                    <th class="at-bat">打</th><th class="runs">得</th><th class="hits">安</th><th class="rbi">点</th>
                    <th class="so">三</th><th class="walks">四</th><th class="results">打席結果</th>
                </tr>
            </thead>
            <tbody>
                <tr><td class="pos">中</td><td class="player">1. 花海 咲 [2年]</td><td class="at-bat">4</td><td class="runs">1</td><td class="hits">1</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">三振, 中安, 遊ゴ, 二ゴ</td></tr>
                <tr><td class="pos">二</td><td class="player">2. 佐藤 健太 [3年]</td><td class="at-bat">4</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">三飛, 三振, 中飛, 左安</td></tr>
                <tr><td class="pos">遊</td><td class="player">3. 十王 翔希 [2年]</td><td class="at-bat">4</td><td class="runs">1</td><td class="hits">1</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">遊ゴ, 右安, 中飛, 一ゴ</td></tr>
                <tr><td class="pos">投</td><td class="player">4. 姫川 友紀 [2年]</td><td class="at-bat">3</td><td class="runs">1</td><td class="hits">1</td><td class="rbi">2</td><td class="so">0</td><td class="walks">1</td><td class="results">二ゴ, <span style="color:red;font-weight:bold;">中本②</span>, 四球, 左飛</td></tr>
                <tr class="sub-player"><td class="pos">投</td><td class="player">└ 白瀬 咲耶 [2年]</td><td class="at-bat">1</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">投ゴ</td></tr>
                <tr><td class="pos">一</td><td class="player">5. 高橋 龍 [3年] (C)</td><td class="at-bat">4</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">1</td><td class="so">1</td><td class="walks">0</td><td class="results">三振, 二ゴ, 右安①, 遊ゴ</td></tr>
                <tr><td class="pos">捕</td><td class="player">6. 有栖川 夏葉 [2年]</td><td class="at-bat">4</td><td class="runs">1</td><td class="hits">2</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">左安, 中安, 二ゴ, 遊ゴ</td></tr>
                <tr><td class="pos">三</td><td class="player">7. 田中 浩二 [3年]</td><td class="at-bat">4</td><td class="runs">1</td><td class="hits">2</td><td class="rbi">2</td><td class="so">1</td><td class="walks">0</td><td class="results">三振, 右安, <span style="color:red;font-weight:bold;">右二②</span>, 三ゴ</td></tr>
                <tr><td class="pos">左</td><td class="player">8. 渡辺 翔 [3年]</td><td class="at-bat">3</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">二ゴ, 三振, 左安</td></tr>
                <tr class="sub-player"><td class="pos">打</td><td class="player">└ 樋口 円香 [1年]</td><td class="at-bat">1</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">三振</td></tr>
                <tr><td class="pos">右</td><td class="player">9. 鈴木 一郎 [3年]</td><td class="at-bat">3</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">三振, 中飛, 左飛</td></tr>
                <tr class="sub-player"><td class="pos">打</td><td class="player">└ 鈴木(1年) [1年]</td><td class="at-bat">1</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">二ゴ</td></tr>
                <tr class="team-totals"><td class="player" colspan="2">合計</td><td class="at-bat">35</td><td class="runs">5</td><td class="hits">10</td><td class="rbi">5</td><td class="so">6</td><td class="walks">1</td><td class="results"></td></tr>
            </tbody>
        </table>
        <table class="pitching-stats-table">
            <thead><tr><th class="result"></th><th class="player">投手名</th><th class="ip">回</th><th class="bf">打者</th><th class="hits">安</th><th class="so">三</th><th class="walks">四</th><th class="runs">失</th><th class="er">自</th><th class="era">防御率</th></tr></thead>
            <tbody>
                <tr><td class="result">○</td><td class="player">姫川 友紀 (2年)</td><td class="ip">6.0</td><td class="bf">24</td><td class="hits">5</td><td class="so">4</td><td class="walks">0</td><td class="runs">2</td><td class="er">2</td><td class="era">3.00</td></tr>
                <tr><td class="result">Ｓ</td><td class="player">白瀬 咲耶 (2年)</td><td class="ip">3.0</td><td class="bf">10</td><td class="hits">1</td><td class="so">1</td><td class="walks">0</td><td class="runs">0</td><td class="er">0</td><td class="era">0.00</td></tr>
            </tbody>
        </table>
    `;

    return scoreBoardHtml + team1Html + team2Html;
}
// ▲▲▲ 新規追加ここまで ▲▲▲

/**
     * AIにナムコグループからのお知らせを生成させる
     */
    async function generateNamcoNews(state, type, matchData = null) {
        const namcoSchools = ["初星学園", "765総合高校", "283学園", "美城学園", "283学園B"];
        let prompt = '';

        if (type === 'bracket') {
            const participatingSchools = state.teams.filter(t => namcoSchools.includes(t));
            if(participatingSchools.length === 0) return null;

            const matchups = participatingSchools.map(school => {
                const schoolIndex = state.teams.indexOf(school);
                if (schoolIndex === -1) return null;
                const opponentIndex = schoolIndex % 2 === 0 ? schoolIndex + 1 : schoolIndex - 1;
                const opponentName = state.teams[opponentIndex];
                return `- ${school} の初戦は ${opponentName} と対戦します。`;
            }).filter(item => item !== null).join('\n');

            prompt = `あなたはナムコグループの広報担当者です。
夏の高校野球選手権大会の組み合わせが決定しました。
以下の情報に基づき、グループの公式サイトに掲載する、プロフェッショナルで丁寧な「お知らせ」記事を生成してください。

### 各校の初戦の組み合わせ
${matchups}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）組み合わせ決定のお知らせ」とする。
- 本文では、抽選会が行われたことと、上記の組み合わせが決定したことを報告してください。
- 最後に、系列校野球部への応援をお願いする言葉で締めくくる。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}`;
        } else if (type === 'matchResult') {
            const { winnerName, loserName, dbMatch } = matchData;
            const isCivilWar = (winnerName === '283学園' && loserName === '283学園B') || (winnerName === '283学園B' && loserName === '283学園');

            if (isCivilWar) {
                // ... (省略)
            } else {
                const namcoTeam = namcoSchools.includes(winnerName) ? winnerName : loserName;
                const opponent = namcoSchools.includes(winnerName) ? loserName : winnerName;
                const result = namcoSchools.includes(winnerName) ? '勝利' : '敗北';
                const score = namcoSchools.includes(winnerName) ? `${dbMatch.score1}-${dbMatch.score2}` : `${dbMatch.score2}-${dbMatch.score1}`;

                prompt = `あなたはナムコグループの広報担当者です。
本日行われた、夏の高校野球選手権大会の試合結果について、公式サイトに掲載する「お知らせ」記事を生成してください。

### 試合情報
- 系列校: ${namcoTeam}
- 対戦相手: ${opponent}
- 結果: ${namcoTeam}の${result}
- スコア: ${score}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）試合結果のお知らせ」とする。
- 本文では、まず試合が行われたことと、結果を簡潔に報告する。
- **もし勝利した場合:**
  - 応援への感謝を述べ、次の試合への意気込みを語る（例：「次戦もチーム一丸となって勝利を目指します」）。
- **もし敗北した場合:**
  - 選手たちの健闘を称え、応援への感謝を深く述べる（例：「皆様の熱い声援が、選手の力となりました。心より感謝申し上げます」）。
  - 新チームでの再起を誓う言葉で締めくくる。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}`;
            }
        }

        if (!prompt) return null;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const newsJson = parseJsonFromText(rawText);
                if (newsJson) {
                    return { ...newsJson, timestamp: Date.now() };
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("ナムコニュースの生成に失敗しました:", error);
            return null;
        }
    }

/**
 * AIが生成した新聞データからHTMLを生成する
 * (★sinbun.txtを参考に、Webニュース記事風のレイアウトに変更)
 */
function createNewspaperHtml(articleData, matchData) {
    const { winnerName, loserName, dbMatch, matchId } = matchData;
    const idParts = matchId.split('-');
    // 128チーム制(7ラウンド)に対応
    const roundNum = idParts[0] === 'F' ? Math.log2(tournamentState.teams.length) : parseInt(idParts[1].slice(1));
    const isLateRound = roundNum >= 5; // R5(準々決勝)以降
    const containerClass = isLateRound ? 'newspaper-late' : 'newspaper-early';
    const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
    const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;

    // AIが生成した本文(article.body)を、最初の段落（リード文）と残りの本文に分割する
    let bodyText = articleData.body.replace(/\\n/g, '\n');
    let leadSentence = articleData.title; // デフォルトではサブ見出し(h2)は記事タイトル
    let mainBody = bodyText;

    const firstParagraphBreak = bodyText.indexOf('\n\n'); // 最初の空行（段落区切り）を探す
    if (firstParagraphBreak !== -1) {
        // 最初の空行までをリード文とする
        leadSentence = bodyText.substring(0, firstParagraphBreak).trim();
        // それ以降を本文とする
        mainBody = bodyText.substring(firstParagraphBreak).trim();
    } else {
        // 段落区切りがない場合、AIが生成した記事タイトル(article.title)をリード文として使用
        mainBody = bodyText;
        leadSentence = articleData.title;
    }
    
    // sinbun.txt [cite: 63, 65] を参考に、写真キャプションを生成
    // AIが生成した newspaperData からキャプションを取得
    const photoCaption = articleData.newspaperData?.photoCaption || `[${getRoundNameFromMatchId(matchId)}の様子]`;

    // sinbun.txt  を参考に、AIが生成した大見出し (newspaperData.mainHeadline) を取得
    const mainHeadline = articleData.newspaperData?.mainHeadline || `${winnerName}、${loserName}を下し${getRoundNameFromMatchId(matchId)}突破`;

    return `
        <div class="newspaper-container ${containerClass}">
            <div class="newspaper-header">
                <h2 class="newspaper-title">熱闘スポーツ</h2>
                <p class="newspaper-date">${new Date(articleData.timestamp).toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
            </div>
            
            <div class="newspaper-content">
                <h1 class="newspaper-main-headline">${mainHeadline}</h1>
                
                <h2 class="newspaper-sub-headline">${leadSentence}</h2>
                
                ${isLateRound ? `
                    <figure class="newspaper-image-wrapper">
                        <div class="newspaper-image-placeholder">${photoCaption}</div>
                        <figcaption class="newspaper-image-caption">${photoCaption}（カメラ・AI記者）</figcaption>
                    </figure>
                ` : ''}
                
                <p class="newspaper-text">${mainBody.replace(/\n/g, '<br><br>')}</p>
                
                <div class="newspaper-score-box">
                    <h3>${getRoundNameFromMatchId(matchId)} 最終スコア</h3>
                    <p class="score">${winnerName} ${winnerScore} - ${loserScore} ${loserName}</p>
                </div>
            </div>
        </div>
    `;
}

async function generateSportsNewspaper(roundNumber) {
    // ★★★ ここからが修正箇所 ★★★
    const numTeams = tournamentState.teams.length; // 128
    const finalRound = Math.log2(numTeams); // 7

    // 128チーム制(7ラウンド)のラウンド名マップ
    const roundNameMap = {
        [finalRound]: '決勝',       // R7 (F-R1-M1)
        [finalRound-1]: '準決勝',   // R6
        [finalRound-2]: '準々決勝', // R5
        [finalRound-3]: '4回戦'     // R4
    };
    // ★★★ 修正ここまで ★★★

    const roundName = roundNameMap[roundNumber];
    if (!roundName) return null; // R1, R2, R3では発行しない

    const matchIdsInRound = Object.keys(tournamentState.matches).filter(id => 
        (id.includes(`-R${roundNumber}-`)) || (roundNumber === finalRound && id.includes('F-R1-'))
    );
    const results = matchIdsInRound.map(id => tournamentState.matches[id]);

    const resultsText = results.map(match => {
        if (!match.winner) return null; // 試合が終わっていない場合は除外
        const winnerRank = getRankDescription(calculateRank(match.winner, tournamentState));
        const loser = match.team1 === match.winner ? match.team2 : match.team1;
        if (!loser) return null; // 相手がいない場合は除外
        const loserRank = getRankDescription(calculateRank(loser, tournamentState));
        const winnerScore = match.team1 === match.winner ? match.score1 : match.score2;
        const loserScore = match.team1 === match.winner ? match.score2 : match.score1;
        return `${winnerRank}・${match.winner}が${loserRank}・${loser}に ${winnerScore}-${loserScore} で勝利。`;
    }).filter(Boolean).join('\n'); // nullを除外

    if (!resultsText) return null; // そのラウンドの結果がまだ出ていない

    const prompt = `あなたは、読者の購買意欲を掻き立てるのが得意な、日本のスポーツ新聞の編集長です。
現在、高校野球の${tournamentState.tournamentYear}年度${tournamentNameMap[tournamentState.currentTournament]}が進行中です。${roundName}の全試合が終了しました。
以下の試合結果を基に、最も衝撃的でドラマチックな出来事を一つ選び出し、それに対応する新聞の一面を飾るテキストを生成してください。

### ${roundName} 全試合結果
${resultsText}

### あなたが作成するテキスト
以下の4つの要素を、JSON形式で出力してください。
1.  **mainHeadline**: 最も重要な結果を伝える、短く、衝撃的で、扇情的な大見出し。（例：「怪物散る！」「王者、盤石の決勝へ」）
2.  **subHeadline**: mainHeadlineを補足する、少し詳しい小見出し。
3.  **photoCaption**: その日のハイライトシーンを切り取った架空の写真に対する、情景が目に浮かぶようなキャプション。（例：「あと一歩及ばず、マウンドに崩れ落ちる〇〇高校のエース△△」）
4.  **otherResults**: その他の注目すべき結果を2つ、簡潔にまとめたもの。

### 出力形式
{"mainHeadline": "...", "subHeadline": "...", "photoCaption": "...", "otherResults": ["...", "..."]}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const newspaperData = parseJsonFromText(rawText);
            if (newspaperData) return newspaperData;
        }
        throw new Error("AI newspaper response format error.");
    } catch (error) {
        console.error("AI newspaper generation failed:", error);
        return null;
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

   /**
     * ラウンド終了時に新聞発行などのイベントを処理する
     * (★128チーム制＝7ラウンド制に対応)
     */
    async function handleRoundCompletion(roundNumber) {
        // ★★★ ここからが修正箇所 ★★★
        const numTeams = tournamentState.teams.length; // 128
        const finalRound = Math.log2(numTeams); // 7

        // R4, R5, R6, R7(決勝) で発行
        const significantRounds = [finalRound, finalRound - 1, finalRound - 2, finalRound - 3].filter(r => r > 0);
        if (!significantRounds.includes(roundNumber)) return;

        // ★ 既に「この大会の」「このラウンド」の新聞が発行済みかチェック
        const alreadyExists = tournamentState.news.some(n => 
            n.roundNumber === roundNumber && 
            n.isNewspaper &&
            n.context?.tournament === tournamentState.currentTournament // 大会キーもチェック
        );
        if (alreadyExists) return;

        const newspaperData = await generateSportsNewspaper(roundNumber);
        if (newspaperData) {
            // 128チーム制(7ラウンド)のラウンド名マップ
            const roundNameMap = {
                [finalRound]: '決勝',       // R7
                [finalRound-1]: '準決勝',   // R6
                [finalRound-2]: '準々決勝', // R5
                [finalRound-3]: '4回戦'     // R4
            };
            // ★★★ 修正ここまで ★★★
            const roundName = roundNameMap[roundNumber] || `${roundNumber}回戦`;

            tournamentState.news.push({
                title: `【熱闘新聞】${roundName}特集号が発行されました！`,
                body: newspaperData.subHeadline,
                timestamp: Date.now(),
                isNewspaper: true,
                roundNumber: roundNumber,
                newspaperData: newspaperData,
                context: { // ★ 再生成や識別用にコンテキストを追加
                    isNewspaper: true,
                    round: roundNumber,
                    tournament: tournamentState.currentTournament
                }
            });
            renderNews(tournamentState.news);
            saveState();
        }
    }
// ▲▲▲ 置き換えここまで ▲▲▲

    /**
     * 新聞モーダルを描画する
     */
    function renderNewspaperModal(newspaperData) {
        const { mainHeadline, subHeadline, photoCaption, otherResults, imageUrl } = newspaperData;
        
        const imageHtml = imageUrl 
            ? `<img src="${imageUrl}" alt="${photoCaption}" class="w-full h-auto my-4 border">` 
            : `<div class="newspaper-image-placeholder my-4"><p class="text-sm p-4">${photoCaption}</p></div>`;

        newspaperModalBody.innerHTML = `
            <div class="newspaper-container newspaper-late">
                <div class="newspaper-header">
                    <h2 class="newspaper-title">熱闘スポーツ</h2>
                    <p class="newspaper-date">${new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                </div>
                <div class="newspaper-content">
                    <h1 class="newspaper-main-headline">${mainHeadline}</h1>
                    <div class="newspaper-body-content">
                        <h2 class="newspaper-sub-headline">${subHeadline}</h2>
                        ${imageHtml}
                        <div class="newspaper-score-box">
                            <h3>その他の主な結果</h3>
                            ${otherResults.map(r => `<p>${r}</p>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

  /**
 * AIに掲示板の返信を生成させる（最新の環境に適合した最終版）
 * (★チーム「通算」盗塁への言及指示を追加した最終版)
 */
async function generateBbsReply(parentCommentId, userReplyText, bbsType, aiPersona, context) {
    const commentSource = bbsType === 'general' ? tournamentState.bbsComments : tournamentState.daiyaBbsComments;
    const parentComment = findCommentById(commentSource, parentCommentId);
    if (!parentComment) return null;

    // --- 1. AIに渡すための「文脈」を収集する ---
    const userReplyObject = { id: 'temp_user_reply', personality: 'あなた', text: userReplyText, replies: [] };
    parentComment.replies.push(userReplyObject);
    const conversationHistory = formatConversationHistory(commentSource, 'temp_user_reply');
    parentComment.replies.pop();

    const mentionedTeams = new Set();
    conversationHistory.split('\n').forEach(line => {
        INITIAL_TEAM_POOL.forEach(team => {
            if (line.includes(team)) {
                mentionedTeams.add(team);
            }
        });
    });

    // --- 2. AIに与える「知識」の部分を作成する ---
    let teamInfoPromptPart = '';
    if (mentionedTeams.size > 0) {
        teamInfoPromptPart = '### 関連チームの背景情報\n';
        mentionedTeams.forEach(teamName => {
            const teamData = TEAM_DATA[teamName];
            const teamRecord = tournamentState.teamRecords[teamName];
            const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord); // ★打率・通算盗塁入りの情報を取得
            teamInfoPromptPart += `- **${teamName}**: ${dynamicInfo}\n`;
        });
    }
    
    // ▼▼▼ ★★★ Gamelog取得ロジックを追加 ★★★ ▼▼▼
    // 会話全体（親コメント＋あなたの返信）から選手名をスキャン
    const fullConversationText = `${parentComment.text}\n${userReplyText}`;
    teamInfoPromptPart += formatPlayerGamelogsForPrompt(mentionedTeams, fullConversationText);
    // ▲▲▲
// ▲▲▲ 置き換えここまで ▲▲▲
    // --- 3. 最終的なプロンプトを組み立てる（★脱線防止策を適用） ---
    const prompt = `あなたは、匿名掲示板のキャラクター「${aiPersona}」です。あなたは今、他のユーザーと日本の高校野球について会話しています。
あなたの唯一の仕事は、会話の流れとあなたの知識に基づき、キャラクターになりきって自然な返信をすることです。野球以外の話題には絶対に触れないでください。
---
### **ステップ1：現在の会話状況を理解する**
- **これまでの会話の流れ**:
${conversationHistory}
- **あなたのキャラクター**: ${aiPersona}
- **現在の大会状況**: ${context.tournamentSummary}
---
### **ステップ2：関連情報を思い出す**
${teamInfoPromptPart}
---
### **ステップ3：返信する**
上記のステップ1と2の情報を元に、会話の最後の発言「${userReplyText}」に対して、あなたのキャラクターとして最も自然で的を射た返信を生成してください。
- **指示**:
  - 必ず相手の発言に直接応答することから始めること。
  - 応答の根拠として、ステップ2の「関連情報」を自然な形で会話に含めること。
  - **【★Gamelogの活用 (最重要)】**:
      - 「参考情報：今大会の主な選手成績履歴」に、言及された選手の**試合ごとの詳細な履歴 (Gamelog)** が含まれています。
      - あなたの返信は、この**Gamelog**を基に、以下の点を分析してください。
      - **好不調の波**: 「3試合連続ヒット中」「10打数ノーヒット」など、選手の**「調子の波」**を分析すること。
      - **対戦相手の質**: 「格下[E]相手にしか打ってない」「Aランク[A]投手から打った」など、**「相手の質」**を分析すること。
      - **登板間隔**: 「連投」「中1日」など、**「投手のコンディション」**を分析すること。
  - **【★今大会の成績 (重要)】**:
      - 「参考情報」に**『今大会のチーム打率は.XXX』**という情報が含まれている場合、それにも触れ、チーム全体の好調・不振について言及すること。
  - **【★通算盗塁への言及 (裁量)】**:
      - 「参考情報」に**『(参考: ... 通算 Y 盗塁)』**という情報が含まれている場合、必要に応じてそのチームの機動力にも言及すること。
// ▲▲▲ 置き換えここまで ▲▲▲
  - 相手が話していない無関係なチームや試合の情報を一方的に解説しないこと。
---
### **ステップ4：出力形式**
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"comment": "（あなたの返信本文）"}`;
    
    // --- 4. AIを呼び出し、結果を処理する ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const replyJson = parseJsonFromText(rawText);
            if (replyJson && replyJson.comment) {
                return {
                    id: crypto.randomUUID(),
                    personality: aiPersona,
                    text: replyJson.comment,
                    timestamp: Date.now(),
                    replies: []
                };
            }
        }
        throw new Error("AIの応答形式が不正です。");
    } catch (error) {
        console.error("AI返信コメントの生成に失敗しました:", error);
        return null;
    }
}


/**
     * AIからの応答テキストからJSONオブジェクトを安全に抽出する
     */
    function parseJsonFromText(text) {
        try {
            const cleanedText = text.replace(/```json/g, '').replace(/```/g, '').trim();
            const jsonMatch = cleanedText.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch (e) {
            console.error("Failed to parse JSON from text:", text, e);
        }
        return null;
    }

    /**
     * リトライ機能付きでバックエンドAPI(Netlify Function)を呼び出す
     */
    async function fetchWithRetry(payload, maxRetries = 3) {
        const functionUrl = '/.netlify/functions/generateApiContent'; // Netlify Functionのエンドポイント
        let lastError;

        for (let i = 0; i < maxRetries; i++) {
            try {
                const response = await fetch(functionUrl, {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    return response;
                }
                
                if (response.status >= 400 && response.status < 500 && response.status !== 429) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error}`);
                }

                lastError = new Error(`API Error: ${response.status}`);
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));

            } catch (error) {
                lastError = error;
                const delay = Math.pow(2, i) * 1000;
                if (i < maxRetries - 1) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        throw lastError;
    }

    /**
     * チームランク（A～E）から説明的な文字列を取得する
     */
    function getRankDescription(rank) {
        switch(rank) {
            case 'A': return '名門校';
            case 'B': return '強豪校';
            case 'C': return '中堅校';
            case 'D': return '発展途上のチーム';
            case 'E': return '挑戦者';
            default: return '実力不明';
        }
    }
    
/**
 * [NEW] 選手の調子フラグを絵文字アイコンに変換する
 * (★「軽傷[🩹]」フラグを追加)
 */
function getPlayerConditionIcon(flag) {
    if (!flag) return "";
    
    // ★★★ 故障・体調不良 (最優先) ★★★
    if (flag === "injured" || flag === "sick") { // 重傷/病気
        return '<span class="condition-icon" title="故障中/体調不良 (起用不可)">🏥</span>';
    }
    if (flag === "minor_injury") { // 軽傷
        return '<span class="condition-icon" title="軽い怪我 (次戦起用不可)">🩹</span>';
    }
    // ★★★ 修正ここまで ★★★

    // 5段階評価
    if (flag === "peak") return '<span class="condition-icon" title="絶好調">🔥</span>';
    if (flag === "hot" || flag === "hot_streak") return '<span class="condition-icon" title="好調">👍</span>';
    if (flag === "cold" || flag === "slumping") return '<span class="condition-icon" title="不調">❄️</span>';
    if (flag === "slump") return '<span class="condition-icon" title="絶不調">🥶</span>';
    
    // 特殊フラグ
    if (flag === "fatigued") return '<span class="condition-icon" title="疲労">😓</span>';
    if (flag === "powered_up") return '<span class="condition-icon" title="一発警戒">💪</span>';
    if (flag === "clutch_hitter") return '<span class="condition-icon" title="勝負強い">✨</span>';
    if (flag === "dominant") return '<span class="condition-icon" title="圧巻">🔥</span>';
    if (flag === "crafty_pitcher") return '<span class="condition-icon" title="技巧派">👍</span>';
    if (flag === "seeking_redemption") return '<span class="condition-icon" title="要修正">❄️</span>';
    if (flag === "tough_loss" || flag === "unlucky") return '<span class="condition-icon" title="不運">😓</span>';
    
    return ""; // 'normal' や不明なフラグは何も表示しない
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
     * チーム名からシードランクの文字列 (例: "(第1シード)") を取得するヘルパー関数
     * @param {string} teamName - チーム名
     * @param {Array<object>} seeds - tournamentState.seeds (シード校のオブジェクト配列)
     * @returns {string} - "(第1シード)" または ""
     */
    function getSeedRankString(teamName, seeds) {
        if (!seeds || !teamName) return '';
        // seeds 配列が { team: "...", rank: 1 } の形式であることを前提とする
        const seedInfo = seeds.find(s => s.team === teamName);
        return seedInfo ? `(第${seedInfo.rank}シード)` : '';
    }

    /**
 * Generates a team's tournament path history, compatible with all tournament types.
 */
function getTournamentPath(teamName, startingMatchId) {
    if (!teamName) return "（不明）";
    const path = [];
    
    // Combine all matches from all tournaments into one list
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    // Determine the current round number to analyze up to that point
    const idParts = startingMatchId.split('-');
    if (idParts.length < 3) return '（地区予選突破）'; // Not a main tournament match
    let currentRoundNum = parseInt(idParts[1].slice(1));

    // Loop from the first round up to the current round
    for (let r = 1; r < currentRoundNum; r++) {
        // Find the match the team won in that round
        const matchInRound = Object.values(allMatches).find(match =>
            match.id && 
            match.id.includes(`-R${r}-`) && // Belongs to the correct round
            match.winner === teamName
        );

        if (matchInRound) {
            const opponent = matchInRound.team1 === teamName ? matchInRound.team2 : matchInRound.team1;
            const winnerScore = matchInRound.team1 === teamName ? matchInRound.score1 : matchInRound.score2;
            const loserScore = matchInRound.team1 === teamName ? matchInRound.score2 : matchInRound.score1;
            path.push(`${r}回戦 vs ${opponent} (${winnerScore}-${loserScore})`);
        }
    }

    return path.length > 0 ? path.join(' → ') : '（今大会初戦）';
}
    /**
     * AIプロンプト用に、チームの次の対戦相手情報を生成する
     */
    /**
 * Generates the next opponent info, compatible with all tournament structures.
 */
function getNextOpponentInfoForPrompt(teamName) {
    // Combine all matches from all tournaments into one list
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    let latestMatch = null;
    let maxRound = -1;

    // Find the most recent game this team played in
    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (match.team1 === teamName || match.team2 === teamName) {
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 0;
            if (roundNum > maxRound) {
                maxRound = roundNum;
                latestMatch = match;
            }
        }
    }

    if (!latestMatch) return "（まだ試合なし）";
    if (latestMatch.winner !== teamName) return "（この試合で敗退）";
    
    // Find the next game this team is in
    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        
        // Look for a future game where this team is slotted but the opponent is not yet decided
        if ((match.team1 === teamName && !match.team2) || (match.team2 === teamName && !match.tran1)) {
             return "（次の対戦相手は未定）";
        }
        
        // Look for a future game where the opponent is known
        if (match.team1 === teamName && match.team2 && !match.winner) {
             return `次の対戦相手は${match.team2}です。`;
        }
        if (match.team2 === teamName && match.team1 && !match.winner) {
            return `次の対戦相手は${match.team1}です。`;
        }
    }

    return "（優勝、または次のステージへ）";
}
    /**
     * AIプロンプト用に、掲示板の会話履歴をフォーマットする
     */
    function formatConversationHistory(comments, targetId) {
        let history = [];
        function findPath(currentComments, currentPath) {
            for(const comment of currentComments) {
                const newPath = [...currentPath, comment];
                if(comment.id === targetId) {
                    history = newPath;
                    return true;
                }
                if(comment.replies && findPath(comment.replies, newPath)) {
                    return true;
                }
            }
            return false;
        }
        findPath(comments, []);
        return history.map(c => `${c.personality}:「${c.text}」`).join('\n');
    }

    /**
     * AIプロンプト用に、現在の大会状況の要約を生成する
     */
    function getTournamentStatusSummary() {
        if (tournamentState.currentTournament === 'autumn') {
            return `現在、${tournamentState.tournamentYear}年度 秋季大会が進行中です。フェーズ: ${tournamentState.autumnPhase}`;
        }
        
        const finalMatch = tournamentState.matches['F-R1-M1'];
        if (finalMatch?.winner) return `${finalMatch.winner}が優勝しました。`;
        if (finalMatch?.team1 && finalMatch.team2) return `決勝戦の組み合わせは ${finalMatch.team1} vs ${finalMatch.team2} です。`;
        
        const numRounds = Math.log2(tournamentState.teams.length);
        for (let r = numRounds - 1; r >= 1; r--) {
            const roundIds = Object.keys(tournamentState.matches).filter(id => id.includes(`-R${r}-`));
            if (roundIds.some(id => tournamentState.matches[id]?.team1 && tournamentState.matches[id]?.team2)) {
                 const roundNameMap = { 5: "準決勝", 4: "準々決勝", 3: "3回戦", 2: "2回戦", 1: "1回戦"};
                 return `現在、${roundNameMap[r] || r + '回戦'}が進行中です。`;
            }
        }
        return '大会はまもなく開始されます。';
    }

    /**
     * IDを元に、入れ子構造のコメントデータから特定のコメントを見つけ出す
     */
    function findCommentById(comments, id) {
        for (const comment of comments) {
            if (comment.id === id) return comment;
            if (comment.replies && comment.replies.length > 0) {
                const found = findCommentById(comment.replies, id);
                if (found) return found;
            }
        }
        return null;
    }

// ▼▼▼ この関数ブロックを「新規追加」(11843行目あたり) ▼▼▼

/**
 * [NEW] E/D/Cランクチームの「快進撃」を讃えるドラマチックな記事をAIに生成させる
 * (★再生成用に context への情報保存を強化)
 * @param {string} loserName - 敗退したチーム名
 * @param {string} loserRank - 敗退したチームのランク (E, D, C)
 * @param {number} roundNum - 敗退したラウンド番号 (3, 4, 5)
 * @param {object} matchContext - 試合の全コンテキスト
 * @returns {Promise<object>} - 生成された記事オブジェクト
 */
async function generateCinderellaArticle(loserName, loserRank, roundNum, matchContext) {
    const { loserJourney, winnerName, dbMatch } = matchContext;
    const loserScore = (dbMatch.team1 === loserName ? dbMatch.score1 : dbMatch.score2);
    const winnerScore = (dbMatch.team1 === loserName ? dbMatch.score2 : dbMatch.score1);
    
    const rankMap = { 'E': 'Eランク', 'D': 'Dランク', 'C': 'Cランク' };
    const roundMap = { 3: '3回戦', 4: '4回戦', 5: '準々決勝' };
    const storyTitle = `${rankMap[loserRank]}・${loserName}の快進撃、${roundMap[roundNum]}で散る。`;

    const prompt = `あなたは、情熱的で人間ドラマを描くのが得意なスポーツ記者です。
あなたは今、${tournamentState.tournamentYear}年度 夏季大会で、信じられないほどの「快進撃(シンデレラストーリー)」を見せたチームの、最後の試合を取材し終えました。
以下のデータに基づき、彼らの健闘を最大限に「褒め称える」、感動的な特集記事を執筆してください。

### 取材データ
- **主役（敗退チーム）:** ${loserName} (${rankMap[loserRank]})
- **快進撃の軌跡:** ${loserJourney}
- **最後の試合:** ${roundMap[roundNum]}、${winnerName}に ${loserScore}-${winnerScore} で敗退。
- **チームの背景:** ${TEAM_DATA[loserName]?.info || '情報なし'}
- **監督:** ${TEAM_DATA[loserName]?.coach?.name || '監督'}

### 執筆指示
1.  **タイトル:** 「${storyTitle}」のような、彼らの挑戦を讃える感動的なタイトルにしてください。
2.  **記事の焦点:** この記事の主役は**勝者ではなく、敗れた${loserName}**です。
3.  **【最重要】勝ち上がりの軌跡:**
    - 「快進撃の軌跡」(${loserJourney})を必ず記事に含めてください。
    - （例：「ノーシードのEランク校として開幕した彼ら。1回戦で〇〇を、2回戦で格上の△△を破り...」）
    - 彼らが「Eランク」や「Dランク」でありながら、ここまで勝ち上がってきたことが、どれほどの偉業であったかをドラマチックに描写してください。
4.  **最後の試合:** 今日の最後の試合が、いかに彼らが全力を出し切った素晴らしい戦いであったかを、スコア（${loserScore}-${winnerScore}）を交えて描写してください。
5.  **監督と選手のコメント:**
    - 試合後、泣き崩れる選手たち。
    - ${TEAM_DATA[loserName]?.coach?.name || '監督'}の、「選手たちは私の誇りだ。胸を張って地元に帰ろう」といった趣旨のコメントを創作してください。
    - 主将の、「ここまで来られたのは応援のおかげ。悔しいが、悔いはない」といった趣旨の涙のコメントを創作してください。
6.  **締めくくり:** 「彼らの夏は終わった。しかし、${loserName}が見せた夢は、静岡のファンの胸に確かに刻まれた」といった、彼らの挑戦を永遠に記憶するかのような、感動的な言葉で締めくくってください。

### 出力形式 (JSON)
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                return { 
                    ...article, 
                    timestamp: Date.now(),
                    // ★★★ ここからが修正箇所 ★★★
                    context: { 
                        ...matchContext, 
                        isCinderellaStory: true, 
                        loserName: loserName, // loserName を明示的に保存
                        loserRank: loserRank, // loserRank を明示的に保存
                        roundNum: roundNum    // roundNum を明示的に保存
                    }
                    // ★★★ 修正ここまで ★★★
                };
            }
        }
        throw new Error("AI cinderella response format error.");
    } catch (error) {
        console.error(`AI快進撃記事（${loserName}）の生成に失敗しました:`, error);
        return { 
            title: "快進撃 記事生成エラー", body: "AI記者との通信に失敗しました。", 
            timestamp: Date.now(), error: true, errorId: `cinderella-${matchContext.matchId}`,
            // ★★★ ここからが修正箇所 ★★★
            context: { 
                ...matchContext, 
                isCinderellaStory: true, 
                loserName: loserName, // loserName を明示的に保存
                loserRank: loserRank, // loserRank を明示的に保存
                roundNum: roundNum    // roundNum を明示的に保存
            }
            // ★★★ 修正ここまで ★★★
        };
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

// ▼▼▼ この関数ブロックを「新規追加」(11899行目あたり) ▼▼▼
/**
 * [NEW] ラウンドが終了したかチェックし、AI新聞の生成をトリガーする
 * @param {number} roundNum - 終了したラウンド番号 (4, 5, 6, 7)
 */
async function checkAndTriggerNewspaper(roundNum) {
    const numTeams = tournamentState.teams.length; // 128
    const finalRound = Math.log2(numTeams); // 7

    // R4未満は対象外
    if (roundNum < 4) return;

    // ★ 既に「この大会の」「このラウンド」の新聞が発行済みかチェック
    const alreadyExists = tournamentState.news.some(n => 
        n.roundNumber === roundNum && 
        n.isNewspaper &&
        n.context?.tournament === tournamentState.currentTournament
    );
    if (alreadyExists) {
        console.log(`Newspaper for R${roundNum} (${tournamentState.currentTournament}) already exists.`);
        return;
    }

    // 1. このラウンドの全試合数を計算
    let numMatchesInRound;
    let roundMatchIds;
    if (roundNum === finalRound) { // 決勝(R7)
        numMatchesInRound = 1;
        roundMatchIds = Object.keys(tournamentState.matches).filter(id => id.startsWith('F-R1-'));
    } else { // R4, R5, R6
        numMatchesInRound = numTeams / Math.pow(2, roundNum);
        roundMatchIds = Object.keys(tournamentState.matches).filter(id => id.includes(`-R${roundNum}-M`));
    }

    // 2. このラウンドの完了した試合数をカウント
    const completedMatches = roundMatchIds.filter(id => tournamentState.matches[id].winner).length;

    // 3. 全試合が完了しているかチェック
    if (completedMatches === numMatchesInRound) {
        console.log(`Round ${roundNum} complete! Generating Newspaper...`);
        
        // ★ AI新聞を生成
        const newspaperData = await generateSportsNewspaper(roundNum);
        
        if (newspaperData) {
            const roundName = getRoundNameFromMatchId(roundMatchIds[0]); // ラウンド名を取得
            
            tournamentState.news.push({
                title: `【熱闘新聞】${roundName}特集号が発行されました！`,
                body: newspaperData.subHeadline,
                timestamp: Date.now(),
                isNewspaper: true,
                roundNumber: roundNum,
                newspaperData: newspaperData,
                context: {
                    isNewspaper: true,
                    round: roundNum,
                    tournament: tournamentState.currentTournament
                }
            });
            
            renderNews(tournamentState.news); // ニュース欄を更新
            saveState(); // 保存
            console.log(`Newspaper for R${roundNum} generated and saved.`);
        }
    }
}
// ▲▲▲ 新規追加ここまで ▲▲▲

/**
 * [NEW] 終了したラウンドを総括する「なんJまとめスレッド」をAIに生成させる
 * (★currentTournament未定義エラーを修正)
 */
async function generateRoundSummaryBbsThread(roundNum) {
    const state = tournamentState;
    const allMatches = state.matches;
    const numTeams = state.teams.length;
    const tournamentName = tournamentNameMap[state.currentTournament] || '大会';
    const roundName = getRoundNameFromMatchId(`L-R${roundNum}-M1`);
    
    if (roundNum >= Math.log2(numTeams) - 1) { // 準決勝(R6)以降は対象外
        return;
    }
    
    let analysisText = "";
    let upsets = [];
    let closeCalls = [];
    let notableNextMatchups = [];

    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    const getTeamRank = (teamName) => calculateRank(teamName, state);
    
    const roundMatchIds = Object.keys(allMatches).filter(id => id.includes(`-R${roundNum}-M`));

    roundMatchIds.forEach(matchId => {
        const match = allMatches[matchId];
        if (!match.winner) return;
        const winner = match.winner;
        const loser = (match.team1 === winner) ? match.team2 : match.team1;
        if (!loser || loser === '(BYE)') return;
        const rankW = getTeamRank(winner);
        const rankL = getTeamRank(loser);
        const rankDiff = rankValues[rankW] - rankValues[rankL];
        const scoreW = Math.max(parseInt(match.score1) || 0, parseInt(match.score2) || 0);
        const scoreL = Math.min(parseInt(match.score1) || 0, parseInt(match.score2) || 0);
        if (rankDiff <= -2) {
            upsets.push(`${winner}(${rankW}) が ${loser}(${rankL}) を ${scoreW}-${scoreL} で破る大波乱`);
        }
        else if ((rankW === 'A' || rankW === 'B') && (scoreW - scoreL <= 2)) {
            closeCalls.push(`${winner}(${rankW}) が ${loser}(${rankL}) に ${scoreW}-${scoreL} の辛勝`);
        }
    });

    const nextRoundNum = roundNum + 1;
    const nextRoundMatchIds = Object.keys(allMatches).filter(id => id.includes(`-R${nextRoundNum}-M`));

    nextRoundMatchIds.forEach(matchId => {
        const match = allMatches[matchId];
        if (match.team1 && match.team2) {
            const rank1 = getTeamRank(match.team1);
            const rank2 = getTeamRank(match.team2);
            if ((rankValues[rank1] >= 4 && rankValues[rank2] >= 4) || (rankValues[rank1] >= 4 && rankValues[rank2] === 3) || (rankValues[rank1] === 3 && rankValues[rank2] >= 4)) {
                notableNextMatchups.push(`${match.team1}(${rank1}) vs ${match.team2}(${rank2})`);
            }
        }
    });

    analysisText += "### 主な番狂わせ (ジャイアントキリング)\n";
    analysisText += upsets.length > 0 ? upsets.map(s => `- ${s}`).join('\n') : "特になし\n";
    analysisText += "\n### 強豪校の苦戦 (接戦)\n";
    analysisText += closeCalls.length > 0 ? closeCalls.map(s => `- ${s}`).join('\n') : "特になし\n";
    analysisText += `\n### 次のラウンド (${getRoundNameFromMatchId(`L-R${nextRoundNum}-M1`)}) の注目カード\n`;
    analysisText += notableNextMatchups.length > 0 ? notableNextMatchups.map(s => `- ${s}`).join('\n') : "特になし\n";

    // ★★★ ここからが修正箇所 ★★★
    let tournamentContextPrompt = "";
    // `currentTournament` ではなく `state.currentTournament` を使用
    if (state.currentTournament === 'summer') {
        tournamentContextPrompt = "3年生にとってはガチで最後の夏や。";
    } else if (state.currentTournament === 'autumn') {
        tournamentContextPrompt = "新チームの初陣やな。ここでの結果がセンバツ選考に響くで。";
    } else if (state.currentTournament === 'spring') {
        tournamentContextPrompt = "夏のシード権がかかった前哨戦や。";
    }
    // ★★★ 修正ここまで ★★★

    const prompt = `あなたは、匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは高校野球に詳しく、煽りやユーモアを交えながら会話を盛り上げます。
${state.tournamentYear}年度 ${tournamentName}の「${roundName}」が全試合終了しました。
以下の分析結果に基づき、**なんJらしいスレッドタイトル**と、そのスレッド内での**リアルタイムな反応コメントを20〜25個**生成してください。

### 大会の文脈 (最重要)
${tournamentContextPrompt}

### 参考情報：静岡県高校野球の「常識」（勢力図）
${PREFECTURE_LORE}

### ${roundName} 試合結果の分析
${analysisText}

### あなたが生成するコメントの方向性
- **スレッドタイトル:** 「${roundName}が終わったわけやが、」というフレーズを必ず使ってください。
- **【★大会の文脈を反映】**: ${tournamentName}ならではの視点（例：「夏は3年生最後やな」「秋の新チームの仕上がり見えてきたな」「春でシード取れよ」）をコメントに含めること。
- **分析結果への反応:**
    - 「主な番狂わせ」に激しく反応してください。（例：「静高がまさかの小笠に負けてて草」）
    - 「強豪校の苦戦」に反応してください。（例：「283学園が静岡北に4-3とか危なすぎワロタ」）
    - 「次のラウンドの注目カード」に期待するコメントをしてください。（例：「次の静商と翔洋の試合はガチで楽しみ」「〇〇 vs △△、事実上の決勝だろ」）
- **なんJらしさ:**
    - 短い煽りレス。「は？」「雑魚w」「ファーwww」
    - 他のコメントへの安価 (>>) 付きの返信やツッコミ。
    - 自分の応援していたチームの敗退を嘆くコメント（架空でOK）。

### 出力形式 (JSON)
{
  "threadTitle": "（${roundName}が終わったわけやが、〇〇すぎワロタwww）",
  "comments": [
    {"personality": "1: 風吹けば名無し", "comment": "（スレ主のコメント）"},
    {"personality": "2: 風吹けば名無し", "comment": "（住民2のコメント）"}
    // ... (合計20〜25個のコメント) ...
  ]
}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const bbsJson = parseJsonFromText(rawText);
            
            if (bbsJson && bbsJson.threadTitle && Array.isArray(bbsJson.comments)) {
                const threadId = `summary-thread-R${roundNum}-${state.currentTournament}`;
                return {
                    id: threadId,
                    title: bbsJson.threadTitle,
                    matchId: threadId,
                    comments: bbsJson.comments.map((c, index) => ({ 
                        id: crypto.randomUUID(),
                        personality: c.personality || `${index + 1}: 風吹けば名無し`, 
                        text: c.comment,
                        timestamp: Date.now() + index * 10, 
                        replies: [] 
                    })),
                    timestamp: Date.now(),
                    context: { isRoundSummary: true, round: roundNum }
                };
            }
        }
        throw new Error("AI round summary response format error.");
    } catch (error) {
        console.error(`AIラウンド総括スレッド(R${roundNum})の生成に失敗しました:`, error);
        return null;
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲


// ▼▼▼ この関数ブロックを「新規追加」(11842行目あたり) ▼▼▼

/**
 * [NEW] ラウンドが終了したかチェックし、AI総括スレッドの生成をトリガーする
 * (★R6(準決勝)終了時にも実行されるよう修正)
 */
async function checkAndTriggerRoundSummary(roundNum) {
    const numTeams = tournamentState.teams.length; // 128
    const finalRound = Math.log2(numTeams); // 7
    
    // ★★★ 修正箇所 ★★★
    // R6(準決勝) = 6。決勝(R7) = 7。
    // R6終了時(roundNum=6)も実行し、R7(決勝)終了時(roundNum=7)は実行しない。
    if (roundNum > (finalRound - 1)) { // (6 > 6) = false, (7 > 6) = true
        return;
    }
    // ★★★ 修正ここまで ★★★
    
    const threadId = `summary-thread-R${roundNum}-${tournamentState.currentTournament}`;
    
    if (tournamentState.matomeThreads[threadId]) {
        console.log(`Round ${roundNum} (${tournamentState.currentTournament}) summary thread already exists. Skipping.`);
        return;
    }

    const numMatchesInRound = numTeams / Math.pow(2, roundNum);
    const roundMatchIds = Object.keys(tournamentState.matches).filter(id => id.includes(`-R${roundNum}-M`));
    const completedMatches = roundMatchIds.filter(id => tournamentState.matches[id].winner).length;

    if (completedMatches === numMatchesInRound) {
        console.log(`Round ${roundNum} complete! Generating summary thread...`);
        
        const threadData = await generateRoundSummaryBbsThread(roundNum);
        
        if (threadData) {
            tournamentState.matomeThreads[threadData.id] = {
                thread: threadData.comments,
                context: threadData.context
            };
            
            const roundName = getRoundNameFromMatchId(`L-R${roundNum}-M1`);
            tournamentState.news.push({
                title: `【${tournamentNameMap[tournamentState.currentTournament]} ${roundName} 総括】${threadData.title}`,
                body: `AIが${roundName}の全試合を分析し、まとめスレッドを立てたようです。「まとめサイト」から確認できます。`,
                timestamp: Date.now(),
                isMatomeLink: true,
                matomeThreadId: threadData.id
            });
            
            renderNews(tournamentState.news);
            console.log(`Round ${roundNum} summary thread generated and saved.`);
        }
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * [NEW] 選手の「故障」や「アクシデント」に関するAI記事を生成する
 * (★「軽傷(accident_minor_injury)」シナリオを追加)
 * @param {string} teamName - チーム名
 * @param {string} playerName - 選手名
 * @param {string} accidentType - "injury_overuse", "accident_sickness", "accident_hbp", "accident_minor_injury"
 * @param {object} context - 関連するGamelogや状況
 * @returns {Promise<object>} - 生成された記事オブジェクト
 */
async function generateAccidentArticle(teamName, playerName, accidentType, context = {}) {
    let prompt = `あなたは「静岡 熱闘スタジアム」の緊急速報デスクです。
${teamName}の${playerName}選手に関する、ネガティブな「アクシデント」情報が入ってきました。
以下のデータに基づき、ニュース記事を生成してください。

### 取材データ
- **チーム:** ${teamName}
- **選手:** ${playerName}
- **アクシデント種別:** ${accidentType}
- **関連データ:** ${context.log || '情報なし'}
- **監督:** ${TEAM_DATA[teamName]?.coach?.name || '監督'}

### 執筆指示
1.  **タイトル:** 衝撃的なタイトルにしてください。
    - (酷使故障の場合): 「【${teamName}に激震】エース${playerName}、連投の影響で背中に張りか」「${playerName}、${context.round || '次戦'}の出場絶望的」
    - (体調不良の場合): 「（号外）${teamName}にアクシデント！ ${playerName}ら主力数名が体調不良を訴え病院へ」
    - (HBP故障の場合): 「【${teamName}】${playerName}、前試合の死球の影響で骨折か」「${playerName}、無念の戦線離脱」
    - (軽傷の場合): 「【${teamName}】${playerName}、練習中に軽度の捻挫」「${context.log || '前試合での走塁'}が影響か。${playerName}、次戦は大事を取って欠場へ」
2.  **本文:**
    - (酷使故障の場合): ${playerName}が${context.log || '連投'}の影響で、身体の異常（例：肩の違和感、背中の張り）を訴えたことを描写してください。監督が「${context.round || '次戦'}は投げさせない」と明言した、というコメントを創作してください。
    - (体調不良の場合): ${playerName}が突発的な体調不良（例：食中毒、高熱）に見舞われ、次戦の出場が絶望的であることを描写してください。
    - (HBP故障の場合): ${playerName}が、${context.log || '前回の試合'}で受けた死球の影響により、病院で精密検査を受けたことを描写してください。検査の結果、「右手の甲（または肋骨）にヒビが入っており、今大会の出場は絶望的」と診断された、という衝撃的な内容にしてください。
    - (軽傷の場合): ${playerName}が${context.log || '前回の試合での走塁'}中に足首を軽度捻挫した（または練習中に軽い肉離れを起こした）と発表。監督は「大事を取って次の試合は休ませる」とコメント。
3.  **影響:** この離脱が、${teamName}の今後にどれほど深刻な影響を与えるかを分析してください。

### 出力形式 (JSON)
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                return { 
                    ...article, 
                    timestamp: Date.now(),
                    isAccident: true,
                    context: { teamName, playerName, accidentType } 
                };
            }
        }
        throw new Error("AI accident response format error.");
    } catch (error) {
        console.error(`AIアクシデント記事（${playerName}）の生成に失敗しました:`, error);
        return null;
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲


/**
 * AIに甲子園（または東海大会）の結果を総括する記事を生成させる
 */
async function generateKoshienSummaryArticle(teamName, resultLabel, type) {
    let context, titleInstruction;

    if (type === 'summer') {
        context = `夏の甲子園、全国の頂点を目指した${teamName}の戦いが終わりました。`;
        titleInstruction = `「${teamName}、聖地での戦いの軌跡」のような、夏の終わりを感じさせる感動的なタイトルにしてください。`;
    } else if (type === 'spring') {
        context = `選抜高校野球大会に出場した${teamName}の最終結果が確定しました。`;
        titleInstruction = `「${teamName}、春の聖地に爪痕」のように、来たる夏への期待を感じさせるタイトルにしてください。`;
    } else { // tokai
        context = `秋季東海大会で、静岡県代表の${teamName}が見事な戦いを見せました。`;
        titleInstruction = `「${teamName}、センバツ当確！」のように、速報らしく、喜びが伝わるタイトルにしてください。`;
    }

    const prompt = `あなたは、情熱的な高校野球専門のAI記者です。
以下の情報に基づき、読者の心を打つような総括記事を生成してください。

### 大会結果
- チーム: ${teamName}
- 最終成績: ${resultLabel}
- 文脈: ${context}

### 執筆指示
- ${titleInstruction}
- チームのこれまでの努力や、県大会での戦いぶりを称え、今回の結果が持つ意味をドラマチックに描写してください。
- 最後に、選手たちへの賛辞や、今後のチームへの期待を述べて締めくくってください。

### 出力形式
JSON形式で出力してください: {"title": "記事のタイトル", "body": "記事の本文"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) return { ...article, timestamp: Date.now() };
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI甲子園記事の生成に失敗しました:", error);
        return { title: "記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true };
    }
}
// --- Match Processing & Event Listeners ---


/**
 * AIにトーナメントの組み合わせから架空の因縁を動的に創作させる
 * @param {object} state - 現在の tournamentState
 * @returns {Promise<Array>} - AIが生成した因縁オブジェクトの配列
 */
async function generateDynamicFeuds(state) {
    const { matches, teams } = state;
    if (!matches || !teams) return [];

    // 1回戦の組み合わせと、各チームの補足情報（監督・ランク・昨年の成績）をリストアップ
    const round1Matchups = Object.values(matches).filter(m => m.id.includes('-R1-M'));
    const matchupInfo = round1Matchups.map(match => {
        const { team1, team2 } = match;
        if (!team1 || !team2) return null; // チームが揃っていない試合は除外

        const team1Data = TEAM_DATA[team1];
        const team1Record = state.teamRecords[team1];
        const team1Info = `"${team1}" (監督: ${team1Data?.coach?.name}, ランク: ${calculateRank(team1, state)}, 昨年: ${getRankString(team1Record?.lastFinish || 64)})`;

        const team2Data = TEAM_DATA[team2];
        const team2Record = state.teamRecords[team2];
        const team2Info = `"${team2}" (監督: ${team2Data?.coach?.name}, ランク: ${calculateRank(team2, state)}, 昨年: ${getRankString(team2Record?.lastFinish || 64)})`;

        return `${team1Info} vs ${team2Info}`;
    }).filter(Boolean).join('\n'); // nullを除外し、改行で連結

    const prompt = `あなたは、静岡県の高校野球の歴史をすべて知るベテランのスポーツライターです。
夏の大会の1回戦の組み合わせが決定しました。以下の対戦カードリストと補足情報（監督、ランク、昨年の成績）を熟読してください。

### 1回戦 組み合わせリスト
${matchupInfo}

### 指示
上記のリストから、最もドラマチックな架空の因縁（フェイク・ストーリー）を持つ対決を**3つ**厳選し、その背景を創作してください。

### 因縁の創作パターン例
- **昨年のリベンジマッチ:** 昨年の大会で劇的な敗北を喫した相手との再戦。
- **監督の師弟対決:** 両チームの監督が、実は大学時代の先輩と後輩だった。
- **元チームメイト対決:** 両校のエースが、中学時代は同じチームのバッテリーだった。
- **無名校の雪辱戦:** 過去に大差で敗れた相手に、成長して再び挑む。

### 出力形式【厳守】
以下のJSON配列形式"のみ"で出力してください。解説や「はい」などの返答は不要です。
[
  { "teams": ["チームA", "チームB"], "type": "因縁のタイプ（例：師弟対決）", "story": "AIが創作した短い背景ストーリー（例：〇〇監督は△△監督の大学時代の後輩にあたる）" },
  { "teams": ["チームC", "チームD"], "type": "昨夏の雪辱戦", "story": "昨夏、C校はD校に9回裏サヨナラ負けを喫しており、選手たちは雪辱に燃えている" },
  { "teams": ["チームE", "チームF"], "type": "元バッテリー対決", "story": "E校のエースとF校の4番打者は、中学時代にバッテリーを組んでいた親友同士だ" }
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const feudsJson = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (Array.isArray(feudsJson)) {
                return feudsJson; // 成功：因縁オブジェクトの配列を返す
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AIによる動的因縁の生成に失敗しました:", error);
        return []; // エラー時は空配列を返す
    }
}
/**
 * 延長イニングを全ての関連テーブルに追加する
 */
function addExtraInning() {
    // --- 1. イニングスコアのテーブルを更新 ---
    const scoreTable = document.getElementById('inning-score-table');
    if (scoreTable) {
        const headerRow = scoreTable.querySelector('thead tr');
        // 現在の最終イニング番号を取得し、1を足す
        const lastInningHeader = headerRow.children[headerRow.children.length - 3];
        const newInningNum = parseInt(lastInningHeader.textContent) + 1;

        // 新しいヘッダーを追加
        const newTh = document.createElement('th');
        newTh.className = 'w-10';
        newTh.textContent = newInningNum;
        headerRow.insertBefore(newTh, headerRow.children[headerRow.children.length - 2]);

        // 各チームの行に新しい入力欄を追加
        scoreTable.querySelectorAll('tbody tr').forEach(row => {
            const newTd = document.createElement('td');
            newTd.innerHTML = `<input type="text" value="">`;
            row.insertBefore(newTd, row.children[row.children.length - 1]);
        });
    }

    // --- 2. 両チームの打撃成績テーブルを更新 ---
    for (const teamKey of ['team1', 'team2']) {
        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (!battingTable) continue;

        // ヘッダーを更新
        const headerRow = battingTable.querySelector('thead tr');
        const lastInningHeader = headerRow.lastElementChild.previousElementSibling;
        const newInningNum = parseInt(lastInningHeader.textContent) + 1;
        const newTh = document.createElement('th');
        newTh.className = 'col-inning';
        newTh.textContent = newInningNum;
        headerRow.insertBefore(newTh, headerRow.lastElementChild);

        // 全ての選手行（スタメン・交代）に新しい入力欄を追加
        battingTable.querySelectorAll('tbody tr').forEach(row => {
            const newTd = document.createElement('td');
            newTd.innerHTML = `<input type="text" placeholder="-">`;
            row.appendChild(newTd);
        });

        // イニング出来事入力欄のcolspanを更新し、新しい入力欄を追加
        const tfoot = battingTable.querySelector('tfoot');
        if (tfoot) {
            const targetCell = tfoot.querySelector('td[colspan]');
            const currentNumInnings = parseInt(targetCell.getAttribute('colspan')) - 1;
            targetCell.setAttribute('colspan', currentNumInnings + 2);

            const newEventTd = document.createElement('td');
            newEventTd.className = 'border-t-2';
            newEventTd.innerHTML = `<input type="text" class="inning-events-input w-full text-left px-1 text-xs" data-team-key="${teamKey}" data-inning-index="${newInningNum - 1}" placeholder="例: 鈴木 盗塁">`;
            
            const eventRow = tfoot.querySelector('tr');
            eventRow.insertBefore(newEventTd, eventRow.lastElementChild);
        }
    }
}

/**
 * ニュースティッカーの表示を更新する
 */
function updateTicker() {
    const tickerContainer = document.querySelector('.ticker-content');
    const oldTickerText = document.getElementById('ticker-text');
    if (!tickerContainer || !oldTickerText) return;

    let headlines = tournamentState.tickerHeadlines || [];
    
    // 表示するヘッドラインがなければ、デフォルトのものを表示
    if (headlines.length === 0) {
        const defaultHeadlines = [
            "昨年度王者・283学園、県内連覇と「全国での一勝」へ視界良好か",
            "『公立最後の砦』静岡、名門復活へ『今年こそ』",
            "プロ注目158km右腕・斎藤擁する富士宮北、ワンマンチームの汚名返上なるか",
            "創部一年目・浜松特支、初めての夏。「まずは1点」を合言葉に挑む",
            "離島のハンデを覆せ！虎府島総合、逆境スピリッツで本土勢に挑む",
            "765総合高校、2年前の栄光再び。ノーシードからの逆襲なるか",
            "最後の夏・川根、閉校する母校の名を刻めるか",
            "『ベスト8の壁』は越えられるか。堅守の聖隷クリストファー、打線の仕上がりは"
        ];
        headlines = new Array(5).fill(defaultHeadlines).flat().sort(() => Math.random() - 0.5);
    }

    const newTextContent = headlines.join('　／／　');
    
    // アニメーションをリセットするために要素を再生成
    const newTickerText = oldTickerText.cloneNode(false);
    newTickerText.textContent = newTextContent;
    oldTickerText.remove();
    tickerContainer.appendChild(newTickerText);
}

/**
 * 試合結果からニュースティッカー用の短いヘッドラインを生成する
 * @param {object} matchData - 試合のデータオブジェクト
 * @returns {string | null} - 生成されたヘッドラインの文字列、またはnull
 */
function generateTickerHeadline(matchData) {
    const { winnerName, loserName, score1, score2 } = matchData;
    const winnerScore = Math.max(parseInt(score1), parseInt(score2));
    const loserScore = Math.min(parseInt(score1), parseInt(score2));
    const scoreDiff = winnerScore - loserScore;

    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    const rankDiff = rankValues[winnerRank] - rankValues[loserRank];

    // パターン1：大番狂わせ（ジャイアントキリング）
    if (rankDiff <= -2) {
        return `【波乱】${getRankDescription(loserRank)}・${loserName}が初戦で散る！ ${winnerName}が金星挙げる`;
    }
    // パターン2：接戦
    if (scoreDiff <= 2 && rankDiff <= 1 && rankDiff >= -1) {
        return `手に汗握る接戦！ ${winnerName}が${loserName}を${winnerScore}-${loserScore}で振り切る`;
    }
    // パターン3：圧勝
    if (scoreDiff >= 8 && rankDiff >= 2) {
        return `王者・${winnerName}、盤石の試合運びで${loserName}を圧倒。${winnerScore}対${loserScore}でコールド勝ち級の快勝`;
    }
    // パターン4：ライバル対決
    const rivalry = RIVALRIES.find(r => r.teams.includes(winnerName) && r.teams.includes(loserName));
    if (rivalry) {
        return `因縁の${rivalry.type}は${winnerName}に軍配！ ${loserName}を下す`;
    }
    // デフォルト
    return `${winnerName}が${loserName}を下し、次のラウンドへ駒を進める`;
}


/**
 * [HELPER] 打席結果の文字列を、ハイライト用の日本語に翻訳する
 * (★「注目」フラグ対応 最終版)
 */
function translateResult(res, playerInfo, eventType = '') {
    if (!res) return null;
    let tempRes = res.trim();

    // 1. 注目フラグをパース
    let markPrefix = ''; // 注目（翻訳後）
    if (tempRes.startsWith('★:')) {
        markPrefix = '（★注目）';
        tempRes = tempRes.substring(3); // "★:" を削除
    }

    // 2. 勢い(Strength)をパース
    let strengthPrefix = '';
    let strengthPrefixOut = '';
    if (tempRes.startsWith('S:')) {
        strengthPrefix = '鋭い';
        strengthPrefixOut = '鋭い当たりの';
        tempRes = tempRes.substring(2); // "S:" を削除
    } else if (tempRes.startsWith('W:')) {
        strengthPrefix = '詰まりながらも';
        strengthPrefixOut = '詰まった当たりの';
        tempRes = tempRes.substring(2); // "W:" を削除
    }

    // 3. 方向をパース
    let direction = '';
    const directionMap = {'投': 'ピッチャー', '捕': 'キャッチャー', '一': 'ファースト', '二': 'セカンド', '三': 'サード', '遊': 'ショート', '左': 'レフト', '中': 'センター', '右': 'ライト'};
    const directionKeys = Object.keys(directionMap);
    for (const key of directionKeys) {
        if (tempRes.startsWith(key)) {
            direction = directionMap[key] + 'へ';
            if (tempRes.includes('ゴロ') || tempRes.includes('飛') || tempRes.includes('邪') || tempRes.includes('直')) {
                direction = directionMap[key];
            }
            tempRes = tempRes.substring(key.length).trim();
            break;
        }
    }

    // 4. 打点とイベントタイプ
    let description = `${playerInfo}が`; // 基本の主語
    const rbiMatch = tempRes.match(/(\d+)点/);
    const eventText = eventType ? `${eventType}となる` : '';

    // 5. 結果の翻訳 (★markPrefixを全てに追加)
    if (tempRes.includes('本塁打')) {
        let hrRbiText = 'ソロ';
        if (rbiMatch) {
            const rbi = parseInt(rbiMatch[1]);
            if (rbi === 4) hrRbiText = '満塁';
            else if (rbi === 3) hrRbiText = '3ラン';
            else if (rbi === 2) hrRbiText = '2ラン';
        }
        description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${hrRbiText}ホームランを放った`;
    
    } else {
        // 本塁打以外
        const rbiText = rbiMatch ? (parseInt(rbiMatch[1]) > 1 ? `${rbiMatch[1]}点タイムリー` : 'タイムリー') : '';

        if (tempRes.includes('三塁打')) description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${rbiText}三塁打を放った`;
        else if (tempRes.includes('二塁打')) description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${rbiText}二塁打を放った`;
        else if (tempRes.includes('安')) description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${rbiText}ヒットを放った`;
        
        else if (tempRes.includes('犠飛')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '外野'}への${eventText}犠牲フライ${rbiMatch ? `で${rbiMatch[1]}点` : 'で1点'}を挙げた`;
        else if (tempRes.includes('犠打')) description = `${playerInfo}が${markPrefix}${direction ? direction + 'へ' : ''}送りバントを決めた`;
        
        else if (tempRes.includes('ゴロ') && rbiMatch) description = `${playerInfo}の${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}ゴロの間に${eventText}${rbiMatch[1]}点を挙げた`;
        else if ((tempRes.includes('エラー') || tempRes.includes('失')) && rbiMatch) description = `${playerInfo}が${markPrefix}相手${direction ? direction + 'の' : ''}エラーの間に${eventText}${rbiMatch[1]}点を記録した`;
        else if (tempRes.includes('野選') && rbiMatch) description = `${playerInfo}の${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}への${eventText}野選の間に${rbiMatch[1]}点を挙げた`;
        
        else if (tempRes.includes('振り逃げ')) {
            if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}三振振り逃げの間に${rbiMatch[1]}点を挙げ、打者も出塁した`;
            else description = `${playerInfo}が${markPrefix}${eventText}三振振り逃げで出塁した`;
        }
        else if (tempRes.includes('打撃妨害')) {
            if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}打撃妨害（押し出し）で${rbiMatch[1]}点を挙げ、出塁した`;
            else description = `${playerInfo}が${markPrefix}${eventText}打撃妨害で出塁した`;
        }

        else if (tempRes.includes('四球')) {
            if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}押し出しの四球を選び、${rbiMatch[1]}点を挙げた`;
            else description = `${playerInfo}が${markPrefix}四球を選んだ`;
        }
        else if (tempRes.includes('死球')) {
            if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}押し出しの死球を受け、${rbiMatch[1]}点を挙げた`;
            else description = `${playerInfo}が${markPrefix}死球で出塁した`;
        }
        else if (tempRes.includes('敬遠')) {
            if (rbiMatch) {
                description = `${playerInfo}が${markPrefix}${eventText}押し出しの敬遠四球を選び、${rbiMatch[1]}点を挙げた`;
            } else {
                description = `${playerInfo}が${markPrefix}${eventText}敬遠四球で出塁した`;
            }
        }
        
        else if (tempRes.includes('三振')) description = `${playerInfo}が${markPrefix}三振に倒れた`;
        else if (tempRes.includes('併殺')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}ゴロで併殺打に倒れた`;
        else if (tempRes.includes('邪')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || 'ファウルゾーン'}への邪飛（ファウルフライ）に倒れた`;
        else if (tempRes.includes('ゴロ')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}ゴロに倒れた`;
        else if (tempRes.includes('飛')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '外野'}フライに倒れた`;
        else if (tempRes.includes('直')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || ''}ライナーに倒れた`;
        
        else if (tempRes.includes('エラー') || tempRes.includes('犠失')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}相手${direction ? direction + 'の' : ''}エラーで出塁した`;
        else if (tempRes.includes('野選')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction ? direction + 'への' : ''}野選で出塁した`;
        else return null;
    }

    // 6. 最終調整
    return description.replace(/タイムリー1点/g, 'タイムリー').replace(/1点を挙げた/g, '点を挙げた');
};
// ▲▲▲ 新規追加ここまで ▲▲▲


/**
 * 試合の詳細データから「事実オブジェクトの配列」と活躍選手リストを返す
 * (★精密版α：打順追跡、方向、交代詳細、走塁アウト詳細、交代状況分析 すべて込み★)
 */
function createHighlightsText(dbMatch, winnerName) {
    // 詳細データがない場合は空を返す
    if (!dbMatch || !dbMatch.details) {
        return { highlights: [], keyPlayerNames: [] };
    }

 // --- 内部ヘルパー関数：打席結果を日本語に翻訳 (★「注目」フラグ対応 最終版) ---
    const translateResult = (res, playerInfo, eventType = '') => {
        if (!res) return null;
        let tempRes = res.trim();

        // 1. 注目フラグをパース
        let markPrefix = ''; // 注目（翻訳後）
        if (tempRes.startsWith('★:')) {
            markPrefix = '（★注目）';
            tempRes = tempRes.substring(3); // "★:" を削除
        }

        // 2. 勢い(Strength)をパース
        let strengthPrefix = '';
        let strengthPrefixOut = '';
        if (tempRes.startsWith('S:')) {
            strengthPrefix = '鋭い';
            strengthPrefixOut = '鋭い当たりの';
            tempRes = tempRes.substring(2); // "S:" を削除
        } else if (tempRes.startsWith('W:')) {
            strengthPrefix = '詰まりながらも';
            strengthPrefixOut = '詰まった当たりの';
            tempRes = tempRes.substring(2); // "W:" を削除
        }

        // 3. 方向をパース
        let direction = '';
        const directionMap = {'投': 'ピッチャー', '捕': 'キャッチャー', '一': 'ファースト', '二': 'セカンド', '三': 'サード', '遊': 'ショート', '左': 'レフト', '中': 'センター', '右': 'ライト'};
        const directionKeys = Object.keys(directionMap);
        for (const key of directionKeys) {
            if (tempRes.startsWith(key)) {
                direction = directionMap[key] + 'へ';
                if (tempRes.includes('ゴロ') || tempRes.includes('飛') || tempRes.includes('邪') || tempRes.includes('直')) {
                    direction = directionMap[key];
                }
                tempRes = tempRes.substring(key.length).trim();
                break;
            }
        }

        // 4. 打点とイベントタイプ
        let description = `${playerInfo}が`; // 基本の主語
        const rbiMatch = tempRes.match(/(\d+)点/);
        const eventText = eventType ? `${eventType}となる` : '';

        // 5. 結果の翻訳 (★markPrefixを全てに追加)
        if (tempRes.includes('本塁打')) {
            let hrRbiText = 'ソロ';
            if (rbiMatch) {
                const rbi = parseInt(rbiMatch[1]);
                if (rbi === 4) hrRbiText = '満塁';
                else if (rbi === 3) hrRbiText = '3ラン';
                else if (rbi === 2) hrRbiText = '2ラン';
            }
            description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${hrRbiText}ホームランを放った`;
        
        } else {
            // 本塁打以外
            const rbiText = rbiMatch ? (parseInt(rbiMatch[1]) > 1 ? `${rbiMatch[1]}点タイムリー` : 'タイムリー') : '';

            if (tempRes.includes('三塁打')) description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${rbiText}三塁打を放った`;
            else if (tempRes.includes('二塁打')) description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${rbiText}二塁打を放った`;
            else if (tempRes.includes('安')) description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${rbiText}ヒットを放った`;
            
            else if (tempRes.includes('犠飛')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '外野'}への${eventText}犠牲フライ${rbiMatch ? `で${rbiMatch[1]}点` : 'で1点'}を挙げた`;
           else if (tempRes.includes('犠打')) {
                if (rbiMatch) {
                    // 打点がある場合 = スクイズ
                    description = `${playerInfo}が${markPrefix}${direction ? direction + 'へ' : ''}スクイズを決めて${eventText}${rbiMatch[1]}点を挙げた`;
                } else {
                    // 打点がない場合 = 送りバント
                    description = `${playerInfo}が${markPrefix}${direction ? direction + 'へ' : ''}送りバントを決めた`;
                }
            }
            // ▲▲▲ 修正ここまで ▲▲▲            
            else if (tempRes.includes('ゴロ') && rbiMatch) description = `${playerInfo}の${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}ゴロの間に${eventText}${rbiMatch[1]}点を挙げた`;
            else if ((tempRes.includes('エラー') || tempRes.includes('失')) && rbiMatch) description = `${playerInfo}が${markPrefix}相手${direction ? direction + 'の' : ''}エラーの間に${eventText}${rbiMatch[1]}点を記録した`;
            else if (tempRes.includes('野選') && rbiMatch) description = `${playerInfo}の${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}への${eventText}野選の間に${rbiMatch[1]}点を挙げた`;

            else if (tempRes.includes('四球')) {
                if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}押し出しの四球を選び、${rbiMatch[1]}点を挙げた`;
                else description = `${playerInfo}が${markPrefix}四球を選んだ`;
            }
            else if (tempRes.includes('死球')) {
                if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}押し出しの死球を受け、${rbiMatch[1]}点を挙げた`;
                else description = `${playerInfo}が${markPrefix}死球で出塁した`;
            }


// ▼▼▼ この else if ブロックをまるごと追加 ▼▼▼
        else if (tempRes.includes('敬遠')) {
            if (rbiMatch) {
                // 満塁での敬遠（押し出し）
                description = `${playerInfo}が${markPrefix}${eventText}押し出しの敬遠四球を選び、${rbiMatch[1]}点を挙げた`;
            } else {
                // 通常の敬遠
                description = `${playerInfo}が${markPrefix}${eventText}敬遠四球で出塁した`;
            }
        }
        // ▲▲▲ 追加ここまで ▲▲▲
            
            else if (tempRes.includes('三振')) description = `${playerInfo}が${markPrefix}三振に倒れた`;
            else if (tempRes.includes('併殺')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}ゴロで併殺打に倒れた`;
            else if (tempRes.includes('邪')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || 'ファウルゾーン'}への邪飛（ファウルフライ）に倒れた`;
            else if (tempRes.includes('ゴロ')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}ゴロに倒れた`;
            else if (tempRes.includes('飛')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '外野'}フライに倒れた`;
            else if (tempRes.includes('直')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || ''}ライナーに倒れた`;
            
            else if (tempRes.includes('エラー') || tempRes.includes('犠失')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}相手${direction ? direction + 'の' : ''}エラーで出塁した`;
            else if (tempRes.includes('野選')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction ? direction + 'への' : ''}野選で出塁した`;
            else return null;
        }

        // 6. 最終調整
        return description.replace(/タイムリー1点/g, 'タイムリー').replace(/1点を挙げた/g, '点を挙げた');
    };
    // --- ヘルパー関数ここまで ---

    // --- 初期化 ---
    const highlights = []; // ハイライトリスト
    const keyPlayerNames = new Set(); // 活躍選手名
    const winningTeamKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
    const losingTeamKey = winningTeamKey === 'team1' ? 'team2' : 'team1';
    const numInnings = dbMatch.details.inningScore?.team1?.length || 9;
    const inningScores = dbMatch.details.inningScore || { team1: Array(numInnings).fill(0), team2: Array(numInnings).fill(0) }; // スコア取得、なければ0埋め

    let hasScored = false;
    let isReversed = false;
    let cumulativeScores = { team1: 0, team2: 0 };
    // ▼▼▼ batterIndices: イニング開始時の先頭打者インデックス ▼▼▼
    let batterIndices = { team1: 0, team2: 0 };
        
    // --- 1. イニングごとのプレーを、精密な打順で解析 ---
    for (let i = 0; i < numInnings; i++) {
        const currentInning = i + 1;
        const scoreBeforeInning = { ...cumulativeScores };

        for (const teamKey of ['team1', 'team2']) {
            const teamName = dbMatch[teamKey];
            const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
            const allBattingData = dbMatch.details.batting?.[teamKey] || [];
            if (allBattingData.length === 0) continue;

            // 打順でソート (スタメン/交代含む)
            const sortedBattingOrder = allBattingData
                .filter(p => p.name) // 名前がある選手のみ
                .sort((a,b) => parseFloat(a.order.replace('-sub','.')) - parseFloat(b.order.replace('-sub','.')));
            if (sortedBattingOrder.length === 0) continue;

            // A. このイニングの全プレーを収集 (変更なし)
            let playsInHalfInning = [];
            sortedBattingOrder.forEach(player => {
                const resultString = player.results?.[i];
                if (resultString) {
                    resultString.split('、').forEach(atBatString => {
                        if(atBatString) {
                            playsInHalfInning.push({ player, atBatString });
                        }
                    });
                }
            });
            if (playsInHalfInning.length === 0) continue;

            // B. 打順インデックスに基づき、プレーを時系列順に並べ替える (改善版)
            const startingBatterIndex = batterIndices[teamKey]; // このイニングの先頭打者
            const orderedPlays = []; // 並べ替えた結果を入れる配列
            let currentBatterIndex = startingBatterIndex; // 現在処理中の打者のインデックス
            let playsFoundCount = 0; // 見つかったプレー数 (無限ループ防止)
            const atBatsCountPerPlayer = {}; // 各選手のこのイニングでの打席数をカウント { "1": 0, "2": 1, ... }

            // playsInHalfInning のすべてのプレーが orderedPlays に入るまでループ
            while (orderedPlays.length < playsInHalfInning.length && playsFoundCount < playsInHalfInning.length * 2) {
                 const currentPlayer = sortedBattingOrder[currentBatterIndex]; // 現在注目している打者
                 const playerOrderKey = currentPlayer.order; // "1", "1-sub-1" など
                 const currentAtBatOrdinal = atBatsCountPerPlayer[playerOrderKey] || 0; // この打者の何打席目か (0始まり)

                 // playsInHalfInning から、現在の打者(currentPlayer)の、まだ処理していない(currentAtBatOrdinal番目の)打席結果を探す
                 let foundPlayIndex = -1;
                 let searchCount = 0;
                 for(let k=0; k < playsInHalfInning.length; k++){
                     if(playsInHalfInning[k].player.order === playerOrderKey) {
                         if(searchCount === currentAtBatOrdinal) {
                             // まだ orderedPlays に追加されていないか確認
                             if (!orderedPlays.includes(playsInHalfInning[k])) {
                                 foundPlayIndex = k;
                                 break;
                             }
                         }
                         searchCount++;
                     }
                 }


                 if (foundPlayIndex !== -1) {
                     const foundPlay = playsInHalfInning[foundPlayIndex];
                     orderedPlays.push(foundPlay); // 順番通りに追加
                     atBatsCountPerPlayer[playerOrderKey] = currentAtBatOrdinal + 1; // この打者の打席数を+1
                     // 次の打者へ (打順が一巡する場合も考慮)
                     currentBatterIndex = (currentBatterIndex + 1) % sortedBattingOrder.length;
                 } else {
                     // 現在の打者の次の打席が見つからない場合、次の打順の選手へ移る
                     // (例: 1番打者が1打席しかなかった場合など)
                     currentBatterIndex = (currentBatterIndex + 1) % sortedBattingOrder.length;
                 }
                 playsFoundCount++; // 無限ループ防止カウンター
            }
            // 並び替えに失敗した場合のフォールバック (元の順で処理) - 念のため残す
            const finalOrderedPlays = orderedPlays.length === playsInHalfInning.length ? orderedPlays : playsInHalfInning;


            // C. 並べ替えた正しい順序で、ハイライトを生成する (変更なし)            // C. 並べ替えた正しい順序で、ハイライトを生成する
            finalOrderedPlays.forEach(play => {
                const { player, atBatString } = play;
                const [batterPlay, runnerPlaysString] = atBatString.split(';'); // 打撃結果と走塁結果を分離

                // 交代選手情報をplayerInfoに付与
                let playerRole = '';
                if (player.order.includes('sub')) {
                    switch(player.sub_type) {
                        case 'PH': playerRole = '代打の'; break;
                        case 'PR': playerRole = '代走の'; break; // 代走は通常打席に立たないが念のため
                        case 'DEF': playerRole = '守備から途中出場の'; break; // 守備交代選手が打席に立った場合
                        case 'PITCHER': playerRole = 'リリーフの'; break; // 投手が打席に立った場合
                        default: playerRole = '途中出場の';
                    }
                } else {
                     playerRole = `${player.order}番`; // スタメン
                }
                const playerInfo = `${playerRole}${player.name}`;

                // 打撃結果の処理
                if (batterPlay && batterPlay.trim() !== '') {
                    let eventType = ''; // イベントタイプ (先制、逆転など)
                    const isScorePlay = batterPlay.includes('点') || batterPlay.toLowerCase().includes('hr') || batterPlay.includes('本');

                    // 得点プレーの場合、イベントタイプを判定
                    if (isScorePlay) {
                        const prevScoreSelf = scoreBeforeInning[teamKey];
                        const prevScoreOpp = scoreBeforeInning[opponentTeamKey];
                        const rbiMatch = batterPlay.match(/(\d+)点/);
                        let addedScore = rbiMatch ? parseInt(rbiMatch[1]) : (batterPlay.includes('点') ? 1 : 0);
                        if (batterPlay.includes('本')) addedScore = Math.max(1, addedScore);

                        if (prevScoreSelf === 0 && prevScoreOpp === 0) {
                            eventType = '先制'; // 両者0点からの初得点
                            hasScored = true;
                        } else if (prevScoreSelf <= prevScoreOpp && (prevScoreSelf + addedScore) > prevScoreOpp && !isReversed) {
                            // ビハインド/同点からリードした場合 (逆転フラグは一度だけ)
                            eventType = '逆転';
                            isReversed = true;
                        } else if (prevScoreSelf < prevScoreOpp && (prevScoreSelf + addedScore) === prevScoreOpp) {
                             eventType = '同点'; // 追いついた場合
                        } else if (prevScoreSelf >= prevScoreOpp) {
                             eventType = '追加点'; // リードを広げる場合
                        } else {
                             eventType = '反撃'; // ビハインドで点を返した場合
                        }
                    }

                    // ヘルパー関数で説明文生成
                    const description = translateResult(batterPlay, playerInfo, eventType);
                    if (description) {
                        highlights.push({ inning: currentInning, team: teamName, player: player.name, description });
                        keyPlayerNames.add(player.name);
                    }
                }

                // 走塁結果の処理 (詳細なアウト種類対応)
                if (runnerPlaysString) {
                    runnerPlaysString.split(',').forEach(runnerPlay => {
                        if (!runnerPlay) return;
                        const runnerPlayParts = runnerPlay.trim().split(' ');
                        if (runnerPlayParts.length < 2) return;
                        
                        const runnerName = runnerPlayParts[0];
                        const play = runnerPlayParts[1];
                        const detail = runnerPlayParts.slice(2).join(' ') || '';
                        
                        let description = `${runnerName}が`;

                        if (play === '盗塁') {
                            if (detail.includes('本塁')) description += `ホームスチール（重盗）を成功させた`;
                            else description += `盗塁成功（${detail}）`;
                        }
                        else if (play === 'タッチアップ') description += `タッチアップから${detail}`;
                        else if (play === '生還' || (play === '進塁' && detail.includes('生還'))) description += `ホームイン`;
                        
                        else if (play === '送球間に進塁') {
                            if (detail.includes('本塁')) description += `キャッチャーの送球の隙を突き、ホームを陥れる好走塁を見せた`;
                            else description += `送球の間に${detail}進塁する好走塁を見せた`;
                        }

                        else if (play === '盗塁死') description += `盗塁失敗`;
                        else if (play === '牽制死') description += `牽制アウト`;
                        else if (play === '走塁死') description += `走塁死`;
                        else if (play === '挟殺プレーでアウト') description += `挟殺アウト`;
                        else if (play.includes('アウト')) description += `走塁中にアウト`;
                        else description += `${play} ${detail}`.trim();

                        highlights.push({ type: 'baserunning', inning: currentInning, team: teamName, player: runnerName, description: description });
                        keyPlayerNames.add(runnerName);
                    });
                }
                // ▲▲▲ 修正ここまで ▲▲▲
            }); // finalOrderedPlays.forEach の終わり

           // ▼▼▼ D. 次のイニングの先頭打者を正確に更新 ▼▼▼
            if (finalOrderedPlays.length > 0) {
                 // このイニングで最後に打席に立った選手を取得
                 const lastPlayer = finalOrderedPlays[finalOrderedPlays.length - 1].player;
                 // sortedBattingOrder で lastPlayer のインデックスを探す
                 const lastBatterIndexInLineup = sortedBattingOrder.findIndex(p => p.order === lastPlayer.order);
                 if (lastBatterIndexInLineup !== -1) {
                      // その次の打者のインデックスを batterIndices に保存
                      batterIndices[teamKey] = (lastBatterIndexInLineup + 1) % sortedBattingOrder.length;
                 } else {
                      // 見つからない場合 (エラーケース) - 簡易更新
                      console.warn(`Could not find index for last batter in inning ${currentInning}: ${lastPlayer.name}`);
                      batterIndices[teamKey] = (startingBatterIndex + finalOrderedPlays.length) % sortedBattingOrder.length;
                 }
            }
            // ▲▲▲ 先頭打者更新ここまで ▲▲▲
        } // teamKey loop の終わり

        // イニング終了時に累計スコアを更新
        cumulativeScores.team1 += parseInt(inningScores.team1?.[i] || 0);
        cumulativeScores.team2 += parseInt(inningScores.team2?.[i] || 0);

    } // inning loop の終わり

    // --- 2. 試合全体の個別要素を分析 ---
    // 惜敗投手 (変更なし)
    const loserName = dbMatch[losingTeamKey];
    const losingPitchers = dbMatch.details.pitching?.[losingTeamKey] || [];
    if (losingPitchers.length === 1) {
        const ace = losingPitchers[0];
        if (ace.result === 'L' && parseFloat(ace.innings || 0) >= 8 && parseInt(ace.earnedRuns || 0) <= 2) {
             highlights.push({ type: 'tough_loss', team: loserName, player: ace.name, description: `${ace.name}投手は${ace.innings}回を${ace.earnedRuns}失点と好投したが、打線の援護に恵まれなかった` });
             keyPlayerNames.add(ace.name);
        }
    }

    // 交代選手の活躍 (代打ヒット - 変更なし)
    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const teamBatting = dbMatch.details.batting?.[teamKey] || [];
        const substitutes = teamBatting.filter(p => p.sub_type && p.sub_type === 'PH'); // 代打のみ抽出
        substitutes.forEach(subPlayer => {
            for (let i = 0; i < numInnings; i++) {
                const resultInInning = subPlayer.results?.[i];
                if (resultInInning) {
                    // ヒット系の結果かチェック
                    if (resultInInning.includes('安') || resultInInning.includes('本') || resultInInning.includes('二') || resultInInning.includes('三')) {
                         let playerRole = '代打の';
                         const playerInfo = `${playerRole}${subPlayer.name}`;
                         const description = translateResult(resultInInning, playerInfo, ''); // イベントタイプなし
                         if(description){
                              highlights.push({ type: 'substitute_hit', inning: i + 1, team: teamName, player: subPlayer.name, description: `${description}。見事起用に応えた` });
                              keyPlayerNames.add(subPlayer.name);
                         }
                    }
                    break; // その選手の最初の打席結果のみ記録
                }
            }
        });
    }

    // ▼▼▼ 投手成績のハイライト生成方法を変更 ▼▼▼
    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const pitchingData = dbMatch.details.pitching?.[teamKey] || [];
        if (!pitchingData) continue;

        let pitchingRelayTextParts = []; // 継投表示用

        pitchingData.forEach((pitcher, pIdx) => {
            if (!pitcher.name || !pitcher.innings) return;

            // 全ての成績を取得 (未入力は 0 や '-' とする)
            const resultMark = {'W': '○', 'L': '●', 'S': 'Ｓ', 'H': 'Ｈ'}[pitcher.result] || ''; // 勝敗ＳＨ
            const innings = pitcher.innings || '不明';
            const batters = pitcher.battersFaced || '-';
            const pitches = pitcher.pitches || '-';
            const hits = pitcher.hits || '0';
            const strikeouts = pitcher.strikeouts || '0';
            const walks = pitcher.walks || '0';
            const runs = pitcher.runs || '0';
            const earnedRuns = pitcher.earnedRuns || '0';

            // 詳細な成績文字列を生成
            const statsDetail = `(${innings}回 打${batters} 球${pitches} 被${hits} 奪${strikeouts} 与${walks} 失${runs} 自${earnedRuns})`;

            // ハイライトの説明文を作成
            let description = `${resultMark}${pitcher.name} ${statsDetail}`;

            // 交代タイミングの情報を取得 (精密版αのロジックを流用)
            let inningWhenChanged = '?'; // 登板イニング
            let isMidInningChange = false;
            let outsWhenChanged = 0;
            let situation = ''; // 交代時の状況

            if (pIdx > 0) { // 2番手以降の場合、前の投手と比較
                const prevPitcher = pitchingData[pIdx - 1];
                if (prevPitcher.innings) {
                    const prevInningsStr = prevPitcher.innings.toString();
                    if (prevInningsStr.includes('.')) {
                        isMidInningChange = true;
                        const parts = prevInningsStr.split('.');
                        inningWhenChanged = parseInt(parts[0]) + 1;
                        outsWhenChanged = parseInt(parts[1] || 0);
                    } else {
                        isMidInningChange = false;
                        inningWhenChanged = Math.floor(parseFloat(prevInningsStr)) + 1;
                        outsWhenChanged = 0;
                    }
                    if (isNaN(inningWhenChanged)) inningWhenChanged = '?';

                    // 交代時の状況分析 (ヘルパー関数呼び出し)
                    if (inningWhenChanged !== '?' && isMidInningChange) {
                        const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
                        const opponentBatting = dbMatch.details.batting?.[opponentTeamKey] || [];
                        if (opponentBatting.length > 0) {
                            const opponentStartingBatterIdx = batterIndices[opponentTeamKey];
                            const simulationResult = simulateHalfInningUntilOuts(opponentBatting, inningWhenChanged - 1, outsWhenChanged, opponentStartingBatterIdx);
                            if (simulationResult) {
                                const runnerCount = simulationResult.runners.filter(r => r !== null).length;
                                if (runnerCount === 3) situation = '満塁のピンチで';
                                else if (runnerCount > 0) situation = `${runnerCount}者を背負い`;
                                // 点差などの情報も追加可能
                            }
                        }
                    }
                }
            } else {
                inningWhenChanged = 1; // 先発投手は1回から
            }

            // 交代情報を説明文に追加
            if (pIdx > 0 && inningWhenChanged !== '?') {
                 if (isMidInningChange) {
                     description = `${inningWhenChanged}回${outsWhenChanged}死${situation}登板した${description}`;
                 } else {
                     description = `${inningWhenChanged}回から登板した${description}`;
                 }
            } else if (pIdx === 0) {
                 description = `先発の${description}`; // 先発投手の記述
            }

            // 特筆すべき成績があれば追記 (完封、奪三振など) - オプション
            if (runs === '0' && parseFloat(innings) >= 7 && pitcher.result === 'W') description += ' 見事な完封勝利';
            else if (parseInt(strikeouts) >= 10) description += ` ${strikeouts}奪三振の快投`;
            else if (pitcher.result === 'L' && parseFloat(innings) >= 8 && parseInt(earnedRuns) <= 2) description += ' 好投も報われず'; // 惜敗

            // ハイライトに追加
            highlights.push({
                type: 'pitching_performance', // タイプ名を変更
                inning: inningWhenChanged !== '?' ? inningWhenChanged : undefined, // 登板イニング
                team: teamName,
                player: pitcher.name,
                description: description
            });
            keyPlayerNames.add(pitcher.name);

            // 継投表示用の情報を記録
            pitchingRelayTextParts.push(`${pitcher.name}(${innings}回)`);

        }); // pitchingData.forEach の終わり

        // 継投全体の情報をハイライトに追加
        if (pitchingRelayTextParts.length > 1) {
             highlights.push({ type: 'pitching_relay', team: teamName, description: `投手リレーは ${pitchingRelayTextParts.join(' → ')} だった` });
        }
    } // teamKey loop の終わり
    // ▲▲▲ 投手成績のハイライト生成ここまで ▲▲▲
  // ▼▼▼ このブロックをまるごと追加 ▼▼▼
    // --- 2B. 守備交代・ポジション変更の処理 ---
    const positionChanges = dbMatch.details.positionChanges || [];
    positionChanges.forEach(change => {
        const teamName = dbMatch[change.teamKey];
        if (!teamName || !change.playerName || !change.newPos) return;

        let description = "";
        let situation = ""; // 状況説明

        // イニング途中の詳細な状況を組み立てる
        if (change.timing === 'mid') {
            const outs = change.outs || '0';
            const runners = change.runners || {};
            let runnerDesc = [];
            if (runners.r1) runnerDesc.push("1塁");
            if (runners.r2) runnerDesc.push("2塁");
            if (runners.r3) runnerDesc.push("3塁");
            
            if (runnerDesc.length === 3) situation = `${outs}アウト 満塁`;
            else if (runnerDesc.length > 0) situation = `${outs}アウト ${runnerDesc.join(', ')}`;
            else situation = `${outs}アウト ランナーなし`;
            
            situation += "の場面で、";
        }

        description = `${change.inning}回${change.topBottom}、${situation}${change.playerName}が${change.newPos}の守備に就いた`;

        highlights.push({
            type: 'substitution',
            inning: parseInt(change.inning) || null,
            team: teamName,
            player: change.playerName,
            description: description
        });
        keyPlayerNames.add(change.playerName);
    });
    // ▲▲▲ 追加ここまで ▲▲▲
// ▼▼▼ このブロックを「試合全体の物語性を分析」の手前で置き換え/挿入 ▼▼▼
    // --- 3. 守備ハイライト / エラー の処理 ---
    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const fieldingPlays = dbMatch.details.fielding?.[teamKey] || [];
        
        // エラーを示すキーワード
        const errorKeywords = ['エラー', 'トンネル', '落球', '後逸', '悪送球', 'ファンブル'];

        fieldingPlays.forEach(play => {
            if (play.player && play.play) {
                let description = '';
                // 入力されたテキストにエラーキーワードが含まれているかチェック
                const isError = errorKeywords.some(keyword => play.play.includes(keyword));

                if (isError) {
                    // エラーの場合
                    description = `${play.player}が${play.play}の痛恨のミスを犯した`;
                } else {
                    // ファインプレーの場合
                    description = `${play.player}が${play.play}のファインプレーを見せた`;
                }
                
                highlights.push({
                    type: isError ? 'fielding_error' : 'fielding_fine_play', // タイプを分ける
                    inning: play.inning || null,
                    team: teamName,
                    player: play.player,
                    description: description
                });
                keyPlayerNames.add(play.player);
            }
        });
    }
    // ▲▲▲ 修正ここまで ▲▲▲

  // --- 4. 試合全体の物語性を分析し、総括ハイライトを生成 ---
    let summaryHighlight = null; // 総括ハイライトを入れる変数
    // 勝者と敗者の最終スコアを取得 (parseIntで数値に変換、失敗時は0)
    const winnerScore = parseInt(dbMatch[winningTeamKey === 'team1' ? 'score1' : 'score2'] || 0);
    const loserScore = parseInt(dbMatch[losingTeamKey === 'team1' ? 'score1' : 'score2'] || 0);
    const totalRuns = winnerScore + loserScore; // 合計得点

    // ヒット数を計算するヘルパー関数 (playerGameStatsから取得)
    const countHitsFromStats = (teamKey) => {
        // 試合ごとの成績データ(playerGameStats)を取得、なければ空のオブジェクト
        const gameStats = dbMatch.details.playerGameStats?.[teamKey] || {};
        // gameStatsオブジェクトの各選手の成績(stats)を取り出し、ヒット数(h)を合計する
        return Object.values(gameStats).reduce((sum, stats) => sum + (stats.h || 0), 0);
    };
    const winnerHits = countHitsFromStats(winningTeamKey); // 勝者のヒット数
    const loserHits = countHitsFromStats(losingTeamKey);   // 敗者のヒット数
    const totalHits = winnerHits + loserHits; // 合計ヒット数

    
    let scoreAfter6th = { team1: 0, team2: 0 }; // 6回終了時点のスコア
    // イニングスコアデータが存在するか確認
    if(inningScores?.team1 && inningScores?.team2){
        // 6回終了 (インデックス5) までのスコアを合計
        for(let i = 0; i < Math.min(numInnings, 6); i++) {
             scoreAfter6th.team1 += parseInt(inningScores.team1[i] || 0);
             scoreAfter6th.team2 += parseInt(inningScores.team2[i] || 0);
        }
    }

    const winnerScoreAfter6th = scoreAfter6th[winningTeamKey]; // 勝者の6回終了時スコア
    const loserScoreAfter6th = scoreAfter6th[losingTeamKey];   // 敗者の6回終了時スコア
    const lastInning = numInnings - 1; // 最終イニングのインデックス (0始まり)

    // サヨナラ勝ちの判定
    let isSayonara = false;
    // 9回裏以降 (lastInning >= 8) かつ 勝者が後攻 (winningTeamKey === 'team2') の場合
    if (lastInning >= 8 && winningTeamKey === 'team2') {
        const scoreInLast = parseInt(inningScores?.team2[lastInning] || 0); // 最終回の得点
        const scoreBeforeLast = winnerScore - scoreInLast; // 最終回開始前の勝者のスコア
        // 最終回に得点があり、かつ最終回開始前に勝者が負けていたか同点だった場合
        if (scoreInLast > 0 && scoreBeforeLast <= loserScore) {
            isSayonara = true;
        }
    }

// ▼▼▼ 新しい判定ロジック ▼▼▼
    let mvpPlayer = null; // 活躍した選手名
    let mvpPerformance = ''; // 活躍内容

    // 1. 勝利チームの打者MVP判定
    const winnerBattingStats = dbMatch.details.playerGameStats?.[winningTeamKey] || {};
    for (const playerName in winnerBattingStats) {
        const stats = winnerBattingStats[playerName];
        if (!stats || !stats.played) continue; // 試合に出ていない選手は除く
        if (stats.hr >= 2) { mvpPlayer = playerName; mvpPerformance = `${stats.hr}本塁打`; break; }
        if (stats.rbi >= 4) { mvpPlayer = playerName; mvpPerformance = `${stats.rbi}打点`; break; }
        if (stats.h >= 4) { mvpPlayer = playerName; mvpPerformance = `${stats.h}安打`; break; }
        // 決勝打などの判定はより複雑になるため、ここでは安打数/本塁打/打点で判定
    }

    // 2. 勝利チームの投手MVP判定 (打者MVPがいなければ)
    const winnerPitchingData = dbMatch.details.pitching?.[winningTeamKey] || [];
    if (!mvpPlayer && winnerPitchingData.length > 0) {
        winnerPitchingData.forEach(pitcher => {
            if (!pitcher.name || !pitcher.innings) return;
            const innings = parseFloat(pitcher.innings);
            const earnedRuns = parseInt(pitcher.earnedRuns || 0);
            const strikeouts = parseInt(pitcher.strikeouts || 0);
            const runs = parseInt(pitcher.runs || 0); // 失点も考慮

            if (pitcher.result === 'W') { // 勝利投手のみ
                 if (runs === 0 && innings >= 7) { // 7回以上完封
                     mvpPlayer = pitcher.name; mvpPerformance = `完封勝利`;
                 } else if (strikeouts >= 10 && innings >= 6) { // 6回以上投げ10奪三振以上
                     mvpPlayer = pitcher.name; mvpPerformance = `${strikeouts}奪三振の快投`;
                 } else if (innings >= 6 && earnedRuns <= 1) { // 6回以上自責点1以下 (HQS相当)
                      mvpPlayer = pitcher.name; mvpPerformance = `好投で試合を作る`;
                 }
            }
             // リリーフ投手の好投も判定できる (例: 複数イニング無失点セーブなど)
             else if (pitcher.result === 'S' && innings >= 2 && earnedRuns === 0) {
                  mvpPlayer = pitcher.name; mvpPerformance = `好リリーフで試合を締める`;
             }
        });
    }

    // 3. 継投成功判定 (MVPがいなければ)
    let isRelaySuccess = false;
    if (!mvpPlayer && winnerPitchingData.length > 1) {
        // 合計自責点が少ない (例: 9回投げて3点以下) かつ 勝利
        const totalER = winnerPitchingData.reduce((sum, p) => sum + parseInt(p.earnedRuns || 0), 0);
        const totalIP = winnerPitchingData.reduce((sum, p) => sum + parseFloat(p.innings || 0), 0);
        // 9イニング換算の自責点が3.00未満くらいを目安にするか、単純に合計自責点が2点以下など
        if (totalER <= 2 && totalIP >= (numInnings - 1)) { // ほぼ試合全体を投げて自責点2以下
            isRelaySuccess = true;
        }
        // 他にも、リードを守り切った、ピンチを切り抜けたなどの判定を追加可能
    }
    // ▲▲▲ 新しい判定ロジックここまで ▲▲▲

    // ★★★ ここからが今回の修正箇所 ★★★
    let lateGameColdSummary = null;
    // 1. コールド勝ち、かつそれが「6回以降」の場合
    if (dbMatch.calledGame && dbMatch.calledInning >= 6) {
        // 2. コールドになったイニングの「直前」（例: 6回コールドなら5回終了時）のスコアを計算
        const checkInningEnd = dbMatch.calledInning - 1; // 5, 6, 7...
        let scoreBeforeBigInning = { team1: 0, team2: 0 };
        if(inningScores?.team1 && inningScores?.team2){
            for(let i = 0; i < Math.min(numInnings, checkInningEnd); i++) { // 5回まで, 6回まで...
                 scoreBeforeBigInning.team1 += parseInt(inningScores.team1[i] || 0);
                 scoreBeforeBigInning.team2 += parseInt(inningScores.team2[i] || 0);
            }
        }
        const winnerScoreBefore = scoreBeforeBigInning[winningTeamKey];
        const loserScoreBefore = scoreBeforeBigInning[losingTeamKey];
        const scoreDiffBefore = Math.abs(winnerScoreBefore - loserScoreBefore);

        // 3. もし直前まで3点差以内の「接戦」だったら、特別な要約文を使う
        if (scoreDiffBefore <= 3) {
            lateGameColdSummary = { type: 'summary', description: `${checkInningEnd}回まで${scoreDiffBefore}点差の接戦だったが、${dbMatch.calledInning}回に${winnerName}が一挙猛攻で試合を決め、コールド勝ちを収めた` };
        }
        // (もし4点差以上開いていたら、lateGameColdSummaryはnullのままになり、この後の「圧勝」ロジックが使われる)
    }
    // ★★★ 修正ここまで ★★★    // ★★★ 修正ここまで ★★★


   // --- 試合内容に応じたサマリーハイライトを決定 (★優先順位変更★) ---
    if (mvpPlayer) {
        // 個人活躍を最優先
        summaryHighlight = { type: 'summary', description: `${mvpPlayer}の${mvpPerformance}の活躍で、${winnerName}が勝利を掴んだ` };
    } else if (isRelaySuccess) {
        // 次に継投成功
        summaryHighlight = { type: 'summary', description: `${winnerName}投手陣が${loserName}打線を${loserScore}失点に抑える見事な継投策で勝利` };
    } else if (isSayonara) {
        // サヨナラ
        summaryHighlight = { type: 'summary', description: `劇的なサヨナラ勝ちで、${winnerName}が熱戦に終止符を打った` };
    
    // ★★★ この else if を追加 ★★★
    } else if (lateGameColdSummary) {
        // 終盤までの接戦コールド
        summaryHighlight = lateGameColdSummary;
    // ★★★ 追加ここまで ★★★

    } else if (winnerScoreAfter6th < loserScoreAfter6th && winnerScore > loserScore && numInnings >= 7) {
        // 終盤逆転
        summaryHighlight = { type: 'summary', description: `${winnerName}が終盤に見事な逆転劇を演じ、勝利を掴んだ` };
    } else if (totalRuns <= 5 && totalHits <= 12) {
        // 投手戦
        summaryHighlight = { type: 'summary', description: `両チーム合わせて${totalHits}安打${totalRuns}得点に終わる、息詰まる投手戦となった` };
    } else if (totalRuns >= 13 && totalHits >= 20) {
        // 打撃戦
        summaryHighlight = { type: 'summary', description: `両チーム合わせて${totalHits}安打${totalRuns}得点が乱れ飛ぶ、壮絶な打撃戦となった` };
    } else if (winnerScore - loserScore >= 7) {
        // 圧勝 (★「接戦コールド」で拾われなかった場合、通常のコールドや大差の試合はここに来る)
        summaryHighlight = { type: 'summary', description: `${winnerName}が投打に相手を圧倒し、${winnerScore}-${loserScore}で快勝した` };
    } else if (winnerScore - loserScore <= 2) {
        // 接戦
        summaryHighlight = { type: 'summary', description: `${winnerName}が${loserName}の粘り強い追撃を振り切り、${winnerScore}-${loserScore}で接戦を制した` };
    } else {
        // デフォルト
        summaryHighlight = { type: 'summary', description: `${winnerName}が${loserName}を下し、${winnerScore}-${loserScore}で勝利した` };
    }

    // 決定したサマリーハイライトがあれば、highlights配列の先頭に追加
    if (summaryHighlight) {
        highlights.unshift(summaryHighlight);
    }
    
// --- 5. 結果を返す ---
// ▼▼▼ この return 文をまるごと置き換えてください ▼▼▼
    return { 
        highlights: highlights, 
        keyPlayerNames: Array.from(keyPlayerNames),
        summaryHighlight: summaryHighlight ? summaryHighlight.description : null // ★要約文を追加
    };
}

// ▼▼▼ ヘルパー関数：交代状況シミュレーション用 (★複数打席対応・先頭打者指定版★) ▼▼▼
/**
 * 指定されたイニングの攻撃を、特定のアウトカウントになるまで簡易的にシミュレートする
 * @param {Array} battingOrder - 相手チームの打順データ (ソート済み)
 * @param {number} inningIndex - シミュレーション対象イニングのインデックス (0始まり)
 * @param {number} targetOuts - シミュレーションを停止するアウトカウント
 * @param {number} startingBatterIdx - このイニングの先頭打者のインデックス
 * @returns {object | null} - { runners: [1B, 2B, 3B], outs: number, scoreSelf: number, scoreOpp: number, nextBatterIdx: number } または null
 */
function simulateHalfInningUntilOuts(battingOrder, inningIndex, targetOuts, startingBatterIdx) {
    if (!battingOrder || battingOrder.length === 0 || targetOuts < 0 || targetOuts > 3) return null;

    let outs = 0;
    let runners = [null, null, null]; // 1B, 2B, 3B
    let scoreSelf = 0; // 仮スコア (守備側)
    let scoreOpp = 0;  // 仮スコア (攻撃側)

    let currentBatterIndex = startingBatterIdx; // 先頭打者から開始
    let playsProcessedCount = 0; // 無限ループ防止 & デバッグ用
    const atBatsCountThisInning = {}; // このイニングでの各打者の打席数 { "1": 0, "2": 1, ... }

    // シミュレーション対象イニングの全プレーを事前に収集・打席順に並べ替える
    const playsForInning = [];
     battingOrder.forEach(player => {
         const resultString = player.results?.[inningIndex];
         if (resultString) {
             resultString.split('、').forEach(atBat => {
                 if(atBat) playsForInning.push({ player, atBat });
             });
         }
     });
     if (playsForInning.length === 0) return { runners, outs, scoreSelf, scoreOpp, nextBatterIdx: startingBatterIdx };

     // 打順並べ替え (createHighlightsText と同じロジック)
     const orderedPlays = [];
     let tempBatterIndex = startingBatterIdx;
     let playsCount = 0;
     const processedFlags = new Array(playsForInning.length).fill(false);
     const atBatsTempCount = {};
     while (orderedPlays.length < playsForInning.length && playsCount < playsForInning.length * 2) {
         const currentPlayer = battingOrder[tempBatterIndex];
         const playerOrderKey = currentPlayer.order;
         const currentAtBatOrdinal = atBatsTempCount[playerOrderKey] || 0;
         let foundPlayIndex = -1;
         let searchCount = 0;
         for(let k=0; k < playsForInning.length; k++){
             if(playsForInning[k].player.order === playerOrderKey && !processedFlags[k]) {
                 if(searchCount === currentAtBatOrdinal) {
                     foundPlayIndex = k;
                     break;
                 }
                 searchCount++;
             }
         }
         if (foundPlayIndex !== -1) {
             orderedPlays.push(playsForInning[foundPlayIndex]);
             processedFlags[foundPlayIndex] = true;
             atBatsTempCount[playerOrderKey] = currentAtBatOrdinal + 1;
             tempBatterIndex = (tempBatterIndex + 1) % battingOrder.length;
         } else {
             tempBatterIndex = (tempBatterIndex + 1) % battingOrder.length;
         }
         playsCount++;
     }
     const finalOrderedPlays = orderedPlays.length === playsForInning.length ? orderedPlays : playsForInning;


    // 並べ替えたプレーを順番に処理し、targetOuts に達するまでシミュレーション
    for (const playData of finalOrderedPlays) {
        if (outs >= targetOuts) break; // 目標アウトカウントに達したら終了

        const { player, atBat } = playData;
        const [batterPlay] = atBat.split(';');

        // 簡易アウト判定
        if (batterPlay.includes('三振') || batterPlay.includes('ゴロ') || batterPlay.includes('飛') || batterPlay.includes('直') || batterPlay.includes('犠')) {
            outs++;
            if (batterPlay.includes('併殺')) outs++;
        }
        if (outs >= targetOuts) break; // アウトが発生して targetOuts に達したら即終了

        // 簡易ランナー状況更新
        if (batterPlay.includes('安') || batterPlay.includes('塁打') || batterPlay.includes('四球') || batterPlay.includes('死球') || batterPlay.includes('エラー')) {
            if (runners[0] && runners[1] && runners[2] && (batterPlay.includes('四球') || batterPlay.includes('死球'))) {
                 scoreOpp++; // 押し出し
            } else {
                if (runners[1]) runners[2] = 'runner'; // 2塁→3塁
                if (runners[0]) runners[1] = runners[0]; // 1塁→2塁
                runners[0] = player.name; // 打者→1塁
            }
        }
        // 簡易得点計算
        if (batterPlay.includes('本塁打')) {
            scoreOpp += runners.filter(r => r !== null).length + 1;
            runners = [null, null, null];
        } else if (batterPlay.includes('点')) {
             const rbiMatch = batterPlay.match(/(\d+)点/);
             scoreOpp += rbiMatch ? parseInt(rbiMatch[1]) : 1;
             // 簡易シミュレーションのため、どの走者が還ったかは無視
        }

        playsProcessedCount++; // 処理済みプレー数
    }

    // 次の打者のインデックスを計算して返す
    const lastSimulatedPlayer = finalOrderedPlays[playsProcessedCount - 1]?.player;
    let nextBatterIdx = startingBatterIdx; // デフォルト
    if(lastSimulatedPlayer){
        const lastSimIdx = battingOrder.findIndex(p => p.order === lastSimulatedPlayer.order);
        if(lastSimIdx !== -1){
            nextBatterIdx = (lastSimIdx + 1) % battingOrder.length;
        }
    }


    return { runners, outs, scoreSelf, scoreOpp, nextBatterIdx }; // シミュレーション結果と次の打者インデックスを返す
}
// ▲▲▲ ヘルパー関数ここまで ▲▲▲

// ▲▲▲ ヘルパー関数ここまで ▲▲▲

/**
 * [修正版] 1打席分の入力ブロックHTMLを生成する
 * (★文字数順にソートして「犠飛」が「飛」に誤判定されるのを防ぐ)
 */
function createBattingResultDropdowns(playersOnField, atBatString = '') {
    // 1. 保存された文字列を「打者プレー」と「走者プレー」に分離
    const [batterPlay, runnerPlaysString] = (atBatString || '').split(';');
    
    let tempResult = (batterPlay || '').trim();

    // 3. 勢いと注目のパース
    let selectedStrength = '';
    let isMarked = false;

    if (tempResult.startsWith('★:')) {
        isMarked = true;
        tempResult = tempResult.substring(3);
    }
    if (tempResult.startsWith('S:')) {
        selectedStrength = 'S:';
        tempResult = tempResult.substring(2);
    } else if (tempResult.startsWith('W:')) {
        selectedStrength = 'W:';
        tempResult = tempResult.substring(2);
    }

    // 4. 残りの情報（結果、方向、打点など）をパースする
    let selectedResult = '', selectedDirection = '', selectedRbi = '', selectedRunnerPlay = '';
    
    if (tempResult) {
        const rbiMatch = tempResult.match(/(\d+点)/);
        if (rbiMatch) {
            selectedRbi = rbiMatch[0];
            tempResult = tempResult.replace(selectedRbi, '').trim();
        }
        if (tempResult.includes('好走塁')) {
            selectedRunnerPlay = '好走塁';
            tempResult = tempResult.replace('好走塁', '').trim();
        }
        
        // ★★★ 修正: ここでも文字数の多い順にソートする ★★★
        const allResultTypes = [ 
            ...BATTING_RESULTS.hits, 
            ...BATTING_RESULTS.outs, 
            ...BATTING_RESULTS.walks, 
            ...BATTING_RESULTS.sacrifices, 
            ...BATTING_RESULTS.other 
        ].sort((a, b) => b.length - a.length);

        for (const type of allResultTypes) {
            if (tempResult.includes(type)) {
                selectedResult = type;
                tempResult = tempResult.replace(type, '').trim(); // 見つかったら削除
                break; // 最初に見つかったもの（長い方）で確定
            }
        }
        
        if (tempResult.length > 0 && DIRECTIONS.includes(tempResult)) {
            selectedDirection = tempResult;
        }
    }

    // 5. HTMLを生成する
    // (プルダウンの選択肢順序は変えなくて良いが、selectedの判定は修正後のselectedResultを使う)
    const resultOptions = [ ...BATTING_RESULTS.hits, ...BATTING_RESULTS.outs, ...BATTING_RESULTS.walks, ...BATTING_RESULTS.sacrifices, ...BATTING_RESULTS.other ]
        .map(r => `<option value="${r}" ${selectedResult === r ? 'selected' : ''}>${r}</option>`).join('');
    const directionOptions = DIRECTIONS.map(d => `<option value="${d}" ${selectedDirection === d ? 'selected' : ''}>${d}</option>`).join('');
    const rbiOptions = RBIS.map(r => `<option value="${r}" ${selectedRbi === r ? 'selected' : ''}>${r}</option>`).join('');
    const runnerPlayOptions = ['好走塁'].map(r => `<option value="${r}" ${selectedRunnerPlay === r ? 'selected' : ''}>${r}</option>`).join('');
    const strengthOptions = `
        <option value="S:" ${selectedStrength === 'S:' ? 'selected' : ''}>強</option>
        <option value="W:" ${selectedStrength === 'W:' ? 'selected' : ''}>弱</option>
    `;

    return `
        <div class="at-bat-block border-t border-dashed pt-2 mt-2 first:mt-0 first:pt-0 first:border-t-0">
            <div class="flex items-center gap-1 batting-result-container mb-1">
                <div class="flex-grow flex gap-1">
                    <select class="batting-result-part w-[25%] text-xs p-1 border rounded result-type"><option value="">-結果-</option>${resultOptions}</select>
                    <select class="batting-result-part w-[20%] text-xs p-1 border rounded result-direction"><option value="">-方向-</option>${directionOptions}</select>
                    <select class="batting-result-part w-[20%] text-xs p-1 border rounded result-rbi"><option value="">-打点-</option>${rbiOptions}</select>
                    <select class="batting-result-part w-[15%] text-xs p-1 border rounded result-strength bg-red-50"><option value="">-勢い-</option>${strengthOptions}</select>
                    <select class="batting-result-part w-[20%] text-xs p-1 border rounded result-runner-play bg-yellow-50"><option value="">-走塁-</option>${runnerPlayOptions}</select>
                </div>
                <div class="w-12 flex-shrink-0">
                    <button class="mark-at-bat-btn w-full h-full text-xs font-bold p-1 rounded border ${isMarked ? 'bg-yellow-300 border-yellow-500 text-yellow-900' : 'bg-gray-100 border-gray-300 text-gray-500 hover:bg-gray-200'}"
                            data-marked="${isMarked ? 'true' : 'false'}"
                            title="この打席を「注目の打席」としてAIにマークします">
                        ★ 注目
                    </button>
                </div>
            </div>
            ${createRunnerInputsHTML(playersOnField, runnerPlaysString)}
        </div>
    `;
}

/**
 * トーナメント表をたどり、次の対戦相手の情報を特定する
 * (★「準決勝勝利時」の相手特定ロジックを修正した最終版)
 * @param {string} teamName - チーム名
 * @param {string} currentMatchId - そのチームが勝利した現在の試合ID
 * @returns {object|null} - 次の対戦相手に関する詳細情報
 */
function findNextOpponent(teamName, currentMatchId) {
    const allMatches = tournamentState.matches;
    if (!allMatches || !allMatches[currentMatchId]) return null;

    const idParts = currentMatchId.split('-');
    const side = idParts[0];

    if (side === 'F') {
        // 決勝戦に勝利した場合
        return { 
            opponentName: '優勝', 
            roundName: '大会終了',
            opponentRank: '',
            nextMatchSchedule: null
        };
    }

    const roundNum = parseInt(idParts[1].slice(1));
    const matchNum = parseInt(idParts[2].slice(1));
    const numTeams = tournamentState.teams.length;
    const finalRound = Math.log2(numTeams);

    let nextMatchId, roundName;
    if (roundNum === finalRound - 1) {
        // ★ 準決勝 (R5) -> 決勝 (F-R1-M1)
        nextMatchId = 'F-R1-M1';
        roundName = '決勝';
    } else if (roundNum < finalRound - 1) {
        const nextRoundNum = roundNum + 1;
        nextMatchId = `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
        const roundNameMap = { [finalRound - 1]: "準決勝", [finalRound - 2]: "準々決勝" };
        roundName = roundNameMap[nextRoundNum] || `${nextRoundNum}回戦`;
    } else {
        return null; // 既に決勝より後 (ありえないが)
    }

    const nextMatch = allMatches[nextMatchId];
    if (!nextMatch) return null;

    let opponentName = null;
    if (nextMatch.team1 && nextMatch.team1 !== teamName) opponentName = nextMatch.team1;
    else if (nextMatch.team2 && nextMatch.team2 !== teamName) opponentName = nextMatch.team2;

    if (opponentName) {
        // 相手が既に決まっている場合
        return {
            opponentName: opponentName,
            opponentRank: calculateRank(opponentName, tournamentState),
            roundName: roundName,
            nextMatchSchedule: nextMatch.schedule
        };
    } else {
        // 相手が未定の場合
        
        // ★★★ ここからが今回の修正箇所 ★★★
        let feederMatchId;
        
        // 1. 次の試合が決勝戦 (F-R1-M1) かつ、相手がまだ決まっていない場合
        if (nextMatchId === 'F-R1-M1') {
            // 反対側の山の準決勝IDを特定する (side は 'L' または 'R')
            const opponentFeederSide = (side === 'L' ? 'R' : 'L');
            feederMatchId = `${opponentFeederSide}-R${roundNum}-M1`; // 準決勝はM1しかない
        }
        // 2. (既存のロジック) 決勝戦以外で、相手が未定の場合
        else {
            const feederMatchNumber = matchNum % 2 === 1 ? matchNum + 1 : matchNum - 1;
            feederMatchId = `${side}-R${roundNum}-M${feederMatchNumber}`;
        }
        // ★★★ 修正ここまで ★★★

        const feederMatch = allMatches[feederMatchId];

        if (feederMatch && feederMatch.team1 && feederMatch.team2) {
            // 相手を決める試合のカードが揃っている場合
            return {
                opponentName: '（未定）',
                roundName: roundName,
                decidingMatch: {
                    team1: feederMatch.team1,
                    rank1: calculateRank(feederMatch.team1, tournamentState),
                    team2: feederMatch.team2,
                    rank2: calculateRank(feederMatch.team2, tournamentState)
                },
                nextMatchSchedule: nextMatch.schedule
            };
        }
        
        // (フォールバック) 相手を決める試合のカードもまだ揃っていない場合
        return { 
            opponentName: '（未定）', 
            opponentRank: '?', 
            roundName: roundName,
            nextMatchSchedule: nextMatch.schedule
        };
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 複数走者に対応した走塁入力欄のHTMLを生成する
 * @param {Array<object>} playersOnField - 現在出場中の選手リスト
 * @param {string} currentResult - 保存済みの打席結果文字列
 * @returns {string} - 生成されたHTML
 */
/**
 * 複数走者に対応した走塁入力欄のHTMLを生成する（区切り文字バグ修正版）
 */
function createRunnerInputsHTML(playersOnField, runnerPlaysString = '') {
    // ▼▼▼ 修正：「送球間に進塁」を追加 ▼▼▼
    const baserunningPlays = ['盗塁', '盗塁死', 'タッチアップ', '進塁', '送球間に進塁', '生還', '走塁死', '牽制死', '挟殺プレーでアウト'];
    // ▲▲▲ 修正ここまで ▲▲▲    

const bases = ['一塁へ', '二塁へ', '三塁へ', '本塁へ(生還)'];
    
    // ▼▼▼【重要修正】区切り文字を「、」から「,」に変更▼▼▼
    const runnerEvents = runnerPlaysString ? runnerPlaysString.split(',') : [];
    // ▲▲▲

    let html = '<div class="runner-plays-container space-y-1 mt-1">';
    
    runnerEvents.forEach(event => {
        const parts = event.trim().split(' ');
        const name = parts[0] || '';
        const play = parts[1] || '';
        const base = parts.slice(2).join(' ') || '';
        
        const nameOptions = playersOnField.map(p => `<option value="${p.name}" ${p.name === name ? 'selected' : ''}>${p.name}</option>`).join('');
        const playOptions = baserunningPlays.map(p => `<option value="${p}" ${p === play ? 'selected' : ''}>${p}</option>`).join('');
        const baseOptions = bases.map(b => `<option value="${b}" ${b === base ? 'selected' : ''}>${b}</option>`).join('');

        html += `
            <div class="runner-play-input flex gap-1 items-center mt-1">
                <select class="runner-name w-1/3 text-xs p-1 border rounded"><option value="">-誰が-</option>${nameOptions}</select>
                <select class="runner-play w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-何をした-</option>${playOptions}</select>
                <select class="runner-base w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-どこへ-</option>${baseOptions}</select>
                <button class="remove-runner-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </div>
        `;
    });

    html += '</div>';
    html += '<button class="add-runner-play-btn text-xs mt-1 bg-gray-200 px-2 py-0.5 rounded hover:bg-gray-300">+ 走者プレーを追加</button>';
    return html;
}

/**
 * 選手の大会通算成績を、AIプロンプト用の短い文章に要約する
 * (★盗塁(SB)の表示を追加した最終版)
 * @param {string} playerName - 選手名
 * @param {string} teamName - チーム名
 * @returns {string | null} - "姫川: 打率.500, 3本塁打, 10打点, 5盗塁" のような要約文。成績がなければnull。
 */
function getPlayerTournamentStatsSummary(playerName, teamName) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord || !teamRecord.playerStats) return null;

    const battingStats = teamRecord.playerStats.batting[playerName];
    const pitchingStats = teamRecord.playerStats.pitching[playerName];
    
    let summaries = [];

    if (battingStats && battingStats.ab > 0) {
        const avg = (battingStats.h / battingStats.ab).toFixed(3);
        // ▼▼▼ この行を修正 ▼▼▼
        summaries.push(`打率${avg}, ${battingStats.hr || 0}本塁打, ${battingStats.rbi || 0}打点, ${battingStats.sb || 0}盗塁`);
        // ▲▲▲ 修正ここまで ▲▲▲
    }

    if (pitchingStats && pitchingStats.ip > 0) {
        const era = pitchingStats.er > 0 ? ((pitchingStats.er * 9) / pitchingStats.ip).toFixed(2) : "0.00";
        summaries.push(`${pitchingStats.w}勝${pitchingStats.l}敗, 防御率${era}, ${pitchingStats.so}奪三振`);
    }

    if (summaries.length > 0) {
        return `${playerName}: ${summaries.join(' / ')}`;
    }
    
    return null;
}
/**
 * Analyzes the results of a half-inning, counts outs, and updates the UI (colors and disabled state).
 */
function updateInningState(teamKey, inningIndex) {
    const battingTable = document.getElementById(`batting-table-${teamKey}`);
    if (!battingTable) return;

    let outCount = 0;
    
    // --- 1. Analyze Batting Results ---
    battingTable.querySelectorAll('tbody tr').forEach(row => {
        const resultCell = row.children[5 + inningIndex];
        if (!resultCell) return;
        
        const atBatContainers = resultCell.querySelectorAll('.batting-result-container');
        atBatContainers.forEach(container => {
            const resultTypeSelect = container.querySelector('.result-type');
            const resultText = resultTypeSelect.value;
            
            // Count outs
            if (BATTING_RESULTS.outs.includes(resultText)) {
                outCount += (resultText === '併殺') ? 2 : 1;
            }

            // Color-code the dropdowns
            const dropdowns = container.querySelectorAll('select');
            dropdowns.forEach(dd => dd.classList.remove('result-hit', 'result-out', 'result-on-base'));

            if (BATTING_RESULTS.hits.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-hit'));
            } else if (BATTING_RESULTS.walks.includes(resultText) || BATTING_RESULTS.other.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-on-base'));
            } else if (BATTING_RESULTS.outs.includes(resultText) || BATTING_RESULTS.sacrifices.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-out'));
            }
        });
    });

    // --- 2. Count Outs from "Inning Events" (Baserunning) ---
    const eventsInput = document.querySelector(`.inning-events-input[data-team-key="${teamKey}"][data-inning-index="${inningIndex}"]`);
    if (eventsInput && eventsInput.value) {
        const events = eventsInput.value.split('、');
        events.forEach(event => {
            if (event.includes('盗塁死') || event.includes('走塁死')) {
                outCount++;
            }
        });
    }

    // --- 3. Lock the Inning if 3 Outs are Reached ---
    const isLocked = outCount >= 3;
    battingTable.querySelectorAll('tbody tr').forEach(row => {
        const resultCell = row.children[5 + inningIndex];
        if (!resultCell) return;
        
        const dropdowns = resultCell.querySelectorAll('.batting-result-container select');
        const addButtons = resultCell.querySelectorAll('.add-at-bat-btn');
        
        dropdowns.forEach(dd => {
            dd.disabled = isLocked;
            if (isLocked) dd.classList.add('bg-gray-100');
        });
        addButtons.forEach(btn => {
            btn.disabled = isLocked;
            if (isLocked) btn.style.visibility = 'hidden';
        });
    });
     if (eventsInput) {
        eventsInput.disabled = isLocked;
        if (isLocked) eventsInput.classList.add('bg-gray-100');
     }
}

// ▼▼▼ この関数をまるごと挿入 ▼▼▼
/**
 * [NEW HELPER] Finds all mentioned players and formats their full gamelogs for AI prompts.
 * @param {Set<string>} mentionedTeams - A Set of team names mentioned.
 * @param {string} conversationText - The text to scan for player names.
 * @returns {string} - A formatted string block of all found gamelogs.
 */
function formatPlayerGamelogsForPrompt(mentionedTeams, conversationText) {
    let logInfo = "";
    let relevantLogsFound = false;
    
    // Helper to parse date (already exists, but let's re-define for safety/scoping if needed, or just ensure it's available)
    const parseDate = (dateStr) => {
        if (!dateStr || !dateStr.includes('/')) return null;
        const [month, day] = dateStr.split('/').map(Number);
        const year = tournamentState.tournamentYear + (month <= 3 ? 1 : 0);
        return new Date(year, month - 1, day);
    };

    const today = parseDate(tournamentState.matches['F-R1-M1']?.schedule?.date || "7/25"); // Use a fallback "today"

    mentionedTeams.forEach(teamName => {
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord || !teamRecord.playerStats) return;

        // 1. Check Batting Gamelogs
        const battingStats = teamRecord.playerStats.batting;
        if (battingStats) {
            for (const playerName in battingStats) {
                if (conversationText.includes(playerName)) {
                    const bStats = battingStats[playerName];
                    if (bStats.gamelogs && bStats.gamelogs.length > 0) {
                        if (!relevantLogsFound) logInfo += `\n### 参考情報：今大会の主な選手成績履歴\n`;
                        relevantLogsFound = true;
                        logInfo += `- ${playerName} (${teamName}, 打者):\n`;
                        
                        bStats.gamelogs.sort((a, b) => (parseDate(a.date) || 0) - (parseDate(b.date) || 0));
                        
                        bStats.gamelogs.forEach(log => {
                            const dateInfo = log.date || '日付不明';
                            const opponentRank = log.opponentRank || 'E';
                            const stats = log.stats || { ab: 0, h: 0, hr: 0, rbi: 0, sb: 0 };
                            let role = "";
                            if (log.sub_type === 'PH') role = "代打";
                            else if (log.order && log.order.includes('sub')) role = "途中出場";
                            else if (log.order) role = `${log.order}番`;
                            
                            const statsLine = `${stats.ab}打数${stats.h}安打 ${stats.hr}HR ${stats.rbi}打点 ${stats.sb}盗塁`;
                            logInfo += `  - ${log.round} (${dateInfo}) (対 ${log.opponent} [${opponentRank}]) (${role}): ${statsLine}\n`;
                        });
                    }
                }
            }
        }

        // 2. Check Pitching Gamelogs
        const pitchingStats = teamRecord.playerStats.pitching;
        if (pitchingStats) {
            for (const playerName in pitchingStats) {
                if (conversationText.includes(playerName)) {
                    const pStats = pitchingStats[playerName];
                    if (pStats.gamelogs && pStats.gamelogs.length > 0) {
                        if (!relevantLogsFound) logInfo += `\n### 参考情報：今大会の主な選手成績履歴\n`;
                        relevantLogsFound = true;
                        logInfo += `- ${playerName} (${teamName}, 投手):\n`;

                        pStats.gamelogs.sort((a, b) => (parseDate(a.date) || 0) - (parseDate(b.date) || 0));

                        pStats.gamelogs.forEach(log => {
                            let dateInfo = log.date || '日付不明';
                            if (today) {
                                const logDate = parseDate(log.date);
                                if (logDate) {
                                    const diffDays = Math.ceil(Math.abs(today - logDate) / (1000 * 60 * 60 * 24));
                                    if (diffDays === 1) dateInfo = `${log.date} (連投)`;
                                    else if (diffDays === 2) dateInfo = `${log.date} (中1日)`;
                                    else if (diffDays > 0) dateInfo = `${log.date} (中${diffDays - 1}日)`;
                                }
                            }
                            const opponentRank = log.opponentRank || 'E';
                            const resultMark = {'W': '○', 'L': '●', 'S': 'Ｓ', 'H': 'Ｈ'}[log.result] || '';
                            pitcherGamelogInfo += `  - ${log.round} (${dateInfo}) (対 ${log.opponent} [${opponentRank}]): ${resultMark}${log.ip}回 ${log.h}被安打 ${log.bb}四球 ${log.so}奪三振 ${log.r}失点(自責${log.er})\n`;
                        });
                    }
                }
            }
        }
    });

    if (!relevantLogsFound) {
        logInfo = "\n### 参考情報：今大会の主な選手成績履歴\n- 言及された選手の詳細な試合履歴は見つかりませんでした。\n";
    }
    return logInfo;
}
// ▲▲▲ 挿入ここまで ▲▲▲

// ▼▼▼ この関数をまるごと追加 ▼▼▼
/**
 * 指定されたmatchIdに関連する、過去に生成されたAIコンテンツを全て削除する
 * @param {string} matchId - 対象の試合ID
 */
function clearPreviousAiContent(matchId) {
    if (!matchId) return;

    // 1. ニュース記事 (通常記事、羽田レポート、エラー) を削除
    // (context.matchId または errorId が matchId と一致するものを削除)
    tournamentState.news = tournamentState.news.filter(article => {
        if (article.context && article.context.matchId === matchId) return false;
        if (article.errorId === matchId) return false;
        return true;
    });

    // 2. 掲示板コメント (通常BBS) を削除
    // (BBSはスレッドではなく個々のコメントなので、context.matchId で削除)
    tournamentState.bbsComments = tournamentState.bbsComments.filter(comment => {
        if (comment.context && comment.context.matchId === matchId) return false;
        if (comment.errorId && comment.errorId.includes(matchId)) return false;
        return true;
    });

    // 3. まとめスレッド (matomeThreads) を削除
    if (tournamentState.matomeThreads && tournamentState.matomeThreads[matchId]) {
        delete tournamentState.matomeThreads[matchId];
    }
}
// ▲▲▲ 追加ここまで ▲▲▲



// ▼▼▼ 既存の「processMatchWin」関数 (16428行目あたり) を、以下で「置き換え」 ▼▼▼

// ▼▼▼ 既存の「processMatchWin」関数 (16428行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * 試合の勝者を処理する中心的関数（全機能統合）
 * (★快進撃記事と通常記事が「両方」生成されるよう修正)
 */
async function processMatchWin(matchId, winnerName) {
    let dbMatch = findMatchById(matchId);
    if (!dbMatch || !dbMatch.team1 || !dbMatch.team2) return;
    
    if (dbMatch.team1 === '(BYE)' || dbMatch.team2 === '(BYE)') {
        console.log("BYE match processing skipped by AI.");
        return;
    }

    // --- 1. 再処理（再生成）の確認 ---
    if (dbMatch.winner) {
        const confirmed = await showConfirm(
            `この試合（${dbMatch.team1} vs ${dbMatch.team2}）は既に「${dbMatch.winner}」の勝利で処理済みです。\n\n` +
            "「詳細入力」でデータを修正しましたか？\n" +
            "「はい」を押すと、現在の詳細入力データを基に、AI記事と掲示板をすべて再生成します。\n\n" +
            "（注意：この操作は元に戻せません）"
        );
        if (!confirmed) return;
        clearPreviousAiContent(matchId);
        dbMatch.winner = null; 
    } else {
        // (初回処理の場合、一時フラグをリセット)
        for (const teamName of [dbMatch.team1, dbMatch.team2]) {
            const teamRecord = tournamentState.teamRecords[teamName];
            if (!teamRecord || !teamRecord.playerStats) continue;
            for (const playerName in teamRecord.playerStats.batting) {
                if(teamRecord.playerStats.batting[playerName]) teamRecord.playerStats.batting[playerName].narrative_flag = null;
            }
            for (const playerName in teamRecord.playerStats.pitching) {
                if(teamRecord.playerStats.pitching[playerName]) teamRecord.playerStats.pitching[playerName].narrative_flag = null;
            }
        }
    }

    const loserName = dbMatch.team1 === winnerName ? dbMatch.team2 : dbMatch.team1;
    dbMatch.winner = winnerName;
    const idParts = matchId.split('-');
    const side = idParts[0];

    // --- スコアの読み取り ---
    const scoresAlreadySetBySkip = (dbMatch.score1 !== '' && dbMatch.score2 !== '' && (dbMatch.score1 != null) && (dbMatch.score2 != null));
    if (!scoresAlreadySetBySkip) {
        const matchEl = document.querySelector(`.matchup[data-match-id="${matchId}"]`);
        if (matchEl) {
            const score1El = matchEl.querySelector('[data-team-pos="1"]');
            const score2El = matchEl.querySelector('[data-team-pos="2"]');
            if (score1El && score2El && score1El.value !== '' && score2El.value !== '') {
                dbMatch.score1 = score1El.value;
                dbMatch.score2 = score2El.value;
            } else {
                dbMatch.score1 = '0';
                dbMatch.score2 = '0';
            }
            dbMatch.summary = matchEl.querySelector('.match-summary-input')?.value || '';
        }
    }
    
    // (コールドゲーム判定)
    dbMatch.calledGame = false;
    dbMatch.calledInning = null;
    let earliestCalledInning = null;
    if (dbMatch.details && dbMatch.details.inningScore && dbMatch.details.inningScore.team1.length >= 5)
    {
        const inningScores1 = dbMatch.details.inningScore.team1;
        const inningScores2 = dbMatch.details.inningScore.team2;
        const actualNumInningsRecorded = inningScores1.length;
        let cumulativeScore1 = 0;
        let cumulativeScore2 = 0;
        for (let i = 0; i < actualNumInningsRecorded; i++) {
            cumulativeScore1 += parseInt(inningScores1[i] || 0);
            cumulativeScore2 += parseInt(inningScores2[i] || 0);
            const currentInning = i + 1;
            const scoreDiff = Math.abs(cumulativeScore1 - cumulativeScore2);
            if (currentInning === 5 && scoreDiff >= 10) { earliestCalledInning = 5; break; }
            if (currentInning === 6 && scoreDiff >= 10) { earliestCalledInning = 6; break; }
            if (currentInning === 7 && scoreDiff >= 7) { earliestCalledInning = 7; break; }
            if (currentInning === 8 && scoreDiff >= 7) { earliestCalledInning = 8; break; }
        }
        if (earliestCalledInning !== null) {
            dbMatch.calledGame = true;
            dbMatch.calledInning = earliestCalledInning;
        }
    }

    // --- 勝者を次のラウンドに進める処理 (全大会共通) ---
    if(tournamentState.teamRecords[winnerName]) tournamentState.teamRecords[winnerName].wins++;
    if(tournamentState.teamRecords[loserName]) tournamentState.teamRecords[loserName].losses++;
    if (side !== 'F') {
        const roundNum = parseInt(idParts[1].slice(1));
        const numTeamsInTournament = tournamentState.teams.length;
        const finalRound = Math.log2(numTeamsInTournament);
        if (roundNum < finalRound) {
            const matchNum = parseInt(idParts[2].slice(1));
            const nextRoundNum = roundNum + 1;
            let nextMatchId = (nextRoundNum === finalRound) ? 'F-R1-M1' : `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
            if (!tournamentState.matches[nextMatchId]) {
                tournamentState.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
            }
            let slot = (nextRoundNum === finalRound) ? (side === 'L' ? 1 : 2) : (matchNum % 2 !== 0 ? 1 : 2);
            tournamentState.matches[nextMatchId][`team${slot}`] = winnerName;
            const nextMatch = tournamentState.matches[nextMatchId];
            if (nextMatch.team1 && nextMatch.team2) {
                nextMatch.rivalryType = checkRivalry(nextMatch.team1, nextMatch.team2);
            }
        }
    }
    // (決勝戦終了時の後処理)
    if (matchId.startsWith('F-R1-M1')) {
        updateTournamentFinishRecords(); 
        if (tournamentState.currentTournament === 'summer') {
            const winnerRecord = tournamentState.teamRecords[winnerName];
            if (winnerRecord) {
                const winnerRank = calculateRank(winnerName, tournamentState);
                const koshienResultKey = simulateKoshien(winnerRank);
                const koshienResult = KOSHIEN_RESULTS[koshienResultKey];
                winnerRecord.lastFinish = koshienResult.rank;
                const newHistoryRecord = { year: tournamentState.tournamentYear, tournament: 'summer_koshien', rank: koshienResult.rank };
                winnerRecord.history.unshift(newHistoryRecord);
                if (!winnerRecord.best || newHistoryRecord.rank < winnerRecord.best.rank) {
                    winnerRecord.best = newHistoryRecord;
                }
                generateKoshienSummaryArticle(winnerName, koshienResult.label, 'summer')
                    .then(koshienArticle => {
                        if(koshienArticle) {
                            tournamentState.news.push(koshienArticle);
                            renderNews(tournamentState.news);
                            saveState();
                        }
                    });
            }
        } else if (tournamentState.currentTournament === 'autumn') {
            tournamentState.senbatsuTeams = [];
            const finalists = [winnerName, loserName];
            const numTeamsInTournament = tournamentState.teams.length;
            const finalRound = Math.log2(numTeamsInTournament);
            const semiFinalLosers = Object.values(tournamentState.matches)
                .filter(m => m.id.includes(`-R${finalRound-1}-M`))
                .map(m => m.winner === m.team1 ? m.team2 : m.team1)
                .filter(Boolean);
            const candidates = [...finalists, ...semiFinalLosers];
            const selectionPromises = candidates.map(async (teamName, index) => {
                let selectionChance = 0.3; if (index < 2) selectionChance = 0.7;
                if (Math.random() < selectionChance) {
                    tournamentState.senbatsuTeams.push(teamName);
                    const senbatsuArticle = await generateKoshienSummaryArticle(teamName, 'センバツ出場決定', 'tokai');
                    if (senbatsuArticle) { tournamentState.news.push(senbatsuArticle); }
                }
            });
            await Promise.all(selectionPromises);
            renderNews(tournamentState.news);
            saveState();
        }
    }
    
    // --- 2. 試合後のデータ更新 (ティッカー、称号) ---
    const newHeadline = generateTickerHeadline({ winnerName, loserName, score1: dbMatch.score1, score2: dbMatch.score2 });
    if (newHeadline) {
        tournamentState.tickerHeadlines.unshift(newHeadline);
        if (tournamentState.tickerHeadlines.length > 20) tournamentState.tickerHeadlines.pop();
        updateTicker();
    }
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    if ((rankValues[loserRank] - rankValues[winnerRank]) >= 2) {
        const winnerRecord = tournamentState.teamRecords[winnerName];
        if (winnerRecord && !winnerRecord.teamTraits.includes('giant_killer')) {
            winnerRecord.teamTraits.push('giant_killer');
        }
    }
    let team1QualityText = "（打球品質データなし）";
    let team2QualityText = "（打球品質データなし）";
    if (dbMatch.details && dbMatch.details.playerGameStats) {
        const calculateQuality = (teamKey) => {
            const quality = { sH: 0, wH: 0, sO: 0, wO: 0, totalAB: 0 };
            const statsTeam = dbMatch.details.playerGameStats[teamKey] || {};
            for (const playerName in statsTeam) {
                const stats = statsTeam[playerName];
                quality.sH += stats.strongHits || 0;
                quality.wH += stats.weakHits || 0;
                quality.sO += stats.strongOuts || 0;
                quality.wO += stats.weakOuts || 0;
                quality.totalAB += stats.ab || 0;
            }
            return quality;
        };
        const team1Quality = calculateQuality('team1');
        const team2Quality = calculateQuality('team2');
        const formatQualityText = (teamName, quality) => {
            if (quality.totalAB === 0) return `(${teamName}: データなし)`;
            const totalHits = quality.sH + quality.wH;
            const totalOuts = quality.sO + quality.wO;
            return `(${teamName}: 安打${totalHits} (うち鋭い当たり${quality.sH}本, 詰まった当たり${quality.wH}本) / 凡退${totalOuts} (うち鋭い凡退${quality.sO}本, 詰まった凡退${quality.wO}本))`;
        };
        team1QualityText = formatQualityText(dbMatch.team1, team1Quality);
        team2QualityText = formatQualityText(dbMatch.team2, team2Quality);
    }

    // --- 3. AIコンテンツ生成の準備と実行 ---
    const matchContext = createMatchContext(matchId, winnerName, team1QualityText, team2QualityText);
    if (!matchContext) {
        console.error("AIコンテンツ生成に必要なmatchContextの作成に失敗しました。");
        renderTournament(tournamentState);
        saveState();
        return;
    }
    let articlePromise = Promise.resolve(null);
    let commentsPromise = Promise.resolve(null);
    let hadaReportPromise = Promise.resolve(null);
    let matomeThreadPromise = Promise.resolve(null);
    let homepageNewsPromise = Promise.resolve(null);
    let cinderellaArticlePromise = Promise.resolve(null);
    let accidentArticlePromise = Promise.resolve(null);

    if (tournamentState.settings.enableArticleGeneration) {
        newsContainer.innerHTML = `<div class="loader">AI記者が記事を執筆中...</div>`;
        const documentary = tournamentState.documentary;
        const loserRank = calculateRank(loserName, tournamentState);
        
        // ★★★ ここからが修正箇所 ★★★
        
        // 1. 快進撃(Cinderella)の判定
        let cinderellaType = null;
        let roundNumForCinderella = 0;
        if (idParts[0] !== 'F' && tournamentState.currentTournament === 'summer') { 
            const roundNum = parseInt(idParts[1].slice(1));
            roundNumForCinderella = roundNum;
            if (loserRank === 'E' && roundNum === 3) cinderellaType = 'E_Rank_Top_32';
            else if (loserRank === 'D' && roundNum === 4) cinderellaType = 'D_Rank_Top_16';
            else if (loserRank === 'C' && roundNum === 5) cinderellaType = 'C_Rank_Top_8';
        }
        
        // 2. 快進撃記事の生成 (該当する場合)
        if (cinderellaType) {
            cinderellaArticlePromise = generateCinderellaArticle(loserName, loserRank, roundNumForCinderella, matchContext);
        }
        
        // 3. 通常記事またはドキュメンタリー記事の生成 (「else if」を削除)
        if (documentary && documentary.target && (documentary.target === winnerName || documentary.target === loserName)) {
            // ドキュメンタリー
            const isWin = documentary.target === winnerName;
            const opponentName = isWin ? loserName : winnerName;
            const opponentData = TEAM_DATA[opponentName];
            const matchInfoForArticle = {
                round: matchId.includes('-R') ? parseInt(matchId.split('-R')[1].split('-')[0]) : 1,
                opponent: opponentName,
                score: isWin ? `${dbMatch.score1}-${dbMatch.score2}` : `${dbMatch.score2}-${dbMatch.score1}`,
                highlights: matchContext.highlights,
                summary: dbMatch.summary,
                opponentInfo: opponentData?.info || '対戦相手の情報なし'
            };
            articlePromise = generateDocumentaryArticle(isWin ? 'win' : 'lose', documentary.type, documentary.target, matchInfoForArticle);
            if (!isWin) tournamentState.documentary = { target: null, type: null };
        } else {
            // 通常記事 (快進撃記事とは「別に」生成される)
            articlePromise = generateNewsArticle(matchContext);
        }
        // ★★★ 修正ここまで ★★★
    }
    const isNotableGame = (winnerRank === 'A' || winnerRank === 'B' || loserRank === 'A' || loserRank === 'B');
    if (tournamentState.settings.enableArticleGeneration && isNotableGame && Math.random() < 0.25) {
        hadaReportPromise = generateHadaReport(matchContext);
    }
    if (tournamentState.settings.enableBbsGeneration) {
        bbsCommentsContainer.innerHTML = `<div class="loader">AIが掲示板を監視中...</div>`;
        commentsPromise = generateBbsComments(matchContext);
        matomeThreadPromise = generateGameMatchBbsComments(matchContext);
    }
    if (tournamentState.settings.enableArticleGeneration && (winnerName === "283学園" || loserName === "283学園")) {
        homepageNewsPromise = generateHomepageNewsUpdate(matchContext);
    }

    // --- 5. AIコンテンツの処理と最終的な画面更新 ---
    const [generatedArticle, generatedComments, generatedHadaReport, generatedMatomeThread, generatedHomepageNews, generatedCinderellaArticle] = await Promise.all([
        articlePromise, 
        commentsPromise,
        hadaReportPromise,
        matomeThreadPromise,
        homepageNewsPromise,
        cinderellaArticlePromise
    ]);
    if (generatedComments) {
        if (Array.isArray(generatedComments) && !generatedComments.some(c => c.error)) {
            const validComments = generatedComments.filter(comment => !comment.error);
            if (validComments.length > 0) {
                tournamentState.bbsComments.push(...validComments);
            }
        } else if (Array.isArray(generatedComments)) {
            const errorCommentData = generatedComments.find(comment => comment.error);
            if (errorCommentData && errorCommentData.context) {
                tournamentState.bbsComments.push({
                    title: "掲示板コメント生成エラー",
                    body: "AIによるコメント生成に一部失敗しました。",
                    timestamp: Date.now(),
                    error: true,
                    errorId: `error-${matchId}-bbs-partial`,
                    context: errorCommentData.context
                });
            }
        } else if (generatedComments.error) {
            tournamentState.bbsComments.push({
                title: generatedComments.title || "掲示板コメント生成エラー",
                body: generatedComments.body || "AIによるコメント生成に失敗しました。",
                timestamp: Date.now(),
                error: true,
                errorId: generatedComments.errorId || `error-${matchId}-bbs`,
                context: generatedComments.context || matchContext
            });
        } else {
            console.error("Unexpected format from generateBbsComments:", generatedComments);
            tournamentState.bbsComments.push({ title: "掲示板コメント形式エラー", body:"予期しないデータ形式です。", timestamp: Date.now(), error: true, context: matchContext });
        }
    }
    
    // ★★★ 修正箇所 (両方の記事をプッシュ) ★★★
    if (generatedCinderellaArticle) {
        tournamentState.news.push(generatedCinderellaArticle);
    }
    if (generatedArticle) {
        if (!generatedArticle.error) {
             generatedArticle.context = matchContext;
             showArticleReviewModal(generatedArticle);
        } else {
            const errorArticle = {
                title: generatedArticle.title || "記事生成エラー",
                body: generatedArticle.body || "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                errorId: matchContext.matchId || 'error',
                context: matchContext
            };
            tournamentState.news.push(errorArticle);
        }
    }
    // ★★★ 修正ここまで ★★★

    if (generatedHadaReport) {
        tournamentState.news.push(generatedHadaReport);
    }
    if (generatedMatomeThread) {
        tournamentState.matomeThreads[matchId] = {
            thread: generatedMatomeThread,
            context: matchContext
        };
    }
    if (generatedHomepageNews && !generatedHomepageNews.error) {
        if (!tournamentState.homepageNews) tournamentState.homepageNews = [];
        tournamentState.homepageNews.unshift(generatedHomepageNews);
    }
    if (!tournamentState.activeScandal && Math.random() < 0.1) {
        triggerScandalEvent(winnerName, loserName);
    }

    // --- 6. ボックススコアHTMLの自動生成 ---
    if (dbMatch.details) {
        try {
            dbMatch.boxScoreHtml = generateBoxScoreHTML(dbMatch);
        } catch (e) {
            console.error("ボックススコアHTMLの自動生成に失敗しました:", e);
            dbMatch.boxScoreHtml = null;
        }
    }

    // --- 7. 選手の「一時的な状態異常」フラグを付与 ---
   if (dbMatch.details && dbMatch.details.playerGameStats) {
        for (const teamKey of ['team1', 'team2']) {
            const teamName = dbMatch[teamKey];
            const opponentName = teamKey === 'team1' ? dbMatch.team2 : dbMatch.team1;
            const teamRecord = tournamentState.teamRecords[teamName];
            if (!teamRecord) continue;
            
            // (A) 打撃フラグの付与
            const battingStats = dbMatch.details.playerGameStats[teamKey] || {};
            for (const playerName in battingStats) {
                const stats = battingStats[playerName];
                const careerStats = teamRecord.playerStats.batting[playerName];
                if (!stats || !careerStats) continue;
                
                // 1. HBP(死球)による故障判定 (70%の確率)
                if (stats.hbp > 0 && Math.random() < 0.70) {
                    careerStats.narrative_flag = "injured"; // 故障
                    accidentArticlePromise = generateAccidentArticle(teamName, playerName, "accident_hbp", { 
                        log: `${getRoundNameFromMatchId(matchId)}の${opponentName}戦で死球を受ける` 
                    });
                }
                // 2. ランダムアクシデント (2%の確率で体調不良)
                else if (stats.pa > 0 && Math.random() < 0.09) {
                    careerStats.narrative_flag = "sick"; // 体調不良
                    accidentArticlePromise = generateAccidentArticle(teamName, playerName, "accident_sickness");
                }
                // 3. NEW: 軽傷 (3%の確率)
                else if (stats.pa > 0 && Math.random() < 0.15) {
                    careerStats.narrative_flag = "minor_injury"; // 軽傷
                    accidentArticlePromise = generateAccidentArticle(teamName, playerName, "accident_minor_injury", { 
                        log: `${getRoundNameFromMatchId(matchId)}の${opponentName}戦でのプレー` 
                    });
                }
                // 4. (通常の調子判定)
                else if (stats.pa > 0) {
                    if (stats.h >= 4 || stats.hr >= 2 || stats.rbi >= 5) careerStats.narrative_flag = "peak";
                    else if (stats.h >= 3 || stats.hr >= 1 || stats.rbi >= 3) careerStats.narrative_flag = "hot";
                    else if (stats.ab >= 3 && stats.h === 0) {
                        if (stats.strongOuts >= 2) careerStats.narrative_flag = "cold";
                        else careerStats.narrative_flag = "slump";
                    } else careerStats.narrative_flag = "normal";
                } else {
                    careerStats.narrative_flag = "normal";
                }
            }
            
            // (B) 投手フラグの付与 (★酷使判定を確率化)
            const pitchingData = dbMatch.details.pitching?.[teamKey] || [];
            pitchingData.forEach(pitcher => {
                const playerName = pitcher.name;
                const careerStats = teamRecord.playerStats.pitching[playerName];
                if (!careerStats) return;
                
                const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
                const opponentBattingStats = dbMatch.details.playerGameStats[opponentTeamKey] || {};
                let totalStrongOuts = 0, totalWeakOuts = 0, totalStrongHits = 0;
                for (const oppPlayerName in opponentBattingStats) {
                    const oppStats = opponentBattingStats[oppPlayerName];
                    totalStrongOuts += oppStats.strongOuts || 0;
                    totalWeakOuts += oppStats.weakOuts || 0;
                    totalStrongHits += oppStats.strongHits || 0;
                }
                const innings = parseFloat(pitcher.innings || 0);
                const earnedRuns = parseInt(pitcher.earnedRuns || 0);
                const strikeouts = parseInt(pitcher.strikeouts || 0);
                const walks = parseInt(pitcher.walks || 0);
                const hits = parseInt(pitcher.hits || 0);
                const pitches = parseInt(pitcher.pitches || 0);

                let overuseLog = "";
                let setInjury = false; // 故障がセットされたか
                
                if (careerStats.gamelogs && careerStats.gamelogs.length >= 1) {
                    const today = parseDate(dbMatch.schedule?.date);
                    const recentLogs = careerStats.gamelogs
                        .filter(log => log.matchId !== matchId)
                        .sort((a, b) => (parseDate(b.date) || 0) - (parseDate(a.date) || 0))
                        .slice(0, 2);
                    
                    if (today && recentLogs.length > 0) {
                        const lastGame = recentLogs[0];
                        const lastDate = parseDate(lastGame.date);
                        const daysRest = lastDate ? Math.ceil(Math.abs(today - lastDate) / (1000 * 60 * 60 * 24)) - 1 : 99;
                        
                        // 酷使判定 (確率化)
                        if (daysRest === 0 && Math.random() < 0.20) { // 連投 (50%で故障)
                            careerStats.narrative_flag = "injured";
                            overuseLog = "連投";
                            setInjury = true;
                        } else if (daysRest === 1 && pitches >= 80 && Math.random() < 0.40) { // 中1日で80球以上 (40%で故障)
                            careerStats.narrative_flag = "injured";
                            overuseLog = "中1日での80球以上の登板";
                            setInjury = true;
                        }
                    }
                }
                if (setInjury && teamName === "283学園") {
                    accidentArticlePromise = generateAccidentArticle(teamName, playerName, "injury_overuse", { log: overuseLog, round: getRoundNameFromMatchId(matchId) });
                }
                
                // (通常の調子判定 ... 酷使で故障「しなかった」場合のみ実行)
                if (!setInjury) {
                    if (innings >= 5) {
                        if ((innings >= 7 && earnedRuns === 0) || strikeouts >= 10) careerStats.narrative_flag = "peak";
                        else if (innings >= 6 && earnedRuns <= 2 && pitcher.result !== 'L') careerStats.narrative_flag = "hot";
                        else if (totalWeakOuts >= 5 && earnedRuns <= 3) careerStats.narrative_flag = "hot";
                        else if (earnedRuns >= 5) careerStats.narrative_flag = "slump";
                        else if (walks >= 5 || (hits >= 8 && innings <= 6)) careerStats.narrative_flag = "cold";
                        else careerStats.narrative_flag = "normal";
                        if (pitcher.result === 'L' && totalStrongHits >= 5) careerStats.narrative_flag = "unlucky";
                        if (pitcher.result === 'L' && innings >= 7 && earnedRuns <= 2) careerStats.narrative_flag = "tough_loss";
                    } else if (pitches >= 100) {
                        careerStats.narrative_flag = "fatigued";
                    } else {
                        careerStats.narrative_flag = "normal";
                    }
                }
            });
        }
    }
    // ★★★ 修正ここまで ★★★    
    // --- 8. ラウンド終了チェックと総括スレッド生成 ---
    if (side !== 'F' && idParts[1] && idParts[1].startsWith('R')) {
        const roundNum = parseInt(idParts[1].slice(1));
        checkAndTriggerRoundSummary(roundNum);
    }

    // --- 9. アクシデント記事の処理 (★新設) ---
    if (accidentArticlePromise) {
        const accidentArticle = await accidentArticlePromise;
        if (accidentArticle) {
            tournamentState.news.push(accidentArticle);
        }
    }

    saveState();

    // --- 10. ロスター情報（背番号、ポジション、投打）を記録 ---
    if (dbMatch.details && dbMatch.details.batting) {
        for (const teamKey of ['team1', 'team2']) {
            const teamName = dbMatch[teamKey];
            const teamRecord = tournamentState.teamRecords[teamName];
            const battingData = dbMatch.details.batting[teamKey];
            if (teamRecord && battingData && battingData.length > 0) {
                teamRecord.previousStarters = battingData
                    .filter(p => p.order && !p.order.toString().includes('sub'))
                    .map(p => ({ order: p.order, name: p.name, pos: p.pos }));
                teamRecord.roster = battingData.map(p => ({
                    order: p.order,
                    name: p.name,
                    number: p.number,
                    pos: p.currentPos || p.pos,
                    throwBat: p.throwBat,
                    sub_type: p.sub_type
                }));
            }
        }
    }
    
    // --- 11. 最終描画 ---
    renderTournament(tournamentState);
}
// ▲▲▲ 置き換えここまで ▲▲▲
// ▲▲▲ 置き換えここまで ▲▲▲

// ▼▼▼ この関数をまるごと追加 ▼▼▼
/**
 * スキャンダルイベントを発生させる
 * @param {string} winnerName 
 * @param {string} loserName 
 */
function triggerScandalEvent(winnerName, loserName) {
    const potentialTargets = [winnerName, loserName];
    const eligibleScandals = [];

    for (const team of potentialTargets) {
        for (const scandal of SCANDAL_DEFINITIONS) {
            if (scandal.condition(team)) {
                eligibleScandals.push({ team, scandal });
            }
        }
    }

    if (eligibleScandals.length > 0) {
        const selected = eligibleScandals[Math.floor(Math.random() * eligibleScandals.length)];
        
        tournamentState.activeScandal = {
            teamName: selected.team,
            scandalId: selected.scandal.id
        };

        // ▼▼▼ この部分を修正 ▼▼▼
        const rumorArticle = {
            title: selected.scandal.rumorTitle(selected.team), // 関数として呼び出し、teamNameを渡す
            body: selected.scandal.rumorBody(selected.team),   // 関数として呼び出し、teamNameを渡す
            timestamp: Date.now(),
            isScandalRumor: true
        };
        // ▲▲▲ ここまで修正 ▲▲▲

        tournamentState.news.push(rumorArticle);
        renderNews(tournamentState.news);
        saveState();
    }
}
// ▲▲▲ ここまで追加 ▲▲▲

// --- 編集モーダル用のグローバル変数 ---
let articleForReview = null; // レビュー中の記事データを一時的に保持する

/**
 * AIが生成した記事を確認・編集するためのモーダルを表示する
 * @param {object} article - AIが生成した記事オブジェクト
 */
function showArticleReviewModal(article) {
    articleForReview = article; // 記事データを一時保存

    document.getElementById('review-title').value = article.title;
    document.getElementById('review-body').value = article.body.replace(/\\n/g, '\n');
    
    document.getElementById('review-modal').classList.remove('hidden');
}

/**
 * 編集モーダルを閉じる
 */
function closeReviewModal() {
    articleForReview = null;
    document.getElementById('review-modal').classList.add('hidden');
}

// --- 遊び方説明書モーダルのイベントリスナー ---
    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('help-modal');
    const helpModalClose = document.getElementById('help-modal-close');

    helpBtn.addEventListener('click', () => {
        helpModal.classList.remove('hidden');
    });
    helpModalClose.addEventListener('click', () => {
        helpModal.classList.add('hidden');
    }); 


// ▼▼▼ 抽選会イベント関連の関数群 ▼▼▼

const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

/**
 * 効果音を読み込む
 */
async function loadSoundEffects() {
    try {
        const drumroll = new Audio("https://actions.google.com/sounds/v1/sports/drum_roll_long.ogg");
        const cheer = new Audio("https://actions.google.com/sounds/v1/crowds/battle_crowd_cheer_med.ogg");
        const gasp = new Audio("https://actions.google.com/sounds/v1/human_sounds/gasp.ogg");
        soundEffects = { drumroll, cheer, gasp };
    } catch (e) {
        console.error("効果音の読み込みに失敗しました:", e);
    }
}

// ▼▼▼ この2つの関数ブロックをまるごと「新規追加」(13058行目あたり、startLotteryEvent の直前) ▼▼▼

/**
 * [NEW] ホームページモーダル専用の、最新トーナメント表HTMLを生成する
 * (283学園のハイライト付き、表示専用)
 * @param {object} state - tournamentState
 * @returns {string} - トーナメント表全体のHTML
 */
function generateHomepageBracketHTML(state) {
    const { matches, teams, seeds } = state;
    if (!teams || teams.length < 32) { // 64チーム制のみ対応
        return '<p class="text-center text-gray-500">（64チーム制トーナメントのデータがありません）</p>';
    }

    const bracketContentWrapper = document.createElement('div');
    bracketContentWrapper.className = 'tournament-container'; // ホームページ用のクラス

    const leftBracketEl = document.createElement('div');
    leftBracketEl.className = 'bracket-half left';

    const rightBracketEl = document.createElement('div');
    rightBracketEl.className = 'bracket-half right';
    
    // 決勝戦の準備 (renderMainBracketと同様)
    const finalRound = 6;
    const semiFinalRound = 5;
    const leftChampion = state.matches[`L-R${semiFinalRound}-M1`]?.winner ?? null;
    const rightChampion = state.matches[`R-R${semiFinalRound}-M1`]?.winner ?? null;
    const finalMatch = state.matches['F-R1-M1'] || {};
    const finalTeam1 = finalMatch.team1 ?? leftChampion;
    const finalTeam2 = finalMatch.team2 ?? rightChampion;
    const finalEl = document.createElement('div');
    finalEl.className = 'bracket-final';
    finalEl.innerHTML = `
        <div class="round-title">決勝</div>
        <div class="final-matchup">
            ${createHomepageMatchHTML('F-R1-M1', finalTeam1, finalTeam2, finalMatch, seeds)}
        </div>
        <div class="winner-box">
            <h2>${finalMatch.winner ? `🏆 優勝 ${finalMatch.winner}` : '🏆'}</h2>
        </div>
    `;

    // --- 左右のハーフを生成 ---
    const roundNameMap = { 1: "1回戦", 2: "2回戦", 3: "3回戦", 4: "準々決勝", 5: "準決勝" };
    
    // 左ハーフ
    let parentEl = leftBracketEl;
    for (let r = 1; r <= semiFinalRound; r++) {
        const roundEl = document.createElement('div');
        roundEl.className = `round r${r}`;
        roundEl.innerHTML = `<div class="round-title">${roundNameMap[r]}</div>`;
        const numMatchesInRound = 32 / Math.pow(2, r);
        for (let m = 1; m <= numMatchesInRound; m++) {
            const matchId = `L-R${r}-M${m}`;
            const dbMatch = matches[matchId] || {};
            const team1 = dbMatch.team1 || (r > 1 ? matches[`L-R${r-1}-M${(m*2)-1}`]?.winner : teams[(m-1)*2]) || null;
            const team2 = dbMatch.team2 || (r > 1 ? matches[`L-R${r-1}-M${(m*2)}`]?.winner : teams[(m-1)*2 + 1]) || null;
            roundEl.innerHTML += createHomepageMatchHTML(matchId, team1, team2, dbMatch, seeds);
        }
        parentEl.appendChild(roundEl);
    }

    // 右ハーフ
    parentEl = rightBracketEl;
    for (let r = 1; r <= semiFinalRound; r++) {
        const roundEl = document.createElement('div');
        roundEl.className = `round r${r}`;
        roundEl.innerHTML = `<div class="round-title">${roundNameMap[r]}</div>`;
        const numMatchesInRound = 32 / Math.pow(2, r);
        for (let m = 1; m <= numMatchesInRound; m++) {
            const matchId = `R-R${r}-M${m}`;
            const dbMatch = matches[matchId] || {};
            const baseIndex = 32; // 右ハーフの開始インデックス
            const team1 = dbMatch.team1 || (r > 1 ? matches[`R-R${r-1}-M${(m*2)-1}`]?.winner : teams[baseIndex + (m-1)*2]) || null;
            const team2 = dbMatch.team2 || (r > 1 ? matches[`R-R${r-1}-M${(m*2)}`]?.winner : teams[baseIndex + (m-1)*2 + 1]) || null;
            roundEl.innerHTML += createHomepageMatchHTML(matchId, team1, team2, dbMatch, seeds);
        }
        parentEl.appendChild(roundEl);
    }
    
    bracketContentWrapper.append(leftBracketEl, finalEl, rightBracketEl);
    return bracketContentWrapper.outerHTML;
}

// ▼▼▼ この関数を「新規追加」(11984行目あたり) ▼▼▼
/**
 * [NEW] チームの全投手の通算成績を集計し、チーム防御率とWHIPを計算する
 * @param {string} teamName - チーム名
 * @returns {object} - { era: string, whip: string }
 */
function calculateTeamPitchingStats(teamName) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord || !teamRecord.playerStats || !teamRecord.playerStats.pitching) {
        return { era: "----", whip: "----" };
    }

    const pitchingStats = teamRecord.playerStats.pitching;
    let totalER = 0;
    let totalIP = 0;
    let totalHits = 0;
    let totalWalks = 0;

    for (const playerName in pitchingStats) {
        const career = pitchingStats[playerName].career;
        if (career) {
            totalER += career.er || 0;
            totalIP += career.ip || 0;
            totalHits += career.h || 0;
            totalWalks += career.bb || 0;
        }
    }

    const era_val = (totalIP > 0) ? ((totalER * 9) / totalIP) : Infinity;
    const whip_val = (totalIP > 0) ? ((totalHits + totalWalks) / totalIP) : Infinity;

    return {
        era: (era_val === Infinity) ? "----" : era_val.toFixed(2),
        whip: (whip_val === Infinity) ? "----" : whip_val.toFixed(2)
    };
}
// ▲▲▲ 新規追加ここまで ▲▲▲

// ▼▼▼ 既存の「createHomepageMatchHTML」関数 (13115行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * [NEW] ホームページモーダル専用の、1試合分のHTMLを生成する
 * (★「一球速報」ボタン ＋ 「調子」アイコン表示を追加した最終版)
 */
function createHomepageMatchHTML(matchId, team1, team2, dbMatch, seeds = []) {
    const is283Team = (name) => name === "283学園" || name === "283学園B";

    const t1Empty = !team1;
    const t2Empty = !team2;
    
    // 283学園のハイライトクラス
    const team1Class = is283Team(team1) ? 'hp-team-283' : '';
    const team2Class = is283Team(team2) ? 'hp-team-283' : '';
    
    // 勝敗クラス
    const winnerClass1 = (dbMatch.winner === team1 && !t1Empty) ? 'winner' : '';
    const loserClass1 = (dbMatch.winner && dbMatch.winner !== team1 && !t1Empty) ? 'loser' : '';
    const winnerClass2 = (dbMatch.winner === team2 && !t2Empty) ? 'winner' : '';
    const loserClass2 = (dbMatch.winner && dbMatch.winner !== team2 && !t2Empty) ? 'loser' : '';
    
    // シード表示
    const seedInfo1 = seeds.find(s => s.team === team1);
    const seedInfo2 = seeds.find(s => s.team === team2);
    const seedLabel1 = seedInfo1 ? `[${seedInfo1.rank}] ` : '';
    const seedLabel2 = seedInfo2 ? `[${seedInfo2.rank}] ` : '';

    const roundClassMatch = matchId.includes('-R1-M') ? 'r1' : '';

    // ★★★ ここからが修正箇所 ★★★
    // 選手の調子アイコンを取得するヘルパー
    const getConditionIconForTeam = (teamName) => {
        if (!teamName) return ""; 
        
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord || !teamRecord.playerStats) return "";

        let icons = [];
        // (注: この関数は「試合前」に描画されるため、アイコンは「前の試合」の結果です)
        // 打者の調子
        if (teamRecord.playerStats.batting) {
            for (const playerName in teamRecord.playerStats.batting) {
                const flag = teamRecord.playerStats.batting[playerName].narrative_flag;
                const icon = getPlayerConditionIcon(flag);
                if (icon) icons.push(icon);
            }
        }
        // 投手の調子
        if (teamRecord.playerStats.pitching) {
            for (const playerName in teamRecord.playerStats.pitching) {
                const flag = teamRecord.playerStats.pitching[playerName].narrative_flag;
                const icon = getPlayerConditionIcon(flag);
                if (icon) icons.push(icon);
            }
        }
        // 重複を除去して返す
        return [...new Set(icons)].join('');
    };

    const team1ConditionIcons = getConditionIconForTeam(team1);
    const team2ConditionIcons = getConditionIconForTeam(team2);

    let footerButtonHTML = '';
    if (dbMatch.winner && dbMatch.boxScoreHtml) {
        footerButtonHTML = `
            <div class="matchup-footer mt-1 text-center">
                <button class="boxscore-btn text-xs bg-blue-600 text-white font-bold px-3 py-1 rounded hover:bg-blue-700" data-match-id="${matchId}">
                    一球速報
                </button>
            </div>
        `;
    }
    // ★★★ 修正ここまで ★★★

    return `
        <div class="matchup ${roundClassMatch}">
            <div class="match">
                <div class="team ${team1Class} ${winnerClass1} ${loserClass1}">
                    <span class="name">${seedLabel1}${team1 || '---'} ${team1ConditionIcons}</span>
                    <span class="score">${dbMatch.score1 ?? ''}</span>
                </div>
                <div class="team ${team2Class} ${winnerClass2} ${loserClass2}">
                    <span class="name">${seedLabel2}${team2 || '---'} ${team2ConditionIcons}</span>
                    <span class="score">${dbMatch.score2 ?? ''}</span>
                </div>
            </div>
            ${footerButtonHTML}
            ${matchId.includes('-R1-M') ? '' : '<div class="connector-line"></div>'}
            ${matchId.includes('-R2-M') ? '<div class="connector-path"></div>' : ''}
            ${matchId.includes('-R3-M') ? '<div class="connector-path"></div>' : ''}
            ${matchId.includes('-R4-M') ? '<div class="connector-path"></div>' : ''}
            ${matchId.includes('-R5-M') ? '<div class="connector-path"></div>' : ''}
        </div>
    `;
}
// ▲▲▲ 置き換えここまで ▲▲▲


/**
 * 抽選会イベントを開始する
 * (★128チーム制＝128スロットに対応)
 */
async function startLotteryEvent() {
    const lotteryModal = document.getElementById('lottery-modal');
    lotteryModal.classList.remove('hidden');
    lotteryModal.classList.add('flex');

    // (シード校決定ロジックは変更なし)
    const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
    historicalRanks.sort((a, b) => a.rank - b.rank);
    const seeds = historicalRanks.slice(0, 8).map((t, i) => ({ team: t.name, rank: i + 1 })); 
    
    // ★★★ ここからが修正箇所 ★★★
    // 簡易トーナメント表を作成 (128チーム分)
    const leftBracket = document.getElementById('lottery-bracket-left');
    const rightBracket = document.getElementById('lottery-bracket-right');
    leftBracket.innerHTML = '';
    rightBracket.innerHTML = '';
    for(let i=0; i<128; i++){ // 64 -> 128
        const slot = document.createElement('div');
        slot.className = 'lottery-slot';
        slot.dataset.index = i;
        slot.innerHTML = `<span>${i+1}.</span> <span class="team-name-placeholder">---</span>`;
        // 64未満は左、64以上は右
        document.getElementById(i < 64 ? 'lottery-bracket-left' : 'lottery-bracket-right').appendChild(slot);
    }
    // ★★★ 修正ここまで ★★★

    // (ボタンイベントリスナーは変更なし)
    document.getElementById('start-lottery-btn').onclick = () => runLotteryAnimation(lotteryOrder, seeds);
    document.getElementById('skip-lottery-btn').onclick = () => {
        lotteryModal.classList.add('hidden');
        SoundManager.stopBgm();
        createNewTournament(false, 'summer');
    };

    // (抽選順の決定ロジックは変更なし)
    const seedTeamsList = seeds.map(s => s.team);
    const nonSeeds = INITIAL_TEAM_POOL.filter(t => !seedTeamsList.includes(t));
    
    // ★ 不戦勝(BYE)を抽選対象に追加
    const byesNeeded = 128 - nonSeeds.length - seeds.length;
    const byes = Array(byesNeeded).fill('(BYE)');
    const lotteryOrder = [...seedTeamsList, ...shuffleArray([...nonSeeds, ...byes])];

    SoundManager.startBgm();
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 抽選会のアニメーションを実行する
 * (★128チーム制・7ラウンド制に対応した最終版)
 * @param {Array<string>} lotteryOrder - 全チームの抽選順 (シード校が先)
 * @param {Array<object>} seeds - シード校8チームのランク付きオブジェクト配列
 */
async function runLotteryAnimation(lotteryOrder, seeds) {
    // --- 1. 初期設定 ---
    document.getElementById('lottery-pot').onclick = null;
    document.getElementById('skip-lottery-btn').style.display = 'none';
    
    const initialAiEnabled = document.getElementById('initial-ai-generation-toggle').checked;

    const commentaryEl = document.getElementById('lottery-commentary').querySelector('p');
    const drawnTeamContainer = document.getElementById('drawn-team-container');
    const drawnTeamEl = document.getElementById('drawn-team');
    const potEl = document.getElementById('lottery-pot');
    const potNameEl = document.getElementById('pot-name');
    
    // ★★★ 修正点 ★★★
    const teamPositions = Array(128).fill(null); // 64 -> 128
    const seedPositionsTemplate = [0, 64, 32, 96, 16, 80, 48, 112]; // 128チーム用の配置
    // ★★★ 修正ここまで ★★★
    
    // (シード配置スロットの準備ロジック ... 変更なし)
    const rank1_4_teams_sorted = seeds.filter(s => s.rank <= 4).sort((a, b) => a.rank - b.rank);
    const rank1_4_teams = [
        rank1_4_teams_sorted[0], // 第1シード
        rank1_4_teams_sorted[1], // 第2シード
        rank1_4_teams_sorted[3], // 第4シード
        rank1_4_teams_sorted[2]  // 第3シード
    ].filter(Boolean);
    const rank5_8_teams = shuffleArray(seeds.filter(s => s.rank > 4));
    const rank1_4_positions = seedPositionsTemplate.slice(0, 4); // [0, 64, 32, 96]
    const rank5_8_positions = shuffleArray(seedPositionsTemplate.slice(4)); // [16, 80, 48, 112] をシャッフル
    
    // ★★★ 修正点 ★★★
    let availableNonSeedSlots = Array.from({length: 128}, (_, i) => i).filter(p => !seedPositionsTemplate.includes(p)); // 64 -> 128
    const blockDeathAnnounced = { A: false, B: false, C: false, D: false };

    // (内部ヘルパー関数: playSound, isStrongRank ... 変更なし)
    const playSound = (id) => {
        const soundElement = document.getElementById(id);
        if (soundElement) {
            soundElement.currentTime = 0;
            soundElement.play().catch(e => console.warn(`Audio play failed for ${id}:`, e));
        }
    };
    const isStrongRank = (team) => ['A'].includes(calculateRank(team, {}));

    // (内部ヘルパー関数: checkDeathBlock ... ★修正★)
    const checkDeathBlock = (position) => {
        // 128チーム / 4ブロック = 1ブロック32チーム
        const blockName = position < 32 ? 'A' : position < 64 ? 'B' : position < 96 ? 'C' : 'D';
        const startIdx = position < 32 ? 0 : position < 64 ? 32 : position < 96 ? 64 : 96;
        constblockSize = 32; // ★ 16 -> 32
        
        if (blockDeathAnnounced[blockName]) return false;
        
        const teamsInBlock = teamPositions.slice(startIdx, startIdx + blockSize);
        // ★ 3チーム -> 4チーム に変更
        const strongTeamsCount = teamsInBlock.filter(team => team && ['A', 'B'].includes(calculateRank(team, {}))).length; 
        if (strongTeamsCount >= 4) { // ★ 3 -> 4
            commentaryEl.textContent = `これは...！ ${blockName}ブロックは有力校が集中する「死のブロック」になりました！`;
            blockDeathAnnounced[blockName] = true;
            playSound('sound-gasp');
            return true;
        }
        return false;
    };
    // ★★★ 修正ここまで ★★★


    // --- 2. 抽選会フェーズ1：シード校の配置 ---
    potNameEl.textContent = "シード校";
    
    // (第1〜第4シードの配置 (固定位置・山分け) ... 変更なし)
    for (let i = 0; i < rank1_4_teams.length; i++) {
        const teamName = rank1_4_teams[i].team;
        const teamRank = rank1_4_teams[i].rank;
        const position = rank1_4_positions[i]; 

        let dreadBg = null;
        if (isStrongRank(teamName) && initialAiEnabled) {
            dreadBg = document.createElement('div');
            dreadBg.className = 'dread-mode-bg';
            document.body.appendChild(dreadBg);
            potEl.classList.add('dread');
            commentaryEl.textContent = `会場が静まり返る... 第${teamRank}シード、 ${teamName} です...`;
            await sleep(2500);
        }

        commentaryEl.textContent = `第${teamRank}シード、${teamName}がクジを引きます...`;
        playSound('sound-drumroll');
        await sleep(1500);
        drawnTeamEl.textContent = teamName;
        drawnTeamContainer.classList.add('fade-in-out');
        teamPositions[position] = teamName;
        await sleep(1250);
        const targetSlot = document.querySelector(`.lottery-slot[data-index="${position}"]`);
        targetSlot.querySelector('.team-name-placeholder').textContent = `[${teamRank}] ${teamName}`;
        targetSlot.classList.add('filled', 'highlight'); 
        playSound('sound-cymbal');
        if (dreadBg) {
            dreadBg.remove();
            potEl.classList.remove('dread');
            playSound('sound-gasp');
        }
        commentaryEl.textContent = `第${teamRank}シード、${teamName}は ${position + 1}番に決定！`;
        await sleep(1500);
        drawnTeamContainer.classList.remove('fade-in-out');
        targetSlot.classList.remove('highlight');
    }

    // (第5〜第8シードの配置 (ランダム位置) ... 変更なし)
    for (let i = 0; i < rank5_8_teams.length; i++) {
        const teamName = rank5_8_teams[i].team;
        const teamRank = rank5_8_teams[i].rank;
        const position = rank5_8_positions[i]; 
        commentaryEl.textContent = `第${teamRank}シード、${teamName}がクジを引きます...`;
        playSound('sound-drumroll');
        await sleep(1500);
        drawnTeamEl.textContent = teamName;
        drawnTeamContainer.classList.add('fade-in-out');
        teamPositions[position] = teamName;
        await sleep(1250);
        const targetSlot = document.querySelector(`.lottery-slot[data-index="${position}"]`);
        targetSlot.querySelector('.team-name-placeholder').textContent = `[${teamRank}] ${teamName}`;
        targetSlot.classList.add('filled', 'highlight');
        playSound('sound-cymbal');
        commentaryEl.textContent = `第${teamRank}シード、${teamName}は ${position + 1}番に決定！`;
        await sleep(1500);
        drawnTeamContainer.classList.remove('fade-in-out');
        targetSlot.classList.remove('highlight');
    }


    // --- 3. 抽選会フェーズ2：ノーシード校の配置 (ロジック変更なし) ---
    potNameEl.textContent = "ノーシード校";
    const nonSeeds = lotteryOrder.filter(t => !seeds.map(s => s.team).includes(t));
    for (const teamName of nonSeeds) {
        let dreadBg = null;
        if (isStrongRank(teamName) && initialAiEnabled) {
            dreadBg = document.createElement('div');
            dreadBg.className = 'dread-mode-bg';
            document.body.appendChild(dreadBg);
            potEl.classList.add('dread');
            commentaryEl.textContent = `会場が静まり返る... ノーシードの強豪 ${teamName} が登場...`;
            await sleep(2500);
        }

        commentaryEl.textContent = `${teamName}がクジを引きます...`;
        playSound('sound-drumroll');
        await sleep(250);
        drawnTeamEl.textContent = teamName;
        drawnTeamContainer.classList.add('fade-in-out');
        const slotIndex = Math.floor(Math.random() * availableNonSeedSlots.length);
        const position = availableNonSeedSlots.splice(slotIndex, 1)[0];
        teamPositions[position] = teamName;
        await sleep(200);
        const targetSlot = document.querySelector(`.lottery-slot[data-index="${position}"]`);
        targetSlot.querySelector('.team-name-placeholder').textContent = teamName;
        targetSlot.classList.add('filled');
        playSound('sound-cymbal');
        if (dreadBg) {
            dreadBg.remove();
            potEl.classList.remove('dread');
            playSound('sound-gasp');
        }
        commentaryEl.textContent = `${teamName}は ${position + 1}番 に決定！`;
        
        let didComment = false;
        if (initialAiEnabled) {
             didComment = checkDeathBlock(position);
        }

        if (!didComment) {
            const opponentIndex = position % 2 === 0 ? position + 1 : position - 1;
            if(teamPositions[opponentIndex]) {
                const opponentName = teamPositions[opponentIndex];
                const opponentIsSeed = seeds.some(s => s.team === opponentName);
                const isRival = (isStrongRank(teamName) && opponentIsSeed) || 
                              (['A','B'].includes(calculateRank(teamName, {})) && ['A','B'].includes(calculateRank(opponentName, {})));
                if (isRival && initialAiEnabled) {
                    commentaryEl.textContent = `決まったー！1回戦から屈指の好カード！ ${teamName} vs ${opponentName}`;
                    playSound('sound-gasp');
                    document.querySelector(`.lottery-slot[data-index="${opponentIndex}"]`).classList.add('highlight');
                    targetSlot.classList.add('highlight');
                    await sleep(1500);
                    document.querySelector(`.lottery-slot[data-index="${opponentIndex}"]`).classList.remove('highlight');
                    targetSlot.classList.remove('highlight');
                }
            }
        }
        await sleep(250);
        drawnTeamContainer.classList.remove('fade-in-out');
    }

    // --- 4. 終了処理 ---
    commentaryEl.textContent = '全ての組み合わせが決定しました！';
    await sleep(2000);
    
    if (initialAiEnabled) {
        await generateCaptainInterviews(teamPositions);
    } else {
        document.getElementById('lottery-modal').classList.add('hidden');
        SoundManager.stopBgm();
        createNewTournament(false, 'summer', teamPositions);
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

// ▲▲▲ 置き換えここまで ▲▲▲
/**
 * 抽選会後の主将インタビューを生成・表示する
 * (★128チーム制・7ラウンド制に対応)
 * @param {Array<string>} teamPositions - 抽選会で決定した最終的なチームの組み合わせ (128チーム)
 */
async function generateCaptainInterviews(teamPositions) {
    const interviewModal = document.getElementById('interview-modal');
    const interviewContent = document.getElementById('interview-content');
    interviewContent.innerHTML = `<div class="loader">AI記者が主将インタビューを作成中...</div>`;
    interviewModal.classList.remove('hidden');

    const matchups = [];
    // ★★★ 修正点: 64 -> 128 ★★★
    for(let i=0; i<128; i+=2){
        matchups.push({team1: teamPositions[i], team2: teamPositions[i+1]});
    }

    // 注目カードを5つに増やす
    const notableMatchups = shuffleArray(matchups).slice(0, 5); // ★ 3 -> 5
    // ★★★ 修正ここまで ★★★

    const matchupsWithRanks = notableMatchups.map(m => ({
        team1: m.team1,
        rank1: calculateRank(m.team1, tournamentState),
        team2: m.team2,
        rank2: calculateRank(m.team2, tournamentState)
    }));
    const promptDataText = matchupsWithRanks.map(m => 
        `- ${m.team1} (ランク: ${m.rank1}) vs ${m.team2} (ランク: ${m.rank2})`
    ).join('\n');

    const prompt = `あなたは高校野球専門のAI記者です。夏の大会の組み合わせ抽選会が終了しました。
以下の注目カードについて、両チームの主将になりきって、抽選結果に対するリアルな反応を語ってください。

### 注目カードと各チームのランク
${promptDataText}

### あなたがなりきる「高校生の主将」の思考パターン
- **(BYE) 不戦勝と当たった場合:**
  - 「初戦が不戦勝なのはラッキーだ」「まずは2回戦に向けてしっかり準備したい」と、安堵と油断のなさを表明する。
- **格下の相手と当たった場合 (例: Aランク vs Dランク):**
  - 少し安堵した様子を見せる。「正直、ホッとした」「自分たちの野球をすれば負けない」
  - しかし油断は禁物だと付け加える。「どのチームも強いので、一戦必勝で戦いたい」
- **格上の相手と当たった場合 (例: Eランク vs Aランク):**
  - 明らかに絶望したり、驚いたりする。「まさか初戦で当たるとは…」「正直、厳しい相手」
  - しかし、挑戦者として「胸を借りるつもりで全力でぶつかりたい」「一矢報いたい」と闘志も見せる。
- **実力が拮Kkしている相手と当たった場合 (例: Cランク vs Cランク):**
  - 「ここが最初の山場になる」「厳しい戦いになることは覚悟している」と、相手への敬意を示す。
  - 「最高の試合をしたい」と、ライバルとの対戦を心待ちにしている様子を見せる。

### 指示
- 上記の思考パターンに基づき、各カードの両主将のコメントを生成してください。
- チームの背景（例：王者、古豪）も少しだけコメントに反映させてください。

### 出力形式 (JSON配列)
[
    {"team": "〇〇高校", "captain_comment": "（主将のコメント）"},
    {"team": "△△高校", "captain_comment": "（主将のコメント）"}
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        const interviews = parseJsonFromText(result.candidates[0].content.parts[0].text);

        if (interviews && Array.isArray(interviews)) {
            interviewContent.innerHTML = interviews.map(iv => `
                <div class="p-4 bg-gray-50 rounded-lg mb-2">
                    <h4 class="font-bold text-lg text-gray-800">${iv.team} 主将</h4>
                    <p class="mt-1 text-gray-700">「${iv.captain_comment}」</p>
                </div>
            `).join('');
        } else {
            throw new Error("Parsed JSON is not an array or is null.");
        }
    } catch (e) {
        interviewContent.innerHTML = `<p class="text-center text-red-500">インタビューの生成に失敗しました。</p>`;
        console.error(e);
    }
    
    document.getElementById('close-interview-btn').onclick = () => {
        interviewModal.classList.add('hidden');
        document.getElementById('lottery-modal').classList.add('hidden');
        SoundManager.stopBgm();
        createNewTournament(false, 'summer', teamPositions);
    };
}
// ▲▲▲ 置き換えここまで ▲▲▲
     
/**
 * [NEW] スクロール連動アニメーション用のIntersection Observer
 */
function setupScrollAnimation() {
    const scrollContainer = document.getElementById('homepage-scroll-container');
    if (!scrollContainer) return;

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('is-visible');
                // 一度表示されたら監視を解除（オプション）
                // observer.unobserve(entry.target);
            } else {
                 // スクロールアウトしたら非表示に戻す場合（オプション）
                 // entry.target.classList.remove('is-visible');
            }
        });
    }, {
        root: scrollContainer, // 監視対象をモーダルのスクロールコンテナに設定
        rootMargin: '0px',
        threshold: 0.1 // 10%見えたらトリガー
    });

    // モーダル内の全セクションを監視対象に追加
    scrollContainer.querySelectorAll('.fade-in-section').forEach(section => {
        observer.observe(section);
    });
}

/**
 * [NEW] ホームページモーダルを開く/閉じるアニメーションのトリガー
 */
function toggleHomepageModal(show) {
    const modal = document.getElementById('homepage-modal');
    if (!modal) return;

    if (show) {
        // モーダルを開く
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        
        // ヒーローセクションのアニメーションをリセット＆トリガー
        const slogan = modal.querySelector('.slogan');
        const subtitle = modal.querySelector('.animate-fade-in-up');
        if (slogan) slogan.classList.remove('animate-fade-in-down');
        if (subtitle) subtitle.classList.remove('is-visible');
        
        // requestAnimationFrame を挟むことで、クラスの再適用を確実にする
        requestAnimationFrame(() => {
            if (slogan) slogan.classList.add('animate-fade-in-down');
            if (subtitle) subtitle.classList.add('is-visible');
        });

        // スクロール連動アニメーションをセットアップ
        setupScrollAnimation();
        
    } else {
        // モーダルを閉じる
        modal.classList.add('hidden');
        modal.classList.remove('flex');
        
        // 閉じる時にアニメーションクラスをリセット（次回開くときのため）
        modal.querySelectorAll('.fade-in-section').forEach(section => {
            section.classList.remove('is-visible');
        });
        modal.querySelector('.slogan')?.classList.remove('animate-fade-in-down');
        modal.querySelector('.animate-fade-in-up')?.classList.remove('is-visible');
    }
}
// ▲▲▲ 新規追加ここまで ▲▲▲

    async function initializeApp() {
  SoundManager.init(); 
 // --- 1. Preload the background image ---
    const bgContainer = document.querySelector('.ballpark-background');
    if (bgContainer) {
        const img = new Image();
        const imageUrl = 'ballpark.jpg'; // The local image path
        
        img.onload = function() {
            // Image loaded successfully, set it as the background and start the dust effect
            bgContainer.style.backgroundImage = `url(${imageUrl})`;
            createDustEffect();
        };
        img.onerror = function() {
            // If the image fails to load, log an error but still start the dust effect
            console.error('Failed to load the background image.');
            createDustEffect();
        };
        
        img.src = imageUrl; // This starts the image download
    } else {
        // If the background container doesn't exist, just start the dust effect
        createDustEffect();
    }
       
 // --- ここから診断コード ---
        try {
            alert('デバッグ開始：initializeApp関数が実行されました。');
            
            if (teamsTextarea) {
                alert('成功：チーム一覧を表示するテキストエリアが見つかりました。');
            } else {
                alert('エラー：チーム一覧を表示するテキストエリアが見つかりません！ id="teams-list" を確認してください。');
                return;
            }

            if (INITIAL_TEAM_POOL && INITIAL_TEAM_POOL.length > 0) {
                alert(`成功：${INITIAL_TEAM_POOL.length}件のチームデータが読み込まれました。`);
            } else {
                alert('エラー：チームデータが読み込めていません！ TEAM_DATAの定義を確認してください。');
                return;
            }

            teamsTextarea.value = INITIAL_TEAM_POOL.join('\n');
            alert('成功：チーム一覧をテキストエリアに表示しました。');

        } catch (e) {
            alert('致命的なエラーが発生しました： ' + e.message);
        }

        // --- ここまで診断コード ---

        
    const savedStateJSON = localStorage.getItem('tournamentState');
    if (savedStateJSON) {
        try {
            const lastState = JSON.parse(savedStateJSON);
            if (lastState && lastState.tournamentYear) {
                const confirmed = await showConfirm("前回の続きから再開しますか？\n（「いいえ」で最初から、または「合い言葉」で再開）");
                
                if (confirmed) { // 「はい」が押された場合
                    tournamentState = lastState;

// ▼▼▼ このブロックをまるごと追加 ▼▼▼
                    // --- 古いセーブデータへの「互換性パッチ」 ---
                    if (tournamentState.teamRecords) {
                        for (const teamName in tournamentState.teamRecords) {
                            const record = tournamentState.teamRecords[teamName];
                            
                            // 1. (model_156) チーム打率(tournamentStats)がなければ初期化
                            if (!record.tournamentStats) {
                                record.tournamentStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0 };
                            }
                            
                            // 2. (model_164) ロスター(roster)がなければ初期化
                            if (!record.roster) {
                                record.roster = null;
                            }
                        }
                    }
                    // 3. (model_106) 応援コメント(preGameComments)がなければ初期化
                    if (!tournamentState.preGameComments) {
                        tournamentState.preGameComments = {};
                    }
                    // ▲▲▲ 追加ここまで ▲▲▲

// ▼▼▼ この1行をまるごと追加 ▼▼▼
                    if (!tournamentState.matomeThreads) tournamentState.matomeThreads = {};
                    // ▲▲▲ 追加ここまで ▲▲▲

                    setupEl.classList.add('hidden');
                    tournamentDisplayEl.classList.remove('hidden');
                    renderTournament(tournamentState);
                    return; 
                } else { // ▼▼▼ 「いいえ」が押された場合の処理を追加 ▼▼▼
                    // 古いセーブデータを完全に消去する
                    localStorage.removeItem('tournamentState');
                }
            }
        } catch (e) {
            console.error("保存されたデータの読み込みに失敗:", e);
            localStorage.removeItem('tournamentState'); 
        }
    }        
        setupEl.classList.remove('hidden');
        tournamentDisplayEl.classList.add('hidden');
　　　　teamsTextarea.value = INITIAL_TEAM_POOL.join('\n');

 updateTicker();
}

    // --- Event Listeners ---
    
    generateBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("新しいトーナメントを開始すると、現在の進行状況は失われます。よろしいですか？");
    if (confirmed) startLotteryEvent();
});
    resumeBtn.addEventListener('click', () => {
        saveLoadModal.classList.remove('hidden');
        loadTabBtn.click();
    });

    nextTournamentBtn.addEventListener('click', async () => {
        const confirmed = await showConfirm("現在の大会を終了し、次の大会へ進みますか？");
        if(confirmed) {
            let nextTournamentType;
            if (tournamentState.currentTournament === 'summer') nextTournamentType = 'autumn';
            else if (tournamentState.currentTournament === 'autumn') nextTournamentType = 'spring';
            else nextTournamentType = 'summer';
            createNewTournament(true, nextTournamentType);
        }
    });

    resetBtn.addEventListener('click', async () => {
        const confirmed = await showConfirm("すべての大会記録をリセットして、最初の状態に戻しますか？");
        if(confirmed){
            localStorage.clear();
            location.reload();
        }
    });

    saveBtn.addEventListener('click', () => {
        document.getElementById('save-code-area').classList.add('hidden');
        saveLoadModal.classList.remove('hidden');
        saveTabBtn.click();
    });
    
    startRankingPlayoffsBtn.addEventListener('click', async () => {
         const confirmed = await showConfirm("全ブロックの予選が終了しました。地区内順位決定戦に進みますか？");
         if(confirmed) setupAutumnRankingTournaments();
    });
    
    // startMainTournamentBtn のイベントリスナー内

startMainTournamentBtn.addEventListener('click', async () => {
    // ★★★ 春季大会用の分岐を追加 ★★★
    if (tournamentState.currentTournament === 'spring') {
        const confirmed = await showConfirm("全代表校が決定しました。県大会本戦に進みますか？");
        if (confirmed) setupSpringMainTournament_Round1();
    } 
    // ★★★ ここまで追加 ★★★
    else { // 秋季大会の既存ロジック
        const confirmed = await showConfirm("全代表校が決定しました。県大会本戦に進みますか？");
        if (confirmed) setupAutumnMainTournament();
    }
});
// --- スキップボタン・ダイジェストボタンのグローバル変数宣言 ---
    
    skipR1Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("1回戦を自動で進行しますか？");
        if (confirmed) skipRound(1);
    });
    skipR2Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("2回戦を自動で進行しますか？");
        if (confirmed) skipRound(2);
    });
    skipR3Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("3回戦を自動で進行しますか？");
        if (confirmed) skipRound(3);
    });

skipR4Btn.addEventListener('click', async () => {
    const confirmed = await showConfirm("4回戦を自動で進行しますか？");
    if (confirmed) skipRound(4);
});

skipR5Btn.addEventListener('click', async () => {
    const confirmed = await showConfirm("準々決勝を自動で進行しますか？");
    if (confirmed) skipRound(5);
});

skipR6Btn.addEventListener('click', async () => {
    const confirmed = await showConfirm("準決勝を自動で進行しますか？");
    if (confirmed) skipRound(6);
});

skipFinalBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("決勝戦を自動で進行しますか？");
    if (confirmed) skipFinal();
});


    generateSummaryBtn.addEventListener('click', async () => {
        generateSummaryBtn.disabled = true;
        generateSummaryBtn.textContent = '記事を生成中...';
        newsContainer.innerHTML = `<div class="loader">AI記者が準々決勝の展望記事を執筆中...</div>`;
        
        // ★★★ 新しい関数を呼び出す ★★★
        const summaryArticle = await generateBest16PreviewArticle();
        // ★★★ 修正ここまで ★★★

        if (summaryArticle) {
            tournamentState.news.push(summaryArticle);
            saveState();
            renderNews(tournamentState.news);
        }
        generateSummaryBtn.classList.add('hidden');
        generateSummaryBtn.disabled = false;
        generateSummaryBtn.textContent = '準々決勝 展望記事を生成';
    });


/**
 * [NEW] 283学園ホームページ用の「お知らせ」記事をAIに生成させる
 * @param {object} matchContext - 試合の全コンテキストデータ
 * @returns {Promise<object|null>} - { title, body, timestamp }
 */
async function generateHomepageNewsUpdate(matchContext) {
    const { winnerName, loserName, dbMatch, matchId, nextOpponent } = matchContext;
    
    // 283学園が勝ったかどうか
    const is283Match = (winnerName === "283学園" || loserName === "283学園");
    if (!is283Match) return null;
    
    const teamName = "283学園";
    const result = (winnerName === teamName) ? '勝利' : '敗北';
    const opponentName = (winnerName === teamName) ? loserName : winnerName;
    const score = (winnerName === teamName) 
        ? `${dbMatch.score1} - ${dbMatch.score2}` 
        : `${dbMatch.score2} - ${dbMatch.score1}`;
    const roundName = getRoundNameFromMatchId(matchId);

    // 1. 戦評の生成
    let summary = dbMatch.summary || matchContext.highlights?.[0]?.description || "熱戦が繰り広げられました。";
    if (result === '敗北') {
        summary = `惜しくも${opponentName}に敗れ、今大会の挑戦は終了となりました。`;
    }

    // 2. 次の試合情報の生成
    let nextMatchText = "";
    if (result === '勝利' && nextOpponent) {
        if (nextOpponent.opponentName === '優勝') {
            nextMatchText = "次戦はありません（県大会優勝）。たくさんのご声援ありがとうございました！";
        } else {
            const opponent = nextOpponent.decidingMatch 
                ? `${nextOpponent.decidingMatch.team1} と ${nextOpponent.decidingMatch.team2} の勝者`
                : (nextOpponent.opponentName || '（未定）');
            
            const schedule = nextOpponent.nextMatchSchedule;
            const location = schedule?.stadiumFull || '未定';
            const date = schedule?.date || '未定';
            const gameNum = schedule?.game ? `第${schedule.game}試合` : '';

            nextMatchText = `次戦（${nextOpponent.roundName}）は、${opponent}と対戦します。\n` +
                            `日時: ${date} ${gameNum}\n` +
                            `場所: ${location}\n\n` +
                            `引き続きのご声援をよろしくお願いいたします。`;
        }
    } else if (result === '敗北') {
        nextMatchText = "皆様の熱い声援が、選手の力となりました。心より感謝申し上げます。\n新チームでの再起にご期待ください。";
    }

    // 3. AIにプロンプトを送信
    const prompt = `あなたは「283学園」野球部の広報担当者です。
以下の試合結果データに基づき、学園のホームページに掲載する「お知らせ」記事のタイトルと本文を、丁寧な「です・ます調」で生成してください。

### 試合データ
- **大会名:** ${tournamentNameMap[tournamentState.currentTournament] || '大会'} ${roundName}
- **自チーム:** ${teamName}
- **対戦相手:** ${opponentName}
- **結果:** ${teamName} の ${result}
- **スコア:** ${score}
- **簡単な戦評(AI生成):** ${summary}
- **次の試合情報(テキスト):** ${nextMatchText}

### 指示
1.  **タイトル:** 「【野球部】（大会名 ラウンド） 試合結果のお知らせ」という形式にしてください。
2.  **本文:**
    - 試合が行われたこと、対戦相手、スコア、勝敗を報告してください。
    - 「簡単な戦評」を自然な文章に直して挿入してください。
    - 最後に「次の試合情報」をそのまま挿入してください。
    - 全体を、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式 (JSON)
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文、改行は\\nを使用）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const newsJson = parseJsonFromText(rawText);
            if (newsJson && newsJson.title && newsJson.body) {
                return { ...newsJson, timestamp: Date.now() };
            }
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("283学園ホームページニュースの生成に失敗しました:", error);
        return {
            title: "記事生成エラー",
            body: "AI広報担当者との通信に失敗しました。",
            timestamp: Date.now(),
            error: true
        };
    }
}

document.body.addEventListener('click', async (e) => {




    // --- 試合進行ボタン (▶) ---
    if (e.target.matches('.win-btn')) {
        const teamSlot = e.target.closest('.team-slot');
        const matchEl = e.target.closest('[data-match-id]');
        if (!teamSlot || !matchEl || teamSlot.classList.contains('empty')) return;

        const matchId = matchEl.dataset.matchId;
        const winnerName = teamSlot.dataset.teamName;
        if (!winnerName) return;

        const score1El = matchEl.querySelector('[data-team-pos="1"]');
        const score2El = matchEl.querySelector('[data-team-pos="2"]');

        if(!score1El || !score2El || score1El.value === '' || score2El.value === '') {
            showAlert('スコアを入力してください。');
            return;
        }

        let dbMatch = findMatchById(matchId);
        if (dbMatch) {
            dbMatch.score1 = score1El.value;
            dbMatch.score2 = score2El.value;
            dbMatch.summary = matchEl.querySelector('.match-summary-input')?.value || '';
        }

        await processMatchWin(matchId, winnerName);
    }

    // --- 「勢力図をアニメーションで見る」ボタン ---
    if (e.target.matches('.view-analysis-btn')) {
        document.getElementById('analysis-modal').classList.remove('hidden');
        currentBlock = 'A';
        playBlockAnimation(currentBlock);
    }
    
    // --- 勢力図モーダル内のタブボタン ---
    if (e.target.matches('.analysis-block-tab-btn')) {
        const blockId = e.target.dataset.block;
        if (blockId && blockId !== currentBlock) {
            currentBlock = blockId;
            playBlockAnimation(blockId);
        }
    }
    
    // --- 勢力図モーダルを閉じるボタン ---
    if (e.target.matches('#analysis-modal-close-btn')) {
        document.getElementById('analysis-modal').classList.add('hidden');
    }

    // --- 試合詳細入力ボタン ---
    if (e.target.matches('.details-btn')) {
        openDetailsModal(e.target.dataset.matchId);
    }

    // --- 【詳細モーダル内】イニング追加ボタン ---
    if (e.target.matches('.add-inning-btn') || e.target.matches('#add-inning-score-btn')) {
        e.preventDefault();
        addExtraInning();
    }

    // --- 【詳細モーダル内】守備ファインプレーを追加ボタン ---
    if (e.target.matches('.add-fielding-play-btn')) {
        e.preventDefault();
        const teamKey = e.target.dataset.teamKey;
        const fieldingTableEl = document.getElementById(`fielding-table-${teamKey}`);
        const battingTableEl = document.getElementById(`batting-table-${teamKey}`);
        
        if (!fieldingTableEl || !battingTableEl) {
            console.error(`エラー: ${teamKey} の fielding-table または batting-table が見つかりません。`);
            alert("致命的なエラー：テーブル要素が見つかりません。コンソールを確認してください。");
            return;
        }
        
        const tableBody = fieldingTableEl.querySelector('tbody');
        const playersOnField = Array.from(battingTableEl.querySelectorAll('.player-name')).map(input => ({name: input.value.trim()})).filter(p => p.name);
        const playerOptions = playersOnField.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
        
        const newRow = tableBody.insertRow();
        newRow.dataset.fieldingIndex = tableBody.rows.length;
        newRow.innerHTML = `
            <td class="w-16"><input type="number" class="fielding-inning" min="1"></td>
            <td>
                <select class="player-name w-full">
                    <option value="">- 選手 -</option>
                    ${playerOptions}
                </select>
            </td>
            <td><input type="text" class="fielding-play" placeholder="例: ダイビングキャッチ"></td>
            <td class="w-12 text-center">
                <button class="remove-fielding-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </td>
        `;
    }

    // --- 【詳細モーダル内】守備ファインプレーを削除ボタン ---
    if (e.target.matches('.remove-fielding-play-btn')) {
        e.preventDefault();
        e.target.closest('tr').remove();
    }

    // --- 天候ボタン ---
    if (e.target.matches('.weather-btn')) {
        const weatherType = e.target.dataset.weather;
        setWeather(weatherType);
    }

    // --- 「チーム通算成績」ボタン（トーナメント表の 📊 ボタン） ---
    if (e.target.matches('.show-team-stats-btn')) {
        e.preventDefault();
        const teamName = e.target.dataset.teamName;
        if (!teamName) return;
        renderTeamStatsModal(teamName); // 統計タブの中身だけ先に描画
        document.getElementById('team-stats-modal').classList.remove('hidden');
        document.getElementById('team-stats-modal').classList.add('flex');
    }

    // --- チーム通算成績モーダルを閉じるボタン ---
    if (e.target.matches('#team-stats-modal-close')) {
        e.preventDefault();
        document.getElementById('team-stats-modal').classList.add('hidden');
        document.getElementById('team-stats-modal').classList.remove('flex');
    }

    // --- [新機能] チーム通算成績モーダルのタブ切り替え ---
    if (e.target.matches('.team-stats-tab-btn')) {
        e.preventDefault();
        const btn = e.target;
        if (btn.classList.contains('active')) return;
        const modal = btn.closest('#team-stats-modal');
        const tabId = btn.dataset.tab;
        const teamName = modal.querySelector('#team-stats-modal-title').textContent.split(' ')[0];
        modal.querySelectorAll('.team-stats-tab-btn').forEach(b => b.classList.remove('active'));
        modal.querySelectorAll('.team-stats-tab-content').forEach(c => c.classList.add('hidden'));
        btn.classList.add('active');
        const contentEl = document.getElementById(`team-stats-tab-content-${tabId}`);
        contentEl.classList.remove('hidden');
        if (tabId === 'lineups') {
            if (contentEl.querySelector('.loader')) {
                renderStartingLineupHistory(teamName);
            }
        }
    }

// --- [NEW] 投手成績の自動計算ボタン ---
        else if (e.target.closest('.calc-pitcher-stats-btn')) {
            e.preventDefault();
            const btn = e.target.closest('.calc-pitcher-stats-btn');
            const pitchingTeamKey = btn.dataset.pitchingTeam;
            const battingTeamKey = btn.dataset.battingTeam;
            
            // ★ async関数を呼び出す
            (async () => {
                await fillPitcherStatsFromBatting(pitchingTeamKey, battingTeamKey);
            })();
        }
// --- [NEW] イニング欄からの「代打」ボタン ---
        else if (e.target.closest('.inning-add-sub-btn')) {
            e.preventDefault();
            const btn = e.target.closest('.inning-add-sub-btn');
            const teamKey = btn.dataset.teamKey;
            const inningIndex = parseInt(btn.dataset.inning, 10);
            const currentOrder = btn.dataset.order;
            const baseOrder = currentOrder.split('-')[0];
            const row = btn.closest('tr');
            const tableBody = row.closest('tbody');

            // 1. 本来の「+ 交代」ボタンを探して、プログラムでクリックする
            // (※注: data-orderが "1" や "1-sub-1" など、可変なため、
            // 　オリジナルの "1" や "2" を持つボタンを探す必要がある)
            // (※[data-order="${baseOrder}"] で、 "1" や "2" のスタメン行のボタンを探す)
            const mainSubButton = tableBody.querySelector(`tr[data-order="${baseOrder}"] .add-sub-row-btn`);
            
            if (!mainSubButton) {
                console.error("オリジナルの「+ 交代」ボタンが見つかりません。");
                return;
            }
            
            // 2. メインの「+ 交代」ボタンをクリックして、新しい行を追加させる
            mainSubButton.click();

            // 3. 新しく追加された行（＝その打順の最後の行）を取得
            const allOrderRows = Array.from(tableBody.querySelectorAll(`tr[data-order^="${baseOrder}"]`));
            const newRow = allOrderRows[allOrderRows.length - 1];

            if (newRow) {
                // 4. 新しい行のドロップダウンを「PH (代打)」に設定
                const subTypeSelect = newRow.querySelector('.sub-type-select');
                if (subTypeSelect) {
                    subTypeSelect.value = 'PH';
                }
                
                // 5. 新しい行の、クリックされたイニングのセルにフォーカスを当てる
                const inningCell = newRow.querySelectorAll('td.col-inning')[inningIndex];
                if (inningCell) {
                    // そのセル内の最初の入力可能な要素にフォーカスする
                    const firstInput = inningCell.querySelector('select, input');
                    if (firstInput) {
                        firstInput.focus();
                    }
                }
            }
        }

// --- [NEW] 試合後 ボックススコア表示ボタン (トーナメント表の「一球速報」) ---
    else if (e.target.closest('.boxscore-btn')) {
        e.preventDefault();
        const matchId = e.target.closest('.boxscore-btn').dataset.matchId;
        const dbMatch = findMatchById(matchId);
        
        if (!dbMatch || !dbMatch.boxScoreHtml) {
            alert("ボックススコアデータが見つかりません。詳細入力が正しく保存されているか確認してください。");
            return;
        }
        
        const modal = document.getElementById('boxscore-modal');
        const modalTitle = document.getElementById('boxscore-modal-title');
        const modalBody = document.getElementById('boxscore-modal-body');
        
        modalTitle.textContent = `ボックススコア: ${dbMatch.team1} vs ${dbMatch.team2} (${getRoundNameFromMatchId(matchId)})`;
        modalBody.innerHTML = dbMatch.boxScoreHtml;
        
        modal.classList.remove('modal-hidden');
        modal.classList.add('flex');
    }
// ▲▲▲ 新規追加ここまで ▲▲▲

// --- [NEW] 簡易入力モーダルを開く ---
    else if (e.target.closest('.scorecard-open-btn')) {
        e.preventDefault();
        openScorecardModal(e.target.closest('.scorecard-open-btn').dataset.matchId);
    }
    // --- [NEW] 簡易入力モーダルを閉じる ---
    else if (e.target.closest('#scorecard-close-btn')) {
        e.preventDefault();
        if (confirm("入力内容を保存せずに閉じますか？")) {
            document.getElementById('scorecard-modal').classList.add('hidden');
            document.getElementById('scorecard-modal').classList.remove('flex');
            activeScorecardState = {};
        }
    }
    
    // ★★★ ここからが修正箇所 (順序入れ替え) ★★★

    // --- [NEW] 簡易入力モーダル：「打点」または「併殺/犠飛/犠打」ボタン (優先度 1) ---
    else if (e.target.closest('.rbi-btn, .result-btn[data-action="out-dp"], .result-btn[data-action="out-sac-f"], .result-btn[data-action="out-sac-b"]')) {
        e.preventDefault();
        
        // 1. もし「結果入力待ち(STEP 1)」なら、まず結果をセット
        if (activeScorecardState.currentStep === "waiting_for_result") {
            const action = e.target.closest('button').dataset.action;
            if (action) {
                handleScorecardAction(action); // これで pendingPlay がセットされ、stepが "waiting_for_direction" に進む
                return; // このクリックでの処理はここまで
            }
        }
        
        // 2. もし「打点入力待ち(STEP 3)」なら、打点をセットしてプレー確定
        if (activeScorecardState.currentStep === "waiting_for_rbi") {
            const btn = e.target.closest('button');
            const rbiValue = btn.dataset.rbi; // "0", "1", "2"...
            
            // (併殺・犠飛・犠打は data-rbi 属性を持たないので、actionから判断)
            const action = btn.dataset.action;
            if (action === 'out-dp') activeScorecardState.pendingPlay.rbi = 'dp';
            else if (action === 'out-sac-f') activeScorecardState.pendingPlay.rbi = 'sf';
            else if (action === 'out-sac-b') activeScorecardState.pendingPlay.rbi = 'sh';
            else activeScorecardState.pendingPlay.rbi = rbiValue; // "0", "1" など
            
            processPlay(); // プレーを確定
        }
    }

    // --- [NEW] 簡易入力モーダル：「結果」または「走塁」ボタン (優先度 2) ---
    // (併殺・犠飛・犠打ボタンは上のifで処理されるため、ここはそれ以外が対象)
    else if (e.target.closest('.result-btn')) {
        e.preventDefault();
        // action は 'hit-1b' や 'run-sb' など
        handleScorecardAction(e.target.closest('.result-btn').dataset.action);
    }
    
    // --- [NEW] 簡易入力モーダル：「打球方向」ホットスポット ---
    else if (e.target.closest('.direction-hotspot')) {
        e.preventDefault();
        if (activeScorecardState.currentStep !== "waiting_for_direction") return;
        
        const direction = e.target.closest('.direction-hotspot').dataset.direction;
        activeScorecardState.pendingPlay.direction = direction; // 方向をセット
        
        // ★ 次のステップ（打点入力）へ
        activeScorecardState.currentStep = "waiting_for_rbi";
        renderScorecard(); // UIを「打点入力モード」に更新
    }

    // --- [NEW] 簡易入力モーダル：「ランナー」クリック (走塁処理) ---
    else if (e.target.closest('.base.runner')) {
        e.preventDefault();
        const state = activeScorecardState;
        if (!state.currentStep.startsWith("waiting_for_runner_")) return;

        const baseEl = e.target.closest('.base.runner');
        let baseIndex = -1; // 0=1B, 1=2B, 2=3B
        if (baseEl.id === 'base-1b') baseIndex = 0;
        else if (baseEl.id === 'base-2b') baseIndex = 1;
        else if (baseEl.id === 'base-3b') baseIndex = 2;
        
        if (baseIndex === -1 || !state.runners[baseIndex]) return; // クリックされた塁にランナーがいない

        const runnerName = state.runners[baseIndex];
        let resultString = "";
        let newOuts = state.outs;
        
        if (state.currentStep === "waiting_for_runner_sb") {
            // 盗塁
            if (baseIndex === 2) { // 3塁ランナー
                state.runners[2] = null;
                state.score[state.topBottom === '表' ? 'team1' : 'team2']++; // ホームスチール
                resultString = `${runnerName} ホームスチール成功`;
            } else if (baseIndex === 1) { // 2塁ランナー
                state.runners[1] = null;
                state.runners[2] = runnerName;
                resultString = `${runnerName} 盗塁 (三塁へ)`;
            } else { // 1塁ランナー
                state.runners[0] = null;
                state.runners[1] = runnerName;
                resultString = `${runnerName} 盗塁 (二塁へ)`;
            }
        } 
        else if (state.currentStep === "waiting_for_runner_cs") {
            // 盗塁死
            state.runners[baseIndex] = null;
            newOuts++;
            resultString = `${runnerName} 盗塁死`;
        }
        else if (state.currentStep === "waiting_for_runner_out") {
            // 走塁死
            state.runners[baseIndex] = null;
            newOuts++;
            resultString = `${runnerName} 走塁死`;
        }

        // ログを記録 (打席とは独立したプレーとして)
        state.playLog.push({
            inning: state.inning,
            topBottom: state.topBottom,
            batterName: `(走者 ${runnerName})`,
            batterOrder: '-',
            resultString: resultString,
            outs: newOuts
        });
        state.outs = newOuts; // アウトカウントを更新

        // 3アウトになったか？
        if (state.outs >= 3) {
            if (state.topBottom === '表') {
                state.topBottom = '裏';
            } else {
                state.topBottom = '表';
                state.inning++;
            }
            state.outs = 0;
            state.runners = [null, null, null];
        }

        // 状態をリセット
        state.currentStep = "waiting_for_result";
        renderScorecard();
    }
    
    // ★★★ 修正ここまで ★★★

    // --- [NEW] 簡易入力モーダルの保存ボタン ---
    else if (e.target.closest('#scorecard-save-btn')) {
        e.preventDefault();
        saveScorecardAndClose();
    }
    // --- [NEW] 簡易入力モーダルの「戻る」ボタン ---
    else if (e.target.closest('#scorecard-undo-btn')) {
        e.preventDefault();
        alert("「1プレー戻す」機能は現在開発中です。");
    }
// ▲▲▲ 置き換えここまで ▲▲▲

// ▲▲▲ 置き換えここまで ▲▲▲
// --- [NEW] (ホームページ内) スマホメニューの開閉 ---
    else if (e.target.closest('#mobile-menu-button')) {
        e.preventDefault();
        const menu = document.getElementById('mobile-menu');
        menu.classList.toggle('hidden');
    }
    // --- [NEW] (ホームページ内) スマホメニューのリンククリック時に閉じる ---
    else if (e.target.closest('.mobile-nav-link')) {
        const menu = document.getElementById('mobile-menu');
        menu.classList.add('hidden');
    }
// ▲▲▲ 新規追加ここまで ▲▲▲

// --- [NEW] (ホームページ内) インタラクティブ・マップ ホットスポット ---
    else if (e.target.closest('.hotspot')) {
        e.preventDefault();
        const hotspot = e.target.closest('.hotspot');
        const popup = document.getElementById('hotspot-popup');
        const dataId = hotspot.dataset.id;
        const data = FACILITY_DATA[dataId];

        if (!data || !popup) return;

        // 1. データをポップアップに注入
        document.getElementById('hotspot-popup-title').textContent = data.title;
        document.getElementById('hotspot-popup-text').textContent = data.text;
        document.getElementById('hotspot-popup-image').src = data.imgSrc;
        
        // 2. ポップアップの位置をホットスポットの近くに調整
        const hotspotRect = hotspot.getBoundingClientRect();
        const mapRect = document.getElementById('campus-map-container').getBoundingClientRect();
        
        // ホットスポットの「マップコンテナ内での」相対Y座標
        const hotspotYInMap = hotspotRect.top - mapRect.top; 
        
        // マップの下半分にある場合はポップアップを「上」に、上半分なら「下」に出す
        if (hotspotYInMap > (mapRect.height / 2)) {
            popup.style.top = 'auto';
            popup.style.bottom = `${mapRect.height - hotspotYInMap + 20}px`; // ホットスポットの真上 (20pxオフセット)
        } else {
            popup.style.top = `${hotspotYInMap + hotspotRect.height + 20}px`; // ホットスポットの真下 (20pxオフセット)
            popup.style.bottom = 'auto';
        }
        
        // X座標はホットスポットの左端に合わせる (CSSのtransformは使わない方がシンプル)
        popup.style.left = `${hotspot.offsetLeft}px`;
        // transform をリセット
        popup.style.transform = 'translateY(-10px)'; // 上に浮き上がるアニメーション用

        // 3. 表示
        popup.classList.remove('hidden');
        // 'visible' クラスを少し遅れて追加してCSSアニメーションを発火
        setTimeout(() => popup.classList.add('visible'), 10);
    }
    
    // --- [NEW] (ホームページ内) ホットスポット・ポップアップを閉じる ---
    else if (e.target.closest('#hotspot-popup-close-btn')) {
        e.preventDefault();
        const popup = document.getElementById('hotspot-popup');
        popup.classList.remove('visible');
        popup.style.transform = 'translateY(0)'; // 元の位置に戻る
        // アニメーションが終わるのを待ってから隠す
        setTimeout(() => popup.classList.add('hidden'), 300);
    }
// ▲▲▲ 新規追加ここまで ▲▲▲

// ▼▼▼ [NEW] スレ立てモーダルを開くボタン ▼▼▼
    else if (e.target.closest('#open-new-thread-modal-btn')) {
        e.preventDefault();
        // フォームをリセット
        document.getElementById('new-thread-title').value = '';
        document.getElementById('new-thread-comment').value = '';
        // モーダルを表示
        document.getElementById('new-thread-modal').classList.remove('hidden');
    }
    // ▲▲▲ 挿入ここまで ▲▲▲
// ▼▼▼ [NEW] スレ立てモーダルを閉じるボタン (キャンセル) ▼▼▼
    else if (e.target.closest('#new-thread-cancel')) {
        e.preventDefault();
        document.getElementById('new-thread-modal').classList.add('hidden');
    }

/// --- [NEW] 283学園ホームページモーダルを開くボタン ---
   else if (e.target.closest('#status-modal-homepage-link')) {
        e.preventDefault();
        const modalId = e.target.closest('#status-modal-homepage-link').dataset.target;
        if (modalId === 'homepage-modal') {
            
            // 1. 最新のトーナメント表を描画
            const homepageBracketPlaceholder = document.getElementById('current-tournament-bracket-container');
            if (homepageBracketPlaceholder) {
                const currentBracketHTML = generateHomepageBracketHTML(tournamentState);
                if(currentBracketHTML.trim() !== "") {
                    homepageBracketPlaceholder.innerHTML = currentBracketHTML;
                } else {
                    homepageBracketPlaceholder.innerHTML = '<p class="text-center text-gray-500">（トーナメントがまだ開始されていません）</p>';
                }
            }

            // 2. 最新の「お知らせ」を動的に描画
            const dynamicNewsListEl = document.getElementById('homepage-dynamic-news-list');
            if (dynamicNewsListEl) {
                const homepageNews = tournamentState.homepageNews || [];
                if (homepageNews.length > 0) {
                    dynamicNewsListEl.innerHTML = homepageNews.map(article => {
                        if (article.error) return '';
                        const bodyForAttr = article.body.replace(/\n/g, '&#10;').replace(/"/g, '&quot;');
                        
                        return `
                            <li class="border-b border-gray-200 pb-3 mb-3 last:border-b-0">
                                <span class="text-sm text-red-600 font-bold">NEW!</span>
                                <span class="text-sm text-gray-500">${new Date(article.timestamp).toLocaleDateString('ja-JP')}</span>
                                <p class-"font-semibold text-gray-800 hover:text-blue-600 cursor-pointer homepage-news-item" 
                                   data-article-body="${bodyForAttr}" 
                                   data-article-title="${article.title.replace(/"/g, '&quot;')}">
                                    ${article.title}
                                </p>
                            </li>
                        `;
                    }).join('');
                    dynamicNewsListEl.classList.remove('hidden');
                } else {
                    dynamicNewsListEl.innerHTML = '';
                    dynamicNewsListEl.classList.add('hidden');
                }
            }

            // ★★★ 3. アニメーション付きでモーダルを開く ★★★
            toggleHomepageModal(true);
            
            // チームステータスモーダルは閉じない（上に重ねる）
        }
    }
// ▲▲▲ 置き換えここまで ▲▲▲

// --- [NEW] (ホームページ内) 動的お知らせクリック ---
    else if (e.target.closest('.homepage-news-item')) {
        e.preventDefault();
        const p = e.target.closest('p');
        const title = p.dataset.articleTitle;
        const body = p.dataset.articleBody.replace(/&#10;/g, '\n'); // 改行を元に戻す
        
        // 既存の一球速報モーダルを流用して表示
        const modal = document.getElementById('boxscore-modal');
        const modalTitle = document.getElementById('boxscore-modal-title');
        const modalBody = document.getElementById('boxscore-modal-body');
        
        modalTitle.textContent = title;
        // 本文を <pre> タグで囲むことで、\n の改行をそのまま表示する
        modalBody.innerHTML = `<pre class="p-4 whitespace-pre-wrap leading-relaxed text-sm">${body}</pre>`;
        
        modal.classList.remove('modal-hidden');
        modal.classList.add('flex');
    }
// ▲▲▲ 新規追加ここまで ▲▲▲

    // --- [NEW] 283学園ホームページモーダルを閉じるボタン ---
   else if (e.target.closest('#homepage-modal-close')) {
        e.preventDefault();
        // ★★★ 4. アニメーション付きでモーダルを閉じる ★★★
        toggleHomepageModal(false);
    }
    // --- [NEW] (ホームページ内) ボックススコア表示ボタン ---
    else if (e.target.closest('#show-boxscore-btn-2024')) {
        e.preventDefault();
        const modal = document.getElementById('boxscore-modal');
        const modalBody = document.getElementById('boxscore-modal-body');
        
        // 架空のスコア表HTMLを生成
        const boxScoreHtml = generate2024FinalBoxScore(); 
        
        document.getElementById('boxscore-modal-title').textContent = "ボックススコア: 283学園 vs 常葉菊川 (2024年 決勝)";
        modalBody.innerHTML = boxScoreHtml;
        modal.classList.remove('modal-hidden');
        modal.classList.add('flex'); // hidden ではなく flex で表示
    }

    // --- [NEW] ボックススコアモーダルを閉じるボタン ---
    else if (e.target.closest('#boxscore-modal-close')) {
        e.preventDefault();
        const modal = document.getElementById('boxscore-modal');
        modal.classList.add('modal-hidden');
        modal.classList.remove('flex');
    }

    // --- [NEW] (ホームページ内) 動的お知らせクリック ---
    else if (e.target.closest('#homepage-dynamic-news-list p')) {
        e.preventDefault();
        const p = e.target.closest('p');
        const title = p.dataset.articleTitle;
        const body = p.dataset.articleBody.replace(/&#10;/g, '\n'); // 改行を元に戻す
        
        // 既存の一球速報モーダルを流用して表示
        const modal = document.getElementById('boxscore-modal');
        const modalTitle = document.getElementById('boxscore-modal-title');
        const modalBody = document.getElementById('boxscore-modal-body');
        
        modalTitle.textContent = title;
        // 本文を <pre> タグで囲むことで、\n の改行をそのまま表示する
        modalBody.innerHTML = `<pre class="p-4 whitespace-pre-wrap leading-relaxed text-sm">${body}</pre>`;
        
        modal.classList.remove('modal-hidden');
        modal.classList.add('flex');
    }

// ▲▲▲ 新規追加ここまで ▲▲▲

    // ▼▼▼ 既存の「#new-thread-submit」の else if ブロックと、このブロックを「置き換え」 ▼▼▼
    else if (e.target.closest('#new-thread-submit')) {
        e.preventDefault();
        
        // ★ AIが動作中であることをユーザーに示す
        const submitBtn = e.target.closest('#new-thread-submit');
        submitBtn.disabled = true;
        submitBtn.textContent = 'AIがレス作成中...';

        const title = document.getElementById('new-thread-title').value.trim();
        const comment = document.getElementById('new-thread-comment').value.trim();
        const fullUserText = `${title} ${comment}`; // ★ スキャン用の結合テキスト

        if (!title || !comment) {
            alert('タイトルと本文の両方を入力してください。');
            submitBtn.disabled = false;
            submitBtn.textContent = 'スレを立てる';
            return;
        }

        const threadId = 'user-' + Date.now();
        const timestamp = Date.now();

        // 1. 記事一覧に表示するための「記事オブジェクト」を作成
        const threadArticle = {
            id: threadId,
            headline: title,
            type: 'game', // AIスレと同じ 'game' タイプとして扱う
            matchId: threadId, // matomeThreads との連携キー
            timestamp: timestamp,
            category: '自スレ' // 専用カテゴリ
        };
        
        if (!tournamentState.userThreads) tournamentState.userThreads = [];
        tournamentState.userThreads.push(threadArticle);

        // 2. スレ主(>>1)のコメントを作成
        const firstComment = {
            id: crypto.randomUUID(),
            personality: '1: 風吹けば名無し (スレ主)',
            text: comment,
            timestamp: timestamp,
            replies: []
        };
        
        // ★★★ ここからが修正箇所 ★★★
        // 3. ユーザーの入力テキストから関連情報をスキャンし、AI用のコンテキストを生成
        
        const mentionedTeams = new Set();
        INITIAL_TEAM_POOL.forEach(team => {
            if (fullUserText.includes(team)) {
                mentionedTeams.add(team);
            }
        });

        let gameContext = ""; // AIに渡すための情報テキスト
        if (mentionedTeams.size > 0) {
            // チーム情報 (打率, 盗塁, 軌跡)
            mentionedTeams.forEach(teamName => {
                const teamData = TEAM_DATA[teamName];
                const teamRecord = tournamentState.teamRecords[teamName];
                const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord); 
                const fate = getTeamFateSummary(teamName);
                gameContext += `\n- **${teamName}**: ${dynamicInfo} (今大会の状況: ${fate})\n`;
            });

            // 選手情報 (Gamelog)
            // formatPlayerGamelogsForPrompt は「言及されたチーム」に所属する「言及された選手」のログを返す
            gameContext += formatPlayerGamelogsForPrompt(mentionedTeams, fullUserText);
        }
        
        // 4. AIにレスポンスを生成させる (★ gameContext を渡す)
        const aiComments = await generateUserThreadBbsComments(title, comment, gameContext);
        // ★★★ 修正ここまで ★★★

        if (!tournamentState.matomeThreads) tournamentState.matomeThreads = {};
        
        // 5. スレ主のコメントとAIのレスを結合して保存
        if (aiComments && Array.isArray(aiComments)) {
            tournamentState.matomeThreads[threadId] = {
                thread: [firstComment, ...aiComments], // ★ AIのレスを結合
                context: { isUserThread: true, title: title } 
            };
        } else {
             // AI生成失敗時も、スレ主のコメントだけでスレは立てる
            tournamentState.matomeThreads[threadId] = {
                thread: [firstComment], 
                context: { isUserThread: true, title: title } 
            };
             alert('AIによるレスの自動生成に失敗しました。スレッドは作成されます。');
        }


        // 6. 保存してUIを更新
        saveState();
        document.getElementById('new-thread-modal').classList.add('hidden');
        
        // 7. まとめサイトの記事一覧をリフレッシュ
        const articlesContainer = document.getElementById('matome-articles-container');
        articlesContainer.innerHTML = `<div class="loader text-center py-8">スレッドを立てています...</div>`;
        (async () => {
            const matomeHtml = await generateMatomeSiteHtml();
            articlesContainer.innerHTML = matomeHtml;
        })();

        // 8. ボタンの状態を元に戻す
        submitBtn.disabled = false;
        submitBtn.textContent = 'スレを立てる';
    }
// ▲▲▲ 置き換えここまで ▲▲▲

    // --- ★★★ ソート機能（ヘッダーTHクリック） ★★★ ---
    if (e.target.matches('.sortable-header')) {
        e.preventDefault();
        const header = e.target.closest('.sortable-header');
        const modal = e.target.closest('#team-stats-modal');
        const tableType = header.dataset.tableType;
        const newSortKey = header.dataset.sortKey;
        const teamName = document.getElementById('team-stats-modal-title').textContent.split(' ')[0];
        let currentKey, currentDir;
        if (tableType === 'batting') {
            currentKey = modal.dataset.sortKeyBatting;
            currentDir = modal.dataset.sortDirBatting;
        } else {
            currentKey = modal.dataset.sortKeyPitching;
            currentDir = modal.dataset.sortDirPitching;
        }
        let newSortDir = 'desc';
        if (newSortKey === currentKey && currentDir === 'desc') {
            newSortDir = 'asc';
        }
        if (tableType === 'batting') {
            modal.dataset.sortKeyBatting = newSortKey;
            modal.dataset.sortDirBatting = newSortDir;
        } else {
            modal.dataset.sortKeyPitching = newSortKey;
            modal.dataset.sortDirPitching = newSortDir;
        }
        renderTeamStatsModal(teamName);
    }

    // --- 「個人通算成績」ボタン（モーダルを開く） ---
    if (e.target.matches('.show-player-stats-btn')) {
        e.preventDefault();
        const btn = e.target;
        const teamName = btn.dataset.teamName;
        const row = btn.closest('tr');
        const playerNameInput = row.querySelector('.player-name');
        if (!playerNameInput) { alert('エラー: 選手名入力欄が見つかりません。'); return; }
        const playerName = playerNameInput.value.trim();
        if (!playerName) { alert('選手名が入力されていません。'); return; }
        renderCareerStatsModal(playerName, teamName);
        document.getElementById('player-stats-modal').classList.remove('hidden');
        document.getElementById('player-stats-modal').classList.add('flex');
    }

    // --- 個人通算成績モーダルを閉じるボタン ---
    if (e.target.matches('#player-stats-modal-close')) {
        e.preventDefault();
        document.getElementById('player-stats-modal').classList.add('hidden');
        document.getElementById('player-stats-modal').classList.remove('flex');
    }

    // --- 【詳細モーダル内】「打順からコピー」ボタン（投手） ---
    if (e.target.matches('.copy-pitchers-from-batting-btn')) {
        e.preventDefault();
        const teamKey = e.target.dataset.teamKey;
        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (!battingTable) { alert('打撃テーブルが見つかりません。'); return; }
        const pitchingTableBody = document.getElementById(`pitching-table-${teamKey}`)?.querySelector('tbody');
        if (!pitchingTableBody) { alert('投手テーブルが見つかりません。'); return; }
        const pitchersInBatting = [];
        battingTable.querySelectorAll('tbody tr').forEach(row => {
            const posSelect = row.querySelector('.player-pos');
            const nameInput = row.querySelector('.player-name');
            const throwBatSelect = row.querySelector('.player-throw-bat');
            if (posSelect && posSelect.value === '投' && nameInput && nameInput.value.trim() !== '') {
                pitchersInBatting.push({ name: nameInput.value.trim(), throwBat: throwBatSelect ? throwBatSelect.value : '' });
            }
        });
        if (pitchersInBatting.length === 0) {
            alert('打撃テーブルに「投」と設定された選手が見つかりません。\n先に打撃テーブルの「守備」欄を「投」に設定してください。');
            return;
        }
        const pitchingRows = pitchingTableBody.querySelectorAll('tr');
        let updatedCount = 0;
        pitchersInBatting.forEach((pitcher, index) => {
            if (pitchingRows[index]) {
                const nameInput = pitchingRows[index].querySelector('.pitcher-name');
                const throwBatSelect = pitchingRows[index].querySelector('.pitcher-throw-bat');
                if (nameInput) nameInput.value = pitcher.name;
                if (throwBatSelect) throwBatSelect.value = pitcher.throwBat;
                updatedCount++;
            }
        });
        alert(`${updatedCount}人の投手を打撃テーブルからコピーしました。`);
    }

    // --- 【まとめサイト】スレッド再生成ボタン ---
    if (e.target.matches('#retry-matome-thread-btn')) {
        e.preventDefault();
        const btn = e.target;
        const matchId = btn.dataset.matchId;
        const originalData = tournamentState.matomeThreads[matchId];
        if (!originalData || !originalData.context) {
            alert("再生成に必要な「試合終了時の情報（コンテキスト）」が見つかりません。");
            return;
        }
        const matchContext = originalData.context;
        const threadContentEl = document.getElementById('bbs-thread-content');
        btn.disabled = true;
        btn.textContent = '生成中...';
        threadContentEl.innerHTML = `<div class="loader text-center py-8">AIがスレッドを再生成中です...（${matchContext.winnerLineupChanges || 'スタメン変更なし'}）</div>`;
        const newCommentsArray = await generateGameMatchBbsComments(matchContext);
        if (newCommentsArray && Array.isArray(newCommentsArray)) {
            tournamentState.matomeThreads[matchId].thread = newCommentsArray;
            saveState();
            threadContentEl.innerHTML = '';
            for (const comment of newCommentsArray) {
                const commentEl = document.createElement('div');
                commentEl.className = 'bbs-comment opacity-0 transition-opacity duration-500';
                commentEl.innerHTML = `<p class="font-semibold text-gray-700 text-sm">${comment.personality}</p><p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>`;
                threadContentEl.appendChild(commentEl);
                setTimeout(() => { commentEl.classList.remove('opacity-0'); }, 50);
                await new Promise(resolve => setTimeout(resolve, 50));
                threadContentEl.scrollTop = threadContentEl.scrollHeight;
            }
        } else {
            tournamentState.matomeThreads[matchId].thread = newCommentsArray;
            saveState();
            threadContentEl.innerHTML = `<p class="text-center text-red-500">スレッドの再生成に失敗しました。(エラー: ${newCommentsArray.body || '不明'})</p>`;
        }
        btn.disabled = false;
        btn.textContent = '再生成';
    }

    // --- 「まとめサイトを見る」ボタン ---
    const showMatomeBtn = e.target.closest('#show-matome-site-btn');
    if (showMatomeBtn) {
        const modal = document.getElementById('integrated-matome-modal');
        const articlesContainer = document.getElementById('matome-articles-container');
        modal.classList.remove('hidden');
        articlesContainer.innerHTML = `<div class="loader text-center py-8">記事を読み込んでいます...</div>`;
        document.querySelectorAll('.matome-tab-content').forEach(tab => tab.classList.add('hidden'));
        document.getElementById('matome-tab-top').classList.remove('hidden');
        document.querySelectorAll('.matome-tab-btn').forEach(btn => btn.classList.remove('active', 'bg-blue-600', 'text-white'));
        document.querySelector('.matome-tab-btn[data-tab="top"]').classList.add('active', 'bg-blue-600', 'text-white');
        (async () => {
            const matomeHtml = await generateMatomeSiteHtml();
            articlesContainer.innerHTML = matomeHtml;
        })();
    }

    // --- 設定モーダルを開く/閉じる ---
    if (e.target.closest('#open-settings-btn')) {
        document.getElementById('toggle-article-generation').checked = tournamentState.settings.enableArticleGeneration;
        document.getElementById('toggle-bbs-generation').checked = tournamentState.settings.enableBbsGeneration;
        document.getElementById('settings-modal').classList.remove('hidden');
    }
    if (e.target.closest('#settings-modal-close-btn')) {
        document.getElementById('settings-modal').classList.add('hidden');
    }

    // --- 統合型まとめサイトモーダルを閉じるボタン ---
    if (e.target.closest('#matome-modal-close-btn')) {
        document.getElementById('integrated-matome-modal').classList.add('hidden');
        document.getElementById('bbs-thread-display-area').classList.add('hidden');
    }

    // --- まとめサイト内のタブ切り替え ---
    const tabBtn = e.target.closest('.matome-tab-btn');
    if (tabBtn) {
        document.querySelectorAll('.matome-tab-btn').forEach(btn => {
            btn.classList.remove('active', 'bg-blue-600', 'text-white', 'hover:bg-blue-700');
            btn.classList.add('text-gray-700', 'hover:bg-gray-100');
        });
        tabBtn.classList.add('active', 'bg-blue-600', 'text-white');
        tabBtn.classList.remove('text-gray-700', 'hover:bg-gray-100');
        const tabId = tabBtn.dataset.tab;
        document.querySelectorAll('.matome-tab-content').forEach(content => {
            content.classList.add('hidden');
        });
        document.getElementById(`matome-tab-${tabId}`).classList.remove('hidden');
        document.getElementById('bbs-thread-display-area').classList.add('hidden');
        if (tabId === 'top') {
            const articlesContainer = document.getElementById('matome-articles-container');
            articlesContainer.innerHTML = `<div class="loader text-center py-8">記事を読み込んでいます...</div>`;
            (async () => {
                const matomeHtml = await generateMatomeSiteHtml();
                articlesContainer.innerHTML = matomeHtml;
            })();
        }
    }
    
    // --- まとめサイト内の記事リンククリック ---
    const matomeLink = e.target.closest('.matome-article-link');
    if (matomeLink) {
        e.preventDefault();
        const headline = matomeLink.dataset.headline;
        const type = matomeLink.dataset.type;
        const category = matomeLink.dataset.category;
        const matchId = matomeLink.dataset.matchId;
        const threadDisplayArea = document.getElementById('bbs-thread-display-area');
        const threadTitleEl = document.getElementById('bbs-thread-title');
        const threadContentEl = document.getElementById('bbs-thread-content');
        document.querySelectorAll('.matome-tab-content').forEach(content => content.classList.add('hidden'));
        threadDisplayArea.classList.remove('hidden');
        threadTitleEl.textContent = headline;
        threadContentEl.innerHTML = `<div class="loader text-center py-8">AIが掲示板の反応を生成中...</div>`;
        (async () => {
            let commentsArray;
            const retryBtn = document.getElementById('retry-matome-thread-btn');
            if (type === 'game' && matchId) {
                const preGeneratedData = tournamentState.matomeThreads[matchId];
                const preGeneratedThread = preGeneratedData ? preGeneratedData.thread : null;
                if (preGeneratedData && preGeneratedData.context) {
                    retryBtn.dataset.matchId = matchId;
                    retryBtn.classList.remove('hidden');
                } else {
                    retryBtn.classList.add('hidden');
                }
                if (preGeneratedThread) {
                    if (Array.isArray(preGeneratedThread)) {
                        commentsArray = preGeneratedThread;
                    } else if (preGeneratedThread.error) {
                        threadContentEl.innerHTML = `<p class="text-center text-red-500">スレッドの生成に失敗しました。(エラー: ${preGeneratedThread.body || '不明'})</p>`;
                        return;
                    }
                } else {
                    threadContentEl.innerHTML = `<p class="text-center text-gray-500">この試合のまとめスレッドはまだありません。</p>`;
                    retryBtn.classList.add('hidden');
                    return;
                }
            } else if (type === 'real') {
                retryBtn.classList.add('hidden');
                commentsArray = await generateRealNewsBbsComments(headline, category);
            }
            if (commentsArray && Array.isArray(commentsArray)) {
                threadContentEl.innerHTML = '';
                for (const comment of commentsArray) {
                    const commentEl = document.createElement('div');
                    commentEl.className = 'bbs-comment opacity-0 transition-opacity duration-500';
                    commentEl.innerHTML = `<p class="font-semibold text-gray-700 text-sm">${comment.personality}</p><p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>`;
                    threadContentEl.appendChild(commentEl);
                    setTimeout(() => { commentEl.classList.remove('opacity-0'); }, 50);
                    const delay = Math.random() * 800 + 200;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    threadContentEl.scrollTop = threadContentEl.scrollHeight;
                }
            } else if (!commentsArray) {
                threadContentEl.innerHTML = `<p class="text-center text-red-500">スレッドの読み込みに失敗しました。</p>`;
            }
        })();
    }

    // --- BBSスレッドから一覧に戻るボタン ---
    if (e.target.closest('#bbs-thread-back-btn')) {
        document.getElementById('bbs-thread-display-area').classList.add('hidden');
        document.getElementById('matome-tab-top').classList.remove('hidden');
    }

    // --- スキャンダル告発/無視ボタン ---
    const scandalBtn = e.target.closest('.report-scandal-btn, .ignore-scandal-btn');
    if (scandalBtn && tournamentState.activeScandal) {
        const { teamName, scandalId } = tournamentState.activeScandal;
        const scandalDef = SCANDAL_DEFINITIONS.find(s => s.id === scandalId);
        if (!scandalDef) return;
        const choice = scandalBtn.classList.contains('report-scandal-btn') ? 'report' : 'ignore';
        const consequence = scandalDef.consequences[choice];
        consequence.applyEffect(teamName, tournamentState);
        const outcomeArticle = {
            title: consequence.outcomeTitle(teamName),
            body: consequence.outcomeBody(teamName),
            timestamp: Date.now()
        };
        tournamentState.news = tournamentState.news.filter(n => !n.isScandalRumor);
        tournamentState.news.push(outcomeArticle);
        tournamentState.activeScandal = null;
        renderTournament(tournamentState);
        saveState();
    }

    // --- ドキュメンタリー密着取材ボタン（各種） ---
    if (e.target.matches('.underdog-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？...`);
        if (confirmed) startDocumentary('underdog', teamName);
    }
    if (e.target.matches('.powerhouse-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) startDocumentary('powerhouse', teamName);
    }
    if (e.target.matches('.powerhouse-revival-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) startDocumentary('powerhouse_revival', teamName);
    }
    if (e.target.matches('.one-man-team-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) startDocumentary('one_man_team', teamName);
    }

    // --- 走者プレー「追加」ボタン ---
    if (e.target.matches('.add-runner-play-btn')) {
        e.preventDefault();
        const container = e.target.closest('.at-bat-block').querySelector('.runner-plays-container');
        if (!container) return;
        if (container.children.length >= 3) {
            alert('一度に追加できる走者プレーは3つまでです。');
            return;
        }
        const table = e.target.closest('.batting-table');
        const playersOnField = Array.from(table.querySelectorAll('.player-name')).map(input => ({name: input.value.trim()})).filter(p => p.name);
        const nameOptions = playersOnField.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
        const baserunningPlays = ['盗塁', '盗塁死', 'タッチアップ', '進塁', '生還', '走塁死', '牽制死', '挟殺プレーでアウト'];
        const bases = ['一塁へ', '二塁へ', '三塁へ', '本塁へ(生還)'];
        const playOptions = baserunningPlays.map(p => `<option value="${p}">${p}</option>`).join('');
        const baseOptions = bases.map(b => `<option value="${b}">${b}</option>`).join('');
        const newPlayHTML = `
            <div class="runner-play-input flex gap-1 items-center mt-1">
                <select class="runner-name w-1/3 text-xs p-1 border rounded"><option value="">-誰が-</option>${nameOptions}</select>
                <select class="runner-play w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-何をした-</option>${playOptions}</select>
                <select class="runner-base w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-どこへ-</option>${baseOptions}</select>
                <button class="remove-runner-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </div>
        `;
        container.insertAdjacentHTML('beforeend', newPlayHTML);
    }
    
    // --- 走者プレー「削除」ボタン ---
    if (e.target.matches('.remove-runner-play-btn')) {
        e.target.closest('.runner-play-input').remove();
    }

    // --- おまかせ入力ボタン ---
    if (e.target.matches('.quick-sim-btn')) {
        e.preventDefault();
        autoFillMatchDetails(e.target.dataset.matchId);
    }

    // --- 1イニングに複数打席を追加するボタン ---
    if (e.target.matches('.add-at-bat-btn')) {
        e.preventDefault();
        const table = e.target.closest('.batting-table');
        const playersOnField = Array.from(table.querySelectorAll('.player-name')).map(input => ({ name: input.value.trim() })).filter(p => p.name);
        const newAtBatHTML = createBattingResultDropdowns(playersOnField, '');
        e.target.insertAdjacentHTML('beforebegin', newAtBatHTML);
    }

    // --- 交代選手追加ボタン ---
    // --- 交代選手追加ボタン ---
    if (e.target.matches('.add-sub-row-btn')) {
        e.preventDefault();
        const btn = e.target;
        const teamKey = btn.dataset.teamKey;

        // ★★★ ここからが修正箇所 ★★★
        // エラーの原因: dbMatch が未定義だったため、ここで match を再取得します
        const match = findMatchById(currentMatchIdForDetails);
        if (!match) {
            console.error("Could not find match to add substitute player.");
            return; 
        }
        // ★★★ 修正ここまで ★★★

        const currentOrder = btn.dataset.order;
        const baseOrder = currentOrder.split('-')[0];
        const tableBody = btn.closest('tbody');
        if (!tableBody) return;
        const allOrderRows = Array.from(tableBody.querySelectorAll(`tr[data-order^="${baseOrder}"]`));
        const targetRow = allOrderRows[allOrderRows.length - 1];
        const subCount = allOrderRows.filter(row => row.dataset.order.includes('sub')).length + 1;
        const newOrder = `${baseOrder}-sub-${subCount}`;
        const newRow = document.createElement('tr');
        newRow.dataset.order = newOrder;
        const throwBatOptionsList = [
            { val: "R/R", label: "右/右" }, { val: "R/L", label: "右/左" }, { val: "R/S", label: "右/両" },
            { val: "L/L", label: "左/左" }, { val: "L/R", label: "左/右" }, { val: "L/S", label: "左/両" }
        ];
        const tbOptionsHtml = throwBatOptionsList.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const subThrowBatSelect = `<select class="player-throw-bat w-full bg-transparent"><option value="">-投/打-</option>${tbOptionsHtml}</select>`;
        const numberOptions = Array.from({length: 20}, (_, i) => `<option value="${i + 1}">${i + 1}</option>`).join('');
        const posOptions = ['投', '捕', '一', '二', '三', '遊', '左', '中', '右'].map(p => `<option value="${p}">${p}</option>`).join('');
        const numInnings = tableBody.parentElement.querySelector('thead tr').children.length - 7;
        let resultInputs = '';
        for (let j = 0; j < numInnings; j++) {
            resultInputs += `<td class="col-inning batting-result-cell align-top p-1">
                                ${createBattingResultDropdowns(null, '')}
                                <button class="add-at-bat-btn text-xs mt-2 bg-blue-100 px-2 py-1 rounded hover:bg-blue-200 w-full font-semibold">＋ 2打席目を追加</button>
                             </td>`;
        }
        newRow.innerHTML = `
            <td class="col-order"></td>
            <td class="col-number"><select class="player-number w-full bg-transparent"><option value=""></option>${numberOptions}</select></td>
            <td class="col-throw-bat">${subThrowBatSelect}</td>
            <td class="col-player pl-4">
                <div class="flex items-center gap-1">
                    <input type="text" class="player-name w-full" placeholder="交代選手名">
                    <button class="show-player-stats-btn text-lg p-1 text-blue-600 hover:bg-blue-100 rounded" 
                            data-team-name="${teamKey === 'team1' ? match.team1 : match.team2}" 
                            data-player-order-key="${newOrder}" 
                            title="通算成績を表示">📊</button>
                </div>
            </td>
            <td class="col-pos">
                <div class="flex items-center justify-between">
                    <select class="player-pos w-full bg-transparent"><option value=""></option>${posOptions}</select>
                    <button class="text-xs bg-gray-200 px-1 ml-1 rounded pos-change-btn" data-team-key="${teamKey}">変更</button>
                </div>
                <span class="text-xs text-gray-500 truncate" title=""></span>
            </td>
            <td class="col-sub-type align-top">
                <select class="sub-type-select w-full bg-transparent mb-1">
                    <option value="" selected>-</option>
                    <option value="PH">代打</option><option value="PR">代走</option>
                    <option value="DEF">守備</option><option value="PITCHER">投手</option>
                </select>
                <button class="add-sub-row-btn text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300 w-full" data-order="${newOrder}" data-team-key="${teamKey}">
                    + 交代
                </button>
            </td>
            ${resultInputs}
        `;
        targetRow.parentNode.insertBefore(newRow, targetRow.nextSibling);
    }
// ▲▲▲ 置き換えここまで ▲▲▲

    // --- 守備変更ボタン（モーダルを開く） ---
    if (e.target.matches('.pos-change-btn')) {
        const btn = e.target;
        const teamKey = btn.dataset.teamKey;
        const row = btn.closest('tr');
        const playerNameInput = row.querySelector('.player-name');
        if (!playerNameInput) return;
        const playerName = playerNameInput.value.trim();
        if (!playerName) {
            alert("先に選手名を入力してください。");
            return;
        }
        const modal = document.getElementById('substitution-modal');
        document.getElementById('sub-modal-player-name').value = playerName;
        modal.dataset.teamKey = teamKey;
        modal.dataset.playerName = playerName;
        modal.dataset.matchId = currentMatchIdForDetails;
        document.getElementById('sub-modal-inning').value = 1;
        document.getElementById('sub-modal-top-bottom').value = '表';
        document.getElementById('sub-modal-timing-start').checked = true;
        document.getElementById('sub-modal-timing-mid').checked = false;
        document.getElementById('sub-modal-mid-inning-details').classList.add('hidden');
        document.getElementById('sub-modal-outs').value = '0';
        document.getElementById('sub-modal-runner1').checked = false;
        document.getElementById('sub-modal-runner2').checked = false;
        document.getElementById('sub-modal-runner3').checked = false;
        document.getElementById('sub-modal-new-pos').value = '';
        modal.classList.remove('hidden');
    }   

    // --- 投手追加ボタン ---
    if (e.target.matches('.add-row-btn')) {
        e.preventDefault();
        const tableId = e.target.dataset.tableId;
        const table = document.getElementById(tableId).querySelector('tbody');
        const newRow = table.insertRow();
        const throwBatOptions = [ { val: "R/R", label: "右/右" }, { val: "R/L", label: "右/左" }, { val: "R/S", label: "右/両" }, { val: "L/L", label: "左/左" }, { val: "L/R", label: "左/右" }, { val: "L/S", label: "左/両" } ];
        const throwStyleOptions = [ { val: "over", label: "オーバー" }, { val: "three_quarter", label: "スリークォーター" }, { val: "side", label: "サイド" }, { val: "under", label: "アンダー" } ];
        const pitcherTypeOptions = [ { val: "honkaku", label: "本格派" }, { val: "sokkyu", label: "速球派" }, { val: "giko", label: "技巧派" }, { val: "nanto", label: "軟投派" } ];
        const velocityOptions = [];
        for (let v = 100; v <= 165; v += 5) { velocityOptions.push({ val: `${v}km`, label: `${v}km帯` }); }
        const tbOptionsHtml = throwBatOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const styleOptionsHtml = throwStyleOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const typeOptionsHtml = pitcherTypeOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const velocityOptionsHtml = velocityOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        newRow.innerHTML = `
            <td class="col-pitcher-result"><select class="pitcher-result"><option value="" selected>-</option><option value="W">○</option><option value="L">●</option><option value="S">S</option><option value="H">H</option></select></td>
            <td class="col-pitcher-name"><input type="text" class="pitcher-name" value=""></td>
            <td class="col-pitcher-throw-bat"><select class="pitcher-throw-bat w-full bg-transparent"><option value="">-投/打-</option>${tbOptionsHtml}</select></td>
            <td class="col-pitcher-style"><select class="pitcher-throw-style w-full bg-transparent"><option value="">-投げ方-</option>${styleOptionsHtml}</select></td>
            <td class="col-pitcher-type"><select class="pitcher-type w-full bg-transparent"><option value="">-タイプ-</option>${typeOptionsHtml}</select></td>
            <td class="col-pitcher-velocity"><select class="pitcher-velocity w-full bg-transparent"><option value="">-球速帯-</option>${velocityOptionsHtml}</select></td>
            <td class="col-stat"><input type="text" class="pitcher-innings" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-batters" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-pitches" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-hits" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-so" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-walks" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-runs" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-er" value=""></td>
        `;
    }

    // --- 先攻後攻入れ替えボタン ---
    if (e.target.matches('#swap-teams-btn')) {
        swapTeamDetails(e.target.dataset.matchId);
    }

// ▼▼▼ このブロックを「新規追加」 ▼▼▼
    // --- チームステータスモーダル（簡易版）を閉じるボタン ---
    const statusModalCloseBtn = e.target.closest('#status-modal-close');
    if (statusModalCloseBtn) {
        e.preventDefault();
        document.getElementById('team-status-modal').classList.add('hidden');
    }
    // ▲▲▲ 追加ここまで ▲▲▲

    // ★★★★★ ここが修正箇所 ★★★★★
    // --- チーム名クリック（ステータス表示） ---
    // (他のボタン操作と競合しないよう、ボタン以外がクリックされたかチェック)
    else if (e.target.closest('.clickable-team-name') && !e.target.closest('button')) {
            const clickableTeamName = e.target.closest('.clickable-team-name');
            const teamName = clickableTeamName.dataset.teamName;
            
            // ★★★ 修正箇所 ★★★
                        if(teamName && teamName !== 'null' && teamName !== '') {
                // ★ matchId を渡さない
                showTeamStatusModal(teamName); 
            }
            // ★★★ 修正ここまで ★★★
        }    // ★★★★★ 修正ここまで ★★★★★

    // --- 記事表示ボタン（通常記事の「本文」） ---
    const newsArticleBtn = e.target.closest('.news-article-btn');
    if (newsArticleBtn) {
        const article = tournamentState.news[parseInt(newsArticleBtn.dataset.index, 10)];
        if (article && article.body) {
            document.getElementById('modal-title').textContent = article.title;
            document.getElementById('modal-body').textContent = article.body;
            document.getElementById('modal-meta').innerHTML = `<p>${new Date(article.timestamp).toLocaleDateString('ja-JP')}</p>`;
            newsModal.classList.remove('hidden');
            newsModal.classList.add('flex');
        } else {
            alert('記事の本文データを取得できませんでした。');
        }
    }

    // ▼▼▼ このブロックを「新規追加」(17805行目あたり) ▼▼▼
    // --- 記事表示ボタン（新聞の「新聞を読む」） ---
   else if (e.target.closest('.newspaper-view-btn')) {
        const newspaperViewBtn = e.target.closest('.newspaper-view-btn');
        const article = tournamentState.news[parseInt(newspaperViewBtn.dataset.index, 10)];
        
        if (article.isNewspaper) {
            if (article.newspaperData) {
                // --- 1. ラウンド終了時の「特集号」を開くロジック ---
                renderNewspaperModal(article.newspaperData);
                newspaperModal.classList.remove('hidden');
                
            // ★★★ ▼▼▼ 以下の else if ブロックを「新規追加」 ▼▼▼ ★★★
            } else if (article.newspaperHtml) {
                // --- 2. 「個別の試合」の新聞を開くロジック ---
                // （個別の新聞は、記事生成時にHTMLも一緒に保存されています）
                newspaperModalBody.innerHTML = article.newspaperHtml;
                newspaperModal.classList.remove('hidden');
            // ★★★ ▲▲▲ 追加ここまで ▲▲▲ ★★★
                
            } else {
                alert('新聞データの形式が正しくありません。(newspaperData も newspaperHtml も見つかりません)');
            }
        }
    }
    // ▲▲▲ 新規追加ここまで ▲▲▲

    // --- 掲示板の「返信する」ボタン ---
    const replyBtn = e.target.closest('.reply-btn');
    if (replyBtn) {
        e.preventDefault();
        const commentId = replyBtn.dataset.commentId;
        const formContainer = document.getElementById(`reply-form-container-${commentId}`);
        if (formContainer) {
            formContainer.classList.toggle('hidden');
        }
        return; 
    }
    
    // --- AI記事の再生成ボタン（エラー記事・成功記事の両方に対応） ---
    const regenerateBtn = e.target.closest('.regenerate-btn, .retry-btn');
    if (regenerateBtn) {
        const articleIndex = parseInt(regenerateBtn.dataset.index, 10);
        const originalArticle = tournamentState.news[articleIndex];
        if (!originalArticle || !originalArticle.context) {
            alert("この記事は再生成できません。");
            return;
        }
        articleForRegeneration = { index: articleIndex, article: originalArticle };
        document.getElementById('feedback-include').value = '';
        document.getElementById('feedback-exclude').value = '';
        document.getElementById('feedback-modal').classList.remove('hidden');
    }
    
    // --- フィードバックモーダルからの再生成実行ボタン ---
    const feedbackSubmitBtn = e.target.closest('#feedback-submit-btn');
    if (feedbackSubmitBtn) {
        if (!articleForRegeneration) return;
        const { index, article } = articleForRegeneration;
        const context = article.context; 
        feedbackSubmitBtn.textContent = '生成中...';
        feedbackSubmitBtn.disabled = true;
        const userFeedback = {
            include: document.getElementById('feedback-include').value,
            exclude: document.getElementById('feedback-exclude').value
        };
        document.getElementById('feedback-modal').classList.add('hidden');
        articleForRegeneration = null;
        tournamentState.news.splice(index, 1);
        renderNews(tournamentState.news);
        newsContainer.innerHTML = `<div class="loader">AI記者があなたの指示を基に記事を再執筆中です...</div>`;
        (async () => {
            let articlePromise;
            // エラー記事用のフォールバックコンテキスト
            const createErrorArticle = () => ({
                title: "記事生成エラー", body: "記事の再生成に失敗しました。",
                timestamp: Date.now(), error: true,
                errorId: context.matchId || context.errorId || `regen-error-${Date.now()}`,
                context: context // 元のコンテキストを保持
            });

            if (context.isDocumentary) {
                const { type, teamName, matchData } = context;
                articlePromise = generateDocumentaryArticle('intro', type, teamName, matchData, userFeedback);
            } else if (context.isBracketAnalysis) {
                articlePromise = generateBracketAnalysisNewsArticle(tournamentState); 
            
            // ★★★ ここからが修正箇所 ★★★
            } else if (context.isCinderellaStory) {
                // 快進撃記事の再生成
                const { loserName, loserRank, roundNum, ...restOfContext } = context;
                articlePromise = generateCinderellaArticle(loserName, loserRank, roundNum, restOfContext);
            // ★★★ 修正ここまで ★★★

            } else if (context.isHadaReport) {
                articlePromise = generateHadaReport(context, userFeedback);
            } else if (context.isTopicArticle || context.theme) {
                const rank = calculateRank(context.teamName, tournamentState); 
                articlePromise = createTopicArticle(context.teamName, rank, context.theme); 
            } else {
                // 通常記事の再生成
                articlePromise = generateNewsArticle(context, userFeedback);
            }
            
            const newArticle = await articlePromise;
            
            if (newArticle && !newArticle.error) {
                newArticle.context = context; // 元のコンテキストを保持
                tournamentState.news.splice(index, 0, newArticle);
                // ★ 快進撃記事もレビューモーダルを通さない
                if (!context.isBracketAnalysis && !context.isHadaReport && !context.isTopicArticle && !context.theme && !context.isCinderellaStory) {
                    showArticleReviewModal(newArticle);
                }
            } else {
                tournamentState.news.splice(index, 0, createErrorArticle());
            }
            saveState();
            renderNews(tournamentState.news);
            feedbackSubmitBtn.textContent = 'この指示で再生成';
            feedbackSubmitBtn.disabled = false;
        })();
    }
// ▲▲▲ 置き換えここまで ▲▲▲

    // --- 試合前 応援コメントボタン（モーダルを開くだけ） ---
    if (e.target.matches('.pre-game-cheer-btn')) {
        e.preventDefault();
        const btn = e.target;
        const matchId = btn.dataset.matchId;
        const match = findMatchById(matchId);
        if (!match || !match.team1 || !match.team2) {
            alert("対戦カードが未定のため、コメントを読み込めません。");
            return;
        }
        const modal = document.getElementById('pre-game-modal');
        const titleEl = document.getElementById('pre-game-title');
        const bodyEl = document.getElementById('pre-game-body');
        const tab1 = document.getElementById('pre-game-tab-team1');
        const tab2 = document.getElementById('pre-game-tab-team2');
        titleEl.textContent = `【${match.team1} vs ${match.team2}】試合前 応援コメント`;
        tab1.textContent = `${match.team1} 応援席`;
        tab2.textContent = `${match.team2} 応援席`;
        tab1.dataset.matchId = matchId;
        tab1.dataset.teamName = match.team1;
        tab1.dataset.opponentName = match.team2;
        tab2.dataset.matchId = matchId;
        tab2.dataset.teamName = match.team2;
        tab2.dataset.opponentName = match.team1;
        tab1.classList.remove('active', 'text-blue-600', 'border-blue-600');
        tab2.classList.remove('active', 'text-blue-600', 'border-blue-600');
        tab1.classList.add('text-gray-500', 'border-transparent');
        tab2.classList.add('text-gray-500', 'border-transparent');
        bodyEl.innerHTML = `<p class="text-gray-500 text-center p-8">↑ 見たいチームの応援席タブをクリックしてください ↑</p>`;
        modal.classList.remove('hidden');
    }

    // --- 守備交代モーダル：「キャンセル」ボタン ---
    if (e.target.matches('#sub-modal-cancel')) {
        document.getElementById('substitution-modal').classList.add('hidden');
    }

    // --- 守備交代モーダル：「交代を記録」ボタン ---
    if (e.target.matches('#sub-modal-save')) {
        const modal = document.getElementById('substitution-modal');
        const matchId = modal.dataset.matchId;
        const teamKey = modal.dataset.teamKey;
        const playerName = modal.dataset.playerName;
        const match = findMatchById(matchId);
        if (!match) {
            alert("エラー: 該当の試合が見つかりません。");
            return;
        }
        const newPos = document.getElementById('sub-modal-new-pos').value;
        if (!newPos) {
            alert("「新しい守備位置」を選択してください。");
            return;
        }
        const substitutionData = {
            playerName: playerName,
            teamKey: teamKey,
            inning: document.getElementById('sub-modal-inning').value,
            topBottom: document.getElementById('sub-modal-top-bottom').value,
            timing: document.querySelector('input[name="sub-timing"]:checked').value,
            newPos: newPos,
            outs: null,
            runners: null
        };
        if (substitutionData.timing === 'mid') {
            substitutionData.outs = document.getElementById('sub-modal-outs').value;
            substitutionData.runners = {
                r1: document.getElementById('sub-modal-runner1').checked,
                r2: document.getElementById('sub-modal-runner2').checked,
                r3: document.getElementById('sub-modal-runner3').checked
            };
        }
        if (!match.details) match.details = {};
        if (!match.details.positionChanges) match.details.positionChanges = [];
        match.details.positionChanges.push(substitutionData);
        saveState();
        alert(`${substitutionData.inning}回${substitutionData.topBottom}、${playerName}選手を${newPos}に交代しました。`);
        modal.classList.add('hidden');
    }

    // --- 【詳細モーダル内】「★ 注目」ボタン（トグル） ---
    if (e.target.matches('.mark-at-bat-btn')) {
        e.preventDefault();
        const btn = e.target;
        const isMarked = btn.dataset.marked === 'true';
        if (isMarked) {
            btn.dataset.marked = 'false';
            btn.classList.remove('bg-yellow-300', 'border-yellow-500', 'text-yellow-900');
            btn.classList.add('bg-gray-100', 'border-gray-300', 'text-gray-500', 'hover:bg-gray-200');
        } else {
            btn.dataset.marked = 'true';
            btn.classList.add('bg-yellow-300', 'border-yellow-500', 'text-yellow-900');
            btn.classList.remove('bg-gray-100', 'border-gray-300', 'text-gray-500', 'hover:bg-gray-200');
        }
    }

    // --- 応援モーダル内の「チームタブ」クリック ---
    // --- 応援モーダル内の「チームタブ」クリック ---
    if (e.target.matches('.pre-game-team-tab')) {
        e.preventDefault();
        const tabBtn = e.target;
        if (tabBtn.classList.contains('active')) return;
        
        // --- タブのUI切り替え ---
        document.querySelectorAll('.pre-game-team-tab').forEach(btn => {
            btn.classList.remove('active', 'text-blue-600', 'border-blue-600');
            btn.classList.add('text-gray-500', 'border-transparent');
        });
        tabBtn.classList.add('active', 'text-blue-600', 'border-blue-600');
        tabBtn.classList.remove('text-gray-500', 'border-transparent');
        
        // --- AIに渡すための情報収集 ---
        const teamKey = tabBtn.dataset.teamKey;
        const matchId = tabBtn.dataset.matchId;
        const teamName = tabBtn.dataset.teamName;
        const opponentName = tabBtn.dataset.opponentName;
        const bodyEl = document.getElementById('pre-game-body');
        const cacheKey = `${matchId}_${teamName}`;

        // --- キャッシュチェック ---
        if (tournamentState.preGameComments[cacheKey]) {
            bodyEl.innerHTML = tournamentState.preGameComments[cacheKey];
            return;
        }

        bodyEl.innerHTML = `<div class="loader text-center py-8">${teamName} 応援団（OB, 在校生, 地元ファン）のコメントを生成中...</div>`;

        // --- ★★★ ここからが新しいコンテキスト構築 ★★★ ---
        
        const rankValues = { 'A': 10, 'B': 8, 'C': 5, 'D': 3, 'E': 2 };
        const rank = calculateRank(teamName, tournamentState);
        const opponentRank = calculateRank(opponentName, tournamentState);
        const numComments = rankValues[rank] || 2;
        
        const teamData = TEAM_DATA[teamName] || {};
        const teamRecord = tournamentState.teamRecords[teamName];
        const match = findMatchById(matchId);

        // 1. チームの動的情報 (打率、通算盗塁、過去成績など)
        const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord);

        // 2. 注目選手情報 (静的)
        const detailedData = DETAILED_TEAM_DATA[teamName] || null;

        // 3. 今大会の勝ち上がり (試合「前」の全軌跡)
        const tournamentPath = getCurrentTournamentPerformance(teamName, matchId);

        // 4. 選手個人のGamelog (今大会の成績履歴)
        // (試合前なので、スキャン対象はチーム名だけ。AIが文中の選手名を読み取る)
        const mentionedTeams = new Set([teamName]);
        const playerGamelogs = formatPlayerGamelogsForPrompt(mentionedTeams, teamName);

        // 5. 試合情報 (球場、因縁)
        const scheduleInfo = match?.schedule 
            ? `試合会場: ${match.schedule.stadiumFull} (${match.schedule.date} ${['①', '②', '③', '④'][match.schedule.game - 1]})`
            : "試合会場: 未定";
        const rivalryInfo = (match?.rivalryType || match?.feudType)
            ? `特記事項: これは「${match.rivalryType || match.feudType}」という因縁の対決です。`
            : null;

        const context = {
            name: teamName, 
            rank: rank,
            opponent: opponentName, 
            opponentRank: opponentRank,
            round: getRoundNameFromMatchId(matchId),
            path: tournamentPath,      // ★強化 (getCurrentTournamentPerformance)
            detailed: detailedData,
            info: dynamicInfo,         // ★強化 (generateDynamicTeamInfo)
            playerGamelogs: playerGamelogs, // ★新設 (Gamelog)
            schedule: scheduleInfo,    // ★新設 (会場)
            rivalry: rivalryInfo       // ★新設 (因縁)
        };
        // --- ★★★ コンテキスト構築ここまで ★★★ ---

        const comments = await generatePreGameCheerComments(context, numComments);
        let html = '';
        comments.forEach(c => {
            html += `<div class="bbs-comment"><p class="font-semibold text-gray-700 text-sm">${c.personality}</p><p class="text-gray-800 my-1 whitespace-pre-wrap">${c.comment}</p></div>`;
        });
        bodyEl.innerHTML = html;
        tournamentState.preGameComments[cacheKey] = html; // 生成結果をキャッシュ
        saveState();
    }
// ▲▲▲ 置き換えここまで ▲▲▲

    // --- フィードバックモーダルの「キャンセル」ボタン ---
    if (e.target.matches('#feedback-cancel-btn')) {
        document.getElementById('feedback-modal').classList.add('hidden');
        articleForRegeneration = null;
    }

    // --- 掲示板コメントのエラー再生成ボタン ---
    if (e.target.matches('.retry-bbs-btn')) {
        const btn = e.target;
        const index = parseInt(btn.dataset.index, 10);
        const errorItem = tournamentState.bbsComments[index];
        const regenType = btn.dataset.type;
        if (!errorItem || !errorItem.context) {
            alert("再生成に必要な情報が見つかりません。");
            return;
        }
        btn.textContent = '生成中...';
        btn.disabled = true;
        let newBbsData = null;
        try {
            if (regenType === 'bracket-thread') {
                newBbsData = await generateBracketBbsThread(tournamentState);
            } else if (regenType === 'match-comments' && errorItem.context.matchId) {
                if (errorItem.context.winnerName && errorItem.context.dbMatch) {
                     newBbsData = await generateBbsComments(errorItem.context);
                } else {
                    throw new Error("試合後コメント再生成のためのContext情報が不足しています。");
                }
            } else {
                 throw new Error("不明な再生成タイプです: " + regenType);
            }
            if (newBbsData && !newBbsData.error) {
                if (Array.isArray(newBbsData)) {
                    tournamentState.bbsComments.splice(index, 1, ...newBbsData);
                } else {
                    tournamentState.bbsComments.splice(index, 1, newBbsData);
                }
            } else {
                 alert('再生成に失敗しました。');
                 btn.textContent = '再生成';
                 btn.disabled = false;
            }
        } catch(err) {
             console.error("BBS再生成中にエラー:", err);
             alert('再生成処理中にエラーが発生しました。');
             btn.textContent = '再生成';
             btn.disabled = false;
        }
        renderBbsComments(tournamentState.bbsComments);
        saveState();
    }
});
    

// <script>タグの、他のイベントリスナーの近くに追加

document.body.addEventListener('change', (e) => {
    if (e.target.matches('#toggle-article-generation')) {
        tournamentState.settings.enableArticleGeneration = e.target.checked;
        saveState();
    }
    if (e.target.matches('#toggle-bbs-generation')) {
        tournamentState.settings.enableBbsGeneration = e.target.checked;
        saveState();
    }
// ▼▼▼ この else if ブロックをまるごと追加 ▼▼▼
    // --- 守備交代モーダルのラジオボタン ---
    else if (e.target.name === 'sub-timing') {
        const detailsDiv = document.getElementById('sub-modal-mid-inning-details');
        if (e.target.value === 'mid') {
            detailsDiv.classList.remove('hidden');
        } else {
            detailsDiv.classList.add('hidden');
        }
    }
    // ▲▲▲ 追加ここまで ▲▲▲

});

   // ==========================================================
//  2.「送信」イベントを処理するリスナー (新設)
// ==========================================================
document.body.addEventListener('submit', async (e) => {
    
    // --- 掲示板の「返信フォーム」が送信された場合 ---
    if (e.target.matches('.reply-form')) {
        e.preventDefault();
        const form = e.target;
        const parentCommentId = form.dataset.commentId;
        const bbsType = form.dataset.bbsType;
        const textarea = form.querySelector('textarea');
        const userReplyText = textarea.value;

        if (!userReplyText.trim()) return;

        form.innerHTML = `<div class="loader text-xs">AIが返信を考えています...</div>`;
        
        const commentSource = bbsType === 'general' ? tournamentState.bbsComments : tournamentState.daiyaBbsComments;
        const parentComment = findCommentById(commentSource, parentCommentId);
        const aiPersona = parentComment.personality;
        const context = { tournamentSummary: getTournamentStatusSummary() };
        
        const aiReply = await generateBbsReply(parentCommentId, userReplyText, bbsType, aiPersona, context);

        if (aiReply) {
            const freshParentComment = findCommentById(commentSource, parentCommentId);
            if (freshParentComment) {
                if (!freshParentComment.replies) {
                    freshParentComment.replies = [];
                }
                freshParentComment.replies.push(aiReply);
            }
            if (bbsType === 'general') renderBbsComments(tournamentState.bbsComments);
            else renderDaiyaBbsComments(tournamentState.daiyaBbsComments);
            saveState();
        } else {
            form.innerHTML = `<textarea class="w-full p-2 border rounded text-sm" placeholder="返信を入力..." required></textarea><button type="submit" class="mt-1 bg-blue-500 text-white px-3 py-1 text-xs rounded hover:bg-blue-600">送信</button>`;
            alert("AIが返信を生成できませんでした。");
        }
    } 
    // --- メインのコメント投稿フォームが送信された場合 ---
    else if (e.target.matches('#main-comment-form')) {
        e.preventDefault();
        const textarea = document.getElementById('main-comment-textarea');
        const userCommentText = textarea.value;
        if (!userCommentText.trim()) return;

        textarea.disabled = true;
        e.target.querySelector('button').disabled = true;
        e.target.querySelector('button').textContent = 'AIが返信中...';

        const userComment = {
            id: crypto.randomUUID(),
            personality: 'あなた',
            text: userCommentText,
            timestamp: Date.now(),
            replies: []
        };
        
        const aiReplies = await generateMultipleReplies(userCommentText);
        userComment.replies = aiReplies;

        tournamentState.bbsComments.push(userComment);
        renderBbsComments(tournamentState.bbsComments);
        saveState();

        textarea.value = '';
        textarea.disabled = false;
        e.target.querySelector('button').disabled = false;
        e.target.querySelector('button').textContent = '投稿する';
    }

}); // ★★★ 閉じカッコ } の正しい位置はここです ★★★

// --- 編集モーダルの「この記事で確定」ボタン ---
    document.getElementById('review-save-btn').addEventListener('click', () => {
        if (articleForReview) {
            // テキストボックスの現在の内容で記事データを更新
            articleForReview.title = document.getElementById('review-title').value;
            articleForReview.body = document.getElementById('review-body').value.replace(/\n/g, '\\n');
            
            // 更新した記事をニュースリストに追加
            tournamentState.news.push(articleForReview);
            renderNews(tournamentState.news);
            saveState();
            
            closeReviewModal();
        }
    });

    // --- 編集モーダルの「キャンセル」ボタン ---
    document.getElementById('review-cancel-btn').addEventListener('click', () => {
        closeReviewModal();
    });

document.body.addEventListener('input', (e) => {
        if (e.target.matches('.match-summary-input')) {
            const matchId = e.target.dataset.matchId;
            let match;
            if (tournamentState.matches[matchId]) {
                match = tournamentState.matches[matchId];
            } else {
                 const [region, bracketId] = matchId.split('-');
                 if (tournamentState.autumnData?.regions[region]) {
                    const regionData = tournamentState.autumnData.regions[region];
                    if(bracketId.startsWith('B')) match = regionData.blocks.find(b=>b.id === `${region}-${bracketId}`).matches[matchId];
                    else if(bracketId === 'CHAMP') match = regionData.champBracket.matches[matchId];
                    else if(bracketId === 'REP') match = regionData.repechageBracket.matches[matchId];
                 }
            }
            if (match) {
                match.summary = e.target.value;
                saveState();
            }
        }

// ▼▼▼ この else if ブロックをまるごと追加 ▼▼▼
    // --- 試合前の雰囲気/公約 ---
    else if (e.target.matches('.team-atmosphere-input')) {
        const matchId = e.target.dataset.matchId;
        const teamKey = e.target.dataset.teamKey; // 'team1' or 'team2'
        const match = findMatchById(matchId);

        if (match) {
            // 'atmosphere_team1' または 'atmosphere_team2' というキーで保存
            match[`atmosphere_${teamKey}`] = e.target.value;
            saveState(); // 入力するたびに自動保存
        }
    }
    // ▲▲▲ 追加ここまで ▲▲▲

// --- ★ 283学園の選手名自動入力 (＆ 調子アイコンの動的更新) ---
        else if (e.target.matches('.player-name')) {
            const input = e.target;
            const playerName = input.value.trim();
            const row = input.closest('tr');
            const table = input.closest('.batting-table');
            if (!row || !table || !currentMatchIdForDetails) return;

            const match = findMatchById(currentMatchIdForDetails);
            if (!match) return;

            const teamKey = table.id.includes('team1') ? 'team1' : 'team2';
            const teamName = match[teamKey];
            
            // --- 1. 選手名簿(Roster)からの自動入力 (283学園など) ---
            const roster = TEAM_ROSTER_MASTER[teamName];
            if (roster) {
                const playerData = roster.find(p => p.name === playerName);
                if (playerData) {
                    const numberSelect = row.querySelector('.player-number');
                    const throwBatSelect = row.querySelector('.player-throw-bat');
                    if (numberSelect) numberSelect.value = playerData.number;
                    if (throwBatSelect) throwBatSelect.value = playerData.throwBat;
                }
            }

            // --- 2. 調子アイコンの動的更新 (全チーム共通) ---
            const teamRecord = tournamentState.teamRecords[teamName];
            let conditionIconHTML = ""; // デフォルトは空
            
            if (playerName && teamRecord?.playerStats?.batting[playerName]) {
                // 打撃の調子を取得
                const flag = teamRecord.playerStats.batting[playerName].narrative_flag;
                conditionIconHTML = getPlayerConditionIcon(flag);
            } else if (playerName && teamRecord?.playerStats?.pitching[playerName]) {
                // 投手（野手で打席に立ってない場合）の調子を取得
                const flag = teamRecord.playerStats.pitching[playerName].narrative_flag;
                conditionIconHTML = getPlayerConditionIcon(flag);
            }

            // 3. アイコンをHTMLに挿入/置換
            const container = input.parentElement;
            let iconSpan = container.querySelector('.condition-icon');
            
            if (conditionIconHTML) { // 新しいアイコンがある場合
                if (iconSpan) {
                    // 既存のアイコンを置き換え
                    iconSpan.outerHTML = conditionIconHTML;
                } else {
                    // 新しくアイコンを挿入 (📊ボタンの前に)
                    const statsBtn = container.querySelector('.show-player-stats-btn');
                    if (statsBtn) {
                        statsBtn.insertAdjacentHTML('beforebegin', conditionIconHTML);
                    }
                }
            } else if (iconSpan) {
                // 新しいアイコンがなく、古いアイコンが残っている場合は削除
                iconSpan.remove();
            }
        }
// ▲▲▲ 置き換えここまで ▲▲▲


// イニングスコアが入力された場合
    else if (e.target.closest('#inning-score-table')) {
        updateTotalScores();
    }


    
// ▼▼▼ THIS IS THE NEW BLOCK TO ADD ▼▼▼
    // --- When an "Inning Event" is typed in ---
    else if (e.target.matches('.inning-events-input')) {
        const teamKey = e.target.dataset.teamKey;
        const inningIndex = parseInt(e.target.dataset.inningIndex, 10);
        if (inningIndex >= 0) {
            updateInningState(teamKey, inningIndex); // Instantly update the out count
        }
    }
    // ▲▲▲ END OF ADDITION ▲▲▲
});
// ==========================================================
//  プルダウン変更イベントの監視 (change)
// ==========================================================
document.body.addEventListener('change', (e) => {
    // --- 打席結果プルダウンが変更された場合 ---
    if (e.target.matches('.batting-result-part')) {
        const cell = e.target.closest('td.batting-result-cell');
        if (!cell) return;
        
        const inningIndex = Array.from(cell.parentElement.children).indexOf(cell) - 5;
        const teamKey = e.target.closest('table.batting-table').id.includes('team1') ? 'team1' : 'team2';
        
        if (inningIndex >= 0) {
            updateInningState(teamKey, inningIndex); // 即座にアウトカウントを更新
        }
    }
});

    modalBg.addEventListener('click', () => newsModal.classList.add('hidden'));
    modalClose.addEventListener('click', () => newsModal.classList.add('hidden'));
    document.getElementById('details-save').addEventListener('click', saveDetailedStats);
    document.getElementById('details-close').addEventListener('click', () => detailsModal.classList.add('hidden'));
    saveLoadCloseBtn.addEventListener('click', () => saveLoadModal.classList.add('hidden'));
    newspaperCloseBtn.addEventListener('click', () => newspaperModal.classList.add('hidden'));
// ▼▼▼ この2行を 10953行目 の直後に追加 ▼▼▼
    const preGameModalClose = document.getElementById('pre-game-modal-close');
    if (preGameModalClose) preGameModalClose.addEventListener('click', () => document.getElementById('pre-game-modal').classList.add('hidden'));
    // ▲▲▲ 追加ここまで ▲▲▲
document.getElementById('status-modal-close').addEventListener('click', () => {
    document.getElementById('team-status-modal').classList.add('hidden');
});

    saveTabBtn.addEventListener('click', () => {
        saveTabBtn.classList.add('border-blue-500'); saveTabBtn.classList.remove('text-gray-500');
        loadTabBtn.classList.remove('border-blue-500'); loadTabBtn.classList.add('text-gray-500');
        saveTabContent.classList.remove('hidden'); loadTabContent.classList.add('hidden');
    });
    loadTabBtn.addEventListener('click', () => {
        loadTabBtn.classList.add('border-blue-500'); loadTabBtn.classList.remove('text-gray-500');
        saveTabBtn.classList.remove('border-blue-500'); saveTabBtn.classList.add('text-gray-500');
        loadTabContent.classList.remove('hidden'); saveTabContent.classList.add('hidden');
    });
    generateSaveCodeBtn.addEventListener('click', () => {
        const jsonString = JSON.stringify(tournamentState);
        const compressed = pako.deflate(jsonString);
        const base64 = uint8ArrayToBase64(compressed);
        document.getElementById('save-code-output').textContent = base64;
        document.getElementById('save-code-area').classList.remove('hidden');
    });
    copySaveCodeBtn.addEventListener('click', () => {
        navigator.clipboard.writeText(document.getElementById('save-code-output').textContent);
        const feedback = document.getElementById('copy-feedback');
        feedback.textContent = 'コピーしました！';
        setTimeout(() => { feedback.textContent = '' }, 2000);
    });
    loadFromCodeBtn.addEventListener('click', () => {
        try {
            const code = document.getElementById('load-code-input').value;
            const binaryString = atob(code);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) { bytes[i] = binaryString.charCodeAt(i); }
            const decompressed = pako.inflate(bytes, { to: 'string' });
            const loadedState = JSON.parse(decompressed);
            tournamentState = loadedState;
            saveState();
            location.reload();
        } catch (e) {
            showAlert('データの読み込みに失敗しました。');
        }
    });

let activeScorecardState = {};

/**
 * 簡易入力モーダルを開き、状態を初期化する
 * (★打球方向・打点・走塁入力ステップを追加)
 */
async function openScorecardModal(matchId) {
    const match = findMatchById(matchId);
    if (!match || !match.team1 || !match.team2) {
        alert("チームが設定されていません。");
        return;
    }

    // 1. 状態(State)の初期化
    activeScorecardState = {
        matchId: matchId,
        team1: match.team1,
        team2: match.team2,
        inning: 1,      // 現在のイニング (1始まり)
        topBottom: '表', // '表' or '裏'
        outs: 0,
        score: { team1: 0, team2: 0 },
        runners: [null, null, null], // [1B, 2B, 3B] (中身は選手名)
        battingOrder: { team1: [], team2: [] },
        batterIndex: { team1: 0, team2: 0 },
        playLog: [], // { teamKey, batterName, resultString, ... }
        
        // ★★★ ここからが修正箇所 ★★★
        currentStep: "waiting_for_result", // "waiting_for_result", "waiting_for_direction", "waiting_for_rbi", "waiting_for_runner_sb", "waiting_for_runner_cs"
        pendingPlay: { // ユーザーの入力を一時的に保持
            type: null,    // "安", "ゴロ", "三振" など
            bases: 0,    // 1, 2, 3, 4
            outs: 0,
            walk: false,
            direction: null, // "遊", "中", "投"
            rbi: 0       // 0, 1, 2, 3, 4
        }
        // ★★★ 修正ここまで ★★★
    };

    // 2. 両チームの打順を取得
    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const roster = TEAM_ROSTER_MASTER[teamName];
        if (roster) {
            activeScorecardState.battingOrder[teamKey] = roster.slice(0, 9).map(p => p.name);
        } else {
            // 2-2. 他チームなら仮の名前を9人分作成
            activeScorecardState.battingOrder[teamKey] = Array.from({length: 9}, (_, i) => `${teamName.slice(0, 3)} ${i+1}番`);
        }
    }

    // 3. モーダルを表示
    document.getElementById('scorecard-modal').classList.remove('hidden');
    document.getElementById('scorecard-modal').classList.add('flex');
    
    // 4. UIを初期状態に描画
    renderScorecard();
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 簡易入力モーダルのUIを、現在の `activeScorecardState` に基づいて更新する
 * (★全入力ステップの表示切り替えを追加)
 */
function renderScorecard() {
    const state = activeScorecardState;
    
    // 1. ヘッダー
    document.getElementById('scorecard-inning').textContent = `${state.inning}回${state.topBottom}`;
    document.getElementById('scorecard-team1').textContent = `${state.team1}: ${state.score.team1}`;
    document.getElementById('scorecard-team2').textContent = `${state.team2}: ${state.score.team2}`;
    
    // 2. アウトカウント
    const outsEl = document.getElementById('scorecard-outs');
    outsEl.innerHTML = `
        <span class="${state.outs >= 1 ? 'text-red-500' : 'text-gray-400'}">●</span>
        <span class="${state.outs >= 2 ? 'text-red-500' : 'text-gray-400'}">●</span>
        <span class="${state.outs >= 3 ? 'text-red-500' : 'text-gray-400'}">●</span>
    `;

    // 3. ランナー
    document.getElementById('base-1b').classList.toggle('runner', !!state.runners[0]);
    document.getElementById('base-2b').classList.toggle('runner', !!state.runners[1]);
    document.getElementById('base-3b').classList.toggle('runner', !!state.runners[2]);

    // ★★★ ここからが修正箇所 ★★★
    // 4. 現在の打者 と 入力ステップ
    const currentTeamKey = state.topBottom === '表' ? 'team1' : 'team2';
    const currentBatterIndex = state.batterIndex[currentTeamKey];
    const currentBatterName = state.battingOrder[currentTeamKey][currentBatterIndex];
    const batterNameEl = document.getElementById('scorecard-batter-name');
    const diamondEl = document.querySelector('.baseball-diamond');
    const resultPanel = document.getElementById('scorecard-result-panel');
    const rbiPanel = document.getElementById('scorecard-rbi-panel');

    // 全ての特殊モードをリセット
    diamondEl.classList.remove('direction-mode', 'runner-select-mode');
    resultPanel.classList.add('hidden');
    rbiPanel.classList.add('hidden');

    if (state.currentStep === "waiting_for_direction") {
        batterNameEl.textContent = `(${currentBatterIndex + 1}) ${currentBatterName} - STEP 2: 打球方向を選択`;
        diamondEl.classList.add('direction-mode'); // ホットスポット表示
    } else if (state.currentStep === "waiting_for_rbi") {
        batterNameEl.textContent = `(${currentBatterIndex + 1}) ${currentBatterName} - STEP 3: 打点 / アウト`;
        rbiPanel.classList.remove('hidden'); // RBIボタン表示
    } else if (state.currentStep === "waiting_for_runner_sb") {
        batterNameEl.textContent = `[走塁] 盗塁したランナーを選択...`;
        diamondEl.classList.add('runner-select-mode'); // ランナー点滅
    } else if (state.currentStep === "waiting_for_runner_cs") {
        batterNameEl.textContent = `[走塁] 盗塁死したランナーを選択...`;
        diamondEl.classList.add('runner-select-mode');
    } else if (state.currentStep === "waiting_for_runner_out") {
        batterNameEl.textContent = `[走塁] 走塁死したランナーを選択...`;
        diamondEl.classList.add('runner-select-mode');
    } else {
        // (C) "waiting_for_result"
        batterNameEl.textContent = `(${currentBatterIndex + 1}) ${currentBatterName} - STEP 1: 打席結果を選択`;
        resultPanel.classList.remove('hidden'); // 結果ボタン表示
    }
    // ★★★ 修正ここまで ★★★

    // 5. ログ
    const logContent = document.getElementById('scorecard-log-content');
    logContent.innerHTML = state.playLog.map(log => 
        `[${log.inning}${log.topBottom}] ${log.batterName}: ${log.resultString} (${log.outs}アウト)`
    ).join('<br>');
    logContent.scrollTop = logContent.scrollHeight;
}
// ▲▲▲ 置き換えここまで ▲▲▲


// ▼▼▼ 既存の「handleScorecardAction」と「saveScorecardAndClose」 (18510行目〜) を、
// ▼▼▼ 以下の3つの関数で「まるごと置き換え」 ▼▼▼

// ▼▼▼ 既存の「handleScorecardAction」と「processPlay」 (18510行目〜) を、
// ▼▼▼ 以下の2つの関数で「まるごと置き換え」 ▼▼▼

// ▼▼▼ 既存の「handleScorecardAction」と「processPlay」 (18510行目〜) を、
// ▼▼▼ 以下の2つの関数で「まるごと置き換え」 ▼▼▼

/**
 * [改修] 簡易入力モーダルの「結果」ボタンクリックを処理する
 * (★併殺・犠打・犠飛をSTEP 1に統合)
 * @param {string} action - 'hit-1b', 'out-dp', 'run-sb' など
 */
function handleScorecardAction(action) {
    const state = activeScorecardState;
    if (state.outs >= 3) return; // 3アウトなら操作不可

    // --- A. 打席結果の入力 ---
    if (state.currentStep === "waiting_for_result" && action.startsWith('run-') === false) {
        state.pendingPlay = { type: null, bases: 0, outs: 0, walk: false, direction: null, rbi: 0 };
        let needsDirection = true;
        let nextStep = "waiting_for_direction"; // デフォルトは方向入力

        switch (action) {
            // ヒット系
            case 'hit-1b': state.pendingPlay.type = '安'; state.pendingPlay.bases = 1; break;
            case 'hit-2b': state.pendingPlay.type = '二塁打'; state.pendingPlay.bases = 2; break;
            case 'hit-3b': state.pendingPlay.type = '三塁打'; state.pendingPlay.bases = 3; break;
            case 'hit-hr': state.pendingPlay.type = '本塁打'; state.pendingPlay.bases = 4; needsDirection = false; nextStep = "waiting_for_rbi"; break;
            // 四死球
            case 'walk-bb': state.pendingPlay.type = '四球'; state.pendingPlay.bases = 1; state.pendingPlay.walk = true; needsDirection = false; nextStep = "waiting_for_rbi"; break;
            case 'walk-hbp': state.pendingPlay.type = '死球'; state.pendingPlay.bases = 1; state.pendingPlay.walk = true; needsDirection = false; nextStep = "waiting_for_rbi"; break;
            // アウト系
            case 'out-k': state.pendingPlay.type = '三振'; state.pendingPlay.outs = 1; needsDirection = false; nextStep = "process_play"; break; // ★打点なし・方向なし
            case 'out-go': state.pendingPlay.type = 'ゴロ'; state.pendingPlay.outs = 1; break;
            case 'out-fo': state.pendingPlay.type = '飛'; state.pendingPlay.outs = 1; break;
            // ★★★ 修正箇所 ★★★
            case 'out-dp': state.pendingPlay.type = '併殺'; state.pendingPlay.outs = 2; break; // ★STEP 2 (方向) -> STEP 3 (打点/0点) へ
            case 'out-sac-b': state.pendingPlay.type = '犠打'; state.pendingPlay.outs = 1; break; // ★STEP 2 (方向) -> STEP 3 (打点/0点) へ
            case 'out-sac-f': state.pendingPlay.type = '犠飛'; state.pendingPlay.outs = 1; break; // ★STEP 2 (方向) -> STEP 3 (打点/1点) へ
            // ★★★ 修正ここまで ★★★
            // その他
            case 'other-error': state.pendingPlay.type = 'エラー'; state.pendingPlay.bases = 1; break;
            case 'other-fc': state.pendingPlay.type = '野選'; state.pendingPlay.bases = 1; break;
            
            default: return;
        }

        // 2. 次のステップを判断
        if (nextStep === "process_play") {
            // 三振など、即時処理
            state.pendingPlay.direction = "投"; // 仮の方向
            processPlay();
        } else if (needsDirection) {
            state.currentStep = "waiting_for_direction";
        } else {
            state.pendingPlay.direction = "投"; // 仮の方向
            state.currentStep = "waiting_for_rbi";
        }
    }
    // --- B. 走塁プレーの入力 ---
    else if (state.currentStep === "waiting_for_result" && action.startsWith('run-')) {
        if (action === 'run-sb') { // 盗塁
            if (state.runners[0] === null && state.runners[1] === null) { alert("盗塁できるランナーがいません。"); return; }
            state.currentStep = "waiting_for_runner_sb";
        }
        else if (action === 'run-cs') { // 盗塁死
            if (state.runners[0] === null && state.runners[1] === null) { alert("盗塁できるランナーがいません。"); return; }
            state.currentStep = "waiting_for_runner_cs";
        }
        else if (action === 'run-other-out') { // 走塁死
            if (state.runners.every(r => r === null)) { alert("ランナーがいません。"); return; }
            state.currentStep = "waiting_for_runner_out";
        }
    }
    
    renderScorecard(); // UIを更新
}

/**
 * [改修] プレーを確定し、ゲームステートを更新する
 * (★併殺・犠飛・犠打の打点ロジックを修正)
 */
function processPlay() {
    const state = activeScorecardState;
    if (!state.pendingPlay.type) return;

    let { type, bases, outs, walk, direction, rbi } = state.pendingPlay;
    const currentTeamKey = state.topBottom === '表' ? 'team1' : 'team2';
    const currentBatterIndex = state.batterIndex[currentTeamKey];
    const currentBatterName = state.battingOrder[currentTeamKey][currentBatterIndex];

    // ★★★ 1. 打点入力による最終決定 ★★★
    if (state.currentStep === "waiting_for_rbi") {
        rbi = parseInt(rbi, 10);
    }
    // ★★★ 修正ここまで ★★★

    // 2. アウトカウントを加算
    state.outs += outs;

    // 3. ランナーを進塁
    let scoreThisPlay = 0;
    const newRunners = [null, null, null];
    
    if (bases === 4) { // ホームラン
        if (state.runners[2]) scoreThisPlay++;
        if (state.runners[1]) scoreThisPlay++;
        if (state.runners[0]) scoreThisPlay++;
        state.runners = [null, null, null];
        scoreThisPlay += 1; // 打者生還
    } else if (walk) { // 四死球
        if (state.runners[0] && state.runners[1] && state.runners[2]) { // 押し出し
            scoreThisPlay = (rbi > 0 ? rbi : 1);
        } else {
            if (state.runners[0] && state.runners[1]) newRunners[2] = state.runners[1];
            if (state.runners[0]) newRunners[1] = state.runners[0];
            newRunners[0] = currentBatterName;
        }
    } else if (bases > 0) { // ヒット、エラー、野選
        scoreThisPlay = rbi;
        if (state.runners[0]) newRunners[bases] = state.runners[0];
        newRunners[bases - 1] = currentBatterName;
    } else if (type === '犠飛' || type === 'ゴロ' || type === '併殺') {
        scoreThisPlay = rbi;
        if (rbi > 0 && state.runners[2]) state.runners[2] = null;
    } else if (type === '犠打') {
        if (state.runners[1]) newRunners[2] = state.runners[1];
        if (state.runners[0]) newRunners[1] = state.runners[0];
    }
    
    state.runners = newRunners;
    state.score[currentTeamKey] += scoreThisPlay;

    // 4. ログ（詳細入力フォーマット）を生成
    let resultString = direction ? direction + type : type;
    if (scoreThisPlay > 0 && type !== '本塁打') {
        resultString += `${scoreThisPlay}点`;
    } else if (type === '本塁打' && scoreThisPlay > 0) {
         resultString += `${scoreThisPlay}点`;
    }

    state.playLog.push({
        inning: state.inning,
        topBottom: state.topBottom,
        batterName: currentBatterName,
        batterOrder: (currentBatterIndex + 1).toString(),
        resultString: resultString,
        outs: state.outs
    });

    // 5. 次の打者へ
    state.batterIndex[currentTeamKey] = (currentBatterIndex + 1) % state.battingOrder[currentTeamKey].length;

    // 6. 3アウトになったか？
    if (state.outs >= 3) {
        if (state.topBottom === '表') {
            state.topBottom = '裏';
        } else {
            state.topBottom = '表';
            state.inning++;
        }
        state.outs = 0;
        state.runners = [null, null, null];
    }
    
    // 7. 状態をリセット
    state.currentStep = "waiting_for_result";
    state.pendingPlay = {};
    
    // 8. UIを再描画
    renderScorecard();
}
// ▲▲▲ 置き換えここまで ▲▲▲
// ▼▼▼ 既存の「saveScorecardAndClose」 (18610行目〜) を、以下で「置き換え」 ▼▼▼

/**
 * [改修] 簡易入力のデータを「詳細入力」の形式に変換して保存する
 * (★併殺・犠打・犠飛の文字列も保存)
 */
function saveScorecardAndClose() {
    const state = activeScorecardState;
    const match = findMatchById(state.matchId);
    if (!match) return;

    // 1. 新しい `details` オブジェクトを準備
    const numInnings = Math.max(9, state.inning);
    const details = { 
        inningScore: { team1: Array(numInnings).fill(0), team2: Array(numInnings).fill(0) }, 
        batting: { team1: [], team2: [] }, 
        pitching: { team1: [], team2: [] }, 
        fielding: { team1: [], team2: [] },
        playerGameStats: { team1: {}, team2: {} },
        positionChanges: []
    };

    // 2. 打順リストを details.batting に変換
    for (const teamKey of ['team1', 'team2']) {
        details.batting[teamKey] = state.battingOrder[teamKey].map((name, index) => ({
            order: (index + 1).toString(),
            name: name,
            number: '', pos: '', throwBat: '', sub_type: null,
            results: Array(numInnings).fill('') // 全イニング分の空スロット
        }));
    }

    // 3. プレーログ(playLog)をスキャンし、イニングスコアと打席結果(results)を埋める
    state.playLog.forEach(log => {
        // 走塁プレー（batterOrder: '-'）は打席結果に含めない
        if (log.batterOrder === '-') return; 

        const inningIndex = log.inning - 1;
        const teamKey = log.topBottom === '表' ? 'team1' : 'team2';
        
        // 3-1. イニングスコア
        const rbiMatch = log.resultString.match(/(\d+)点/);
        if (rbiMatch) {
            details.inningScore[teamKey][inningIndex] += parseInt(rbiMatch[1], 10);
        } else if (log.resultString.includes('本塁打')) {
            // ソロホームラン（1点）
            details.inningScore[teamKey][inningIndex] += 1;
        }

        // 3-2. 打席結果文字列
        const batter = details.batting[teamKey].find(p => p.order === log.batterOrder);
        if (batter) {
            // (1イニング複数打席に対応)
            if (batter.results[inningIndex]) {
                batter.results[inningIndex] += `、${log.resultString}`;
            } else {
                batter.results[inningIndex] = log.resultString;
            }
        }
    });

    // 4. `match.details` を上書き
    match.details = details;
    
    // 5. saveDetailedStats を呼び出して、通算成績とボックススコアHTMLを生成させる
    saveDetailedStats(); // これが最終的な保存と集計を行う

    // 6. モーダルを閉じる
    document.getElementById('scorecard-modal').classList.add('hidden');
    document.getElementById('scorecard-modal').classList.remove('flex');
    activeScorecardState = {}; // 状態をリセット
}
// ▲▲▲ 置き換えここまで ▲▲▲
    // アプリケーション起動
    initializeApp();
</script>

<script>
    mermaid.initialize({ startOnLoad: true });
</script>




<div id="homepage-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[200]">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-6xl max-h-[95vh] flex flex-col">
        <div class="flex-shrink-0 flex justify-between items-center border-b p-4 bg-gray-50 rounded-t-lg">
            <h3 class="text-xl font-bold text-blue-700">283学園 高等学校 - 硬式野球部</h3>
            <button id="homepage-modal-close" class="text-gray-500 hover:text-gray-700 text-3xl">&times;</button>
        </div>
        
        <div id="homepage-scroll-container" class="flex-grow overflow-y-auto" style="font-family: 'Noto Sans JP', sans-serif; background-color: #f4f7fa;">
            
            <header class="bg-white shadow-sm sticky top-0 z-50">
                <div class="container mx-auto px-4 sm:px-6 py-3 md:py-4">
                    <div class="flex justify-between items-center">
                        <div>
                            <a href="#" class="text-2xl md:text-3xl font-extrabold text-gray-900 flex items-center">
                                <svg class="h-8 w-8 md:h-10 md:w-10 mr-2 text-blue-700" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path></svg>
                                <span class="text-blue-700">283</span>学園
                            </a>
                        </div>
                        
                        <nav class="hidden md:flex space-x-4 lg:space-x-6 text-sm lg:text-base">
                            <a href="#about" class="nav-link text-gray-600 hover:text-blue-700 font-medium pb-1">野球部について</a>
                            <a href="#players" class="nav-link text-gray-600 hover:text-blue-700 font-medium pb-1">選手紹介</a>
                            <a href="#roster" class="nav-link text-gray-600 hover:text-blue-700 font-medium pb-1">部員紹介</a>
                            <a href="#facility" class="nav-link text-gray-600 hover:text-blue-700 font-medium pb-1">施設紹介</a>
                            <a href="#school-song" class="nav-link text-gray-600 hover:text-blue-700 font-medium pb-1">校歌</a>
                            <a href="#results" class="nav-link text-gray-600 hover:text-blue-700 font-medium pb-1">戦績</a>
                            <a href="#gallery" class="nav-link text-gray-600 hover:text-blue-700 font-medium pb-1">ギャラリー</a>
                            <a href="#access" class="nav-link text-gray-600 hover:text-blue-700 font-medium pb-1">アクセス</a>
                        </nav>

                        <div class="md:hidden">
                            <button id="mobile-menu-button" class="text-gray-500 hover:text-blue-700 focus:outline-none p-2">
                                <svg class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>

                <div id="mobile-menu" class="hidden md:hidden bg-gray-50 border-t border-gray-200 absolute w-full shadow-lg">
                    <div class="flex flex-col px-4 py-2 space-y-1">
                        <a href="#about" class="mobile-nav-link block py-3 px-2 text-gray-700 font-medium hover:bg-blue-50 hover:text-blue-700 border-b border-gray-200">野球部について</a>
                        <a href="#players" class="mobile-nav-link block py-3 px-2 text-gray-700 font-medium hover:bg-blue-50 hover:text-blue-700 border-b border-gray-200">選手紹介</a>
                        <a href="#roster" class="mobile-nav-link block py-3 px-2 text-gray-700 font-medium hover:bg-blue-50 hover:text-blue-700 border-b border-gray-200">部員紹介</a>
                        <a href="#facility" class="mobile-nav-link block py-3 px-2 text-gray-700 font-medium hover:bg-blue-50 hover:text-blue-700 border-b border-gray-200">施設紹介</a>
                        <a href="#school-song" class="mobile-nav-link block py-3 px-2 text-gray-700 font-medium hover:bg-blue-50 hover:text-blue-700 border-b border-gray-200">校歌</a>
                        <a href="#results" class="mobile-nav-link block py-3 px-2 text-gray-700 font-medium hover:bg-blue-50 hover:text-blue-700 border-b border-gray-200">戦績</a>
                        <a href="#gallery" class="mobile-nav-link block py-3 px-2 text-gray-700 font-medium hover:bg-blue-50 hover:text-blue-700 border-b border-gray-200">ギャラリー</a>
                        <a href="#access" class="mobile-nav-link block py-3 px-2 text-gray-700 font-medium hover:bg-blue-50 hover:text-blue-700">アクセス</a>
                    </div>
                </div>
            </header>
            <section class="hero-bg text-white py-40 px-6">
                <div class="container mx-auto text-center">
                    <h1 class="slogan tracking-wider animate-fade-in-down">強</h1>
                    <p class="text-xl sm:text-3xl font-light mt-4 max-w-3xl mx-auto text-shadow-lg animate-fade-in-up">
                        個の技量に頼らず、一人ひとりの力を集めて戦う。
                    </p>
                </div>
            </section>

            <div class="container mx-auto px-4 sm:px-6 py-20">
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-12">

                    <main class="lg:col-span-2 space-y-20">

                        <section id="about" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-6">野球部について</h2>
                            <span class="inline-block bg-blue-700 text-white text-sm font-bold px-4 py-1 rounded-full mb-6">昨年度県大会王者・第1シード</span>
                            <div class="space-y-5 text-gray-700 leading-relaxed text-base">
                                <p>昨年度、創部まもなくして夏の県大会初優勝を果たし、第1シード校として今大会に臨みます。しかし、初出場となった昨夏の甲子園では初戦（対 浦和学院 7-9）で敗退。全国の舞台での「一勝」の重みを痛感しました。</p>
                                <p>名将・天井努監督の下、昨年の経験を糧に「県大会連覇」と、その先の「甲子園での一勝」を揺るぎない目標として掲げています。王者としてのプレッシャーをはねのけ、チームスローガンである<strong class="font-bold text-blue-700">『強』</strong>を体現します。</p>
                            </div>
                            <div class="mt-10 bg-gray-50 p-6 rounded-lg border border-gray-200">
                                <h4 class="text-xl font-bold text-gray-800 mb-3">監督・部長あいさつ</h4>
                                <div class="flex items-start space-x-4">
                                    <div class="flex-shrink-0 w-24 h-24 bg-gray-300 rounded-md flex items-center justify-center text-gray-500 text-xs">[監督イメージ]</div>
                                    <div>
                                        <p class="text-gray-700 italic">「我々の強みは、守備の一体感と打線のつながりです。姫川、白瀬を中心とした投手リレーは全国でもピカイチと自負しています。個の力に頼らず、全員の力を集めて『強い』チームとして戦います。」</p>
                                        <p class="text-right font-bold text-gray-800 mt-3">- 283学園野球部 監督　天井 努</p>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <section id="philosophy" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">指導方針・練習内容</h2>
                            <div class="space-y-6 text-gray-700 leading-relaxed">
                                <div>
                                    <h4 class="text-xl font-bold text-blue-700 mb-2">1. ID野球とデータ解析</h4>
                                    <p>天井監督の指導の下、全試合・全練習を映像データ化。専属アナリストが常駐する「データ解析室」にて、選手のフォーム、打球傾向、投球の回転数に至るまでを徹底的に分析。科学的根拠に基づいた「ID野球」がチームの基盤です。</p>
                                </div>
                                <div>
                                    <h4 class="text-xl font-bold text-blue-700 mb-2">2. 「二軍」制度の導入（283学園B）</h4>
                                    <p>部員数100名超に対応するため、他校にはない「二軍（283学園B）」制度を導入。七草はづきコーチの指導の下、Bチームも独自の練習試合を重ね、Aチームと常に入れ替え戦を行う環境を整備。この熾烈な内部競争が、王者としての層の厚さを生み出しています。</p>
                                </div>
                            </div>
                        </section>

                        <section id="players" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">注目選手</h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div class="player-card border p-5 rounded-lg bg-gray-50"><div class="flex justify-between items-baseline"><h5 class="text-xl font-bold text-blue-700">姫川 (3年・投手)</h5><span class="text-xs font-medium bg-red-100 text-red-800 px-2 py-0.5 rounded-full">プロ注目</span></div><p class="text-gray-700 mt-2">投打の中心。MAX151kmの直球とスプリットで圧倒する怪物。高校通算42本塁打。</p></div>
                                <div class="player-card border p-5 rounded-lg bg-gray-50"><h5 class="text-xl font-bold text-blue-700">白瀬 (3年・投手)</h5><p class="text-gray-700 mt-2">絶対的守護神。MAX155kmの伸び上がるストレートが武器。春の静岡高戦で完全試合を達成。</p></div>
                                <div class="player-card border p-5 rounded-lg bg-white"><h5 class="text-xl font-bold text-gray-800">花海 咲 (3年・中堅手)</h5><p class="text-gray-700 mt-2">1年夏からレギュラーの経験豊富なスラッガー。走攻守三拍子揃った攻守の要。</p></div>
                                <div class="player-card border p-5 rounded-lg bg-blue-50 border-blue-200"><div class="flex justify-between items-baseline"><h5 class="text-xl font-bold text-blue-700">花海 佑 (1年・右翼手)</h5><span class="text-xs font-medium bg-blue-100 text-blue-800 px-2 py-0.5 rounded-full">1年生</span></div><p class="text-gray-700 mt-2">1年生のスーパースター。兄・咲との連携も抜群。入学以来、既に通算13本塁打を記録。</p></div>
                            </div>
                        </section>

                        <section id="roster" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">部員紹介 (2025年度 夏)</h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">1</span>
                                        <span class="player-profile-name">白瀬</span>
                                        <span class="player-profile-grade">3年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[投]</strong> <strong>[右投/右打]</strong><br>
                                        184cm / 82kg<br>
                                        出身: 東京シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">2</span>
                                        <span class="player-profile-name">有栖川</span>
                                        <span class="player-profile-grade">3年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[捕]</strong> <strong>[右投/左打]</strong><br>
                                        178cm / 78kg<br>
                                        出身: 神奈川ボーイズ
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">3</span>
                                        <span class="player-profile-name">姫川</span>
                                        <span class="player-profile-grade">3年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[投/一]</strong> <strong>[右投/右打]</strong><br>
                                        182cm / 80kg<br>
                                        出身: 大阪シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">4</span>
                                        <span class="player-profile-name">樋口</span>
                                        <span class="player-profile-grade">3年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[二]</strong> <strong>[右投/右打]</strong><br>
                                        170cm / 68kg<br>
                                        出身: 静岡葵中学
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">5</span>
                                        <span class="player-profile-name">八宮</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[三]</strong> <strong>[右投/右打]</strong><br>
                                        175cm / 72kg<br>
                                        出身: 浜松ボーイズ
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">6</span>
                                        <span class="player-profile-name">十王</span>
                                        <span class="player-profile-grade">3年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[遊]</strong> <strong>[右投/左打]</strong><br>
                                        176cm / 70kg<br>
                                        出身: 名古屋ドリームス
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">7</span>
                                        <span class="player-profile-name">芹沢</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[外]</strong> <strong>[右投/両打]</strong><br>
                                        172cm / 69kg<br>
                                        出身: 沼津シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">8</span>
                                        <span class="player-profile-name">花海佑</span>
                                        <span class="player-profile-grade">1年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[外]</strong> <strong>[右投/右打]</strong><br>
                                        177cm / 73kg<br>
                                        出身: 北海道シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">9</span>
                                        <span class="player-profile-name">花海咲</span>
                                        <span class="player-profile-grade">3年<span class="player-profile-captain">(主将)</span></span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[外]</strong> <strong>[左投/左打]</strong><br>
                                        178cm / 75kg<br>
                                        出身: 北海道シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">10</span>
                                        <span class="player-profile-name">黛</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[投]</strong> <strong>[右投/右打]</strong><br>
                                        180cm / 76kg<br>
                                        出身: 富士シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">11</span>
                                        <span class="player-profile-name">市川</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[投]</strong> <strong>[左投/左打]</strong><br>
                                        179cm / 74kg<br>
                                        出身: 静岡蒲原中学
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">12</span>
                                        <span class="player-profile-name">福丸</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[捕]</strong> <strong>[右投/右打]</strong><br>
                                        176cm / 77kg<br>
                                        出身: 焼津リトルシニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">13</span>
                                        <span class="player-profile-name">鈴木</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[一]</strong> <strong>[右投/左打]</strong><br>
                                        181cm / 85kg<br>
                                        出身: 愛知ボーイズ
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">14</span>
                                        <span class="player-profile-name">有村</span>
                                        <span class="player-profile-grade">1年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[内]</strong> <strong>[右投/右打]</strong><br>
                                        173cm / 67kg<br>
                                        出身: 福岡シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">15</span>
                                        <span class="player-profile-name">田中</span>
                                        <span class="player-profile-grade">3年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[内]</strong> <strong>[右投/右打]</strong><br>
                                        174cm / 70kg<br>
                                        出身: 静岡服織中学
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">16</span>
                                        <span class="player-profile-name">大崎</span>
                                        <span class="player-profile-grade">1年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[外]</strong> <strong>[右投/左打]</strong><br>
                                        170cm / 68kg<br>
                                        出身: 三島リトルシニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">17</span>
                                        <span class="player-profile-name">風野</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[内]</strong> <strong>[右投/右打]</strong><br>
                                        169cm / 65kg<br>
                                        出身: 新潟シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">18</span>
                                        <span class="player-profile-name">西城</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[投]</strong> <strong>[右投/右打]</strong><br>
                                        183cm / 81kg<br>
                                        出身: 広島ボーイズ
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">19</span>
                                        <span class="player-profile-name">浅倉</span>
                                        <span class="player-profile-grade">1年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[内]</strong> <strong>[右投/右打]</strong><br>
                                        168cm / 64kg<br>
                                        出身: 長崎シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">20</span>
                                        <span class="player-profile-name">杜野</span>
                                        <span class="player-profile-grade">1年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[外]</strong> <strong>[左投/左打]</strong><br>
                                        171cm / 67kg<br>
                                        出身: 宮城シニア
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                       <section id="facility" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">施設紹介</h2>
                            <p class="text-gray-700 leading-relaxed mb-6">ナムコグループの全面的な支援により、本校は全国トップクラスの練習環境を誇ります。マップ上の「<span class="font-bold text-blue-700">+</span>」アイコンをクリックして、各施設をご覧ください。</p>
                            
                            <div id="campus-map-container">
                                <img id="campus-map-image" src="https://img.freepik.com/premium-vector/university-campus-map-vector-illustration_147933-461.jpg" alt="283学園 キャンパスマップ">

                                <div class="hotspot" style="top: 60%; left: 25%;" data-id="ground"><span>+</span></div>
                                <div class="hotspot" style="top: 35%; left: 45%;" data-id="dome"><span>+</span></div>
                                <div class="hotspot" style="top: 20%; left: 70%;" data-id="data-lab"><span>+</span></div>
                                
                                <div id="hotspot-popup" class="hotspot-popup hidden">
                                    <button id="hotspot-popup-close-btn" class="hotspot-popup-close">&times;</button>
                                    <img id="hotspot-popup-image" src="" alt="施設写真" class="hotspot-popup-image">
                                    <div class="hotspot-popup-content">
                                        <h4 id="hotspot-popup-title" class="hotspot-popup-title"></h4>
                                        <p id="hotspot-popup-text" class="hotspot-popup-text"></p>
                                    </div>
                                </div>
                            </div>
                        </section>                        
                        <section id="school-song" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">283学園 校歌</h2>
                            <div class="text-center max-w-lg mx-auto">
                                <p class="text-sm text-gray-600">作詞: 天井 努　/　作曲: 283学園音楽科</p>
                                <div class="mt-6"><p class="text-lg leading-relaxed text-gray-800">一、<br>蒼き空 仰ぎ見る<br>我らが学び舎 283学園<br>若き翼（つばさ） 胸に抱き<br>未来（あす）へと羽ばたく 強い意志<br>ああ 輝ける光よ 我らにあれ</p></div>
                                <div class="mt-8"><p class="text-lg leading-relaxed text-gray-800">二、<br>遠州の風 受けながら<br>真理（まこと）を求めん 友と共に<br>鍛えし知恵 磨きし技<br>『強』なる理想を 追い求めて<br>ああ 誇り高き 我らが 283学園</p></div>
                            </div>
                        </section>

                        <section id="results" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">2025年 選手権静岡大会 (最新の戦績)</h2>
                            <p class="text-gray-700 leading-relaxed mb-6">
                                現在進行中、または終了した最新の大会の戦績です。試合が終了すると、このトーナメント表も更新されます。
                            </p>
                            <div id="current-tournament-bracket-container" class="bracket-wrapper">
                                <p class="text-center text-gray-500">（現在のトーナメント表を読み込み中...）</p>
                            </div>
                            
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8 mt-12">2024年 選手権静岡大会 (昨年度)</h2>
                            
                            <p class="text-gray-700 leading-relaxed mb-6">
                                姫川(2年)、花海咲(2年)ら、現3年生が中心となり、創部以来初の「夏の甲子園」出場を果たした大会の全軌跡です。
                            </p>
                            <div class="bracket-wrapper">
                                <div class="tournament-container">
                                    <div class="bracket-half left">
                                        <div class="round r1">
                                            <div class="round-title">1回戦</div>
                                            <div class="matchup"><div class="match"><div class="team winner hp-team-283"><span class="name">283学園</span><span class="score">20</span></div><div class="team loser"><span class="name">新居</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">浜松開誠館</span><span class="score">7</span></div><div class="team loser"><span class="name">初星学園</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">聖隷クリストファー</span><span class="score">10</span></div><div class="team loser"><span class="name">浜松特支</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">日大三島</span><span class="score">8</span></div><div class="team loser"><span class="name">裾野</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">掛川西</span><span class="score">5</span></div><div class="team loser"><span class="name">富士宮北</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">東海大翔洋</span><span class="score">6</span></div><div class="team loser"><span class="name">美城学園</span><span class="score">2</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">藤枝明誠</span><span class="score">11</span></div><div class="team loser"><span class="name">沼津高専</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡学園</span><span class="score">9</span></div><div class="team loser"><span class="name">三島南</span><span class="score">2</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">浜松市立</span><span class="score">7</span></div><div class="team loser"><span class="name">御殿場南</span><span class="score">6</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">磐田東</span><span class="score">4</span></div><div class="team loser"><span class="name">浜松学院</span><span class="score">3</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">焼津水産</span><span class="score">5</span></div><div class="team loser"><span class="name">御殿場西</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">科学技術</span><span class="score">8</span></div><div class="team loser"><span class="name">誠恵</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡</span><span class="score">8</span></div><div class="team loser"><span class="name">小山</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">知徳</span><span class="score">5</span></div><div class="team loser"><span class="name">虎府島総合</span><span class="score">4</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静清</span><span class="score">10</span></div><div class="team loser"><span class="name">富士東</span><span class="score">9</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner hp-team-283"><span>283学園B</span><span class="score">5</span></div><div class="team loser"><span class="name">伊豆伊東</span><span class="score">3</span></div></div></div>
                                        </div>
                                        <div class="round r2">
                                            <div class="round-title">2回戦</div>
                                            <div class="matchup"><div class="match"><div class="team winner hp-team-283"><span class="name">283学園</span><span class="score">11</span></div><div class="team loser"><span class="name">浜松開誠館</span><span class="score">1</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">聖隷クリストファー</span><span class="score">5</span></div><div class="team loser"><span class="name">日大三島</span><span class="score">3</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">掛川西</span><span class="score">4</span></div><div class="team loser"><span class="name">東海大翔洋</span><span class="score">0</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">藤枝明誠</span><span class="score">6</span></div><div class="team loser"><span class="name">静岡学園</span><span class="score">4</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">磐田東</span><span class="score">7</span></div><div class="team loser"><span class="name">浜松市立</span><span class="score">3</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">科学技術</span><span class="score">5</span></div><div class="team loser"><span class="name">焼津水産</span><span class="score">2</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡</span><span class="score">7</span></div><div class="team loser"><span class="name">知徳</span><span class="score">0</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span>静清</span><span class="score">7</span></div><div class="team loser hp-team-283"><span class="name">283学園B</span><span class="score">0</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                        </div>
                                        <div class="round r3">
                                            <div class="round-title">3回戦</div>
                                            <div class="matchup"><div class="match"><div class="team winner hp-team-283"><span class="name">283学園</span><span class="score">10</span></div><div class="team loser"><span class="name">聖隷クリストファー</span><span class="score">2</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">藤枝明誠</span><span class="score">5</span></div><div class="team loser"><span class="name">掛川西</span><span class="score">1</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">科学技術</span><span class="score">3</span></div><div class="team loser"><span class="name">磐田東</span><span class="score">2</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡</span><span class="score">4</span></div><div class="team loser"><span class="name">静清</span><span class="score">3</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                        </div>
                                        <div class="round r4">
                                            <div class="round-title">準々決勝</div>
                                            <div class="matchup"><div class="match"><div class="team winner hp-team-283"><span class="name">283学園</span><span class="score">8</span></div><div class="team loser"><span class="name">藤枝明誠</span><span class="score">3</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡</span><span class="score">7</span></div><div class="team loser"><span class="name">科学技術</span><span class="score">0</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                        </div>
                                        <div class="round r5">
                                            <div class="round-title">準決勝</div>
                                            <div class="matchup"><div class="match"><div class="team winner hp-team-283"><span class="name">283学園</span><span class="score">6</span></div><div class="team loser"><span class="name">静岡</span><span class="score">1</span></div></div><div class="connector-line"></div></div>
                                        </div>
                                    </div>
                                    <div class="bracket-final">
                                        <div class="round-title">決勝</div>
                                        <div class="final-matchup">
                                            <div class="match">
                                                <div class="team winner hp-team-283"><span class="name">283学園</span><span class="score">5</span></div>
                                                <div class="team loser"><span class="name">常葉菊川</span><span class="score">2</span></div>
                                            </div>
                                            <button id="show-boxscore-btn-2024" class="mt-2 w-full text-sm bg-blue-600 text-white font-bold px-4 py-2 rounded hover:bg-blue-700 transition-all">
                                                決勝戦ボックススコア
                                            </button>
                                            </div>
                                        <div class="winner-box">
                                            <h2>🏆 優勝 283学園</h2>
                                        </div>
                                    </div>
                                    <div class="bracket-half right">
                                        <div class="round r1">
                                            <div class="round-title">1回戦</div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span>常葉菊川</span><span class="score">15</span></div><div class="team loser"><span class="name">川根</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">浜松工業</span><span class="score">6</span></div><div class="team loser"><span class="name">島田工業</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">765総合高校</span><span class="score">8</span></div><div class="team loser"><span class="name">袋井</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">常葉橘</span><span class="score">10</span></div><div class="team loser"><span class="name">桐陽</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">駿河総合</span><span class="score">7</span></div><div class="team loser"><span class="name">飛龍</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">加藤学園</span><span class="score">11</span></div><div class="team loser"><span class="name">磐田南</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">伊豆総合</span><span class="score">5</span></div><div class="team loser"><span class="name">富士宮西</span><span class="score">4</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">韮山</span><span class="score">6</span></div><div class="team loser"><span class="name">市立沼津</span><span class="score">3</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">三島北</span><span class="score">10</span></div><div class="team loser"><span class="name">湖西</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">富士市立</span><span class="score">7</span></div><div class="team loser"><span class="name">熱海</span><span class="score">1B</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">オイスカ浜松国際</span><span class="score">4</span></div><div class="team loser"><span class="name">静岡市立</span><span class="score">3</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">浜松商業</span><span class="score">9</span></div><div class="team loser"><span class="name">城南静岡</span><span class="score">2</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡商業</span><span class="score">7</span></div><div class="team loser"><span class="name">浜松南</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">島田</span><span class="score">4</span></div><div class="team loser"><span class="name">伊豆中央</span><span class="score">2</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">沼津城北</span><span class="score">8</span></div><div class="team loser"><span class="name">浜松城北工業</span><span class="score">7</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">天竜</span><span class="score">5</span></div><div class="team loser"><span class="name">下田</span><span class="score">0</span></div></div></div>
                                        </div>
                                        <div class="round r2">
                                            <div class="round-title">2回戦</div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">常葉菊川</span><span class="score">9</span></div><div class="team loser"><span class="name">浜松工業</span><span class="score">0</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span>常葉橘</span><span class="score">4</span></div><div class="team loser"><span class="name">765総合高校</span><span class="score">3</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">駿河総合</span><span class="score">5</span></div><div class="team loser"><span class="name">加藤学園</span><span class="score">4</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">韮山</span><span class="score">8</span></div><div class="team loser"><span class="name">伊豆総合</span><span class="score">1B</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">三島北</span><span class="score">8</span></div><div class="team loser"><span class="name">富士市立</span><span class="score">1G</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">浜松商業</span><span class="score">6</span></div><div class="team loser"><span class="name">オイスカ浜松国際</span><span class="score">5</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡商業</span><span class="score">10</span></div><div class="team loser"><span class="name">島田</span><span class="score">0</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">天竜</span><span class="score">4</span></div><div class="team loser"><span class="name">沼津城北</span><span class="score">0</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                        </div>
                                        <div class="round r3">
                                            <div class="round-title">3回戦</div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">常葉菊川</span><span class="score">7</span></div><div class="team loser"><span class="name">常葉橘</span><span class="score">0</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span>韮山</span><span class="score">5</span></div><div class="team loser"><span class="name">駿河総合</span><span class="score">2</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">三島北</span><span class="score">2</span></div><div class="team loser"><span class="name">浜松商業</span><span class="score">0</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡商業</span><span class="score">6</span></div><div class="team loser"><span class="name">天竜</span><span class="score">1</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                        </div>
                                        <div class="round r4">
                                            <div class="round-title">準々決勝</div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">常葉菊川</span><span class="score">7</span></div><div class="team loser"><span class="name">韮山</span><span class="score">1</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡商業</span><span class="score">3</span></div><div class="team loser"><span class="name">三島北</span><span class="score">0</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                        </div>
                                        <div class="round r5">
                                            <div class="round-title">準決勝</div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">常葉菊川</span><span class="score">4</span></div><div class_name="name">静岡商業</span><span class="score">3</span></div></div><div class="connector-line"></div></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="space-y-6 mt-12">
                            <div><h3 class="text-xl font-bold text-gray-800">2023年（2年生）</h3><hr class="my-2"><p class="text-sm text-gray-600">秋季静岡大会 優勝 / 選手権静岡大会 決勝敗退 (対 765総合 2-3) / 春季静岡大会 決勝敗退 (対 加藤学園 1-2)</p></div>
                            <div><h3 class="text-xl font-bold text-gray-800">2022年（1年生）</h3><hr class="my-2"><p class="text-sm text-gray-600">秋季静岡大会 準決勝敗退 / 選手権静岡大会 準決勝敗退</p></div>
                            <div><h3 class="text-xl font-bold text-gray-800">2021年（創部2年目）</h3><hr class="my-2"><p class="text-sm text-gray-600">秋季静岡大会 準々決勝敗退 / 選手権静岡大会 4回戦敗退</p></div>
                            <div><h3 class="text-xl font-bold text-gray-800">2020年（創部1年目）</h3><hr class="my-2"><p class="text-sm text-gray-600">秋季静岡大会 2回戦敗退 / 選手権静岡大会 2回戦敗退</p></div>
                        </div>
                    </section>

                    <section id="ob-career" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                        <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">OBの主な進路 (架空)</h2>
                        <p class="text-gray-700 leading-relaxed mb-6">創部まもないながら、卒業生は野球を継続する道を選んでいます。2025年春、初の卒業生（創部3年目に入学した世代）が新たなステージへと羽ばたきました。</p>
                        <div class="overflow-x-auto"><table class="w-full min-w-[600px] text-left text-sm"><thead class="bg-gray-100"><tr><th class="px-4 py-3 font-semibold">選手名 (ダミー)</th><th class="px-4 py-3 font-semibold">卒業年度</th><th class="px-4 py-3 font-semibold">ポジション</th><th class="px-4 py-3 font-semibold">主な進路</th></tr></thead><tbody class="divide-y divide-gray-200"><tr class="hover:bg-gray-50"><td class="px-4 py-3 font-medium">高山 翼</td><td class="px-4 py-3">2025年3月卒 (3期生)</td><td class="px-4 py-3">投手</td><td class="px-4 py-3 font-semibold">東京六大学リーグ (進学)</td></tr><tr class="hover:bg-gray-50"><td class="px-4 py-3 font-medium">早川 瞬</td><td class="px-4 py-3">2025年3月卒 (3期生)</td><td class="px-4 py-3">内野手</td><td class="px-4 py-3 font-semibold">社会人野球 (ナムコグループ)</td></tr><tr class="hover:bg-gray-50"><td class="px-4 py-3 font-medium">伊集院 北斗</td><td class="px-4 py-3">2024年3月卒 (2期生)</td><td class="px-4 py-3">外野手</td><td class="px-4 py-3 font-semibold">東都大学リーグ (進学)</td></tr><tr class="hover:bg-gray-50"><td class="px-4 py-3 font-medium">天ヶ瀬 冬馬</td><td class="px-4 py-3">2023年3月卒 (1期生)</td><td class="px-4 py-3">捕手</td><td class="px-4 py-3 font-semibold">独立リーグ (中退)</td></tr></tbody></table></div>
                    </section>

                    <section id="gallery" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                        <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">ギャラリー</h2>
                        <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                            <a href="https://source.unsplash.com/random/1200x800/?baseball,victory" target="_blank" class="gallery-image aspect-video rounded-lg overflow-hidden shadow-md"><img src="https://source.unsplash.com/random/800x600/?baseball,victory" alt="昨夏 優勝の瞬間" class="w-full h-full object-cover"></a>
                            <a href="https://source.unsplash.com/random/1200x800/?baseball,pitcher" target="_blank" class="gallery-image aspect-video rounded-lg overflow-hidden shadow-md"><img src="https://source.unsplash.com/random/800x600/?baseball,pitcher" alt="姫川の投球フォーム" class="w-full h-full object-cover"></a>
                            <a href="https://source.unsplash.com/random/1200x800/?baseball,stadium" target="_blank" class="gallery-image aspect-video rounded-lg overflow-hidden shadow-md"><img src="https://source.unsplash.com/random/800x600/?baseball,stadium" alt="甲子園での試合風景" class="w-full h-full object-cover"></a>
                            <a href="https://source.unsplash.com/random/1200x800/?baseball,batter" target="_blank" class="gallery-image aspect-video rounded-lg overflow-hidden shadow-md"><img src="https://source.unsplash.com/random/800x600/?baseball,batter" alt="花海佑のバッティング" class="w-full h-full object-cover"></a>
                            <a href="https://source.unsplash.com/random/1200x800/?baseball,practice" target="_blank" class="gallery-image aspect-video rounded-lg overflow-hidden shadow-md"><img src="https://source.unsplash.com/random/800x600/?baseball,practice" alt="室内練習場での打撃練習" class="w-full h-full object-cover"></a>
                            <a href="https://source.unsplash.com/random/1200x800/?baseball,team" target="_blank" class="gallery-image aspect-video rounded-lg overflow-hidden shadow-md"><img src="https://source.unsplash.com/random/800x600/?baseball,team" alt="チーム全員での円陣" class="w-full h-full object-cover"></a>
                        </div>
                    </section>

                    <section id="access" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                        <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">アクセス</h2>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                            <div><img src="https://source.unsplash.com/random/800x600/?map" alt="地図" class="w-full h-64 object-cover rounded-lg"></div>
                            <div class="text-gray-700">
                                <h4 class="text-lg font-semibold mb-2">283学園 高等学校</h4>
                                <p class="mb-4">〒430-XXXX 静岡県浜松市（ダミー住所）</p>
                                <h5 class="font-semibold mb-1">電車でお越しの場合</h5>
                                <p class="mb-4">JR「浜松駅」よりバスで約20分、「283学園前」下車すぐ。</p>
                                <h5 class="font-semibold mb-1">お車でお越しの場合</h5>
                                <p>東名高速道路「浜松IC」より約15分。<br>(※来客用駐車場には限りがございます)</p>
                            </div>
                        </div>
                    </section>

                </main>

                <aside id="news" class="lg:col-span-1">
                    <div class="bg-white p-6 rounded-xl shadow-xl sticky top-24">
                        <h3 class="text-xl font-bold text-blue-800 section-title mb-6">お知らせ</h3>
                        
                        <ul id="homepage-dynamic-news-list" class="space-y-4 mb-6 border-b pb-4 hidden">
                            </ul>
                        
                        <ul class="space-y-4">
                            <li><span class="text-sm text-gray-500">2025/11/10</span><p class="font-semibold text-gray-800 hover:text-blue-600 cursor-pointer">文化祭「283フェスティバル」開催のお知らせ</p></li>
                            <li><span class="text-sm text-gray-500">2025/11/05</span><p class="font-semibold text-gray-800 hover:text-blue-600 cursor-pointer">【野球部】夏の選手権大会 組み合わせ決定</p></li>
                            <li><span class="text-sm text-gray-500">2025/11/01</span><p class="font-semibold text-gray-800 hover:text-blue-600 cursor-pointer">【野球部】春季大会優勝、第1シード決定！</p></li>
                            <li><span class="text-sm text-gray-500">2025/10/28</span><p class="font-semibold text-gray-800 hover:text-blue-600 cursor-pointer">【野球部】1年生・花海佑 練習試合で2HR</p></li>
                            <li><span class="text-sm text-gray-500">2025/10/20</span><p class="font-semibold text-gray-800 hover:text-blue-600 cursor-pointer">オープンキャンパスの申し込みを開始しました。</p></li>
                        </ul>
                    </div>
                </aside>

            </div>
        </div>

        <footer class="bg-gray-900 text-gray-400 py-16 mt-16">
            <div class="container mx-auto px-6 text-center">
                <p class="font-bold text-2xl text-white">283学園 高等学校</p>
                <p class="text-sm mt-3">〒430-XXXX 静岡県浜松市（ダミー住所）</p>
                <p class="text-sm mt-1">TEL: 053-XXX-XXXX / FAX: 053-XXX-XXXX</p>
                <div class="mt-8 border-t border-gray-700 pt-8">
                     <p class="text-xs">Powered by Namco Group</p>
                    <p class="text-xs mt-1">&copy; 2025 Tsubasa Gakuen High School. All rights reserved.</p>
                </div>
            </div>
        </footer>
        
    </div>
</div>
</div>

<div id="boxscore-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 modal-hidden items-center justify-center z-[160]">
    <div class="bg-white p-4 md:p-6 rounded-lg shadow-xl w-full max-w-6xl max-h-[95vh] flex flex-col">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 id="boxscore-modal-title" class="text-xl font-bold text-gray-800">ボックススコア</h3>
            <button id="boxscore-modal-close" class="text-gray-400 hover:text-gray-600">&times;</button>
        </div>
        <div id="boxscore-modal-body" class="overflow-y-auto flex-grow">
            <div class="loader text-center py-16">ボックススコアを読み込み中...</div>
        </div>
    </div>
</div>

<div id="scorecard-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[180]">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-6xl max-h-[95vh] flex flex-col">
        
        <div id="scorecard-header" class="flex-shrink-0 flex justify-between items-center border-b p-3 md:p-4 bg-gray-800 text-white rounded-t-lg">
            <div class="flex items-center">
                <span id="scorecard-inning" class="text-xl md:text-3xl font-bold mr-3">1回表</span>
                <span id="scorecard-at-bat" class="text-sm md:text-lg">
                    打者: <span id="scorecard-batter-name" class="font-semibold">---</span>
                </span>
            </div>
            <div class="flex items-center space-x-3 md:space-x-4">
                <div id="scorecard-outs" class="text-lg md:text-xl font-semibold">
                    <span class="text-gray-400">●</span> <span class="text-gray-400">●</span> <span class="text-gray-400">●</span>
                </div>
                <div id="scorecard-teams" class="text-right">
                    <div id="scorecard-team1" class="text-sm md:text-base font-semibold">TEAM A: 0</div>
                    <div id="scorecard-team2" class="text-sm md:text-base font-semibold">TEAM B: 0</div>
                </div>
            </div>
        </div>

        <div class="scorecard-grid flex-grow overflow-y-auto bg-gray-100">

            <div id="baseball-diamond-container" class="flex items-center justify-center p-4">
                <div class="baseball-diamond">
                    <div id="base-1b" class="base"></div>
                    <div id="base-2b" class="base"></div>
                    <div id="base-3b" class="base"></div>
                    <div id="base-home" class="base"></div>
                    <div id="pitchers-mound"></div>
                    
                    <div id="pos-p" class="direction-hotspot" data-direction="投">投</div>
                    <div id="pos-c" class="direction-hotspot" data-direction="捕">捕</div>
                    <div id="pos-1b" class="direction-hotspot" data-direction="一">一</div>
                    <div id="pos-2b" class="direction-hotspot" data-direction="二">二</div>
                    <div id="pos-3b" class="direction-hotspot" data-direction="三">三</div>
                    <div id="pos-ss" class="direction-hotspot" data-direction="遊">遊</div>
                    <div id="pos-lf" class="direction-hotspot" data-direction="左">左</div>
                    <div id="pos-cf" class="direction-hotspot" data-direction="中">中</div>
                    <div id="pos-rf" class="direction-hotspot" data-direction="右">右</div>
                </div>
            </div>

           <div id="scorecard-actions" class="p-2 md:p-4">
                
                <div id="scorecard-result-panel">
                    <h4 class="font-bold mb-2 text-gray-700">STEP 1: 打席結果</h4>
                    <div class="grid grid-cols-3 gap-2">
                        <button class="result-btn result-btn-hit" data-action="hit-1b">[ 1B ] ヒット</button>
                        <button class="result-btn result-btn-hit" data-action="hit-2b">[ 2B ] 二塁打</button>
                        <button class="result-btn result-btn-hit" data-action="hit-3b">[ 3B ] 三塁打</button>
                        <button class="result-btn result-btn-hit" data-action="hit-hr">[ HR ] 本塁打</button>
                        <button class="result-btn result-btn-walk" data-action="walk-bb">[ BB ] 四球</button>
                        <button class="result-btn result-btn-walk" data-action="walk-hbp">[ HBP ] 死球</button>
                        <button class="result-btn result-btn-out" data-action="out-k">[ K ] 三振</button>
                        <button class="result-btn result-btn-out" data-action="out-go">[ GO ] ゴロ</button>
                        <button class="result-btn result-btn-out" data-action="out-fo">[ FO ] フライ</button>
                        <button class="result-btn result-btn-out" data-action="out-dp">[ DP ] 併殺</button>
                        <button class="result-btn result-btn-out" data-action="out-sac-b">[ SH ] 犠打</button>
                        <button class="result-btn result-btn-out" data-action="out-sac-f">[ SF ] 犠飛</button>
                        <button class="result-btn result-btn-other" data-action="other-error">[ E ] エラー</button>
                        <button class="result-btn result-btn-other" data-action="other-fc">[ FC ] 野選</button>
                    </div>
                </div>

                <div id="scorecard-rbi-panel" class="hidden">
                    <h4 class="font-bold mb-2 text-green-700">STEP 3: 打点/得点</h4>
                    <div class="grid grid-cols-3 gap-2">
                        <button class="rbi-btn" data-rbi="0">[ 0点 ]</button>
                        <button class="rbi-btn" data-rbi="1">[ 1点 ]</button>
                        <button class="rbi-btn" data-rbi="2">[ 2点 ]</button>
                        <button class="rbi-btn" data-rbi="3">[ 3点 ]</button>
                        <button class="rbi-btn" data-rbi="4">[ 4点 ]</button>
                    </div>
                </div>

                <h4 class="font-bold mt-4 mb-2 text-gray-700">走塁・その他</h4>
                <div class="grid grid-cols-3 gap-2">
                    <button class="result-btn result-btn-hit" data-action="run-sb">[ SB ] 盗塁</button>
                    <button class="result-btn result-btn-out" data-action="run-cs">[ CS ] 盗塁死</button>
                    <button class="result-btn result-btn-out" data-action="run-other-out">[ OUT ] 走塁死</button>
                </div>
            </div>

            <div id="scorecard-log" class="p-2 md:p-4">
                <h4 class="font-bold mb-2 text-gray-700">簡易ログ</h4>
                <div id="scorecard-log-content" class="h-24 md:h-full w-full bg-gray-200 rounded p-2 text-xs overflow-y-auto font-mono">
                    (ここにプレーが記録されます)
                </div>
            </div>

        </div>

        <div class="flex-shrink-0 flex justify-between items-center border-t p-4 bg-gray-50 rounded-b-lg">
            <button id="scorecard-undo-btn" class="bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600">
                1プレー戻す
            </button>
            <div>
                <button id="scorecard-save-btn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 mr-4">
                    保存して閉じる
                </button>
                <button id="scorecard-close-btn" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-400">
                    キャンセル
                </button>
            </div>
        </div>
    </div>
</div>

<div id="pre-game-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden flex items-center justify-center z-[200]">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h3 id="pre-game-title" class="text-xl font-bold">試合前 応援コメント</h3>
                <button id="pre-game-modal-close" class="text-gray-400 hover:text-gray-600">&times;</button>
            </div>
            
            <div class="flex border-b mb-4">
                <button id="pre-game-tab-team1" class="pre-game-team-tab py-2 px-4 font-semibold text-gray-500 border-b-2 border-transparent" data-team-key="team1">
                    （チーム1）
                </button>
                <button id="pre-game-tab-team2" class="pre-game-team-tab py-2 px-4 font-semibold text-gray-500 border-b-2 border-transparent" data-team-key="team2">
                    （チーム2）
                </button>
            </div>
            <div id="pre-game-body" class="overflow-y-auto space-y-3 p-2 bg-gray-50 rounded min-h-[200px]">
                <p class="text-gray-500 text-center p-8">↑ 見たいチームの応援席タブをクリックしてください ↑</p>
            </div>
        </div>
    </div>

<div id="substitution-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[150]">

    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg">
        <h3 class="text-xl font-bold mb-4 border-b pb-3">守備交代</h3>
        <div class="space-y-4">
            <div>
                <label class="block text-sm font-medium text-gray-700">選手名</label>
                <input type="text" id="sub-modal-player-name" class="w-full bg-gray-100 p-2 border rounded" readonly>
            </div>
            
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label for="sub-modal-inning" class="block text-sm font-medium text-gray-700">イニング</label>
                    <input type="number" id="sub-modal-inning" value="1" min="1" max="20" class="w-full p-2 border rounded">
                </div>
                <div>
                    <label for="sub-modal-top-bottom" class="block text-sm font-medium text-gray-700">表 / 裏</label>
                    <select id="sub-modal-top-bottom" class="w-full p-2 border rounded bg-white">
                        <option value="表">表</option>
                        <option value="裏">裏</option>
                    </select>
                </div>
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-700">交代タイミング</label>
                <div class="flex gap-4 mt-1">
                    <label><input type="radio" name="sub-timing" id="sub-modal-timing-start" value="start" checked> イニング開始時</label>
                    <label><input type="radio" name="sub-timing" id="sub-modal-timing-mid" value="mid"> イニング途中</label>
                </div>
            </div>

            <div id="sub-modal-mid-inning-details" class="hidden space-y-3 p-3 bg-gray-50 rounded border">
                <div>
                    <label for="sub-modal-outs" class="block text-sm font-medium text-gray-700">アウトカウント</label>
                    <select id="sub-modal-outs" class="w-full p-2 border rounded bg-white">
                        <option value="0">0アウト</option>
                        <option value="1">1アウト</option>
                        <option value="2">2アウト</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">ランナー状況</label>
                    <div class="flex gap-4 mt-1">
                        <label><input type="checkbox" id="sub-modal-runner1"> 1塁</label>
                        <label><input type="checkbox" id="sub-modal-runner2"> 2塁</label>
                        <label><input type="checkbox" id="sub-modal-runner3"> 3塁</label>
                    </div>
                </div>
            </div>
            <div>
                <label for="sub-modal-new-pos" class="block text-sm font-medium text-gray-700">新しい守備位置</label>
                <select id="sub-modal-new-pos" class="w-full p-2 border rounded bg-white">
                    <option value="">- 選択 -</option>
                    <option value="投">投手 (投)</option>
                    <option value="捕">捕手 (捕)</option>
                    <option value="一">一塁手 (一)</option>
                    <option value="二">二塁手 (二)</option>
                    <option value="三">三塁手 (三)</option>
                    <option value="遊">遊撃手 (遊)</option>
                    <option value="左">左翼手 (左)</option>
                    <option value="中">中堅手 (中)</option>
                    <option value="右">右翼手 (右)</option>
                </select>
            </div>
        </div>

        <div class="mt-6 text-center border-t pt-4">
            <button id="sub-modal-save" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 mr-4">
                交代を記録
            </button>
            <button id="sub-modal-cancel" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-400">
                キャンセル
            </button>
        </div>
    </div>
</div>


    </body>
</html>