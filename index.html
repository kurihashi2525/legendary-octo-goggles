<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【最終実装版】AI記者付きトーナメント表</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&family=Noto+Serif+JP:wght@700&display=swap" rel="stylesheet">
 <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Yuji+Syuku&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
/* styleタグ内の分かりやすい場所に追加 */


/* ▼▼▼ 禍々しい雰囲気用のCSS ▼▼▼ */
.dread-mode-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(127, 29, 29, 0.5); /* 不気味な赤色のオーバーレイ */
    z-index: 199; /* 抽選会モーダルのすぐ下 */
    pointer-events: none;
    animation: fadeIn 0.5s forwards;
}

#lottery-pot.dread {
    background-color: #7f1d1d; /* red-900 */
    border-color: #fca5a5; /* red-300 */
    animation: pulse-dread 1s infinite;
}

@keyframes pulse-dread {
    0%, 100% {
        transform: scale(1.05);
        box-shadow: 0 0 15px 5px rgba(255, 100, 100, 0.7);
    }
    50% {
        transform: scale(1.1);
        box-shadow: 0 0 30px 15px rgba(255, 100, 100, 0.9);
    }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ 抽選会イベント用のCSS ▼▼▼ */
#drawn-team-container.fade-in-out {
    animation: fadeInOut 2.5s ease-in-out forwards;
}

@keyframes fadeInOut {
    0% { opacity: 0; transform: scale(0.8); }
    20%, 80% { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(0.8); }
}

.lottery-slot {
    border: 1px solid #d1d5db;
    background-color: #f3f4f6;
    padding: 4px 8px;
    font-size: 14px;
    font-weight: 500;
    border-radius: 4px;
    transition: all 0.3s ease-in-out;
}
.lottery-slot.filled {
    background-color: #fffbeb; /* amber-100 */
    border-color: #f59e0b; /* amber-500 */
    font-weight: 700;
    transform: scale(1.05);
}
.lottery-slot.highlight {
    background-color: #ef4444; /* red-500 */
    color: white;
    border-color: #b91c1c; /* red-700 */
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}
.animate-fade-in-up {
    animation: fadeInUp 0.5s ease-out forwards;
}
@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* Weather Effects */
.rain {
    position: absolute;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
}
.drop {
    position: absolute;
    bottom: 100%;
    width: 1px;
    height: 50px;
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.4));
    animation: drop 0.5s linear infinite;
}
@keyframes drop {
    to { transform: translateY(100vh); }
}

.sunshine {
    position: absolute;
    top: -50px;
    left: -50px;
    width: 100px;
    height: 100px;
    z-index: 2;
}
.sun {
    position: absolute;
    width: 100px;
    height: 100px;
    background: radial-gradient(circle, rgba(255,255,220,0.8) 0%, rgba(255,255,220,0) 60%);
    border-radius: 50%;
}
.sun-flare {
    position: absolute;
    width: 200px;
    height: 200px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    animation: flare 5s infinite;
}
@keyframes flare {
    0% { transform: scale(1); opacity: 0.1; }
    50% { transform: scale(1.2); opacity: 0.2; }
    100% { transform: scale(1); opacity: 0.1; }
}

/* Weather Control Buttons */
.weather-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.5);
    background-color: rgba(255, 255, 255, 0.2);
    font-size: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
}
.weather-btn:hover {
    background-color: rgba(255, 255, 255, 0.4);
    border-color: white;
}

/* ▼▼▼ このブロックを追加 ▼▼▼ */
        .subtitle-text {
            color: white;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
        }
        .setup-header {
            color: white !important; /* Tailwind CSSより優先させる */
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            border-bottom-color: rgba(255, 255, 255, 0.5) !important; /* 下線も白っぽくする */
        }
        /* ▲▲▲ ▲▲▲ */

/* ▼▼▼ このブロックを追加 ▼▼▼ */
     .main-title {
            font-family: 'Yuji Syuku', serif;
            font-size: 3rem; /* 少し大きくして迫力を出す */
            letter-spacing: 0.2em; /* 文字間を調整 */
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7);
            animation: fadeIn 2s ease-in-out; /* フェードインアニメーション */
        }

        .subtitle-text {
            color: white;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            animation: fadeIn 2.2s ease-in-out; /* アニメーションを追加 */
        }

        /* メインコンテンツエリアをガラスパネル風に */
        .setup-card {
            background-color: rgba(10, 10, 20, 0.65) !important; /* 半透明背景を優先 */
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px); /* 背景をぼかす（対応ブラウザのみ） */
            padding: 2.5rem !important; /* paddingを調整 */
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            animation: fadeIn 1.5s ease-in-out;
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .setup-header {
            color: white !important;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            border-bottom-color: rgba(255, 255, 255, 0.5) !important;
        }

        /* チーム一覧エリアを名簿風に */
        #teams-list {
            background-color: rgba(0, 0, 0, 0.2) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            color: #f0f0f0 !important;
            font-size: 0.9rem;
            line-height: 1.6;
            padding: 1.5rem !important;
        }

        /* ボタンエリアにアニメーションを追加 */
        #setup .mt-8 {
            animation: fadeIn 2.5s ease-in-out;
        }

        /* フェードイン用アニメーションの定義 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ このブロックを追加 ▼▼▼ */
#news-ticker-container {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    display: flex;
    align-items: center;
    z-index: 50; /* 他の要素より手前に */
    height: 30px;
    font-family: 'Noto Sans JP', sans-serif;
    border-top: 1px solid rgba(255, 255, 255, 0.3);
}
.ticker-label {
    background-color: #e53935; /* 赤色 */
    font-weight: bold;
    padding: 0 12px;
    height: 100%;
    display: flex;
    align-items: center;
    font-size: 0.9rem;
}
.ticker-content {
    flex-grow: 1;
    overflow: hidden; /* はみ出したテキストを隠す */
    padding-left: 1rem;
}
#ticker-text {
    white-space: nowrap; /* テキストを改行させない */
    /* アニメーション時間を少し長めに設定してゆっくり流す */
    animation: scroll-ticker 40s linear infinite;
}
@keyframes scroll-ticker {
    0% { transform: translateX(100%); }
    100% { transform: translateX(-100%); }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* 写実的な天候アニメーション用のスタイル */
   /* 写実的な天候アニメーション用のスタイル（★調査モード★） */
/* 背景画像 */
.ballpark-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* Layer 1 (Bottom) */
    /* ▼▼▼ This line is the only change ▼▼▼ */
    background-image: url('ballpark.jpg'); /* Use the local image */
    /* ▲▲▲ END OF CHANGE ▲▲▲ */
    background-size: cover;
    background-position: center;
    filter: blur(2px) brightness(0.7);
    animation: subtle-breathing 20s ease-in-out infinite;
}
/* 土埃のアニメーション用コンテナ */
#dust-container {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; /* クリックの邪魔をしない */
    z-index: 2; /* 階層2（中間） */
}
/* メインコンテンツのコンテナ */
#app-container {
    position: relative; /* z-indexを有効にするため */
    z-index: 3; /* 階層3（一番手前） */
}
@keyframes subtle-breathing {
    0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); }
}
.dust-particle {
    position: absolute; background-color: rgba(255, 255, 255, 0.5);
    border-radius: 50%; opacity: 0; animation: drift-up linear infinite;
}
@keyframes drift-up {
    0% { transform: translateY(100vh) translateX(var(--x-start)); opacity: 0; }
    10% { opacity: 1; } 90% { opacity: 1; }
    100% { transform: translateY(-100px) translateX(var(--x-end)); opacity: 0; }
}
/* Input field color-coding */
.result-hit { background-color: #eff6ff !important; color: #1d4ed8; } /* Blue for hits */
.result-out { background-color: #fee2e2 !important; color: #b91c1c; } /* Red for outs */
.result-on-base { background-color: #f0fdf4 !important; color: #15803d; } /* Green for walks, etc. */

.clickable-team-name {
    cursor: pointer;
    transition: color 0.2s;
}
.clickable-team-name:hover {
    color: #1d4ed8; /* blue-700 */
}
        body { 
    font-family: 'Inter', 'Noto Sans JP', sans-serif; 
}
.setup-card { 
    background-color: transparent; /* 背景を透明に */
    padding: 24px; 
    border-radius: 12px; 
    box-shadow: none; /* 影を削除 */
    margin-bottom: 24px;
}
.display-card {
    background-color: #fff; padding: 24px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); margin-bottom: 24px;
}
        #main-bracket-container { display: flex; justify-content: center; padding: 20px; font-size: 12px; overflow-x: auto; border: 1px solid #e5e7eb; background-color: #f9fafb; border-radius: 8px;}
        .bracket-half { display: flex; }
        .bracket-half.right { flex-direction: row-reverse; }
        .bracket-final { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0 10px; flex-shrink: 0; min-width: 60px; }
        .bracket-final .final-matchup { border: 2px solid #f59e0b; background-color: #fffbeb; border-radius: 6px; padding: 5px; margin-top: 10px; }
        .bracket-final .winner-box { font-weight: bold; color: #b45309; text-align: center; padding: 10px 20px; white-space: nowrap; font-size: 1.25rem; }
        .bracket-final .final-title { font-weight: 600; color: #4b5563; margin-bottom: 10px; writing-mode: vertical-rl; letter-spacing: 2px; }
        .round { display: flex; flex-direction: column; justify-content: space-around; flex-shrink: 0; width: 180px; padding: 0 10px; }
        .matchup { margin: 8px 0; position: relative; display: flex; flex-direction: column; justify-content: center; flex-grow: 1; }
        .team-slot { display: flex; align-items: center; background-color: #ffffff; border: 1px solid #e5e7eb; border-radius: 4px; margin-bottom: 4px; transition: background-color 0.3s; position: relative; }
        .team-slot:last-of-type { margin-bottom: 0; }
        .team-name { flex-grow: 1; padding: 6px 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .team-name .rank { font-weight: bold; margin-right: 4px; }
        .team-name .rank-A { color: #ef4444; }
        .team-name .rank-B { color: #f97316; }
        .team-name .rank-C { color: #eab308; }
        .team-name .rank-D { color: #3b82f6; }
        .team-name .rank-E { color: #6b7280; }
        .team-name.seed { font-weight: bold; color: #ca8a04; }
        .score-input { width: 40px; padding: 6px 4px; border-left: 1px solid #e5e7eb; text-align: center; background-color: #fff; }
        .win-btn { background-color: #d1d5db; color: #fff; border: none; padding: 6px 8px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; cursor: pointer; font-weight: bold; transition: background-color 0.2s; }
        .team-slot:not(.empty) .win-btn { background-color: #3b82f6; }
        .team-slot:not(.empty):hover .win-btn { background-color: #2563eb; }
        .team-slot.winner { background-color: #dbeafe; border-color: #93c5fd; font-weight: 600; }
        .team-slot.loser { background-color: #f3f4f6; opacity: 0.6; }
        .team-slot.empty .team-name { color: #9ca3af; }
        .team-slot.empty .score-input, .team-slot.empty .win-btn, .team-slot.empty .details-btn { display: none; }
        .matchup::after { content: ''; position: absolute; top: 50%; width: 10px; height: 2px; background-color: #cbd5e1; }
        .bracket-half.left .matchup::after { right: -10px; }
        .bracket-half.right .matchup::after { left: -10px; }
        .round.subsequent-round .matchup::before { content: ''; position: absolute; top: -8px; height: calc(100% + 16px); width: 2px; background-color: #cbd5e1; }
        .bracket-half.left .round.subsequent-round .matchup::before { right: -10px; }
        .bracket-half.right .round.subsequent-round .matchup::before { left: -10px; }
        .hidden { display: none; }
        .news-article { border-left: 4px solid #3b82f6; cursor: pointer; transition: background-color 0.2s; }
        #modal-bg { background-color: rgba(0,0,0,0.5); }
        .confirm-modal, .details-modal, .save-load-modal, .newspaper-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .confirm-modal-content, .details-modal-content, .save-load-modal-content, .newspaper-modal-content { background-color: white; padding: 24px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .details-modal-content { width: 95%; max-width: 1000px; max-height: 90vh; overflow-y: auto;}
        .save-load-modal-content { width: 95%; max-width: 500px; }
        .newspaper-modal-content { width: 95%; max-width: 800px; max-height: 95vh; overflow-y: auto; }
        .confirm-modal-content { text-align: center; }
        .loader { text-align: center; padding: 20px; font-style: italic; color: #6b7280; }
        .details-btn { background-color: #6b7280; color: white; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: auto; margin-right: 2px; }
        .details-btn:hover { background-color: #4b5563; }
        .matchup-footer { text-align: center; margin-top: 2px; display: flex; justify-content: center; align-items: center; gap: 4px;}
        .stats-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .stats-table th, .stats-table td { border: 1px solid #e5e7eb; padding: 4px 6px; text-align: center; }
        .stats-table th { background-color: #f3f4f6; }
        .stats-table input { width: 100%; border: none; text-align: center; background: transparent;}
        .stats-table input:focus { outline: 1px solid #3b82f6; }
        .modal-body-scroll { max-height: 70vh; overflow-y: auto; }
        #save-code-output { word-break: break-all; background-color: #f3f4f6; padding: 8px; border-radius: 4px; max-height: 200px; overflow-y: auto; user-select: all; }
        .bbs-comment { background-color: #ffffff; border: 1px solid #e5e7eb; padding: 8px 12px; border-radius: 8px; font-size: 14px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .match-summary-input { resize: none; height: 40px; }
        .article-error { background-color: #fee2e2; border-left: 4px solid #ef4444; color: #b91c1c; padding: 1rem; border-radius: 0.5rem; display: flex; justify-content: space-between; align-items: center; }
        .retry-btn { background-color: #ef4444; color: white; padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-weight: 600; cursor: pointer; }
        .retry-btn:hover { background-color: #dc2626; }
        .namco-news-item { cursor: pointer; transition: background-color 0.2s; }
        .namco-news-tag { background-color: #f97316; color: white; font-size: 0.75rem; padding: 2px 8px; border-radius: 9999px; margin-left: 8px; }
      
.region-map-scroll-container {
    display: flex;
    overflow-x: auto;
    padding-bottom: 16px; /* Space for the scrollbar */
    gap: 16px;
}
.region-column { 
    flex: 0 0 250px; /* Prevent cards from shrinking */
    background-color: #ffffff; 
    border: 1px solid #e5e7eb; 
    border-radius: 8px; 
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
}
.region-header { 
    padding: 12px 16px; 
    background-color: #f9fafb; 
    border-bottom: 1px solid #e5e7eb; 
}
.region-title { 
    font-weight: 700; 
    font-size: 1.1rem; 
    color: #1f2937; 
}
.region-stats { 
    font-size: 0.8rem; 
    color: #4b5563; 
    font-weight: 500;
}
.region-team-list { 
    list-style: none; 
    padding: 12px 16px; 
    margin: 0;
    flex-grow: 1; /* Allow list to fill space */
}
.region-team { 
    padding: 6px 0; 
    font-size: 0.9rem;
    border-bottom: 1px solid #f3f4f6;
}
.region-team:last-child {
    border-bottom: none;
}
.team-surviving { 
    font-weight: 500; 
    color: #1f2937; 
}
.team-eliminated { 
    color: #9ca3af; 
    text-decoration: line-through; 
}
         .scorebook-font {
            font-family: 'Yuji Syuku', serif;
        }
        .newspaper-container { font-family: 'Noto Serif JP', serif; padding: 2rem; background-color: #fdfdf8; }
        .newspaper-early { filter: grayscale(100%); border: 2px solid #333; }
        .newspaper-late { border: 2px solid #a10e25; }
        .newspaper-header { text-align: center; border-bottom: 4px double #333; padding-bottom: 0.5rem; margin-bottom: 1rem; }
        .newspaper-title { font-size: 1.2rem; font-weight: 700; }
        .newspaper-date { font-size: 0.8rem; }
        .newspaper-content { display: flex; gap: 1.5rem; }
        .newspaper-main-headline { writing-mode: vertical-rl; text-orientation: mixed; font-size: 2.5rem; font-weight: 700; letter-spacing: 0.2em; border-right: 2px solid #333; padding-right: 1rem; margin-right: 1rem; }
        .newspaper-late .newspaper-main-headline { color: #a10e25; border-right-color: #a10e25;}
        .newspaper-body-content { flex-grow: 1; }
        .newspaper-sub-headline { font-size: 1.5rem; font-weight: 700; margin-bottom: 1rem; border-bottom: 1px solid #666; padding-bottom: 0.5rem; }
        .newspaper-late .newspaper-sub-headline { color: #333; }
        .newspaper-text { font-family: 'Noto Sans JP', sans-serif; column-count: 3; column-gap: 1.5rem; text-align: justify; font-size: 0.9rem; line-height: 1.8; }
        .newspaper-early .newspaper-text { column-count: 2; }
        .newspaper-score-box { border: 2px solid #333; padding: 1rem; text-align: center; margin-top: 1rem; }
        .newspaper-score-box h3 { font-weight: 700; margin-bottom: 0.5rem; font-size: 1.1rem; }
        .newspaper-score-box .score { font-size: 2rem; font-weight: 700; }
        .newspaper-late .newspaper-score-box { background-color: #fff8f8; border-color: #a10e25; }
        .newspaper-image-placeholder { width: 100%; height: 200px; background-color: #e0e0e0; margin: 1rem 0; display: flex; align-items: center; justify-content: center; font-family: 'Noto Sans JP', sans-serif; color: #888; border: 1px dashed #aaa; }
        .rivalry-match .team-slot { border: 2px solid #ef4444 !important; background-color: #fff1f2; }
        .feud-match .team-slot { border: 2px solid #8b5cf6 !important; background-color: #f5f3ff; }
        .rivalry-match .team-slot.winner { background-color: #fecaca; }
        .feud-match .team-slot.winner { background-color: #ddd6fe; }
    
/* 詳細入力テーブル用のスタイル */
/* 詳細入力テーブル用のスタイル（最終版） */
.details-table { 
    border-collapse: collapse; 
    font-size: 12px; 
    
}
/* ▼▼▼ この新しいルールを追加 ▼▼▼ */
.details-table th {
    white-space: nowrap; /* ヘッダーの文字が折り返さないようにする */
}
/* ▲▲▲ ▲▲▲ */
.details-table td { 
    border: 1px solid #e5e7eb; 
    padding: 4px; 
    text-align: center; 
    vertical-align: middle; 
}
.details-table th { background-color: #f9fafb; font-weight: 600; }
.details-table input, .details-table select { width: 100%; border: none; text-align: center; background: transparent; font-size: 12px; }
.details-table input:focus, .details-table select:focus { outline: 1px solid #3b82f6; }

/* ★列幅設定★ */
/* イニングスコアテーブル */
#inning-score-table { table-layout: auto; width: auto; } /* スコアボードは自動幅 */
#inning-score-table .col-team { min-width: 120px; text-align: left; padding-left: 8px; }
#inning-score-table .col-inning-score { width: 40px; }
#inning-score-table .col-total { width: 50px; }
#inning-score-table .col-add-inning { width: 40px; }

/* 打撃成績テーブル */
/* ★列幅設定（min-widthで最低幅を保証）★ */
.batting-table .col-order { min-width: 40px; }
.batting-table .col-number { min-width: 60px; }
.batting-table .col-player { min-width: 120px; }
.batting-table .col-pos { min-width: 100px; }
.batting-table .col-sub-type { min-width: 80px; }
.batting-table .col-inning { min-width: 300px; }  /* ←お好みの幅に調整してください */
/* ▲▲▲ ▲▲▲ */
        .add-row-btn { background-color: #e5e7eb; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-top: 4px; }

        .add-row-btn:hover { background-color: #d1d5db; }　



　 </style>
</head>
<body class="p-4 md:p-8">
     <audio id="lottery-bgm" src="./bgm.mp3" loop preload="auto"></audio>
    <div class="ballpark-background"></div>
    <div id="dust-container"></div>
 <div id="rain-container" class="rain hidden"></div>
    <div id="sun-container" class="sunshine hidden">
        <div class="sun"></div>
        <div class="sun-flare"></div>
    </div>
    <div id="app-container" class="max-w-full mx-auto">
/div>

<div id="news-ticker-container">
    <div class="ticker-label">NEWS</div>
    <div class="ticker-content">
        <p id="ticker-text"></p>
    </div>
</div>

    <div id="weather-controls" class="fixed bottom-4 right-4 z-10">
        <div class="flex gap-2 p-2 bg-black bg-opacity-20 rounded-lg">
            <button id="unmute-btn" class="weather-btn">🔇</button>
            <button class="weather-btn" data-weather="sun">☀️</button>
            <button class="weather-btn" data-weather="rain">🌧️</button>
            <button class="weather-btn" data-weather="none">💨</button>
        </div>
    </div>
        

        <div class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white main-title">AI記者付きトーナメント表</h1>
            <p id="tournament-year-display" class="mt-2 subtitle-text">（最終実装版）</p>
        </div>

        <div id="setup" class="setup-card">
             <div class="w-full">
                 <h2 class="text-xl font-semibold mb-4 border-b pb-2 setup-header">参加チーム (64チーム)</h2>
                 <textarea id="teams-list" class="w-full h-96 p-3 border border-gray-300 rounded-lg" readonly></textarea>
             </div>
             <div class="mt-8 text-center">
                 <button id="resume-btn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-green-700 shadow-md mb-4 w-full md:w-auto">
                   再開（合い言葉入力）
                 </button>
                 <button id="generate-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 shadow-md w-full md:w-auto">
                     新しいトーナメントを開始
                 </button>
　　　　　　　　<button id="help-btn" class="bg-gray-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-gray-600 shadow-md mt-4 w-full md:w-auto">
    遊び方
</button>
 <button id="show-matome-site-btn" class="bg-orange-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-orange-600 shadow-md mt-4 w-full md:w-auto">
    📰 まとめサイトを見る
    </button>            
 </div>
        </div>

<div id="bbs-thread-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[210]">
    <div class="bg-gray-100 p-6 rounded-lg shadow-xl w-full max-w-3xl max-h-[90vh] flex flex-col">
        <div class="flex justify-between items-center border-b-2 border-gray-300 pb-3 mb-4">
            <h3 id="bbs-thread-title" class="text-xl font-bold text-gray-800"></h3>
            <button id="bbs-thread-close-btn" class="text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div id="bbs-thread-content" class="overflow-y-auto space-y-3">
            <div class="loader">スレッドを読み込んでいます...</div>
        </div>
    </div>
</div>


        <div id="tournament-display" class="hidden">
            <div id="autumn-regional-blocks-container" class="display-card hidden"></div>
            <div id="autumn-ranking-playoffs-container" class="display-card hidden"></div>
            
            <div id="autumn-controls" class="text-center my-4 hidden">
                <button id="start-ranking-playoffs-btn" class="bg-purple-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-purple-700 shadow-md hidden">
                    地区内順位決定戦へ進む
                </button>
                <button id="start-main-tournament-btn" class="bg-teal-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-teal-700 shadow-md hidden">
                    県大会本戦へ進む
                </button>
            </div>

            


<div id="region-map-section" class="display-card hidden scorebook-font">
                 <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">地区別 勝ち残り状況</h2>
                 <div id="region-map-container" class="w-full"></div>
            </div>
             <div id="namco-news-section" class="hidden display-card border-2 border-orange-400">
                 <h2 class="text-xl font-bold text-orange-600 mb-3 text-center">ナムコグループからのお知らせ</h2>
                 <div id="namco-news-content" class="space-y-2"></div>
             </div>
            <div class="flex justify-between items-start mb-4">
                <div>
                    <button id="generate-summary-btn" class="hidden bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 shadow-md">
                        ここまでの大会ハイライト記事を生成
                    </button>
                    <button id="next-tournament-btn" class="hidden bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 shadow-md">
                        次の大会へ進む
                    </button>
                </div>
               <div class="ml-auto">
                    <div class="flex items-center justify-end space-x-2">
                        <button id="skip-r1-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">1回戦スキップ</button>
                        <button id="skip-r2-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">2回戦スキップ</button>
                        <button id="skip-r3-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">3回戦スキップ</button>
                        <span id="save-feedback" class="text-gray-600 font-bold opacity-0 transition-opacity duration-500"></span>
<button id="show-matome-site-btn" class="bg-orange-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-600 shadow-md">
    📰 まとめ
    </button>
                        <button id="save-btn" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-700 shadow-md">セーブ</button>
                        <button id="reset-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 shadow-md">リセット</button>
                    </div>
                    <div id="skip-loader-container" class="h-6 text-right mt-1">
                         <span id="skip-loader" class="hidden text-sm text-gray-600 font-bold">試合を進行しています...</span>
                    </div>
                </div>
            </div>
            <div id="main-bracket-wrapper" class="display-card scorebook-font">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">トーナメント表</h2>
                <div class="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4 rounded-md text-sm">
                    <p><b>PCでの表示について:</b> トーナメント表の全体が表示されない場合は、表のエリア内でマウスのホイールを回しながら <b>Shiftキー</b> を押すか、表の下に表示されるスクロールバーを直接ドラッグすることで、左右にスクロールできます。</p>
                </div>
                <div id="main-bracket-container"></div>
            </div>
            <div id="news-section" class="display-card">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">注目ニュース</h2>
                <div id="news-articles" class="space-y-4">
                    <p class="text-gray-500 text-center">まだニュースはありません。</p>
                </div>
            </div>
             <div id="daiya-bbs-section" class="hidden display-card border-4 border-green-600">
                 <h2 id="daiya-bbs-title" class="text-2xl font-bold text-green-800 mb-4 text-center">【特設】代矢東 応援掲示板</h2>
                 <div id="daiya-bbs-comments" class="space-y-3">
                     <p class="text-gray-500 text-center">まだ反応はありません。</p>
                 </div>
             </div>
             <div id="bbs-section" class="display-card">
                 <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">掲示板の反応</h2>
<div class="mb-4 p-4 border rounded-lg bg-white">
    <form id="main-comment-form">
        <textarea id="main-comment-textarea" class="w-full p-2 border rounded" rows="2" placeholder="コメントを書き込む... (例: 今日の姫川はレベチだったわ！)" required></textarea>
        <div class="text-right mt-2">
            <button type="submit" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">投稿する</button>
        </div>
    </form>
</div>
                 <div id="bbs-comments" class="space-y-3">
                     <p class="text-gray-500 text-center">まだ反応はありません。</p>
                 </div>
             </div>
        </div>
    </div>

    <div id="news-modal" class="fixed inset-0 z-50 hidden items-center justify-center">
        <div id="modal-bg" class="absolute inset-0"></div>
        <div class="relative bg-white rounded-lg shadow-xl max-w-2xl w-full m-4">
            <div class="p-6 modal-body-scroll">
                <h3 id="modal-title" class="text-2xl font-bold text-gray-900"></h3>
                <div id="modal-meta" class="text-gray-400 text-sm mt-2 flex items-center gap-4"></div>
                <p id="modal-body" class="mt-4 text-gray-600 whitespace-pre-wrap"></p>
            </div>
            <button id="modal-close" class="absolute top-3 right-3 text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    
  
<div id="matome-site-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[200]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-3xl max-h-[90vh] flex flex-col">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 class="text-2xl font-bold text-gray-800 scorebook-font">俺たちの甲子園速報＠なんJまとめ</h3>
            <button id="matome-site-close-btn" class="text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div id="matome-site-content" class="overflow-y-auto space-y-4">
            <div class="loader">ニュースを取得中...</div>
        </div>
    </div>
</div>

  <div id="confirm-modal" class="confirm-modal hidden">
        <div class="confirm-modal-content">
            <p id="confirm-modal-text" class="mb-4 text-lg"></p>
            <button id="confirm-ok" class="bg-red-600 text-white px-6 py-2 rounded-lg mr-2">はい</button>
            <button id="confirm-cancel" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">いいえ</button>
        </div>
    </div>

    <div id="details-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
        <div class="details-modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-6xl max-h-[90vh] flex flex-col">
            <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">試合詳細入力</h3>
            <div id="details-modal-body" class="overflow-y-auto space-y-6 flex-grow">
                </div>
            <div class="mt-6 text-center border-t pt-4">
                <button id="details-save" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">この内容で保存</button>
                <button id="details-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
            </div>
        </div>
    </div>
    
    <div id="save-load-modal" class="save-load-modal hidden">
        <div class="save-load-modal-content">
            <div class="flex border-b">
                <button id="save-tab-btn" class="px-4 py-2 font-semibold border-b-2 border-blue-500">セーブ (合い言葉の発行)</button>
                <button id="load-tab-btn" class="px-4 py-2 text-gray-500">ロード (合い言葉の入力)</button>
            </div>
            <div id="save-tab-content" class="py-4">
                <p class="text-sm mb-2">現在の進行状況を保存するための「合い言葉」を発行します。下のボタンを押してください。</p>
                <button id="generate-save-code-btn" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700">合い言葉を発行</button>
                <div id="save-code-area" class="hidden mt-4">
                    <p class="text-sm font-bold text-green-600">合い言葉が発行されました。以下をコピーして安全な場所に保管してください。</p>
                    <div class="flex items-center mt-2">
                        <div id="save-code-output" class="flex-grow text-xs"></div>
                        <button id="copy-save-code-btn" class="ml-2 bg-gray-200 px-3 py-1 rounded text-xs font-semibold hover:bg-gray-300">コピー</button>
                    </div>
                    <p id="copy-feedback" class="text-xs text-green-600 mt-1 h-4"></p>
                </div>
            </div>
            <div id="load-tab-content" class="py-4 hidden">
                <p class="text-sm mb-2">保存した「合い言葉」を以下に貼り付けてください。</p>
                <textarea id="load-code-input" placeholder="合い言葉をここに貼り付け" class="w-full h-32 p-2 border rounded mb-2"></textarea>
                <button id="load-from-code-btn" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">このデータで再開する</button>
            </div>
             <div class="mt-4 text-right">
                 <button id="save-load-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
             </div>
        </div>
    </div>

    <div id="newspaper-modal" class="newspaper-modal hidden">
        <div class="newspaper-modal-content">
            <div id="newspaper-modal-body"></div>
            <div class="mt-4 text-center">
                <button id="newspaper-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
            </div>
        </div>
    </div>


<div id="feedback-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-[150]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記者への追加指示</h3>
        <div class="space-y-4">
            <div>
                <label for="feedback-include" class="block text-sm font-medium text-gray-700">✅ この要素を必ず含めてください</label>
                <textarea id="feedback-include" rows="4" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="例：殊勲打を放った〇〇選手のコメントを中心に。&#10;例：敗れた△△高校のエースの涙にも触れてほしい。"></textarea>
            </div>
            <div>
                <label for="feedback-exclude" class="block text-sm font-medium text-gray-700">❌ この要素・展開は避けてください</label>
                <textarea id="feedback-exclude" rows="3" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="例：監督の采配ミスという論調はもういい。&#10;例：ありきたりな「全員野球」という言葉は使わないで。"></textarea>
            </div>
        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="feedback-submit-btn" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">この指示で再生成</button>
            <button id="feedback-cancel-btn" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="review-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記事の最終確認・編集</h3>
        <div class="overflow-y-auto space-y-4 flex-grow">
            <div>
                <label for="review-title" class="block text-sm font-medium text-gray-700">タイトル</label>
                <input type="text" id="review-title" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div>
                <label for="review-body" class="block text-sm font-medium text-gray-700">本文</label>
                <textarea id="review-body" rows="15" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 whitespace-pre-wrap"></textarea>
            </div>
        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="review-save-btn" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">この記事で確定</button>
            <button id="review-cancel-btn" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="lottery-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 hidden items-center justify-center z-[200] font-sans">
    <div id="lottery-content" class="bg-white rounded-lg shadow-2xl w-full max-w-6xl h-[95vh] flex flex-col p-6">
        <h2 class="text-4xl font-bold text-center mb-4 scorebook-font text-gray-800 tracking-widest">夏の高校野球 組み合わせ抽選会</h2>
        <div id="lottery-stage" class="flex-grow bg-gray-800 rounded p-4 flex gap-4 overflow-hidden relative border-4 border-gray-600">
            <div class="w-1/3 flex flex-col items-center justify-between bg-gray-200 rounded-lg shadow-inner p-4">
                <div id="lottery-pot-container" class="w-full flex flex-col items-center">
                    <p id="pot-name" class="text-2xl font-bold text-gray-700 mb-2">Aシード</p>
                    <div id="lottery-pot" class="w-48 h-48 bg-red-800 border-4 border-yellow-400 text-white flex items-center justify-center text-5xl font-bold shadow-lg rounded-full cursor-pointer transition-transform duration-200 hover:scale-105">
                        抽選
                    </div>
                </div>
                <div id="drawn-team-container" class="w-full h-32 border-4 border-dashed border-gray-400 rounded-lg flex items-center justify-center opacity-0 bg-white">
                    <p id="drawn-team" class="text-4xl font-bold text-gray-800"></p>
                </div>
            </div>
            <div id="lottery-bracket" class="w-2/3 grid grid-cols-2 gap-x-4 h-full overflow-y-auto p-2 bg-gray-100 rounded-lg shadow-inner">
                <div id="lottery-bracket-left" class="space-y-1"></div>
                <div id="lottery-bracket-right" class="space-y-1"></div>
            </div>
        </div>
        <div class="h-32 flex flex-col justify-between pt-4">
            <div id="lottery-commentary" class="h-20 text-center text-2xl font-semibold text-gray-800 bg-yellow-100 border-2 border-yellow-300 rounded p-2 flex items-center justify-center">
                <p>静岡大会 抽選会へようこそ。主将は抽選箱をクリックしてクジを引いてください。</p>
            </div>
            <div id="lottery-controls" class="text-center">
    <button id="start-lottery-btn" class="bg-blue-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-blue-700">抽選を開始</button>
    <button id="skip-lottery-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 ml-4">スキップ</button>
</div>
        </div>
    </div>
</div>

<div id="interview-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-[300]">
    <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full p-6 m-4 animate-fade-in-up">
        <h3 class="text-2xl font-bold text-gray-900 mb-4 border-b pb-2">抽選会後 主将インタビュー</h3>
        <div id="interview-content" class="space-y-4 max-h-[60vh] overflow-y-auto"></div>
        <div class="text-center mt-6">
            <button id="close-interview-btn" class="bg-blue-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-blue-700">大会を始める</button>
        </div>
    </div>
</div>

<div id="help-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記者付きトーナメント表 取扱説明書</h3>
        <div class="overflow-y-auto space-y-6 flex-grow pr-4 text-gray-700">
            
            <div>
                <h4 class="font-bold text-lg text-blue-700 mb-2">はじめに：このゲームの目的</h4>
                <p class="text-sm">
                    このシミュレーターの目的は、単にトーナメントを勝ち進めることだけではありません。あなたの采配や入力した試合内容によって、AIが自動でリアルな「ニュース記事」や「掲示板の反応」を生成します。あなただけの、唯一無二の高校野球の物語を創り上げ、その歴史の目撃者となることが、このゲームの醍醐味です。
                </p>
            </div>

            <div>
                <h4 class="font-bold text-lg text-blue-700 mb-2">基本的な遊び方</h4>
                <ol class="list-decimal list-inside space-y-2 text-sm">
                    <li><strong>トーナメント開始:</strong> 「新しいトーナメントを開始」でゲームを始めます。最初の大会は夏の県大会です。</li>
                    <li><strong>スコア入力:</strong> トーナメント表の試合カードに、半角数字で最終スコアを入力します。</li>
                    <li><strong>勝者決定:</strong> スコアを入力したら、勝った方のチームの青い「▶」ボタンを押します。</li>
                    <li><strong>AIコンテンツ生成:</strong> 勝者が決まると、AIが自動で「ニュース記事」と「掲示板の反応」を生成します。</li>
                    <li><strong>繰り返し:</strong> 全ての試合でこれを繰り返し、優勝チームを決定してください。「セーブ」ボタンでいつでも進行状況を「合い言葉」として保存できます。</li>
                </ol>
            </div>
            
            <div>
                <h4 class="font-bold text-lg text-orange-700 mb-2">一年間の流れと各大会のルール</h4>
                <p class="text-sm mb-3">
                    この世界では、夏の大会が終わると新チームによる秋季大会、そして春季大会へと時間が流れます。それぞれの大会には独自のルールと目的があります。
                </p>
                <div class="space-y-4">
                    <div class="p-4 border rounded-lg bg-gray-50">
                        <h5 class="font-semibold text-gray-800">夏の大会 (メインイベント)</h5>
                        <p class="text-sm text-gray-600">3年生にとって最後の大会。64校による一発勝負のトーナメントで、優勝校は夏の甲子園に出場したとみなされ、AIがその全国での戦績をシミュレートします。</p>
                    </div>

                    <div class="p-4 border rounded-lg bg-gray-50">
                        <h5 class="font-semibold text-gray-800">秋の大会 (新チームの始まりと、春への道)</h5>
                        <p class="text-sm text-gray-600 mb-3">1,2年生の新チームで挑む最初の公式戦。この大会の最終成績が、次の春季大会のシード権を決定します。</p>
                        <pre class="text-xs bg-white p-3 rounded-md border overflow-x-auto">
秋季大会の流れ (東部・中部・西部地区)
----------------------------------------------------------------
[各地区20チーム] → [4ブロックに分割 (各5チーム)] → [ブロック予選]
                                |
                                |
              +-----------------+-----------------+
              | (各ブロック優勝4チーム)           | (各ブロック準優勝4チーム)
              ↓                                 ↓
[上位校トーナメント (1位-4位決定)]     [敗者復活トーナメント (5位決定)]
              |                                 |
              +-----------------+-----------------+
                                |
                                ↓
                      [各地区代表5チームが県大会へ] → [計16チームによる県大会本戦]

伊豆地区 (4チーム)
-------------------
[予選なし] → [直接、県大会本戦へ (1チーム)]
                        </pre>
                    </div>

                    <div class="p-4 border rounded-lg bg-gray-50">
                        <h5 class="font-semibold text-gray-800">春の大会 (夏のシード権をかけた戦い)</h5>
                        <p class="text-sm text-gray-600 mb-3">夏の大会の前哨戦。この大会の結果が、夏の大会のシード校を決定します。</p>
                        <pre class="text-xs bg-white p-3 rounded-md border overflow-x-auto">
春季大会の流れ
----------------------------------------------------------------
[秋季大会ベスト8 (シード校)] → [県大会2回戦から登場]
                                               |
                                               +--> [ベスト16による本戦]
                                               |
[それ以外の全チーム] → [地区予選] → [予選突破16チーム] → [県大会1回戦]
                        </pre>
                    </div>
                </div>
            </div>

            <div>
                <h4 class="font-bold text-lg text-green-700 mb-2">【重要】詳細入力：あなただけの物語を創る</h4>
                <p class="text-sm mb-3">
                    このシミュレーターの真価は「詳細入力」にあります。スコアだけでなく、試合内容を細かく入力することで、AIが生成する物語の解像度が劇的に向上します。
                </p>
                <ul class="list-disc list-inside space-y-2 text-sm bg-green-50 p-4 rounded-lg">
                    <li><strong>イニングスコア:</strong> 試合展開をAIに教えます。「初回に大量得点した試合」と「9回に逆転した試合」では、生成される記事の物語が全く異なります。</li>
                    <li><strong>個人成績:</strong> その試合の「ヒーロー」をAIに教えます。ここで入力された選手が、記事やハイライトの中心人物となります。</li>
                    <li><strong>選手交代（出場）:</strong> ドロップダウンから「代打」「代走」「守備」を選ぶことで、監督の采配の意図をAIが理解します。</li>
                    <li><strong>この回の主な出来事:</strong> 打席結果には現れないプレー（例：盗塁、盗塁死）を入力します。「鈴木 盗塁、佐藤 盗塁死」のように入力してください。</li>
                    <li><strong>試合の決め手:</strong> トーナメント表のテキストエリアです。ここに「エース〇〇、気迫の150球完投勝利」のように入力すると、AIは他のどの情報よりもこれを**最優先**し、記事全体のテーマにします。</li>
                </ul>
            </div>
            
            <div>
                <h4 class="font-bold text-lg text-red-700 mb-2">トラブルシューティング</h4>
                <ul class="list-disc list-inside space-y-2 text-sm">
                    <li><strong>エラーでクラッシュする場合:</strong> ほとんどの原因は、ブラウザに保存されている古いセーブデータと、最新のコードの間に矛盾が生じていることです。コード内の`TEAM_DATA`を編集した後は、**必ず「リセット」ボタンで古いセーブデータを完全に消去してから**「新しいトーナメントを開始」してください。</li>
                    <li><strong>AIの記事がおかしい/事実と違う:</strong> AIに渡す情報が不足しているか、AIが稀に混乱している可能性があります。まずは「確認・編集」画面で手修正をお試しください。それでも改善しない場合は、詳細入力でより多くの情報（特に敗者チームの打撃成績など）を与えてみてください。</li>
                </ul>
            </div>

        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="help-modal-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
        </div>
    </div>
</div>

<div id="team-status-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 id="status-modal-team-name" class="text-2xl font-bold text-gray-800"></h3>
            <button id="status-modal-close" class="text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="space-y-4">
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">最高戦績</h4>
                <p id="status-modal-best" class="text-lg text-amber-600 font-bold"></p>
            </div>
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">直近の成績</h4>
                <div id="status-modal-history" class="space-y-1 text-gray-700"></div>
            </div>
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">称号</h4>
                <div id="status-modal-traits" class="flex flex-wrap gap-2"></div>
            </div>
            
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">監督</h4>
                <div id="status-modal-coach" class="text-gray-700"></div>
            </div>
            </div>
    </div>
</div>
<script type="module">

const BATTING_RESULTS = {
    hits: ['安', '二塁打', '三塁打', '本塁打'],
    outs: ['三振', 'ゴロ', '飛', '直', '併殺'],
    walks: ['四球', '死球'],
    sacrifices: ['犠打', '犠飛', '犠失'], // ← ここに追加
    other: ['野選', 'エラー']
};
const DIRECTIONS = ['投', '捕', '一', '二', '三', '遊', '左', '中', '右'];
const RBIS = ['1点', '2点', '3点', '4点'];

    // --- ライバル関係と称号の定義 ---
    const RIVALRIES = [
        { teams: ["代矢東", "雷門南"], type: "公立の覇権争い" },
        { teams: ["283学園", "稲城実業"], type: "私立の王者対決" },
        { teams: ["765総合高校", "代矢東"], type: "新旧王者対決" },
        { teams: ["青道", "稲城実業"], type: "西東京ライバル対決" }
    ];
    const TITLES = {
        GIANT_KILLER: { id: 'giant_killer', name: 'ジャイアントキラー', desc: '格上の強豪校を倒した実績を持つ。' },
        REPECHAGE_KING: { id: 'repechage_king', name: '不屈の敗者復活組', desc: '敗者復活戦から這い上がってきた実績があり、非常に粘り強い。' },
        WALL_OF_TOKYO: { id: 'wall_of_tokyo', name: '西東京の壁', desc: '西東京地区に立ちはだかる絶対的強者。' } // 例
    };
const tournamentNameMap = { summer: '夏季大会', autumn: '秋季大会', spring: '春季大会' };

// ▼▼▼ このブロックをまるごと置き換える ▼▼▼
const SCANDAL_DEFINITIONS = [
    {
        id: 'overpractice',
        condition: (teamName) => ['A', 'B'].includes(calculateRank(teamName, tournamentState)),
        
        // 文字列から関数に変更
        rumorTitle: (teamName) => `【週刊熱闘】${teamName}に「違法練習」疑惑か？`,
        rumorBody: (teamName) => `強豪として知られる${teamName}だが、その強さの裏には、高校野球連盟が定める練習時間規定を大幅に超過するほどの猛練習があるというタレコミが本誌に寄せられた。深夜までバットの音が鳴り響くという近隣住民の証言もあり、今後の動向が注目される。`,
        
        consequences: {
            report: {
                // こちらも同様に関数に変更
                outcomeTitle: (teamName) => `【速報】${teamName}、練習規定違反で公式戦を辞退`,
                outcomeBody: (teamName) => `先日、週刊誌で報じられた${teamName}の練習時間規定違反問題で、高野連は調査の結果、違反の事実を認定。同校は事態を重く受け止め、今大会の残り試合を辞退することを発表した。`,
                applyEffect: (teamName, state) => {
        if (state.teamRecords[teamName]) {
            state.teamRecords[teamName].penalty = 'forfeit';
        }

        const currentMatch = findCurrentMatchForTeam(teamName, state);
        if (!currentMatch) return; // 該当する試合がなければ何もしない

        const opponent = currentMatch.team1 === teamName ? currentMatch.team2 : currentMatch.team1;

        // 相手がいない場合（シードなど）は、単に負け扱いにする
        if (!opponent) {
            currentMatch.winner = `(不戦敗)`;
            currentMatch.team1 = teamName;
            currentMatch.team2 = null;
            return;
        }

        // 不戦勝として試合結果を記録
        currentMatch.winner = opponent;
        currentMatch.summary = `${teamName}の不祥事による不戦勝`;

        if (currentMatch.team1 === opponent) {
            currentMatch.score1 = 'W'; // Win
            currentMatch.score2 = 'L'; // Lose
        } else {
            currentMatch.score1 = 'L';
            currentMatch.score2 = 'W';
        }

        // チーム記録を更新
        if(state.teamRecords[opponent]) state.teamRecords[opponent].wins++;
        if(state.teamRecords[teamName]) state.teamRecords[teamName].losses++;
        
        // 勝者を次のラウンドへ自動で進める
        advanceWinnerToNextRound(currentMatch, opponent, state);
    }
            },
            ignore: {
                outcomeTitle: (teamName) => `${teamName}の練習問題、高野連は「事実確認できず」`,
                outcomeBody: (teamName) => `先日、一部週刊誌で報じられた${teamName}の練習時間に関する疑惑に対し、高野連は「現時点で違反の事実は確認できなかった」と発表。噂は噂のまま、球児たちの夏は続く。`,
                applyEffect: (teamName, state) => { /* 何もしない */ }
            }
        }
    }
];
// ▲▲▲ ここまで置き換え ▲▲▲
    // --- DOM Elements ---
    const setupEl = document.getElementById('setup');
    const tournamentDisplayEl = document.getElementById('tournament-display');
    const teamsTextarea = document.getElementById('teams-list');
    const generateBtn = document.getElementById('generate-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const resetBtn = document.getElementById('reset-btn');
    const nextTournamentBtn = document.getElementById('next-tournament-btn');
    const saveBtn = document.getElementById('save-btn');
    const mainBracketContainer = document.getElementById('main-bracket-container');
    const mainBracketWrapper = document.getElementById('main-bracket-wrapper');
    const newsContainer = document.getElementById('news-articles');
    const bbsCommentsContainer = document.getElementById('bbs-comments');
    const daiyaBbsSection = document.getElementById('daiya-bbs-section');
    const daiyaBbsCommentsContainer = document.getElementById('daiya-bbs-comments');
    const namcoNewsSection = document.getElementById('namco-news-section');
    const namcoNewsContent = document.getElementById('namco-news-content');
    const tournamentYearDisplay = document.getElementById('tournament-year-display');
    const generateSummaryBtn = document.getElementById('generate-summary-btn');
    const skipR1Btn = document.getElementById('skip-r1-btn');
    const skipR2Btn = document.getElementById('skip-r2-btn');
    const skipR3Btn = document.getElementById('skip-r3-btn');
    const skipLoader = document.getElementById('skip-loader');

    // Autumn Tournament UI
    const autumnRegionalContainer = document.getElementById('autumn-regional-blocks-container');
    const autumnRankingContainer = document.getElementById('autumn-ranking-playoffs-container');
    const autumnControls = document.getElementById('autumn-controls');
    const startRankingPlayoffsBtn = document.getElementById('start-ranking-playoffs-btn');
    const startMainTournamentBtn = document.getElementById('start-main-tournament-btn');

    // Modals
    const newsModal = document.getElementById('news-modal');
    const modalBg = document.getElementById('modal-bg');
    const modalClose = document.getElementById('modal-close');
    const confirmModal = document.getElementById('confirm-modal');
    const detailsModal = document.getElementById('details-modal');
    const saveLoadModal = document.getElementById('save-load-modal');
    const saveTabBtn = document.getElementById('save-tab-btn');
    const loadTabBtn = document.getElementById('load-tab-btn');
    const saveTabContent = document.getElementById('save-tab-content');
    const loadTabContent = document.getElementById('load-tab-content');
    const generateSaveCodeBtn = document.getElementById('generate-save-code-btn');
    const loadFromCodeBtn = document.getElementById('load-from-code-btn');
    const saveLoadCloseBtn = document.getElementById('save-load-close');
    const copySaveCodeBtn = document.getElementById('copy-save-code-btn');
    const newspaperModal = document.getElementById('newspaper-modal');
    const newspaperModalBody = document.getElementById('newspaper-modal-body');
    const newspaperCloseBtn = document.getElementById('newspaper-close');

    
    // --- State Management ---
    let tournamentState = {};
    let currentMatchIdForDetails = null;
    let articleForRegeneration = null; 
    let soundEffects = {};
    const UNDERDOG_TEAMS = ["虎府島総合", "緑山", "鷲尾", "県立由暇"];
    const POWERHOUSE_TEAMS = ["283学園", "天下無双学園", "代矢東", "雷門南", "稲城実業", "青道", "765総合高校"];
　　const POWERHOUSE_REVIVAL_TEAMS = ["海堂学園", "帝王実業", "風林大尾"];
　　const ONE_MAN_TEAMS = ["大船渡"];

// ▼▼▼ このオブジェクトで、既存のSoundManagerを完全に置き換えてください ▼▼▼
// ▼▼▼ サウンド管理システム ▼▼▼
// ▼▼▼ サウンド管理システム（ローカルファイル対応・最終完成版）▼▼▼
// ▼▼▼ BGM管理に特化した新しいサウンドマネージャー ▼▼▼
// ▼▼▼ BGMの音量調整機能付きサウンドマネージャー ▼▼▼
const SoundManager = {
    bgm: null,
    isReady: false,
    volume: 0.07, // BGMの音量を設定 (0.0がミュート, 1.0が最大)

    init() {
        this.bgm = document.getElementById('lottery-bgm');
        
        const unlockAudio = () => {
            if (!this.isReady && this.bgm) {
                this.isReady = true;
                this.bgm.volume = this.volume; // 初期音量を設定
                this.bgm.play().catch(e => console.error("BGM unlock failed:", e));
                this.bgm.pause();
                console.log("BGM ready.");
            }
            document.body.removeEventListener('click', unlockAudio);
        };
        
        document.body.addEventListener('click', unlockAudio, { once: true });
    },

    startBgm() {
        if (this.isReady && this.bgm) {
            this.bgm.volume = this.volume; // 再生前に音量を設定
            this.bgm.currentTime = 0;
            this.bgm.play().catch(e => console.error("BGM play failed:", e));
        }
    },

    stopBgm() {
        if (this.bgm) {
            this.bgm.pause();
            this.bgm.currentTime = 0;
        }
    }
};
// ▲▲▲
// ▲▲▲
// ▲▲▲ ▲▲▲
// ▲▲▲

    // ▼▼▼ 100種類の日本の苗字リスト ▼▼▼
const JAPANESE_SURNAMES = [
    "佐藤", "鈴木", "高橋", "田中", "伊藤", "渡辺", "山本", "中村", "小林", "加藤",
    "吉田", "山田", "佐々木", "山口", "松本", "井上", "木村", "林", "斎藤", "清水",
    "山崎", "森", "池田", "橋本", "阿部", "石川", "山下", "中島", "石井", "小川",
    "前田", "岡田", "長谷川", "藤田", "後藤", "村上", "近藤", "坂本", "遠藤", "青木",
    "藤井", "西村", "三浦", "岡本", "松田", "中川", "中野", "原田", "小野", "田村",
    "竹内", "金子", "和田", "中山", "石田", "上田", "森田", "原", "柴田", "酒井",
    "工藤", "横山", "宮崎", "宮本", "内田", "高木", "安藤", "谷口", "大野", "丸山",
    "今井", "高田", "藤原", "武田", "松井", "杉山", "村田", "大塚", "千葉", "岩崎",
    "桜井", "野口", "松尾", "菊地", "野村", "新井", "渡部", "佐野", "安田", "宮田",
    "小島", "大西", "杉本", "市川", "古川", "久保", "川崎", "飯田", "中田", "堀"
];

// ▼▼▼ サウンド管理システム ▼▼▼

// ▲▲▲

// --- Team Master Data ---
    const TEAM_DATA = {
    "西浦": { name_yomi: "にしうら", region: "西部", type: "公立", deviation: 52, best: "県大会ベスト16", last: "県大会ベスト16", info: "三年前にできた新設校。歴史は浅いが驚異の躍進が光る。", coach: { name: '志賀 剛', style: '育成上手', experience: '新任' } },
    "本島越谷": { name_yomi: "もとじまこしがや", region: "東部", type: "私立", deviation: 32, best: "県大会ベスト8", last: "初戦敗退", info: "近年野球部に力を入れている新興私立。プロ野球選手を外部コーチに招聘している。", coach: { name: '元木 大介', style: '積極打撃', experience: 'プロOB' } },
    "海堂学園": { name_yomi: "かいどうがくえん", region: "西部", type: "私立", deviation: 40, best: "県大会ベスト8", last: "県大会2回戦", info: "かつては甲子園を優勝し県内で海堂ブームを巻き起こした。が、それも30年前の話であり、今となってはかつての輝きは見えない古豪と化している", coach: { name: '伊武 雅之', style: 'データ野球', experience: 'ベテラン' } },
    "初星学園": { name_yomi: "はつぼしがくえん", region: "中部", type: "私立", deviation: 58, best: "県大会2回戦", last: "初戦敗退", info: "県に複数あるナムコグループの設立した学校の一つ。野球部は設立したばかりで、部員数は多くないものの、そのポテンシャルは高く。毎年上位に食い込んでくる。野球部よりも学校としての特色であるアイドル科目当てに受験する人が多い。", coach: { name: '石川 実', style: '育成上手', experience: '中堅' } },
    "緑山": { name_yomi: "みどりやま", region: "中部", type: "公立", deviation: 45, best: "なし", last: "なし", info: "今年初めて野球部を新しく創立した公立校。全員1年生で経験は浅いが、ガッツで他校に食らいつきたい", coach: { name: '北村 大輔', style: '全員野球', experience: '新任' } },
    "765総合高校": { name_yomi: "なむこそうごう", region: "中部", type: "私立", deviation: 55, best: "県大会ベスト16", last: "県大会2回戦", info: "初星学園と経営母体は同じナムコグループであるがこちらは野球部に力を入れている。2年前には県を制覇し甲子園でもベスト16まで進んだ経験もあり、当時1年生からレギュラーだったメンバーが再び甲子園を目指し、聖地を知るものとしてチームを引っ張っている。", popularity: true, coach: { name: '黒井 崇男', style: '総合力', experience: 'ベテラン' } },
    "鷲尾": { name_yomi: "わしお", region: "中部", type: "公立", deviation: 53, best: "県大会ベスト16", last: "初戦敗退", info: "普通の公立校。昔は地区一番の進学校だったが立地の悪さと少子化に伴い偏差値も低下、近年は毎年定員割れを起こしており、廃校も時間の問題である。野球部もベスト16が過去に一度きりでパッとしない。", coach: { name: '鈴木 誠', style: '堅実', experience: 'ベテラン' } },
    "283学園": { name_yomi: "つばさがくえん", region: "西部", type: "私立", deviation: 60, best: "甲子園1回戦", last: "県優勝(甲子園初戦敗退)", info: "ナムコグループが15年前に設立した高校。昨年は2年生エース姫川が投打にわたりチームを引っ張り創部初の優勝を成し遂げた。昨年のレギュラーも複数残っており、大会連覇に向け、前回王者が牙を研ぐ。", popularity: true, coach: { name: '天井 努', style: 'ID野球', experience: '名将' } },
    "土理琉工業": { name_yomi: "どりるこうぎょう", region: "西部", type: "公立", deviation: 41, best: "県大会2回戦", last: "初戦敗退", info: "県で唯一の工業高校。野球部はあまり強くない。", coach: { name: '田中 鉄平', style: '根性野球', experience: 'ベテラン' } },
    "実践学園": { name_yomi: "じっせんがくえん", region: "中部", type: "私立", deviation: 63, best: "甲子園出場", last: "初戦敗退", info: "私立の進学校。野球部はあまり強くないが、サッカー部が強く、野球部の大会時には有志でサッカー部が応援に駆け付けオリジナルのサッカースタイルの応援で盛り立てる。これを実践学園の名物として見に来る隠れファンも多い。", coach: { name: '中田 譲二', style: '守備重視', experience: '中堅' } },
    "武蔵野第一": { name_yomi: "むさしのだいいち", region: "東部", type: "公立", deviation: 55, best: "県大会ベスト8", last: "県大会ベスト8", info: "公立進学校。野球部はここ数年初戦敗退が続いていたが、140km左腕の榛名の台頭により昨年の夏は創部初のベスト8に進出した。2年生となった榛名の速球は健在であり、今年も武蔵野旋風に期待したい。", coach: { name: '大川 透', style: '投手中心', experience: '中堅' } },
    "代矢東": { name_yomi: "だいやひがし", region: "東部", type: "公立", deviation: 65, best: "甲子園3回戦", last: "県大会ベスト4", info: "老若男女問わず地元民に愛される創立93年を迎える伝統校。近年は他校の私立との選手獲得競争に一つ遅れをとっており、甲子園からは遠ざかっているが、歴史は厚く、甲子園には通算13回出場している。そのため公立に似合わず多額の寄付により設備は充実している。頭もよくスポーツも強いため、県民の憧れである。代矢東の試合がある際には球場に多くのOBが駆け付け、大応援団を結成し、相手を圧倒する。近年はナムコグループが県内を牛耳りかけているため、公立の希望の星としてメディアに取り上げられることも多い。", popularity: true, coach: { name: '高島 礼', style: '伝統野球', experience: '名将' } },
    "風林大尾": { name_yomi: "ふうりんたいび", region: "東部", type: "私立", deviation: 59, best: "甲子園2回戦", last: "初戦敗退", info: "私立の進学校。昔は野球部が強かったが監督の不祥事により一度は廃部危機にまでなった。昔よりは勢いはないが、経営体制を一新しイメージのクリーン化に努めた結果、部員数も回復してきた。そろそろ古豪として、復活の狼煙をあげたい。", coach: { name: '林田 健太郎', style: '機動力野球', experience: '期待の若手' } },
    "青道": { name_yomi: "せいどう", region: "西部", type: "私立", deviation: 54, best: "甲子園準優勝", last: "県大会ベスト8", info: "28年前に甲子園準優勝の経験もある強豪校。毎年ベスト8までは安定して出場するが、近年はそこが壁となり突破できずにいる。今年こそは甲子園へ、と学校側のサポートも厚い。", popularity: true, coach: { name: '片岡 鉄心', style: '守備重視', experience: '名将' } },
    "聖秀": { name_yomi: "せいしゅう", region: "東部", type: "私立", deviation: 48, best: "なし", last: "なし", info: "野球部創部一年目の新米野球部。部員は10人と少ないが主将で3番を打つ茂野が攻守でチームを引っ張る。", coach: { name: '茂野 吾郎', style: '超攻撃型', experience: '新任' } },
    "大船渡": { name_yomi: "おおふなと", region: "東部", type: "公立", deviation: 51, best: "甲子園出場", last: "初戦敗退", info: "甲子園出場ほどではないものの、公立校の中ではれっきとした実力をもつ中堅校。今年はプロ注目右腕の斎藤を擁し甲子園初出場を狙う。", coach: { name: '佐々木 朗', style: '投手中心', experience: '中堅' } },
    "美城学園": { name_yomi: "みしろがくえん", region: "中部", type: "私立", deviation: 61, best: "県大会ベスト4", last: "県大会2回戦", info: "ナムコグループを母体とする高校。こちらの野球部は中堅校として県内でなお馳せており、組み合わせ次第では甲子園も狙える実力を持っている。近年はほかの高校にリソースを持っていかれ、ナムコグループの中だと低迷気味である。", coach: { name: '三城 常務', style: 'エリート野球', experience: 'ベテラン' } },
    "東大学園": { name_yomi: "とうだいがくえん", region: "中部", type: "私立", deviation: 78, best: "県大会2回戦", last: "初戦敗退", info: "全国的に有名な進学校。野球部は弱いが、持ち前の頭脳を活かしたデータ野球で強豪校に食らいつきたい。", coach: { name: '京大 一郎', style: 'データ野球', experience: '中堅' } },
    "金足農業": { name_yomi: "かなあしのうぎょう", region: "東部", type: "公立", deviation: 42, best: "甲子園準優勝", last: "県大会2回戦", info: "数年前には金農フィーバーで一世を風靡したが、その後は低迷している。もう一度輝くべく甲子園を狙っている。", popularity: true, coach: { name: '吉田 輝夫', style: '全員野球', experience: 'ベテラン' } },
    "御殿場南": { name_yomi: "ごてんばみなみ", region: "東部", type: "公立", deviation: 54, best: "県大会ベスト16", last: "県大会ベスト16", info: "山間部にある公立校。毎年初戦敗退が続いていたが昨年は11年ぶり初戦突破を皮切りに50年ぶりのベスト16に進出。今年も躍進へ期待がかかる。", coach: { name: '山内 浩司', style: '堅実', experience: '中堅' } },
    "雷門南": { name_yomi: "らいもんみなみ", region: "西部", type: "公立", deviation: 61, best: "甲子園2回戦", last: "県大会ベスト4", info: "代矢東と並ぶ県内二大大規模公立のひとつ。代矢東が文武両道ならばこちらはスポーツが盛んである。特にラグビー部サッカー部は全国制覇を成し遂げており、野球部の躍進にも期待がかかる。", coach: { name: '円堂 守', style: '超次元野球', experience: '名将' } },
    "横須賀": { name_yomi: "よこすか", region: "西部", type: "公立", deviation: 55, best: "甲子園出場", last: "県大会2回戦", info: "海辺にある公立校。野球部としては中堅校である。", coach: { name: '山口 一', style: '機動力野球', experience: 'ベテラン' } },
    "今治学園": { name_yomi: "いまばりがくえん", region: "西部", type: "私立", deviation: 52, best: "県大会ベスト16", last: "県大会ベスト16", info: "体育科のみの通信制私立。着々と結果を出しており、昨年はベスト16", coach: { name: '岡田 武史', style: '育成上手', experience: 'ベテラン' } },
    "田辺水産": { name_yomi: "たなべすいさん", region: "中部", type: "公立", deviation: 44, best: "県大会ベスト4", last: "県大会2回戦", info: "貴重な水産高校。野球部も一昨年はベスト4へ進出したりと勢いがある。試合時のスタンドには大漁とかかれた大きな旗が舞う。", coach: { name: '浜田 大吉', style: '積極打撃', experience: '中堅' } },
    "八千代": { name_yomi: "やちよ", region: "中部", type: "公立", deviation: 59, best: "県大会ベスト8", last: "初戦敗退", info: "大きな市にある。中規模公立。野球部としての特色はこれといってないが、人口が多い地域のため、毎年それなりのレベルの新入生が集まる。", coach: { name: '千葉 繁', style: '総合力', experience: 'ベテラン' } },
    "日南学園": { name_yomi: "にちなんがくえん", region: "西部", type: "私立", deviation: 46, best: "甲子園ベスト4", last: "初戦敗退", info: "野球部はそこそこつよいがガラが悪く、メディア受けが悪い。", coach: { name: '金本 知憲', style: '積極打撃', experience: 'プロOB' } },
    "薬師": { name_yomi: "やくし", region: "東部", type: "私立", deviation: 50, best: "甲子園出場", last: "県大会2回戦", info: "普通の私立高校だが、たまに上位にくる。", coach: { name: '轟 雷蔵', style: '打撃偏重', experience: 'ベテラン' } },
    "稲城実業": { name_yomi: "いなしろじつぎょう", region: "西部", type: "私立", deviation: 57, best: "甲子園優勝", last: "県大会ベスト8", info: "野球部に力を入れている私立。毎年ベスト8の壁に苦しんでいるが、成宮、平野、赤松の三枚看板で甲子園を目指す。", popularity: true, coach: { name: '国友 広重', style: '総合力', experience: '名将' } },
    "市大三": { name_yomi: "しだいさん", region: "西部", type: "私立", deviation: 56, best: "甲子園出場", last: "県大会2回戦", info: "こちらもベスト８や16にはよく顔をだす私立校。総合力はあるもののパッとしない。", coach: { name: '田崎 圭介', style: '堅実', experience: 'ベテラン' } },
    "極亜久": { name_yomi: "ごくあく", region: "東部", type: "私立", deviation: 38, best: "甲子園出場", last: "初戦敗退", info: "むかしは甲子園にも出場したことある学校。今は少子化のあおりを受け、ただの低偏差値高校になっている。", coach: { name: '影山 秀路', style: 'ラフプレー', experience: 'ベテラン' } },
    "銀河学院": { name_yomi: "ぎんががくいん", region: "中部", type: "私立", deviation: 55, best: "甲子園出場", last: "県大会ベスト16", info: "VRを取り入れたトレーニングを行う珍しい学校。よく野球youtuberに取り上げられている。野球部の成績もボチボチ", coach: { name: '速水 奨', style: 'データ野球', experience: '中堅' } },
    "猫矢": { name_yomi: "ねこや", region: "中部", type: "公立", deviation: 49, best: "県大会2回戦", last: "初戦敗退", info: "人口1万人ほどの町にある小規模な公立校。チャンス応援時にはその校名にちなんで「猫ダンス」を披露する。", coach: { name: '猫田 権蔵', style: '機動力野球', experience: 'ベテラン' } },
    "虎府島総合": { name_yomi: "こふとうそうごう", region: "西部", type: "公立", deviation: 47, best: "県大会ベスト16", last: "初戦敗退", info: "離島にある公立校。移動の際には巨額の資金が必要なので、本島へ遠征はめったにやらない。そのため、練習試合は基本的に組まれないが「虎府島スピリッツ」を胸にベスト8を目指す。島民からの信頼も厚く、試合時には島民の5割が駆け付けてくるらしい。", coach: { name: '島袋 譲二', style: '全員野球', experience: 'ベテラン' } },
    "力全": { name_yomi: "りきぜん", region: "東部", type: "公立", deviation: 51, best: "県大会ベスト8", last: "初戦敗退", info: "校名通り、力こそ全てが校訓の公立校。練習ではウエイトメニューが6割を占めるが、私立の栄養状態にはかなわず、いつも強豪私立に競り負けてしまう。", coach: { name: '金剛 毅', style: 'パワー野球', experience: '中堅' } },
    "帝王実業": { name_yomi: "ていおうじつぎょう", region: "中部", type: "私立", deviation: 55, best: "甲子園優勝", last: "初戦敗退", info: "古豪。半世紀前は5連覇をするほどの実力を持っていたが、それは過去の話。最近ではベスト8にも上がってこないので、復活を待ち望む声も多い。", coach: { name: '犬飼 賢人', style: '守備重視', experience: '名将' } },
    "小束": { name_yomi: "こづか", region: "西部", type: "私立", deviation: 56, best: "県大会ベスト4", last: "県大会ベスト16", info: "昔からある歴史のある私立校。野球部の成績も安定的に初戦は突破するものの上位にはいまいち食い込めないでいる。そろそろ覚醒に期待したい。", coach: { name: '小和田 雅人', style: '堅実', experience: 'ベテラン' } },
    "豊中學園": { name_yomi: "とよなかがくえん", region: "東部", type: "私立", deviation: 60, best: "県大会ベスト4", last: "県大会ベスト16", info: "ダークホース。強い高校にはめっぽう強く、二大公立やナムコグループ系列の高校には相性がいいが、普通の公立中堅校の試合では競り負けてしまう残念なチーム。実力は確かなので、ジンクスを解消したい。", coach: { name: '豊臣 秀幸', style: '奇策', experience: '策士' } },
    "須磨東": { name_yomi: "すまひがし", region: "東部", type: "私立", deviation: 61, best: "県大会ベスト8", last: "県大会ベスト16", info: "4年前はは準優勝したものの、ここ最近ではベスト16止まりが続く。", coach: { name: '須田 幸雄', style: '総合力', experience: 'ベテラン' } },
    "283学園B": { name_yomi: "つばさがくえんB", region: "西部", type: "私立", deviation: 59, best: "なし", last: "なし", info: "昨年の優勝により部員数が急激に増加した283学園。あまりにも試合に出れない人数が多いので理事長の配慮でbチームを作った。基本的に本部校でレギュラーになれなかったものたちの寄せ集めなので勝ち上がれないが、部員たちは打倒283学園を目指し頑張っている。県内からは同じ県内に同じ高校のチームの二つ目を作り大会に参加させるのは違反行為なのでは、という声が多く上がったが、県内はナムコグループが牛耳っているため、ごり押しで可決させた。", coach: { name: '七草 はづき', style: '育成上手', experience: '期待の若手' } },
    "城場羅": { name_yomi: "じょうばら", region: "伊豆", type: "私立", deviation: 43, best: "県大会2回戦", last: "県大会2回戦", info: "去年共学になった。野球部も学校側が盛り上げようと、女子率を活かした大規模吹奏楽応援で球場の雰囲気を作る。", coach: { name: '伊集院 隼人', style: '機動力野球', experience: '期待の若手' } },
    "女子大共立": { name_yomi: "じょしだいきょうりつ", region: "中部", type: "私立", deviation: 63, best: "県大会2回戦", last: "県大会2回戦", info: "元女子高。野球部員よりもマネージャーの数の方が多い。", coach: { name: '高橋 留美', style: '守備重視', experience: '中堅' } },
    "天下無双学園": { name_yomi: "てんかむそう", region: "東部", type: "私立", deviation: 55, best: "県準優勝", last: "県準優勝", info: "打撃こそ野球。がモットーの打撃型チーム。中堅校以下にはめっぽう強いが、甲子園出場レベルの相手にはめっぽう弱い。", coach: { name: '織田 信長', style: '超攻撃型', experience: 'ベテラン' } },
    "横浜": { name_yomi: "よこはま", region: "東部", type: "公立", deviation: 62, best: "県大会ベスト16", last: "県大会2回戦", info: "公立ではあるものの、プロ野球選手のOBからの支援により設備は充実。その影響か、近年少しずつ力をつけている。", coach: { name: '渡辺 元智', style: '総合力', experience: '名将' } },
    "あかつき大付属": { name_yomi: "あかつきだいふぞく", region: "西部", type: "私立", deviation: 60, best: "甲子園準優勝", last: "県大会ベスト8", info: "甲子園を狙う野球二番手校。学校に集まってくるのは他校でセレクションに落ちたものの集まりである。", coach: { name: '猪狩 茂', style: '投手中心', experience: 'ベテラン' } },
    "ときめき青春": { name_yomi: "ときめきせいしゅん", region: "中部", type: "私立", deviation: 57, best: "甲子園出場", last: "県大会2回戦", info: "中堅校。ユニークな名前とは裏腹に侮れない実力を持つ。", coach: { name: '藤崎 詩織', style: 'データ野球', experience: '期待の若手' } },
    "干鰯大付属": { name_yomi: "ひわしだいふぞく", region: "中部", type: "私立", deviation: 49, best: "県大会ベスト16", last: "県大会2回戦", info: "中堅校。野球部としての実績はないが、大学付属校のため、それなりのメンバーが集まるため、そこそこの戦力になる。", coach: { name: '鰯水 等', style: '堅実', experience: '中堅' } },
    "AOHARU学院": { name_yomi: "アオハルがくいん", region: "西部", type: "私立", deviation: 54, best: "甲子園ベスト8", last: "県大会2回戦", info: "中堅校。13年前には甲子園出場経験もある私立校。今では当時のエースだった青葉健司が監督となり、母校を再び聖地へと導こうとしている。", coach: { name: '青葉 健司', style: '育成上手', experience: '期待の若手' } },
    "場須前第一": { name_yomi: "ばすまえだいいち", region: "東部", type: "公立", deviation: 53, best: "県大会2回戦", last: "初戦敗退", info: "野球部としての特色はないが、学校としてはその校名にちなんで、バスの運転手になるためのコースが設けられている。", coach: { name: '安全 太郎', style: '守備重視', experience: 'ベテラン' } },
    "北斗": { name_yomi: "ほくと", region: "東部", type: "公立", deviation: 58, best: "甲子園ベスト16", last: "初戦敗退", info: "30年前には甲子園経験もある。今では私立優勢になり、鳴りを潜めたが、もう一度輝いてほしい、と地元住民からの期待は高い。", coach: { name: '拳崎 史郎', style: '積極打撃', experience: 'ベテラン' } },
    "赤霧大那覇": { name_yomi: "あかぎりだいなは", region: "西部", type: "私立", deviation: 51, best: "県大会ベスト8", last: "県大会2回戦", info: "中堅校。セイバーメトリクスを利用した効率的な野球で勝利を狙う。", coach: { name: '赤嶺 譲二', style: 'データ野球', experience: '中堅' } },
    "極星学園": { name_yomi: "きょくせいがくえん", region: "西部", type: "私立", deviation: 49, best: "県大会ベスト4", last: "県大会2回戦", info: "中堅校。県内に蔓延るナムコグループに対抗して、極グループが設立した極星学園。5年前にはベスト4まで進出する快進撃を見せた侮れないチームである。", coach: { name: '桐生 一馬', style: '根性野球', experience: '伝説' } },
    "県立由暇": { name_yomi: "けんりつゆか", region: "中部", type: "公立", deviation: 48, best: "県大会初戦敗退", last: "初戦敗退", info: "普通の公立。公式戦で勝ったことがない。", coach: { name: '田中 一郎', style: '堅実', experience: '中堅' } },
    "足利": { name_yomi: "あしかが", region: "東部", type: "公立", deviation: 52, best: "県大会ベスト16", last: "初戦敗退", info: "県名物「足利山」のふもとに位置する高校。トレーニングでは足利山を利用したマラソンをする。", coach: { name: '山路 和弘', style: '機動力野球', experience: 'ベテラン' } },
    "常翔学園": { name_yomi: "じょうしょうがくえん", region: "中部", type: "私立", deviation: 61, best: "甲子園出場", last: "県大会ベスト16", info: "中堅校。設立して19年と月日は浅いが、甲子園経験のある実力校。今年は、過去に帝王実業で甲子園連覇した際のチームの指揮を執っていた國村監督を招聘し、躍進が期待される。", coach: { name: '國村 隼', style: '総合力', experience: '名将' } },
    "音駒": { name_yomi: "ねこま", region: "東部", type: "公立", deviation: 62, best: "県大会ベスト16", last: "初戦敗退", info: "校名通り、吹奏楽部が売りの公立校。", coach: { name: '猫又 育史', style: '守備重視', experience: 'ベテラン' } },
    "七森": { name_yomi: "ななもり", region: "東部", type: "公立", deviation: 55, best: "県大会2回戦", last: "初戦敗退", info: "自由主義が校訓の公立校。常識にとらわれない発想は、野球のどう影響を及ぼすのだろうか。", coach: { name: '西垣 奈々', style: '奇策', experience: '期待の若手' } },
    "珠湖": { name_yomi: "たまこ", region: "伊豆", type: "公立", deviation: 50, best: "県大会初戦敗退", last: "初戦敗退", info: "湖の近くに位置する小規模の学校。公式戦で勝ったことがない。", coach: { name: '水上 善次', style: '堅実', experience: '中堅' } },
    "潮見": { name_yomi: "しおみ", region: "西部", type: "公立", deviation: 57, best: "県大会ベスト8", last: "初戦敗退", info: "たまに中盤まで勝ち進むが基本的にはトーナメント序盤での敗退が多い。", coach: { name: '海野 平', style: '機動力野球', experience: 'ベテラン' } },
    "市立根戸": { name_yomi: "しりつねど", region: "伊豆", type: "公立", deviation: 46, best: "県大会ベスト16", last: "初戦敗退", info: "70年の歴史をもつ伝統校。野球部が盛り上がれば、地域も盛り上がるだろう。", coach: { name: '根本 陸夫', style: '育成上手', experience: 'ベテラン' } },
    "福井": { name_yomi: "ふくい", region: "中部", type: "公立", deviation: 53, best: "県大会ベスト16", last: "初戦敗退", info: "バランスの良い公立校。毎年それなりのチームに仕上げてきているが、籤運が悪く、強豪私立に轢かれている。", coach: { name: '井上 和彦', style: '総合力', experience: '中堅' } },
    "春日井中央": { name_yomi: "かすがいちゅうおう", region: "中部", type: "公立", deviation: 59, best: "県大会ベスト4", last: "初戦敗退", info: "過去にはベスト4の経験もある公立校。", coach: { name: '伊藤 健太郎', style: '積極打撃', experience: 'ベテラン' } },
    "高槻南": { name_yomi: "たかつきみなみ", region: "西部", type: "公立", deviation: 56, best: "県大会2回戦", last: "初戦敗退", info: "今年学校を改築し、新校舎となったうえで迎える初めての夏、野球部が盛り上がれば学校としての人気も爆発的に伸びるのではないだろうか。", coach: { name: '高木 渉', style: '育成上手', experience: '期待の若手' } },
    "島田": { name_yomi: "しまだ", region: "中部", type: "公立", deviation: 53, best: "県大会2回戦", last: "初戦敗退", info: "大正8年からある古い学校だが、野球部の実績は乏しい。以前は部員数が足りない際には伊豆中央と連合チームを組んでいた。", coach: { name: '島本 宏', style: '堅実', experience: '中堅' } },
    "伊豆中央": { name_yomi: "いずちゅうおう", region: "伊豆", type: "公立", deviation: 51, best: "県大会2回戦", last: "初戦敗退", info: "今年は久しぶりにメンバーがそろい、単独チームでの出場となった。以前は部員数が足りない際には島田と連合チームを組んでいた。", coach: { name: '中田 島蔵', style: '全員野球', experience: '中堅' } }
};
    const DETAILED_TEAM_DATA = {
        "283学園": {
            summary: "夏の連覇の先に、聖地での勝利を目指す。昨年王者、守備の一体感と打線のつながりを強みに、試合ごとに成長。チームスローガンは『強』。個の技量に頼らず、一人ひとりの力を集めて戦う。",
            players: [
                { name: "姫川友紀", year: 3, position: "ピッチャー", desc: "投打の中心。MAX151kmの直球とスプリット、高校通算42本塁打の怪物。" },
                { name: "花海咲", year: 3, position: "センター", desc: "走攻守三拍子揃ったリードオフマン。監督が「ものが違う」と絶賛。" },
                { name: "鈴木佐奈", year: 2, position: "ファースト", desc: "芯で捉える技術を持つ打者。守備でも存在感。" },
                { name: "十王星南", year: 3, position: "ショート", desc: "鉄壁の守備を誇る名手。チャンスメイクも得意な打者。" },
                { name: "浅倉享", year: 2, position: "レフト", desc: "2年生ながら5番に座ることもあるクラッチヒッター。ポテンシャルが高い。" },
                { name: "島村海斗", year: 3, position: "サード", desc: "強肩強打のパワーヒッター。勝負強い打撃が光る。" },
                { name: "有栖川悠覇", year: 3, position: "キャッチャー", desc: "大舞台に強い主軸。変化球打ちの技術はチームトップクラス。" },
                { name: "芹沢優吾", year: 2, position: "セカンド", desc: "小技と守備センスが光る二塁手。チャンスでの一打も。" },
                { name: "花海佑", year: 1, position: "ライト", desc: "1年生のスーパースター。兄・雄介との連携も抜群。既に通算13本塁打。" },
                { name: "天海晴彦", year: 2, position: "ピッチャー", desc: "チーム最速の直球を持つ。春はメンバー外の悔しさをバネに復調を目指す。" },
                { name: "ピーター", year: 3, position: "ピッチャー", desc: "春の大会で完全試合を達成。伸び上がるストレートが武器。" }
            ]
        },
        "天下無双学園": {
            summary: "個々のレベルアップが結実し昨年は準優勝。個人成績の可視化と実力主義でチーム内の競争を活性化させ、初の甲子園を目指す。スローガンは『個々の能力重視』。",
            players: [
                { name: "沖田総司", year: 3, position: "ピッチャー", desc: "投打の大黒柱。MAX157kmの速球を持つ主砲。" },
                { name: "土方任三郎", year: 3, position: "キャッチャー", desc: "グラウンド上の監督。高いスローイング技術と高校通算28本塁打のパワーを持つ。" },
                { name: "宮本和佐", year: 3, position: "ファースト", desc: "力強い打撃と勝負強さが魅力の3番打者。" },
                { name: "柳生俊昌", year: 2, position: "セカンド", desc: "バッティングセンスに優れる2年生。落ち着いたプレーが光る。" },
                { name: "近藤春樹", year: 3, position: "サード", desc: "ガッツあふれるプレーでチームを引っ張る5番打者。高校通算46本塁打。" },
                { name: "坂本俊樹", year: 3, position: "ショート", desc: "走攻守三拍子揃った抜群の身体能力を持つショート。" },
                { name: "岡田克也", year: 3, position: "ライト", desc: "高校通算71本塁打を誇る絶対的な4番。恵まれた体格からの強打が武器。" },
                { name: "森晴継", year: 2, position: "センター", desc: "50m6秒フラットの俊足。攻守にわたり抜群の勝負強さを見せる。" },
                { name: "上泉誠", year: 3, position: "レフト", desc: "バランスと勝負強い打撃が武器。逆転劇のきっかけを作る。" },
                { name: "拝拓也", year: 3, position: "ピッチャー", desc: "巧みな投球術と強い精神力を持つ控え投手。MAX155km。" },
                { name: "疋田文也", year: 2, position: "ピッチャー", desc: "クレバーさと強気を兼ね備えた2年生投手。昨夏も登板経験あり。" }
            ]
        },
        "雷門南": {
            summary: "昨年ベスト4。選手の長所を活かす野球で、磨き上げた守備力とタイプの違う3年生投手3人の継投を武器に、2005年以来の夏の聖地を目指す。",
            players: [
                { name: "豪炎寺秀一", year: 3, position: "ピッチャー", desc: "最速158kmの直球と縦スライダーで打者を打ち取る絶対的エース。" },
                { name: "円堂憲作", year: 3, position: "キャッチャー", desc: "冷静なリードで多彩な投手陣を引っ張る扇の要。3番打者としても活躍。" },
                { name: "壁山英二郎", year: 3, position: "ファースト", desc: "190cmの長身を生かした守備と長打力が魅力。" },
                { name: "半田慎二", year: 3, position: "セカンド", desc: "小柄ながら攻守に堅実なプレーでチームに貢献。" },
                { name: "一ノ瀬拓郎", year: 3, position: "サード", desc: "チーム一の打球の速さを誇る2番打者。" },
                { name: "土門海斗", year: 3, position: "ショート", desc: "ミスの少ない堅実な守備で試合のリズムを作る内野の要。" },
                { name: "染岡竜吾", year: 3, position: "レフト", desc: "監督も絶大な信頼を寄せる大砲。気持ちの強さも魅力。" },
                { name: "風丸一郎", year: 3, position: "センター", desc: "サイクルヒット達成経験もあるリードオフマン。ミート力が格段にアップ。" },
                { name: "栗松鉄平", year: 2, position: "ライト", desc: "力強いスイングから放たれる長打が魅力の2年生。" },
                { name: "鬼道優斗", year: 3, position: "ピッチャー", desc: "キレのある縦スライダーと内角への直球が魅力の右腕。" },
                { name: "松野裕介", year: 2, position: "ピッチャー", desc: "MAX144kmのストレートとカットボールが武器の2年生。奪三振能力が高い。" }
            ]
        },
        "代矢東": {
            summary: "投打の大黒柱を中心にダイナミックなベースボールを展開。攻めの姿勢を貫き、1999年以来の聖地を見据える伝統校。どこからでも得点できる打線が強み。",
            players: [
                { name: "渋谷卓", year: 3, position: "ピッチャー", desc: "常時150km超の速球を投げる本格派エース。" },
                { name: "片野坂晴人", year: 3, position: "キャッチャー", desc: "小柄ながら強肩強打の司令塔。盗塁阻止率は随一。" },
                { name: "郷野将暉", year: 3, position: "ファースト", desc: "高校通算63本塁打のプロ注目スラッガー。得点圏での勝負強さが光る。" },
                { name: "片倉郁弥", year: 3, position: "セカンド", desc: "俊足と広い守備範囲が武器の機動力内野手。" },
                { name: "島津成哉", year: 3, position: "サード", desc: "反応速度と強肩が武器の守備の要。広角に打ち分ける打撃も。" },
                { name: "藤原元輝", year: 3, position: "ショート", desc: "軽快なフットワークが光る守備職人。つなぎ役もこなす。" },
                { name: "倉科哲史", year: 3, position: "レフト", desc: "小柄ながら高い身体能力を持つ。クリーンアップの前を打つ。" },
                { name: "滝川文隆", year: 3, position: "センター", desc: "抜群の走力でセンターラインを統率するリードオフマン。" },
                { name: "川又良太", year: 3, position: "ライト", desc: "安定した打率を誇る右打者。正確な返球も魅力。" },
                { name: "六反田良弥", year: 3, position: "ピッチャー", desc: "最速152kmの剛腕。リリーフも先発もこなす万能型。" },
                { name: "鳥羽晴康", year: 3, position: "ピッチャー", desc: "左腕から多彩な変化球を投げるクローザー的存在。" }
            ]
        },
        "青道": {
            summary: "昨年ベスト8。選手の長所を活かした攻撃力と堅守を武器に雪辱を期す。タイプの異なる3人の投手による継投が強み。",
            players: [
                { name: "沢村栄玲", year: 2, position: "ピッチャー", desc: "最速140kmの直球と多彩な変化球で三振を奪う次世代エース左腕。" },
                { name: "降谷暁", year: 3, position: "ピッチャー", desc: "長身から投げ下ろすスライダーとシュートが武器の大型右腕。" },
                { name: "御幸一也", year: 3, position: "キャッチャー", desc: "攻守にわたる高い野球センスを誇るプロ注目の司令塔。" },
                { name: "前園裕太", year: 2, position: "一塁手／外野手", desc: "高い打撃技術と強肩を持つ大型野手。" },
                { name: "小湊夏樹", year: 3, position: "二塁手", desc: "堅実な守備と巧みなバットコントロールが光る。" },
                { name: "金丸真也", year: 3, position: "三塁手", desc: "打球反応が速く、強肩が武器。中距離ヒッター。" },
                { name: "倉持実", year: 2, position: "ショート", desc: "俊敏な動きと華麗な守備が魅力の内野の要。" },
                { name: "結城大介", year: 3, position: "レフト", desc: "長打力を武器に快音を響かせる強打者。" },
                { name: "東条光希", year: 3, position: "センター", desc: "強肩と確実な捕球で外野を統率する守備職人。" },
                { name: "白洲浩司", year: 3, position: "ライト", desc: "打撃センスが光る左打者。冷静な状況判断が持ち味。" }
            ]
        },
        "武蔵野第一": {
            summary: "雪辱を期す知性派軍団。絶対的エース榛名を擁し、データを駆使した緻密な野球で昨夏の悔しさを晴らす。チームスローガンは『知は力なり』。",
            players: [
                { name: "榛名 元希", year: 3, position: "ピッチャー", desc: "最速140km後半の直球と高速スライダーで三振の山を築く絶対的エース。" },
                { name: "秋丸協平", year: 3, position: "キャッチャー", desc: "冷静沈着なリードでエース榛名を支える扇の要。" },
                { name: "大川 公彦", year: 3, position: "ファースト", desc: "チーム不動の4番。一振りで試合の流れを変えるパワーが魅力。" },
                { name: "福原 恭介", year: 3, position: "ショート", desc: "卓越したバットコントロールと選球眼を持つ1番打者。守備も堅実。" },
                { name: "町田誠", year: 3, position: "センター", desc: "走攻守三拍子揃ったアベレージヒッター。3番を担う。" }
            ]
        },
        "稲城実業": {
            summary: "王座奪還へ、揺るぎなき『王国』のプライド。昨年の雪辱に燃える絶対王者。投打にタレントを揃え、最強左腕・成宮を軸に再び全国の頂点を目指す。スローガンは『常勝』。",
            players: [
                { name: "成宮 鳴", year: 3, position: "ピッチャー", desc: "「キング」の異名を持つ世代最強左腕。MAX150km/hの直球と魔球チェンジアップを操る。" },
                { name: "神谷 カルロス 俊樹", year: 3, position: "センター", desc: "50m5秒台の俊足を誇る「チーター」。攻守に規格外の身体能力を見せる。" },
                { name: "白河 勝之", year: 3, position: "ショート", desc: "卓越した野球センスと華麗な守備が光る内野の司令塔。" },
                { name: "多田野 樹", year: 2, position: "キャッチャー", desc: "「キング」成宮の女房役を射止めた2年生捕手。冷静なリードが持ち味。" },
                { name: "山岡 陸", year: 3, position: "サード", desc: "稲実の新たな4番打者。勝負強いクラッチヒッター。高校通算61本。" }
            ]
        },
        "あかつき大付属": {
            summary: "あかつき史上最強の『黄金世代』。投打の柱・猪狩兄弟を擁し、個の力で世代の頂点を証明する。セレクション落ちの雑草軍団が狙うは完全優勝。スローガンは『実力主義』。",
            players: [
                { name: "猪狩 守", year: 3, position: "ピッチャー", desc: "「黄金世代」を率いるキャプテンにして絶対的エース。「ライジングキャノン」と呼ばれる剛速球が武器。" },
                { name: "猪狩 進", year: 2, position: "キャッチャー", desc: "兄・守とバッテリーを組む天才捕手。「球界の頭脳」と称されるリードと俊足が武器。" },
                { name: "三本松 一", year: 3, position: "ファースト", desc: "不動の4番。高校生離れしたパワーを誇る規格外の長距離砲。" },
                { name: "七井将暉", year: 3, position: "レフト", desc: "三本松と双璧をなす長距離砲。広角に打ち分ける技術と「バズーカ」強肩も。" },
                { name: "矢部 翔雄", year: 3, position: "センター", desc: "俊足が武器の外野手。意外な勝負強さも見せる。" }
            ]
        }
    };
    const INITIAL_TEAM_POOL = Object.keys(TEAM_DATA);

    // --- Utility & State Functions ---
   

 function shuffleArray(array) {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
    }
    
    function saveState() {
        try {
            localStorage.setItem('tournamentState', JSON.stringify(tournamentState));
        } catch (e) {
            console.error("進行状況の保存に失敗しました:", e);
            showAlert("進行状況の保存に失敗しました。ブラウザのストレージ容量が不足している可能性があります。");
        }
    }
    
    function uint8ArrayToBase64(bytes) {
        let binary = '';
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    function getRankFromHistoryString(historyString) {
        if (historyString.includes('優勝')) return 1;
        if (historyString.includes('準優勝')) return 2;
        if (historyString.includes('ベスト4')) return 4;
        if (historyString.includes('ベスト8')) return 8;
        if (historyString.includes('ベスト16')) return 16;
        if (historyString.includes('3回戦')) return 16;
        if (historyString.includes('2回戦')) return 32;
        if (historyString.includes('初戦敗退')) return 64;
        return 64;
    }

    function getRankString(rank) {
 // ★★★ このifブロックを関数の先頭に追加 ★★★
    if (rank <= -1) {
        for (const key in KOSHIEN_RESULTS) {
            if (KOSHIEN_RESULTS[key].rank === rank) {
                return KOSHIEN_RESULTS[key].label;
            }
        }
    }
    // ★★★ ここまで追加 ★★★
        if (rank === 1) return "優勝";
        if (rank === 2) return "準優勝";
        if (rank <= 4) return "ベスト4";
        if (rank <= 8) return "ベスト8";
        if (rank <= 16) return "ベスト16";
        if (rank <= 32) return "3回戦敗退";
        if (rank <= 64) return "2回戦敗退";
        return "初戦敗退";
    }
// --- Utility & State Functions --- などに追加

/**
 * Creates a subtle, realistic dust particle animation.
 */
function createDustEffect() {
    const container = document.getElementById('dust-container');
    if (!container) return;
    
    const particleCount = 20; // The number of dust particles

    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'dust-particle';
        
        const size = Math.random() * 3 + 1; // Particle size between 1px and 4px
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // Use CSS variables to randomize the start and end points of the animation
        particle.style.setProperty('--x-start', `${Math.random() * 100}vw`);
        particle.style.setProperty('--x-end', `${Math.random() * 100}vw`);
        
        particle.style.animationDuration = `${Math.random() * 20 + 10}s`; // Duration between 10s and 30s
        particle.style.animationDelay = `${Math.random() * 10}s`; // Stagger the start time
        
        container.appendChild(particle);
    }
}
/**
 * スコアボードの合計点を更新する
 */
/**
/**
 * スコアボードの合計点を更新する
 */
function updateTotalScores() {
    const table = document.getElementById('inning-score-table');
    if(!table) return;

    table.querySelectorAll('tbody tr').forEach(row => {
        const total = Array.from(row.querySelectorAll('input')).reduce((sum, input) => {
            const value = parseInt(input.value);
            return isNaN(value) ? sum : sum + value;
        }, 0);
        
        const totalCell = row.querySelector('.total-score');
        if (totalCell) {
            totalCell.textContent = total;
        }
    });
}
/**
 * 戦績レコードを読みやすい文字列に変換する
 */
function formatRecordToString(record) {
    if (!record) return "データなし";
    const year = record.year.toString().slice(-2);
    const tournamentNameMap = { summer: '夏', autumn: '秋', spring: '春' };
    const tournament = tournamentNameMap[record.tournament] || '';
    const rank = getRankString(record.rank);
    // ★★★ 以下の行を変更 ★★★
    const prefix = record.rank < 0 ? '' : '県大会'; // 甲子園成績の場合は「県大会」をつけない
    return `'${year} ${tournament}: ${prefix}${rank}`;
    // ★★★ ここまで変更 ★★★
}

// AI Content Generation & Helpers のセクションに追加

// ▼▼▼ このブロックをまるごと追加 ▼▼▼

// ▼▼▼ この関数をまるごと追加 ▼▼▼
/**
 * 本格的なまとめサイトのHTMLを、現実と架空のニュースを融合させて生成する（エラー修正・ダミーデータ強化版）
 * @returns {Promise<string>} 生成されたHTML文字列
 */
async function generateMatomeSiteHtml() {
    let articles = [];
    const now = Date.now();

    // --- 1. 現実のニュースを、自作のサーバーにリクエストして取得 ---
    const searchQueries = [
        { query: "日本の最新ニュース 政治", category: "政治" },
        { query: "芸能ニュース 速報", category: "芸能" },
        { query: "なんj 学歴スレ", category: "学歴" },
        { query: "プロ野球 試合結果", category: "プロ野球" },
        { query: "大谷翔平 速報", category: "MLB" },
    ];

    try {
        // サーバーの「/get-news」というドアを叩いて、ニュースを要求する
        const response = await fetch('/.netlify/functions/get-news', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ queries: searchQueries.map(q => q.query) })
        });
        const searchResults = await response.json();
        
        // --- 2. AIによる「スレタイ化」は、本格実装ではサーバー側で行うのが理想だが、今回はフロントで実行 ---
        searchResults.forEach((result, index) => {
            if (result && result.items && result.items.length > 0) {
                const topHit = result.items[0];
                articles.push({
                    headline: `【${searchQueries[index].category}】${topHit.title}`,
                    type: 'real',
                    timestamp: now - Math.random() * 1000 * 3600 * 2,
                    category: searchQueries[index].category
                });
            }
        });

    } catch (e) {
        console.error("サーバーからのニュース取得に失敗しました:", e);
        articles.push({ headline: "【速報】ニュースサーバー、ダウン中", type: 'real', timestamp: now, category: 'システム' });
    }

    // --- 2. ゲーム内のニュースを取得し、スレタイ化 ---
    const gameNewsList = tournamentState.news || [];
    gameNewsList.filter(n => n.context && n.context.dbMatch).slice(-5).forEach(gameNews => {
        const { winnerName, loserName, dbMatch } = gameNews.context;
        const winnerRank = calculateRank(winnerName, tournamentState);
        const loserRank = calculateRank(loserName, tournamentState);
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        let gameTitle = `【高校野球】${winnerName}が${loserName}に勝利！`; // デフォルト

        if (rankValues[winnerRank] < rankValues[loserRank]) {
            gameTitle = `【超絶悲報】${loserName}(${loserRank}ランク)、格下の${winnerName}(${winnerRank}ランク)に負けるｗｗｗｗ`;
        } else if ((parseInt(dbMatch.score1) + parseInt(dbMatch.score2)) > 15) {
            gameTitle = `【乱打戦】${winnerName}vs${loserName}、とんでもない試合になる`;
        } else if ((parseInt(dbMatch.score1) + parseInt(dbMatch.score2)) < 3) {
            gameTitle = `【投手戦】${winnerName}、${loserName}を完封リレーで下す！`;
        }
        
        articles.push({
            headline: gameTitle,
            type: 'game',
            matchId: dbMatch.id,
            timestamp: gameNews.timestamp,
            category: '高校野球'
        });
    });

    // --- 3. 全記事をタイムスタンプでソートしてHTMLを生成 ---
    articles.sort((a, b) => b.timestamp - a.timestamp);

    if (articles.length === 0) {
        return '<p class="text-center text-gray-500">まだ表示できるニュースがありません。</p>';
    }

    const categoryColors = {
        "高校野球": "bg-green-100 text-green-800",
        "NPB": "bg-blue-100 text-blue-800",
        "MLB": "bg-sky-100 text-sky-800",
        "芸能": "bg-pink-100 text-pink-800",
        "政治": "bg-gray-200 text-gray-800",
        "学歴": "bg-indigo-100 text-indigo-800",
        "速報": "bg-red-100 text-red-800",
        "なんJ": "bg-yellow-100 text-yellow-800",
        "議論": "bg-purple-100 text-purple-800",
    };

    return articles.map(article => {
        const time = new Date(article.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
        const commentCount = Math.floor(Math.random() * 1000) + 1;
        const color = categoryColors[article.category] || "bg-gray-100 text-gray-800";
        return `
            <a href="#" class="matome-article-link block p-3 hover:bg-gray-50 rounded border-b" 
               data-headline="${article.headline}" data-type="${article.type}" data-category="${article.category}"
               ${article.matchId ? `data-match-id="${article.matchId}"` : ''}>
                <p class="font-bold text-lg text-gray-800 hover:text-blue-700">${article.headline}</p>
                <div class="flex items-center justify-between text-sm text-gray-500 mt-1">
                    <span><span class="text-xs font-semibold px-2 py-0.5 rounded ${color}">${article.category}</span></span>
                    <span>[${time}] コメント: ${commentCount} 💬</span>
                </div>
            </a>
        `;
    }).join('');
}
/**
 * 現実のニュースヘッドラインに対する、なんJ風の掲示板コメントをAIに生成させる（カテゴリ対応・完全版）
 * @param {string} headline - 現実のニュースの見出し
 * @param {string} category - ニュースのカテゴリ
 * @returns {Promise<Array|null>} コメントオブジェクトの配列
 */
async function generateRealNewsBbsComments(headline, category) {
    // 1. 基本となるAIのペルソナ（人格）を設定
    let personaPrompt = `あなたは、日本の匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは少し皮肉屋で、ネットスラングを多用し、あらゆる話題に短いコメントを書き込みます。あなたの口癖は「～やで」「～やん」「どうすんのこれ」「草」「ｗｗｗ」などです。`;
    
    // 2. ニュースのカテゴリに応じて、AIへの追加指示を切り替える
    let instructions = ``;
    switch (category) {
        case '政治':
            instructions = `政治ニュースに詳しい住民として、与党や野党を煽ったり、将来を悲観したり、達観したようなコメントをしてください。`;
            break;
        case '芸能・ゴシップ':
            instructions = `芸能ニュースが大好きな野次馬として、「〇〇ロスだわ」「どうせすぐ別れる」といった、お祝いと嫉妬が入り混じったコメントをしてください。`;
            break;
        case '学歴':
            instructions = `学歴コンプレックスを持つ住民として、「F欄のワイ、高みの見物」「結局は学歴よりコミュ力」といった、自虐や持論を展開してください。`;
            break;
        default:
            instructions = `一般的な住民として、ニュースに反応してください。`;
            break;
    }
    
    // 3. 最終的なAIへの指示書（プロンプト）を組み立てる
    const prompt = `${personaPrompt}

以下の【${category}】のニュースヘッドラインに対して、${instructions}リアルな掲示板の反応（スレッド）を5～7個生成してください。

### ニュースヘッドライン
${headline}

### あなたがなりきるべきキャラクターたちと指示
- **>>1（スレ主）:** ニュースを貼り付けただけのような、素っ気ない投稿。
- **悲観的な住民:** 「もう終わりだよこの国」「日本オワタ」など、すぐに絶望する。
- **楽観的な住民:** 「まあなんとかなるやろ」「ええやん」と、あまり深く考えない。
- **斜に構えた住民:** 「で、俺たちの生活に何か影響あるわけ？」と、一歩引いた視点からコメントする。
- **すぐに面白がる住民:** どんなニュースでも「草」「ｗｗｗ」と笑い飛ばす。

### 出力形式
必ず以下のJSON配列形式で出力してください。
[
    {"personality": "1: 風吹けば名無し", "comment": "（スレ主のコメント）"},
    {"personality": "2: 風吹けば名無し", "comment": "（住民2のコメント）"},
    {"personality": "3: 風吹けば名無し", "comment": "（住民3のコメント）"}
]`;

    // 4. AIにリクエストを送信し、結果を整形して返す
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now()
                }));
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI real news BBS generation failed:", error);
        return null;
    }
}

// ▲▲▲ ここまで追加 ▲▲▲

/**
 * 指定されたチームが次に出場する、まだ終わっていない試合を探す
 * @param {string} teamName - 探したいチーム名
 * @param {object} state - 現在のtournamentState
 * @returns {object|null} - 見つかった試合オブジェクト、またはnull
 */
function findCurrentMatchForTeam(teamName, state) {
    const allMatches = { ...state.matches, ...(state.autumnData?.allMatches || {}), ...(state.springData?.allMatches || {}) };
    let earliestMatch = null;
    let minRound = Infinity;

    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (!match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 0;
            if (roundNum < minRound) {
                minRound = roundNum;
                earliestMatch = match;
            }
        }
    }
    return earliestMatch;
}

// ▼▼▼ この関数をまるごと追加 ▼▼▼
/**
 * ゲーム内の試合結果に対する、なんJまとめサイト風のスレッドをAIに生成させる
 * @param {object} matchContext - 試合の全コンテキスト情報
 * @returns {Promise<Array|null>} コメントオブジェクトの配列
 */
async function generateGameMatchBbsComments(matchContext) {
    const { winnerName, loserName, dbMatch, highlightsText } = matchContext;
    const score = `${dbMatch.score1}-${dbMatch.score2}`;
    
    const prompt = `あなたは、日本の匿名掲示板「なんでも実況J（なんJ）」のまとめサイト管理人です。
以下の試合結果について、ユーザーの興味を引くような「スレッドタイトル」と、そのスレッド内での「なんJ民たちのリアルな反応」を10個前後生成してください。

### 試合結果データ
- **勝利チーム:** ${winnerName}
- **敗北チーム:** ${loserName}
- **スコア:** ${score}
- **試合ハイライト:** ${highlightsText || '特になし'}
- **ユーザーによる試合の決め手:** ${dbMatch.summary || '特になし'}

### 指示
1.  **スレッドタイトル:** 試合結果が最も端的に伝わり、かつ少し煽り気味の面白いタイトルを考えてください。（例：【悲報】〇〇、あまりにも弱い【甲子園】）
2.  **コメント生成:**
    - なんJ特有の口調（「～やで」「～ニキ」「草」「どうすんのこれ」など）やネットスラングを多用してください。
    - 試合内容（特にハイライトやスコア）に具体的に言及してください。
    - 勝者を称賛する声、敗者を煽る声、斜に構えた意見、全く関係ない雑談などをバランス良く混ぜてください。
    - 試合展開を実況しているかのような、時系列を感じさせるコメントもいくつか含めてください。

### 出力形式
必ず以下のJSON形式で出力してください。
{
  "threadTitle": "（生成したスレッドタイトル）",
  "comments": [
    {"personality": "1: 風吹けば名無し", "comment": "（スレ主のコメント）"},
    {"personality": "2: 風吹けば名無し", "comment": "（住民2のコメント）"},
    {"personality": "3: 風吹けば名無し", "comment": "（住民3のコメント）"}
  ]
}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const bbsJson = parseJsonFromText(rawText);
            if (bbsJson && bbsJson.threadTitle && Array.isArray(bbsJson.comments)) {
                // 扱いやすいように、タイトルもオブジェクトに含めて返す
                return {
                    title: bbsJson.threadTitle,
                    comments: bbsJson.comments.map(c => ({
                        id: crypto.randomUUID(),
                        personality: c.personality,
                        text: c.comment,
                        timestamp: Date.now()
                    }))
                };
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI game match BBS generation failed:", error);
        return null;
    }
}
// ▲▲▲ ここまで追加 ▲▲▲

/**
 * トーナメントの勝者を次のラウンドに進める（processMatchWinから抜粋・改造）
 * @param {object} match - 終了した試合のオブジェクト
 * @param {string} winnerName - 勝者名
 * @param {object} state - 現在のtournamentState
 */
function advanceWinnerToNextRound(match, winnerName, state) {
    const matchId = match.id;
    const idParts = matchId.split('-');
    const side = idParts[0];

    if (side === 'F') return; // 決勝戦なら何もしない

    const roundStr = idParts[1];
    const roundNum = parseInt(roundStr.slice(1));
    
    // このロジックは夏季・春季県大会（16 or 64チーム）を想定
    if (state.teams && state.teams.length > 0) {
        const numTeamsInTournament = state.teams.length;
        const finalRound = Math.log2(numTeamsInTournament);

        if (roundNum < finalRound) {
            const matchNum = parseInt(idParts[2].slice(1));
            const nextRoundNum = roundNum + 1;
            let nextMatchId = (nextRoundNum === finalRound) ? 'F-R1-M1' : `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
            
            if (!state.matches[nextMatchId]) {
                state.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
            }
            let slot = (nextRoundNum === finalRound) ? (side === 'L' ? 1 : 2) : (matchNum % 2 !== 0 ? 1 : 2);
            state.matches[nextMatchId][`team${slot}`] = winnerName;
        }
    }
    // TODO: 秋季大会などの複雑な進行ロジックが必要な場合は、ここに追加する
}

// ▲▲▲ ここまで追加 ▲▲▲


/**
 * 密着ドキュメンタリーを開始し、序章の記事を生成する
 * @param {'underdog' | 'powerhouse'} type - ドキュメンタリーの種類
 * @param {string} teamName - 取材対象のチーム名
 */
async function startDocumentary(type, teamName) {
    tournamentState.documentary = { target: teamName, type: type }; // ← オブジェクトで保存
    newsContainer.innerHTML = `<div class="loader">AI記者が「${teamName}」の特別ドキュメンタリー番組の制作を開始しました...</div>`;
    
    renderTournament(tournamentState); 
    
    const article = await generateDocumentaryArticle('intro', type, teamName); // ← type を渡す

    if (article) {
        tournamentState.news.push(article);
    } else {
        tournamentState.news.push({
            title: "記事生成エラー",
            body: `「${teamName}」のドキュメンタリー記事生成に失敗しました。`,
            timestamp: Date.now(),
            error: true
        });
    }
    renderNews(tournamentState.news);
    saveState();
}

/**
 * ドキュメンタリー調の記事をAIに生成させる（全4テーマ統合・フィードバック機能付き最終完全版）
 * @param {'intro' | 'win' | 'lose'} phase - 記事の種類
 * @param {'underdog' | 'powerhouse' | 'powerhouse_revival' | 'one_man_team'} type - ドキュメンタリーの種類
 * @param {string} teamName - 主役のチーム名
 * @param {object} [matchData=null] - 試合データ
 * @param {object} [userFeedback=null] - ユーザーからの追加指示
 * @returns {Promise<object|null>}
 */
async function generateDocumentaryArticle(phase, type, teamName, matchData = null, userFeedback = null) {
    const teamMasterData = TEAM_DATA[teamName];
    let prompt = `あなたは、情熱的で人間ドラマを描くのが得意なドキュメンタリー番組の記者です。あなたは今、高校野球チーム「${teamName}」に密着取材しています。`;
    let title = "";

    // AIに渡すための登場人物リストを動的に作成
    let charactersPrompt = `### 主な登場人物\n- 監督: ${teamMasterData.coach.name} (${teamMasterData.coach.style})\n`;
    if ((type === 'powerhouse' || type === 'powerhouse_revival' || type === 'one_man_team') && DETAILED_TEAM_DATA[teamName]) {
        const detailedData = DETAILED_TEAM_DATA[teamName];
        const keyPlayers = detailedData.players.map(p => `- ${p.name}(${p.year}年, ${p.position}): ${p.desc}`).join('\n');
        charactersPrompt += `### 注目選手\n${keyPlayers}\n`;
    }
    
    // ユーザーからのフィードバックをプロンプトに追加する部分
    let feedbackPrompt = '';
    if (userFeedback) {
        if (userFeedback.include && userFeedback.include.trim() !== '') {
            feedbackPrompt += `\n- **【最重要指示】** 以下の要素を必ず記事の中心に据えて、最もドラマチックに描写してください：\n${userFeedback.include}\n`;
        }
        if (userFeedback.exclude && userFeedback.exclude.trim() !== '') {
            feedbackPrompt += `\n- **【厳禁事項】** 以下の要素や表現は、絶対に記事に含めないでください：\n${userFeedback.exclude}\n`;
        }
    }
    const finalFeedbackPrompt = `\n### ディレクターからの追加指示\n${feedbackPrompt || '特になし'}`;


    if (type === 'powerhouse_revival') {
        // --- 古豪復活チーム用のプロンプト ---
        switch (phase) {
            case 'intro':
                title = `『${teamName}、復活への序曲』`;
                prompt += `
### 取材テーマ
かつて黄金時代を築いた古豪「${teamName}」が、失われた栄光を取り戻すべく挑む夏を追う、感動的なドキュメンタリーの導入記事を作成してください。
${charactersPrompt}
### 構成案
1.  **【埃をかぶった優勝旗】**
    部室に眠る、色褪せた優勝旗やトロフィーの描写から始める。過去の栄光の重圧と、現在のチームが置かれた状況との対比を鮮やかに描く。
2.  **【OBたちの熱き眼差し】**
    練習を厳しい目で見つめるOB会長にインタビュー。「俺たちの時代は…」という昔語りと、現在のチームへの歯がゆさ、そして心の底にある期待を語らせる。
3.  **【重圧を背負う主将】**
    主将に「〇〇（校名）のユニフォームを着て戦うことの意味」を問う。伝統の重みと、それを力に変えようとする彼の覚悟を描写する。
4.  **【監督の信念】**
    監督に「古豪復活への道筋」をインタビューする。OBからのプレッシャーの中で、彼が信じる今の選手たちの可能性について語らせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、復活への第一歩』`;
                prompt += `
### 取材テーマ
古豪「${teamName}」が ${matchData.opponent} との試合に ${matchData.score} で勝利しました。「名門復活への狼煙」となるこの一勝の価値を、感動的に描写してください。
${charactersPrompt}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1. 勝利の瞬間、安堵と誇りの入り混じった表情で整列する選手たちを描写する。
2. OB席が「よくやったぞ！」という歓声と拍手に包まれる様子を伝える。
3. 監督に「伝統の粘り強さが出せた」という趣旨のコメントをさせる。
4. 主将に、次戦への意気込みと共に「先輩たちが築いた歴史に、新たな1ページを刻みたい」と語らせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、夢、またも届かず』`;
                prompt += `
### 取材テーマ
古豪「${teamName}」の夏が、${matchData.opponent}に ${matchData.score} で敗れ、終わりを告げました。復活を願った人々の期待と、それに応えられなかった選手たちの無念さを、切なく描いてください。
${charactersPrompt}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1. 試合後、OBたちの厳しい叱咤と温かい労いの声が飛び交う、独特の雰囲気のスタンドを描写する。
2. グラウンドに泣き崩れる選手たちと、彼らにかける言葉が見つからない監督の姿。
3. 主将が涙ながらに「先輩たちに申し訳ない…」と語るインタビュー。
4. 「彼らの挑戦は終わった。しかし、〇〇（校名）の野球部の灯が消えることはない。来年こそは、と誓う後輩たちの目が、確かに前を向いていた」と、未来への希望で締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } else if (type === 'one_man_team') {
        // --- 絶対的エースチーム用のプロンプト ---
        switch (phase) {
            case 'intro':
                title = `『${teamName}のエースと、8人の仲間たち』`;
                prompt += `
### 取材テーマ
プロ注目の絶対的エースを擁する「${teamName}」。メディアの注目がエース一人に集まる中で、他の選手たちは何を想い、戦うのか。天才の苦悩と、彼を支える「その他大勢」と呼ばれた仲間たちのプライドを描く、感動的なドキュメンタリーの導入記事を作成してください。
${charactersPrompt}
### 構成案
1.  **【殺到する報道陣】**
    練習グラウンドに集まる、エースだけを狙う無数のカメラの描写から始める。
2.  **【エースの孤独なマウンド】**
    エースにインタビュー。「チームを勝たせるのが自分の仕事」と語る彼の言葉の裏にある、10代の少年が背負うにはあまりに重いプレッシャーを描写する。
3.  **【名もなき脇役たちの意地】**
    メディアからは「モブ」として扱われる、他の野手たちに焦点を当てる。「俺たちは、あいつの引き立て役じゃない。俺たちの守備や打撃がなければ、あいつはただの一人の投手に過ぎない」という、彼らの静かなプライドと葛藤を引き出す。
4.  **【監督の信念】**
    監督に「彼らはワンマンチームですか？」と問う。「世間はそう言うだろう。だが、私だけは知っている。本当の主役が誰なのかをね」と、意味深に語らせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `エース快投！しかし、勝利の影に${teamName}の結束あり`;
                prompt += `
### 取材テーマ
「${teamName}」が ${matchData.opponent} に ${matchData.score} で勝利。メディアはエースの快投ばかりを報じるだろう。しかし、その裏にあった仲間たちのファインプレーや、チームの結束こそが真の勝因だったことを、あなたの視点で深く描写してください。
${charactersPrompt}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1. エースの完璧な投球内容を簡潔に紹介する。
2. しかし、と続け、**ハイライトにあった**、メディアが決して報じないであろう「名もなき選手のファインプレー」や「繋ぎのバッティング」を、試合のターニングポイントとして詳細に描写する。
3. そのプレーをした選手に「エースを助けるのが俺たちの仕事ですから」と、誇らしげに語らせる。
4. エースに「今日の勝利は、俺一人の力じゃない。みんなが守ってくれたおかげです」と、初めて仲間に感謝の言葉を述べさせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `英雄、あまりに早すぎる敗退。${teamName}の夏、終わる`;
                prompt += `
### 取材テーマ
絶対的エースを擁しながら、「${teamName}」は ${matchData.opponent} に ${matchData.score} で敗れました。エースが打たれ、仲間たちが涙する…。天才と仲間たちの、残酷で、しかし美しい夏の終わりを描いてください。
${charactersPrompt}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1. **ハイライトにあった**、エースが決勝点を浴びたシーンをスローモーションのように描写する。
2. マウンドで呆然とするエースと、彼に駆け寄り「お前のせいじゃない」と声をかける仲間たちの姿を描く。
3. 試合後、「全部、自分のせいです…」と涙を流すエースと、「俺たちが、あいつを守ってやれなかった…」と悔しがる野手たちの両方のコメントを紹介する。
4. 「彼らはワンマンチームではなかった。勝つ時も、負ける時も、彼らは一つのチームだった」と締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } else if (type === 'powerhouse') {
        // --- 強豪校用のプロンプト ---
        switch (phase) {
            case 'intro':
                title = `『${teamName}、王者の告白』序章`;
                prompt += `
### 取材テーマ
絶対的王者「${teamName}」の栄光の裏に隠された苦悩と、常人には理解しがたいプレッシャーを描く、重厚なドキュメンタリーの導入記事を作成してください。
${charactersPrompt} 
### 構成案
1.  **【静寂のトロフィー室】**
    薄暗い部屋に無数に並ぶ、優勝トロフィーや盾の描写から始める。それらが放つ輝きと、同時に感じられる「過去の栄光」という重圧を描写する。
2.  **【監督の分析室】**
    監督へのインタビュー。場所はグラウンドではなく、無数のデータや映像が映し出されたモニターが並ぶ、彼の「城」である分析室。勝利への執念と、選手たちを非情な競争に晒すことへの苦悩を語らせる。
3.  **【Bグラウンドの陽炎】**
    Aチームが練習するメイングラウンドから離れた「Bグラウンド」の情景を映す。そこでは、ベンチ入りできなかった3年生の控え部員が、最後の夏にも関わらず、黙々と後輩への球拾いや打撃投手を務めている。彼の「チームへの愛」と「諦め」の独白を引き出す。
4.  **【スーパールーキーの野心】**
    1年生ながらベンチ入りを果たした天才ルーキーにインタビュー。偉大な先輩たちへの尊敬と、同時に「早くあの人たちを追い越したい」という若さゆえの野心と焦燥感を語らせる。
5.  **【主将の孤独な背中】**
    最後に、主将に話を聞く。場所は、全員が帰った後、一人で素振りをする夜のグラウンド。スター選手揃いのチームを一つにまとめることの難しさ、そして「負けることが許されない」という王者ならではの孤独な覚悟を語らせる。
### 描写のポイント
-   **対比:** 完璧に整備された設備と、そこで流される選手たちの生々しい汗や涙を対比させること。
-   **音:** トロフィー室の静寂、Bグラウンドから聞こえる声にならない叫び、監督の静かだが重い言葉、主将のバットが夜の空気を切り裂く音など、「音」の描写を効果的に使うこと。
-   **心理描写:** 登場人物たちのセリフだけでなく、彼らの表情や仕草から、言葉にならない葛藤やプライドを丁寧に描写すること。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、王者の告白』第${matchData.round}章`;
                prompt += `
### 取材テーマ
「${teamName}」が、${matchData.opponent}との試合に ${matchData.score} で勝利しました。しかし、彼らにとってこの勝利は歓喜ではなく、「次へ進むための義務」でしかない。その独特の空気感を、以下のハイライトを基にリアルに描写してください。
${charactersPrompt}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1. 試合後、安堵の表情を浮かべるも、決して喜びを爆発させない選手たちの姿を描写する。
2. **ハイライトを基に**、試合内容の反省点を冷静に監督にインタビューする。
3. **ハイライトで活躍した**選手にも「今日のプレーで満足せず、次を見据えている」という趣旨のコメントをさせる。
4. 記事の最後に「彼らの戦いは、まだ終わらない」という一文で、次なる戦いへの緊張感を煽る。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、王者の告白』最終章`;
                prompt += `
### 取材テーマ
絶対的王者「${teamName}」の夏が、${matchData.opponent}に ${matchData.score} で敗れ、終わりを告げました。王国の崩壊の瞬間と、選手たちの初めて見せる涙、そして彼らが背負っていた重圧からの解放を、以下のハイライトを基に感傷的かつ克明に記録してください。
${charactersPrompt}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1. 試合終了のサイレンが鳴り響く、球場の信じられないような静寂を描写する。
2. **ハイライトを参考に**、グラウンドに泣き崩れる選手たち。特に、これまで常に気丈に振る舞ってきた主将の涙に焦点を当てる。
3. **ハイライトで勝敗を分けたプレー**について、監督に敗戦の責任と、選手たちへの労いの言葉を語らせる。
4. 「彼らは今日、初めてただの高校生に戻れたのかもしれない」というような、詩的な一文で締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } else { 
        // --- 逆境チーム用のプロンプト ---
        switch (phase) {
            case 'intro':
                title = `『${teamName}、魂の記録』序章`;
                prompt += `
### 取材テーマ
「${teamName}」が抱える困難な状況と、それでも夢を諦めない彼ら、そして彼らを支える地域の人々の姿を描く、感動的なドキュメンタリーの導入記事を作成してください。
${charactersPrompt}
### 構成案
1. 記者がチームの元を訪れる場面から始める。
2. 監督や選手、マネージャー、地元の人々など、複数の人物にインタビューし、それぞれの視点からチームの苦悩と情熱を明らかにする。
3. 最後に、大会へ向かう彼らの決意で締めくくる。
### 必ず含めるべき要素
- チームが抱える具体的なハンデ（例：${teamMasterData.info}）
- 監督の名前や登場人物の実名を効果的に使用すること。
- 情景が目に浮かぶような、エモーショナルな描写
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、魂の記録』第${matchData.round}章`;
                prompt += `
### 取材テーマ
「${teamName}」が、${matchData.opponent}との激闘を ${matchData.score} で制しました。この奇跡的な勝利が彼らにとってどれほど大きな意味を持つのか、以下のハイライトを基に感動的に描写してください。
${charactersPrompt}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1. 勝利の瞬間の選手たちの様子を描写する（例：子供のように抱き合って泣いた）。
2. **ハイライトで示された試合のターニングポイント**を、手に汗握るように振り返る。
3. 監督や主役選手の、喜びと感謝に満ちた勝利インタビューを挿入する。
4. この勝利を見届けた地元の人々の、我が事のような喜びの声を加える。
5. 「彼らの物語は、まだ終わらない」と、次の試合への期待感で締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、魂の記録』最終章`;
                prompt += `
### 取材テーマ
「${teamName}」の夏が、${matchData.opponent}に ${matchData.score} で敗れ、終わりを告げました。夢破れた彼らの姿と、それでも確かに残ったもの、そして彼らを見守った人々の想いを、以下のハイライトを基に描くドキュメンタリー最終章を作成してください。
${charactersPrompt}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1. 試合終了の瞬間、泣き崩れるも、やがて顔を上げる選手たちの姿を描写する。
2. 監督や主将が、**ハイライトにあった悔しいプレー**にも触れつつ、この夏を振り返る最後のインタビューに答える。
3. チームを支え続けたマネージャーや地元の人々の、選手たちへの温かい労いの言葉を挿入する。
4. 3年生の引退と、彼らの想いが後輩たちへと受け継がれていくことを示唆して、物語を締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    }
    
    // AIへのリクエスト実行部分は変更なし
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) return { ...article, timestamp: Date.now() };
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI documentary article generation failed:", error);
        return null;
    }
}

/**
 * Sets the weather effect for the background.
 * @param {'none' | 'rain' | 'sun'} weatherType - The type of weather to display.
 */
function setWeather(weatherType) {
    const rainContainer = document.getElementById('rain-container');
    const sunContainer = document.getElementById('sun-container');

    // Hide all weather effects first
    rainContainer.classList.add('hidden');
    sunContainer.classList.add('hidden');
    rainContainer.innerHTML = ''; // Clear old raindrops

    if (weatherType === 'rain') {
        rainContainer.classList.remove('hidden');
        // Create 100 raindrops
        for (let i = 0; i < 100; i++) {
            const drop = document.createElement('div');
            drop.className = 'drop';
            drop.style.left = Math.random() * 100 + 'vw';
            drop.style.animationDelay = Math.random() * 0.5 + 's';
            drop.style.animationDuration = Math.random() * 0.2 + 0.3 + 's';
            rainContainer.appendChild(drop);
        }
    } else if (weatherType === 'sun') {
        sunContainer.classList.remove('hidden');
    }
}

/**
 * 詳細入力モーダル内のチームデータ、またはチーム名自体を入れ替える
 * @param {string} matchId - 対象の試合ID
 */
function swapTeamDetails(matchId) {
    const match = findMatchById(matchId);
    if (!match) return;

    // 1. チーム名と、トーナメント表に表示されているスコアを入れ替える
    const tempTeam = match.team1;
    match.team1 = match.team2;
    match.team2 = tempTeam;

    const tempScore = match.score1;
    match.score1 = match.score2;
    match.score2 = tempScore;

    // 2. もし詳細データが入力済みなら、その中身も入れ替える
    if (match.details) {
        // 打撃データを入れ替え
        const tempBatting = match.details.batting.team1;
        match.details.batting.team1 = match.details.batting.team2;
        match.details.batting.team2 = tempBatting;

        // 投手データを入れ替え
        const tempPitching = match.details.pitching.team1;
        match.details.pitching.team1 = match.details.pitching.team2;
        match.details.pitching.team2 = tempPitching;
        
        // イニングスコアを入れ替え
        if (match.details.inningScore) {
            const tempInningScore = match.details.inningScore.team1;
            match.details.inningScore.team1 = match.details.inningScore.team2;
            match.details.inningScore.team2 = tempInningScore;
        }
    }

    // 3. 変更を保存し、画面を更新する
    saveState();
    renderTournament(tournamentState); // トーナメント表も更新
    openDetailsModal(matchId); // モーダルを再描画して変更を反映
}
/**
 * チームステータスモーダルを表示する
 */
function showTeamStatusModal(teamName) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) return;

    // モーダルの要素を取得
    const modal = document.getElementById('team-status-modal');
    const bestEl = document.getElementById('status-modal-best');
    const historyEl = document.getElementById('status-modal-history');
    const traitsEl = document.getElementById('status-modal-traits');
    // ↓↓↓ おそらく抜けていたのがこの一行です ↓↓↓
    const coachEl = document.getElementById('status-modal-coach'); 

    // チーム名を設定
    document.getElementById('status-modal-team-name').textContent = teamName;
    
    // 最高戦績を設定
    bestEl.textContent = teamRecord.best ? formatRecordToString(teamRecord.best) : 'まだありません';

    // 直近の成績を設定
    historyEl.innerHTML = '';
    if (teamRecord.history && teamRecord.history.length > 0) {
        teamRecord.history.slice(0, 2).forEach(rec => {
            const p = document.createElement('p');
            p.textContent = formatRecordToString(rec);
            historyEl.appendChild(p);
        });
    } else {
        historyEl.innerHTML = '<p>まだありません</p>';
    }

    // 称号を設定
    traitsEl.innerHTML = '';
    if (teamRecord.teamTraits && teamRecord.teamTraits.length > 0) {
        teamRecord.teamTraits.forEach(traitId => {
            const trait = TITLES[traitId];
            if (trait) {
                const span = document.createElement('span');
                span.className = 'bg-blue-100 text-blue-800 text-xs font-semibold px-2.5 py-0.5 rounded-full';
                span.textContent = trait.name;
                traitsEl.appendChild(span);
            }
        });
    } else {
        traitsEl.innerHTML = '<p class="text-gray-500 text-sm">なし</p>';
    }
    
    // 監督情報を設定
    const teamMasterData = TEAM_DATA[teamName];
    if (teamMasterData && teamMasterData.coach) {
        const coach = teamMasterData.coach;
        coachEl.textContent = `${coach.name} (${coach.experience} / ${coach.style})`;
    } else {
        coachEl.textContent = '情報なし';
    }
    
    // モーダルを表示
    modal.classList.remove('hidden');
}
    // --- Custom Alert/Confirm ---
    function showAlert(message) {
        alert(message);
    }

    function showConfirm(message) {
        return new Promise((resolve) => {
            const confirmOk = document.getElementById('confirm-ok');
            const confirmCancel = document.getElementById('confirm-cancel');
            document.getElementById('confirm-modal-text').textContent = message;
            confirmModal.classList.remove('hidden');

            const onOk = () => {
                confirmModal.classList.add('hidden');
                cleanup();
                resolve(true);
            };

            const onCancel = () => {
                confirmModal.classList.add('hidden');
                cleanup();
                resolve(false);
            };
            
            const cleanup = () => {
                confirmOk.removeEventListener('click', onOk);
                confirmCancel.removeEventListener('click', onCancel);
            };

            confirmOk.addEventListener('click', onOk);
            confirmCancel.addEventListener('click', onCancel);
        });
    }

// --- Utility & State Functions --- などに追加

// 甲子園での成績を定義（数字が小さいほど上位）
const KOSHIEN_RESULTS = {
    CHAMPION:       { rank: -1, label: '全国優勝' },
    RUNNER_UP:    { rank: -2, label: '全国準優勝' },
    BEST_4:         { rank: -4, label: '甲子園ベスト4' },
    BEST_8:         { rank: -8, label: '甲子園ベスト8' },
    BEST_16:        { rank: -16, label: '甲子園3回戦敗退' }, // ベスト16
    ROUND_2:        { rank: -32, label: '甲子園2回戦敗退' },
    ROUND_1:        { rank: -64, label: '甲子園初戦敗退' },
};

// チームのA～Eランクごとの、甲子園での成績確率（ウェイト方式）
const KOSHIEN_PROBABILITIES = {
    'A': [
        { result: 'CHAMPION', weight: 20 }, { result: 'RUNNER_UP', weight: 25 },
        { result: 'BEST_4', weight: 25 },   { result: 'BEST_8', weight: 15 },
        { result: 'BEST_16', weight: 10 },  { result: 'ROUND_2', weight: 4 },
        { result: 'ROUND_1', weight: 1 }
    ],
    'B': [
        { result: 'CHAMPION', weight: 5 },  { result: 'RUNNER_UP', weight: 10 },
        { result: 'BEST_4', weight: 20 },   { result: 'BEST_8', weight: 30 },
        { result: 'BEST_16', weight: 20 },  { result: 'ROUND_2', weight: 10 },
        { result: 'ROUND_1', weight: 5 }
    ],
    'C': [
        { result: 'CHAMPION', weight: 1 },  { result: 'RUNNER_UP', weight: 3 },
        { result: 'BEST_4', weight: 8 },    { result: 'BEST_8', weight: 20 },
        { result: 'BEST_16', weight: 30 },  { result: 'ROUND_2', weight: 28 },
        { result: 'ROUND_1', weight: 10 }
    ],
    'D': [
        { result: 'BEST_8', weight: 5 },    { result: 'BEST_16', weight: 15 },
        { result: 'ROUND_2', weight: 40 },  { result: 'ROUND_1', weight: 40 }
    ],
    'E': [
        { result: 'BEST_16', weight: 5 },   { result: 'ROUND_2', weight: 25 },
        { result: 'ROUND_1', weight: 70 }
    ],
};

/**
 * チームランクに基づき、甲子園での成績を確率で決定する
 * @param {string} teamRank - 'A'から'E'までのチームランク
 * @returns {string} - KOSHIEN_RESULTSのキー ('CHAMPION', 'BEST_8'など)
 */
function simulateKoshien(teamRank) {
    const probabilities = KOSHIEN_PROBABILITIES[teamRank] || KOSHIEN_PROBABILITIES['E'];
    const totalWeight = probabilities.reduce((sum, p) => sum + p.weight, 0);
    let random = Math.random() * totalWeight;

    for (const prob of probabilities) {
        if (random < prob.weight) {
            return prob.result;
        }
        random -= prob.weight;
    }
    return 'ROUND_1'; // フォールバック
}
    /**
     * 試合IDを元に、stateオブジェクトの深い階層から試合オブジェクトを検索して返す
     */
    function findMatchById(matchId) {
        // 通常のトーナメント表（夏季・春季・秋季県大会）を検索
        if (tournamentState.matches && tournamentState.matches[matchId]) {
            return tournamentState.matches[matchId];
        }

        // 秋季大会の地区予選・順位決定戦を検索
        if (tournamentState.autumnData) {
            for (const region of ['東部', '中部', '西部']) {
                const regionData = tournamentState.autumnData.regions[region];
                if (!regionData) continue;
                if (regionData.blocks) {
                    for (const block of regionData.blocks) {
                        if (block.matches[matchId]) return block.matches[matchId];
                    }
                }
                if (regionData.champBracket && regionData.champBracket.matches[matchId]) {
                    return regionData.champBracket.matches[matchId];
                }
                if (regionData.repechageBracket && regionData.repechageBracket.matches[matchId]) {
                    return regionData.repechageBracket.matches[matchId];
                }
            }
        }
        
        // 春季大会の地区予選を検索
        if (tournamentState.springData) {
             for (const region of ['東部', '中部', '西部', '伊豆']) {
                 const regionData = tournamentState.springData.regions[region];
                 if (regionData && regionData.blocks) {
                     for (const block of regionData.blocks) {
                         if (block.matches[matchId]) return block.matches[matchId];
                     }
                 }
             }
        }

        return null; // どこにも見つからなかった場合
    }
// --- Team Rank Calculation ---
    function calculateRank(teamName, state) {
    if (!teamName) return ''; 

    const teamData = TEAM_DATA[teamName];
    
    // ▼▼▼ この安全装置を追加 ▼▼▼
    if (!teamData) {
        // もしTEAM_DATAにチームが見つからなければ、エラーを起こさずに
        // デフォルトのEランクを返して、この関数の処理を終了する
        return 'E'; 
    }
    // ▲▲▲ ▲▲▲

    // この行は、上記のチェックのおかげで安全に実行される
    let score = 0;
    score += teamData.deviation;

        if (teamData.best.includes('優勝')) score += 25;
        else if (teamData.best.includes('準優勝')) score += 20;
        else if (teamData.best.includes('ベスト4')) score += 15;
        else if (teamData.best.includes('ベスト8')) score += 10;
        else if (teamData.best.includes('出場')) score += 10;
        else if (teamData.best.includes('ベスト16')) score += 5;

        if (teamData.popularity) score += 5;

        if (state.teamRecords && state.teamRecords[teamName]) {
            const lastFinish = state.teamRecords[teamName].lastFinish;
            const rankMultiplier = 3.0; 
            if (lastFinish === 1) score += 30 * rankMultiplier; 
            else if (lastFinish === 2) score += 25 * rankMultiplier;
            else if (lastFinish <= 4) score += 20 * rankMultiplier;
            else if (lastFinish <= 8) score += 15 * rankMultiplier;
            else if (lastFinish <= 16) score += 5 * rankMultiplier;
            else if (lastFinish >= 64) score -= 5 * rankMultiplier;
        }
        
        if (score >= 85) return 'A';
        if (score >= 70) return 'B';
        if (score >= 55) return 'C';
        if (score >= 40) return 'D';
        return 'E';
    }
// --- Tournament Logic & Rendering ---

   /**
 * 新しいトーナメントを開始するメイン関数（省略箇所を全て復元した最終完成版）
 * @param {boolean} isNext - これが最初のトーナメントではないか（世代交代か）
 * @param {string} nextTournamentType - 'summer', 'autumn', 'spring'のいずれか
 * @param {Array<string> | null} predeterminedTeams - 抽選会で決定済みの組み合わせ
 */
async function createNewTournament(isNext = false, nextTournamentType = 'summer', predeterminedTeams = null) {
    setupEl.classList.add('hidden');
    tournamentDisplayEl.classList.remove('hidden');

    // 世代交代処理
    if (isNext && tournamentState.teamRecords) {
        for (const teamName in tournamentState.teamRecords) {
            if (tournamentState.teamRecords.hasOwnProperty(teamName)) {
                const record = tournamentState.teamRecords[teamName];
                record.previousRank = record.lastFinish;
                record.wins = 0;
                record.losses = 0;
            }
        }
    }

        // --- 秋季大会の開始 ---
        if (nextTournamentType === 'autumn') {
            tournamentState.currentTournament = 'autumn';
            tournamentState.autumnPhase = 'regional_blocks'; // 秋季大会の最初のステージを設定
            if (isNext) {
                 // 夏の次は年は進まない
            } else {
                tournamentState.tournamentYear = 2025; // 初期年も設定可能
            }

            // 秋季大会用の state を初期化
            tournamentState.teams = [];
            tournamentState.matches = {};
            tournamentState.news = [];
            tournamentState.seeds = [];
            tournamentState.bbsComments = [];
            tournamentState.daiyaBbsComments = [];
            tournamentState.tickerHeadlines = [];
            tournamentState.rivalries = RIVALRIES;
            tournamentState.feuds = tournamentState.feuds || [];
            tournamentState.namcoNews = null;
            tournamentState.is16team = false;
            // 新しい秋季大会専用のデータ構造
            tournamentState.autumnData = {
                regions: {
                    '東部': { blockWinners: [], blockRunnersUp: [], ranking: [], finalReps: [] },
                    '中部': { blockWinners: [], blockRunnersUp: [], ranking: [], finalReps: [] },
                    '西部': { blockWinners: [], blockRunnersUp: [], ranking: [], finalReps: [] },
                    '伊豆': { finalReps: [] } // 伊豆は予選なし
                }
            };
            
            await setupAutumnRegionalBlocks(); // ステージ1（地区ブロック予選）を開始
            return;
        }
// createNewTournament 関数内

    // ... 既存の if (nextTournamentType === 'autumn') { ... } ブロックの後ろに挿入 ...

    // --- NEW: 春季大会の開始処理 ---
    else if (nextTournamentType === 'spring') {
        tournamentState.currentTournament = 'spring';
        tournamentState.autumnPhase = null; // 春なので秋のフェーズはクリア
        if(isNext) tournamentState.tournamentYear++;

        // 秋季大会の結果からシード校と予選参加校を決定
        const allRankedTeams = Object.keys(tournamentState.teamRecords)
            .map(name => ({ name, rank: tournamentState.teamRecords[name].lastFinish }))
            .sort((a, b) => a.rank - b.rank);

        const seedTeams = allRankedTeams.slice(0, 8).map(t => t.name);
        const qualifierTeams = allRankedTeams.slice(8).map(t => t.name);

        tournamentState.springPhase = 'regional_qualifiers'; // 春季大会の最初のステージを設定
        tournamentState.springData = { // 春季大会専用のデータストアを初期化
            seedTeams,
            qualifierTeams,
            regions: {
                '東部': { blocks: [], repechageBracket: null, finalReps: [] },
                '中部': { blocks: [], repechageBracket: null, finalReps: [] },
                '西部': { blocks: [], repechageBracket: null, finalReps: [] },
                '伊豆': { izuBracket: null, finalReps: [] }
            },
            allMatches: {} // 予選の全試合をここに集約
        };

        await setupSpringRegionalQualifiers(); // ステージ1（地区予選）を開始

 // ★★★ 春の甲子園シミュレーションここから ★★★
    if (tournamentState.senbatsuTeams && tournamentState.senbatsuTeams.length > 0) {
        for (const teamName of tournamentState.senbatsuTeams) {
            const teamRecord = tournamentState.teamRecords[teamName];
            const teamRank = calculateRank(teamName, tournamentState);
            const koshienResultKey = simulateKoshien(teamRank);
            const koshienResult = KOSHIEN_RESULTS[koshienResultKey];
            
            // 選抜の結果を特別なプロパティとして記録（春の県大会成績とは別）
            teamRecord.senbatsuResult = koshienResult;

            // 履歴と自己ベストは更新する
            const newHistoryRecord = {
                year: tournamentState.tournamentYear,
                tournament: 'spring', // 春の大会の一部として記録
                rank: koshienResult.rank
            };
            if (!teamRecord.history) teamRecord.history = [];
            teamRecord.history.unshift(newHistoryRecord);
            if (!teamRecord.best || newHistoryRecord.rank < teamRecord.best.rank) {
                teamRecord.best = newHistoryRecord;
            }

            // 選抜の結果を知らせる記事を生成
            const article = await generateKoshienSummaryArticle(teamName, koshienResult.label, 'spring');
            if(article) tournamentState.news.push(article);
        }
        renderNews(tournamentState.news);
    }
    tournamentState.senbatsuTeams = []; // 使い終わったのでクリア
    // ★★★ 春の甲子園シミュレーションここまで ★★★

        return;
    }

   
        
            // --- ここからが夏季大会の処理 ---
    mainBracketWrapper.classList.remove('hidden');
    tournamentState.is16team = false;
    
    // 年度とチーム記録の初期化
    if (!isNext) { 
        tournamentState.tournamentYear = 2025;
        tournamentState.currentTournament = 'summer';
        tournamentState.teamRecords = {};
        const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
        historicalRanks.sort((a, b) => a.rank - b.rank);
        
        INITIAL_TEAM_POOL.forEach(t => {
            const historicalRank = historicalRanks.find(hr => hr.name === t);
            tournamentState.teamRecords[t] = { 
                wins: 0, losses: 0, best: null, history: [],
                lastFinish: historicalRank ? historicalRank.rank : 64, 
                previousRank: null,
                teamTraits: [], 
                previousStarters: null,
                roster: null,
            };
        });
    }
    
    let teams;
    let seeds = [];

    if (predeterminedTeams) {
        // 抽選会からの組み合わせ
        teams = predeterminedTeams;
        const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
        historicalRanks.sort((a, b) => a.rank - b.rank);
        seeds = historicalRanks.slice(0, 8).map(t => t.name);
    } else {
        // 抽選会スキップ時の組み合わせ
        if (isNext) {
            const lastTournamentTeams = Object.keys(tournamentState.teamRecords)
                .map(teamName => ({ name: teamName, ...tournamentState.teamRecords[teamName] }))
                .sort((a, b) => a.lastFinish - b.lastFinish);
            seeds = lastTournamentTeams.slice(0, 8).map(t => t.name);
        } else {
            const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
            historicalRanks.sort((a, b) => a.rank - b.rank);
            seeds = historicalRanks.slice(0, 8).map(t => t.name);
        }

        const nonSeeds = INITIAL_TEAM_POOL.filter(t => !seeds.includes(t));
        const shuffledNonSeeds = shuffleArray(nonSeeds);
        teams = Array(64).fill(null);
        const seedPositionsTemplate = [0, 32, 16, 48, 8, 40, 24, 56];
        const seedPlacements = {};
        seeds.forEach((seed, i) => { seedPlacements[seedPositionsTemplate[i]] = seed; });
        let nonSeedIndex = 0;
        for (let i = 0; i < 64; i++) {
            teams[i] = seedPlacements[i] ? seedPlacements[i] : shuffledNonSeeds[nonSeedIndex++];
        }
    }
    
    // トーナメントデータの作成
    tournamentState.teams = teams;
    tournamentState.matches = {};
    tournamentState.news = [];
    tournamentState.documentary = { target: null, type: null };
    tournamentState.activeScandal = null;
    tournamentState.seeds = seeds;
    tournamentState.bbsComments = [];
    tournamentState.daiyaBbsComments = [];
    tournamentState.tickerHeadlines = []; 
    tournamentState.rivalries = RIVALRIES;
    tournamentState.feuds = tournamentState.feuds || [];
    tournamentState.namcoNews = null;

    const round1Setup = teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    round1Setup.forEach((match, index) => {
        const side = index < 16 ? 'L' : 'R';
        const matchNum = index < 16 ? index + 1 : index - 15;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

    saveState();
    renderTournament(tournamentState);
    
    // ▼▼▼【重要】ご指摘のあった、大会開始時のAIコンテンツ生成処理を復元▼▼▼
    const currentTournamentName = tournamentNameMap[tournamentState.currentTournament];
    newsContainer.innerHTML = `<div class="loader">AI記者が${currentTournamentName}の展望記事を執筆中...</div>`;
    bbsCommentsContainer.innerHTML = `<div class="loader">AIが組み合わせを分析中...</div>`;
    namcoNewsSection.classList.remove('hidden');
    namcoNewsContent.innerHTML = `<div class="loader">ナムコグループからのお知らせを確認中...</div>`;

    const [previewArticle, bracketComments, namcoNews] = await Promise.all([
        generateNewsArticle(null, null, null, 'preview'),
        generateBracketReactionComments(tournamentState),
        generateNamcoNews(tournamentState, 'bracket')
    ]);

    if (previewArticle) tournamentState.news.unshift(previewArticle);
    if (bracketComments && bracketComments.length > 0) tournamentState.bbsComments.push(...bracketComments);
    if (namcoNews) tournamentState.namcoNews = namcoNews;

    renderNews(tournamentState.news);
    renderBbsComments(tournamentState.bbsComments);
    renderNamcoNews(tournamentState.namcoNews);
    saveState();
    // ▲▲▲ここまで▲▲▲
}

   /**
 * 大会終了時に、全チームの最終順位をteamRecordsに記録し、履歴を更新する
 */
function updateTournamentFinishRecords() {
    const { matches, teams } = tournamentState;
    if (!teams || teams.length === 0) return;

    const numTeams = teams.length;
    const finalRound = Math.log2(numTeams);

    // 最終順位を決定する
    const getRoundLosers = (round, side) => {
        const losers = [];
        const numMatches = (numTeams / 2) / Math.pow(2, round - 1);
        for (let m = 1; m <= numMatches; m++) {
            const match = matches[`${side}-R${round}-M${m}`];
            if (match && match.winner) {
                const loser = match.winner === match.team1 ? match.team2 : match.team1;
                if (loser) losers.push(loser);
            }
        }
        return losers;
    };

    const finalMatch = matches['F-R1-M1'];
    if (finalMatch && finalMatch.winner) {
        const winner = finalMatch.winner;
        const runnerUp = finalMatch.winner === finalMatch.team1 ? finalMatch.team2 : finalMatch.team1;
        if (tournamentState.teamRecords[winner]) tournamentState.teamRecords[winner].lastFinish = 1;
        if (tournamentState.teamRecords[runnerUp]) tournamentState.teamRecords[runnerUp].lastFinish = 2;
    }

    // 準決勝以前の敗退順位を記録
    for (let r = finalRound - 1; r >= 1; r--) {
        const finishRank = Math.pow(2, finalRound - r + 1);
        getRoundLosers(r, 'L').concat(getRoundLosers(r, 'R')).forEach(t => {
            if (t && tournamentState.teamRecords[t]) tournamentState.teamRecords[t].lastFinish = finishRank;
        });
    }

    // ★★★ ここからが戦績履歴と最高成績の更新処理 ★★★
    Object.keys(tournamentState.teamRecords).forEach(team => {
        const record = tournamentState.teamRecords[team];
        if(!record.lastFinish) return; // 試合に参加していない場合はスキップ

        // 今回の大会結果オブジェクトを作成
        const newHistoryRecord = {
            year: tournamentState.tournamentYear,
            tournament: tournamentState.currentTournament,
            rank: record.lastFinish
        };

        // 履歴の先頭に追加 (新しいものが常に一番上に来るように)
        if (!record.history) record.history = [];
        record.history.unshift(newHistoryRecord);

        // 最高成績を更新
        // (bestが未設定か、今回の成績の方が良い(rankの数字が小さい)場合に更新)
        if (!record.best || newHistoryRecord.rank < record.best.rank) {
            record.best = newHistoryRecord;
        }
    });
    // ★★★ ここまで ★★★
}

 /**
     * 現在のトーナメント状態に基づいてUI全体を再描画する
     * @param {object} data - 現在のtournamentState
     */
// 【修正対象1】
function renderTournament(data) {
        let tournamentNameString = tournamentNameMap[data.currentTournament] || '大会';

    mainBracketWrapper.classList.add('hidden');
    autumnRegionalContainer.classList.add('hidden');
    autumnRankingContainer.classList.add('hidden');
    
// ★★★ 春季大会ロジック開始 ★★★
    if (data.currentTournament === 'spring') {
        switch(data.springPhase) {
            case 'regional_qualifiers':
                tournamentNameString = '春季大会 地区予選';
                autumnRegionalContainer.classList.remove('hidden'); // 秋のコンテナを流用
                renderSpringRegionalQualifiers();
                break;
            case 'main_round1':
                tournamentNameString = '春季大会 県大会1回戦';
                mainBracketWrapper.classList.remove('hidden');
                renderMainBracket(data);
                break;
            case 'main_round2_onwards':
                tournamentNameString = '春季大会 県大会'; // シンプルに
                mainBracketWrapper.classList.remove('hidden');
                renderMainBracket(data);
                break;
        }
    } 
    // ★★★ 春季大会ロジック終了 ★★★
        else if (data.currentTournament === 'autumn') {   
        switch(data.autumnPhase) {
            case 'regional_blocks': 
                tournamentNameString = '秋季大会 地区ブロック予選';
                autumnRegionalContainer.classList.remove('hidden');
                renderAutumnRegionalBlocks(); // 修正済み
                break;
            case 'regional_ranking': 
                tournamentNameString = '秋季大会 地区内順位決定戦';
                autumnRankingContainer.classList.remove('hidden');
                renderAutumnRankingTournaments(); // 修正済み
                break;
            case 'main': 
                tournamentNameString = '秋季大会 県大会本戦';
                mainBracketWrapper.classList.remove('hidden');
                renderMainBracket(data);
                break;
        }
    } else {
        mainBracketWrapper.classList.remove('hidden');
        renderMainBracket(data);
    }
    tournamentYearDisplay.textContent = `${data.tournamentYear}年度 ${tournamentNameString}`;

    renderRegionMap(data);
    renderNews(data.news || []);
    renderBbsComments(data.bbsComments || []);
    renderDaiyaBbsComments(data.daiyaBbsComments || []);
    renderNamcoNews(data.namcoNews);
    checkTournamentProgress();
    updateTicker();
}

    /**
     * メインのトーナメント表（64チームまたは16チーム）を描画する
     */
    function renderMainBracket(data) {
        if (!data.teams || data.teams.length === 0) {
             mainBracketContainer.innerHTML = '';
             return;
        };

        const { matches, teams, seeds } = data;
        const numTeams = teams.length;

        const bracketContentWrapper = document.createElement('div');
        bracketContentWrapper.className = 'flex flex-row';

        const leftBracketEl = document.createElement('div');
        leftBracketEl.className = 'bracket-half left';

        const rightBracketEl = document.createElement('div');
        rightBracketEl.className = 'bracket-half right';
        
        const finalRound = Math.log2(numTeams);
        const semiFinalRound = finalRound - 1;
        
        const leftChampion = data.matches[`L-R${semiFinalRound}-M1`]?.winner ?? null;
        const rightChampion = data.matches[`R-R${semiFinalRound}-M1`]?.winner ?? null;
        
        const finalMatch = data.matches['F-R1-M1'] || {};
        const finalTeam1 = finalMatch.team1 ?? leftChampion;
        const finalTeam2 = finalMatch.team2 ?? rightChampion;

        const finalEl = document.createElement('div');
        finalEl.className = 'bracket-final';
        finalEl.innerHTML = `<div class="final-title">決勝</div><div class="final-matchup" data-match-id="F-R1-M1">${createMatchHTML('F-R1-M1', finalTeam1, finalTeam2, finalMatch, seeds)}</div><div class="winner-box" id="tournament-winner">${finalMatch.winner ? `🏆 ${finalMatch.winner} 🏆` : '🏆'}</div>`;

        const round1Setup = teams.reduce((acc, team, i) => {
            if (i % 2 === 0) acc.push({ team1: team, team2: null });
            else acc[acc.length - 1].team2 = team;
            return acc;
        }, []);
        
        const leftHalfSetup = round1Setup.slice(0, round1Setup.length / 2);
        const rightHalfSetup = round1Setup.slice(round1Setup.length / 2);

        generateHalf(leftBracketEl, leftHalfSetup, 'L', matches, seeds);
        generateHalf(rightBracketEl, rightHalfSetup, 'R', matches, seeds);

        mainBracketContainer.innerHTML = '';
        bracketContentWrapper.append(leftBracketEl, finalEl, rightBracketEl);
        mainBracketContainer.appendChild(bracketContentWrapper);

        if (finalMatch.winner) {
            nextTournamentBtn.classList.remove('hidden');
        } else {
            nextTournamentBtn.classList.add('hidden');
        }
    }

    /**
     * トーナメント表の片側（レフトまたはライト）を描画するヘルパー関数
     */
    function generateHalf(containerEl, setup, side, allMatches, seeds) {
        containerEl.innerHTML = '';
        const numMatchesInFirstRound = setup.length;
        const numTeamsOnSide = numMatchesInFirstRound * 2;
        const numRounds = Math.log2(numTeamsOnSide);

        const roundNameMap = tournamentState.is16team
            ? { 1: "1回戦", 2: "準々決勝", 3: "準決勝" }
            : { 1: "1回戦", 2: "2回戦", 3: "3回戦", 4: "準々決勝", 5: "準決勝" };

        const roundElements = [];
        for (let i = 0; i < numRounds; i++) {
            const roundEl = document.createElement('div');
            roundEl.className = 'round';
            if (i > 0) roundEl.classList.add('subsequent-round');

            const roundTitle = document.createElement('h3');
            roundTitle.className = 'text-center font-bold mb-2';
            roundTitle.textContent = roundNameMap[i + 1] || `${i + 1}回戦`;
            roundEl.appendChild(roundTitle);

            containerEl.appendChild(roundEl);
            roundElements.push(roundEl);
        }

        setup.forEach((matchSetup, index) => {
            const matchId = `${side}-R1-M${index + 1}`;
            let dbMatch = allMatches[matchId] || {};
            roundElements[0].insertAdjacentHTML('beforeend', createMatchHTML(matchId, matchSetup.team1, matchSetup.team2, dbMatch, seeds));
        });

        for (let r = 2; r <= numRounds; r++) {
            const numMatchesInRound = numMatchesInFirstRound / Math.pow(2, r - 1);
            for (let m = 1; m <= numMatchesInRound; m++) {
                const matchId = `${side}-R${r}-M${m}`;
                const prevMatch1Id = `${side}-R${r - 1}-M${(m * 2) - 1}`;
                const prevMatch2Id = `${side}-R${r - 1}-M${m * 2}`;
                const team1 = allMatches[prevMatch1Id]?.winner || null;
                const team2 = allMatches[prevMatch2Id]?.winner || null;
                const dbMatch = allMatches[matchId] || {};
                roundElements[r - 1].insertAdjacentHTML('beforeend', createMatchHTML(matchId, team1, team2, dbMatch, seeds));
            }
        }
    }

    /**
     * 1試合分のHTMLを生成する
     */
    /**
 * 1試合分のHTMLを生成する（ドキュメンタリーボタン対応・エラー修正版）
 */
function createMatchHTML(matchId, team1, team2, dbMatch, seeds = []) {
    // ▼▼▼ 先に関数の定義をここ（関数の冒頭）に移動します ▼▼▼
    const createSpecialButtons = (teamName) => {
    if (!teamName || (tournamentState.documentary && tournamentState.documentary.target)) return '';
    
    let buttonHTML = '';
    // 逆境チーム用
    if (UNDERDOG_TEAMS.includes(teamName)) {
        buttonHTML += `<button class="underdog-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の逆境に密着取材する">📹</button>`;
    }
    // 通常の強豪校用
    if (POWERHOUSE_TEAMS.includes(teamName)) {
        buttonHTML += `<button class="powerhouse-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の王者の苦悩に密着取材する">👑</button>`;
    }
    // ▼▼▼ ここから追加 ▼▼▼
    // 古豪復活チーム用
    if (POWERHOUSE_REVIVAL_TEAMS.includes(teamName)) {
        buttonHTML += `<button class="powerhouse-revival-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の古豪復活に密着取材する">🏰</button>`;
    }
if (ONE_MAN_TEAMS.includes(teamName)) {
        buttonHTML += `<button class="one-man-team-doc-btn text-lg ml-2" data-team-name="${teamName}" title="絶対的エースとその仲間たちに密着取材する">🌟</button>`;
    }


        return buttonHTML;
    };
    // ▲▲▲ 関数の定義はここまで ▲▲▲

    const t1Empty = !team1;
    const t2Empty = !team2;

    let specialMatchClass = '';
    if (!t1Empty && !t2Empty) {
        const feud = tournamentState.feuds?.find(f => f.teams.includes(team1) && f.teams.includes(team2));
        if (feud) {
            specialMatchClass = 'feud-match';
        } else {
            const rivalry = tournamentState.rivalries?.find(r => r.teams.includes(team1) && r.teams.includes(team2));
            if (rivalry) {
                specialMatchClass = 'rivalry-match';
            }
        }
    }

    const rank1 = calculateRank(team1, tournamentState);
    const rank2 = calculateRank(team2, tournamentState);
    const rankColor = (rank) => {
        switch (rank) {
            case 'A': return 'rank-A';
            case 'B': return 'rank-B';
            case 'C': return 'rank-C';
            case 'D': return 'rank-D';
            case 'E': return 'rank-E';
            default: return '';
        }
    };

    const isMainBracketMatch = matchId.includes('-R');
    const roundStr = isMainBracketMatch ? matchId.split('-')[1] : '';
    const showDetailsButton = !t1Empty && !t2Empty;
    const isSeed1 = seeds.includes(team1);
    const isSeed2 = seeds.includes(team2);

    // HTMLテンプレート内の関数呼び出し名を修正
    const content = `
        <div class="team-slot ${t1Empty ? 'empty' : ''} ${dbMatch.winner === team1 && !t1Empty ? 'winner' : ''} ${dbMatch.winner && dbMatch.winner !== team1 && dbMatch.winner !== null ? 'loser' : ''}" data-team-name="${team1 || ''}">
            <span class="team-name clickable-team-name ${isSeed1 ? 'seed' : ''}" title="${team1 || ''}" data-team-name="${team1 || ''}">
                ${team1 ? `<span class="rank ${rankColor(rank1)}">[${rank1}]</span>` : ''}
                ${isSeed1 ? 'S ' : ''}${team1 || '---'}
            </span>
            ${createSpecialButtons(team1)} 
            <input type="text" class="score-input" value="${dbMatch.score1 ?? ''}" data-team-pos="1">
            <button class="win-btn">▶</button>
        </div>
        <div class="team-slot ${t2Empty ? 'empty' : ''} ${dbMatch.winner === team2 && !t2Empty ? 'winner' : ''} ${dbMatch.winner && dbMatch.winner !== team2 && dbMatch.winner !== null ? 'loser' : ''}" data-team-name="${team2 || ''}">
            <span class="team-name clickable-team-name ${isSeed2 ? 'seed' : ''}" title="${team2 || ''}" data-team-name="${team2 || ''}">
                ${team2 ? `<span class="rank ${rankColor(rank2)}">[${rank2}]</span>` : ''}
                ${isSeed2 ? 'S ' : ''}${team2 || '---'}
            </span>
            ${createSpecialButtons(team2)}
            <input type="text" class="score-input" value="${dbMatch.score2 ?? ''}" data-team-pos="2">
            <button class="win-btn">▶</button>
        </div>
        <div class="match-summary-container ${!t1Empty && !t2Empty ? '' : 'hidden'}">
            <textarea class="match-summary-input w-full text-xs p-1 mt-1 border rounded" data-match-id="${matchId}" placeholder="試合の決め手（任意）">${dbMatch.summary || ''}</textarea>
        </div>
    `;

    const footer = showDetailsButton ?
        `<div class="matchup-footer">
            <button class="details-btn" data-match-id="${matchId}">詳細入力</button>
            <button class="quick-sim-btn text-lg" data-match-id="${matchId}" title="このスコアでおまかせ入力">🎲</button>
        </div>` :
        '';

    return `<div class="matchup ${specialMatchClass}" data-match-id="${matchId}">${content}${footer}</div>`;
}

    /**
     * UIの各種コンテンツエリア（ニュース、掲示板など）を描画する関数群
     */
   /**
 * UIの各種コンテンツエリア（ニュース、掲示板など）を描画する関数群
 * （再生成ボタンを常時表示するように修正）
 */
function renderNews(news) {
    if (!news || news.length === 0) {
        newsContainer.innerHTML = `<p class="text-gray-500 text-center">まだニュースはありません。</p>`;
        return;
    }
    newsContainer.innerHTML = '';
    news.slice().reverse().forEach((article, index) => {
        const articleEl = document.createElement('div');
        const originalIndex = news.length - 1 - index;

        // ▼▼▼ このブロックを全面的に修正 ▼▼▼
        let regenerateButtonHTML = ''; // 先に変数を定義しておく
        
        if (article.context) { // contextを持つ記事（＝再生成可能）の場合にボタンを生成
            regenerateButtonHTML = `<button class="text-sm bg-yellow-100 text-yellow-700 px-3 py-1 rounded hover:bg-yellow-200 ml-2 regenerate-btn" data-index="${originalIndex}">再生成</button>`;
        }

        if (article.error) {
            articleEl.className = 'article-error';
            articleEl.innerHTML = `
                <span>${article.title}</span>
                ${regenerateButtonHTML}
            `;
        } else {
            articleEl.className = 'bg-white p-4 rounded-lg shadow';
            articleEl.innerHTML = `
                <div class="flex justify-between items-start">
                    <div>
                        <h3 class="font-bold text-lg text-blue-600">${article.title}</h3>
                        <p class="text-xs text-gray-400 mt-1">${new Date(article.timestamp).toLocaleDateString('ja-JP')}</p>
                    </div>
                    <div class="flex items-center">
                        <button class="text-sm bg-gray-200 px-3 py-1 rounded hover:bg-gray-300 news-article-btn" data-index="${originalIndex}">本文</button>
                        ${article.isNewspaper ? `<button class="text-sm bg-red-100 text-red-700 px-3 py-1 rounded hover:bg-red-200 ml-2 newspaper-view-btn" data-index="${originalIndex}">新聞を読む</button>` : ''}
                        ${regenerateButtonHTML}
                    </div>
                </div>
            `;
        }
        // ▲▲▲ ここまで修正 ▲▲▲
        newsContainer.appendChild(articleEl);
    });
}

    function renderBbsComments(comments) {
    if (!comments || comments.length === 0) {
        bbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">まだ反応はありません。</p>`;
        return;
    }
    bbsCommentsContainer.innerHTML = '';
    
    comments.slice().reverse().forEach((comment, index) => {
        // ▼▼▼ THIS IS THE NEW LOGIC ▼▼▼
        // Check if the comment object is an error message
        if (comment.error) {
            const errorEl = document.createElement('div');
            errorEl.className = 'article-error'; // Reuse the article error style
            // The original index is needed for the retry function
            const originalIndex = comments.length - 1 - index;
            errorEl.innerHTML = `
                <span>${comment.title}</span>
                <button class="retry-bbs-btn" data-index="${originalIndex}">再生成</button>
            `;
            bbsCommentsContainer.appendChild(errorEl);
        } 
        // ▲▲▲ ▲▲▲
        else {
            // If it's a normal comment, render it as before
            renderCommentThread(comment, bbsCommentsContainer, 'general');
        }
    });
}

    function renderDaiyaBbsComments(comments) {
        if (!comments || comments.length === 0) {
            daiyaBbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">まだ反応はありません。</p>`;
            return;
        }
        daiyaBbsCommentsContainer.innerHTML = '';
        comments.slice().reverse().forEach(comment => {
            renderCommentThread(comment, daiyaBbsCommentsContainer, 'daiya');
        });
    }

    function renderNamcoNews(news) {
        if (!news) {
            namcoNewsSection.classList.add('hidden');
            return;
        }
        namcoNewsSection.classList.remove('hidden');
        namcoNewsContent.innerHTML = '';
        const newsItem = document.createElement('div');
        newsItem.className = 'namco-news-item p-2 hover:bg-orange-50 rounded';
        newsItem.innerHTML = `<p class="font-semibold text-gray-700">${news.title}<span class="namco-news-tag">野球部</span></p>`;
        newsItem.addEventListener('click', () => {
            document.getElementById('modal-title').textContent = news.title;
            document.getElementById('modal-body').textContent = news.body;
            document.getElementById('modal-meta').innerHTML = `<p>${new Date(news.timestamp).toLocaleDateString('ja-JP')}</p><p class="font-bold text-gray-500">野球部</p>`;
            newsModal.classList.remove('hidden');
            newsModal.classList.add('flex');
        });
        namcoNewsContent.appendChild(newsItem);
    }

    function renderCommentThread(comment, container, bbsType) {
        const threadContainer = document.createElement('div');
        if (container.id === `replies-to-${comment.id}` || (container.id.includes('bbs-comments') && container.children.length > 0)) {
            threadContainer.className = 'ml-4 border-l-2 pl-4 mt-2';
        } else {
            threadContainer.className = 'mt-2';
        }

        const personalityClass = comment.personality === 'あなた' ? 'text-blue-600 font-bold' : 'text-gray-600';
        const commentEl = document.createElement('div');
        commentEl.className = 'bbs-comment';
        commentEl.innerHTML = `
            <div class="flex justify-between items-center">
                <p class="font-semibold ${personalityClass} text-sm">${comment.personality || '名無しさん'}</p>
                <button class="reply-btn text-xs text-blue-500 hover:underline" data-comment-id="${comment.id}" data-bbs-type="${bbsType}">返信する</button>
            </div>
            <p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>
            <p class="text-xs text-gray-400 text-right">${new Date(comment.timestamp).toLocaleString('ja-JP')}</p>
            <div id="reply-form-container-${comment.id}" class="hidden mt-2">
                <form class="reply-form" data-comment-id="${comment.id}" data-bbs-type="${bbsType}">
                    <textarea class="w-full p-2 border rounded text-sm" placeholder="返信を入力..." required></textarea>
                    <button type="submit" class="mt-1 bg-blue-500 text-white px-3 py-1 text-xs rounded hover:bg-blue-600">送信</button>
                </form>
            </div>
        `;
        threadContainer.appendChild(commentEl);

        const repliesContainer = document.createElement('div');
        repliesContainer.id = `replies-to-${comment.id}`;
        threadContainer.appendChild(repliesContainer);

        container.appendChild(threadContainer);

        if (comment.replies && comment.replies.length > 0) {
            comment.replies.slice().reverse().forEach(reply => {
                renderCommentThread(reply, repliesContainer, bbsType);
            });
        }
    }

    /**
 * Renders the regional survival status with a new card-based, scrollable layout.
 */
function renderRegionMap(data) {
    const regionMapSection = document.getElementById('region-map-section');
    const finalMatch = data.matches['F-R1-M1'];
    if ((!data.matches || Object.keys(data.matches).length === 0) && !finalMatch) {
        regionMapSection.classList.add('hidden');
        return;
    }
    regionMapSection.classList.remove('hidden');

    const container = document.getElementById('region-map-container');
    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    INITIAL_TEAM_POOL.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region && teamsByRegion[region]) {
            teamsByRegion[region].push(teamName);
        }
    });

    const eliminatedTeams = new Set();
    const allMatches = { ...data.matches, ...(data.autumnData?.allMatches || {}) };

    Object.values(allMatches).filter(match => match.winner).forEach(match => {
        const loser = match.team1 === match.winner ? match.team2 : match.team1;
        if (loser) eliminatedTeams.add(loser);
    });

    if (finalMatch?.winner) {
        const tournamentWinner = finalMatch.winner;
        eliminatedTeams.forEach(team => {
            if (team === tournamentWinner) eliminatedTeams.delete(team);
        });
    }
    
    let html = '<div class="region-map-scroll-container">'; // New scroll container
    for (const region in teamsByRegion) {
        const teams = teamsByRegion[region];
        if (teams.length === 0) continue;
        
        const survivingCount = teams.filter(team => !eliminatedTeams.has(team)).length;

        html += `
        <div class="region-column">
            <div class="region-header">
                <h3 class="region-title">${region}地区</h3>
                <p class="region-stats">${survivingCount} / ${teams.length} チーム生存</p>
            </div>
            <ul class="region-team-list">
                ${teams.sort((a, b) => { // Sort teams to put survivors at the top
                    const aElim = eliminatedTeams.has(a);
                    const bElim = eliminatedTeams.has(b);
                    if (aElim === bElim) return a.localeCompare(b, 'ja');
                    return aElim ? 1 : -1;
                }).map(team => `
                    <li class="region-team ${eliminatedTeams.has(team) ? 'team-eliminated' : 'team-surviving'}">
                        ${team}
                    </li>
                `).join('')}
            </ul>
        </div>
        `;
    }
    html += '</div>';
    container.innerHTML = html;
}
    
    /**
     * スキップボタンの表示・非表示を制御する
     */
    function checkTournamentProgress() {
        if (tournamentState.is16team || !tournamentState.matches || Object.keys(tournamentState.matches).length === 0 || tournamentState.currentTournament === 'autumn') {
            skipR1Btn.classList.add('hidden');
            skipR2Btn.classList.add('hidden');
            skipR3Btn.classList.add('hidden');
            generateSummaryBtn.classList.add('hidden');
            return;
        }

        const matchIds = Object.keys(tournamentState.matches);
        const getRoundStatus = (roundNumber) => {
            const roundMatchIds = matchIds.filter(id => id.includes(`-R${roundNumber}-M`));
            const played = roundMatchIds.filter(id => tournamentState.matches[id] && tournamentState.matches[id].winner).length;
            const total = 64 / Math.pow(2, roundNumber);
            return { total, played };
        };

        const r1 = getRoundStatus(1);
        const r2 = getRoundStatus(2);
        const r3 = getRoundStatus(3);
        const r4 = getRoundStatus(4);

        skipR1Btn.classList.toggle('hidden', r1.played > 0);
        skipR2Btn.classList.toggle('hidden', !(r1.played === r1.total && r2.played === 0));
        skipR3Btn.classList.toggle('hidden', !(r2.played === r2.total && r3.played === 0));

        const summaryGenerated = tournamentState.news.some(n => n.summaryType === 'best8');
        generateSummaryBtn.classList.toggle('hidden', !(r3.played === r3.total && r4.played === 0 && !summaryGenerated));
    }

    function checkBest8Decided(){} // checkTournamentProgressに統合
// --- 試合詳細モーダル関連の関数（高機能版） ---

   /**
     * 【修正版】新しい試合詳細モーダルを開き、各種テーブルを生成する
     */
    /**
     * イニングスコアのテーブルHTMLを生成する
     */
    /**
 * イニングスコアのテーブルHTMLを生成する（★列幅クラスを適用した最終版）
 */
/**
/**
 * イニングスコアのテーブルHTMLを生成する（0点表示バグ修正版）
 * @param {string} team1Name - チーム1の名前
 * @param {string} team2Name - チーム2の名前
 * @param {object} details - 試合の詳細データ
 * @returns {string} - 生成されたHTML
 */
function createInningScoreTable(team1Name, team2Name, details) {
    const inningData = details.inningScore || { team1: [], team2: [] };
    const numInnings = (inningData.team1 && inningData.team1.length > 0) ? inningData.team1.length : 9;
    
    let header = '';
    for (let i = 1; i <= numInnings; i++) {
        header += `<th class="col-inning-score">${i}</th>`;
    }

    const createRow = (teamKey, teamName) => {
        let cells = '';
        for (let i = 0; i < numInnings; i++) {
            // ▼▼▼【重要修正】ここがバグの原因でした▼▼▼
            // 保存された値が0の場合でも、''（空文字）ではなく0と表示されるように修正
            const scoreValue = inningData[teamKey]?.[i] ?? ''; // nullかundefinedの場合のみ''にする
            cells += `<td class="col-inning-score"><input type="number" value="${scoreValue}"></td>`;
            // ▲▲▲
        }
        return `<tr>
                    <th class="col-team text-left font-semibold pl-2">${teamName}</th>
                    ${cells}
                    <td class="total-score col-total"></td>
                </tr>`;
    };

    return `
        <div class="mb-6 overflow-x-auto">
            <h4 class="font-bold mb-2">イニングスコア</h4>
            <table class="details-table" id="inning-score-table">
                <thead>
                    <tr>
                        <th class="col-team">チーム</th>${header}<th class="col-total">計</th><th class="col-add-inning"><button id="add-inning-score-btn" class="text-xs font-bold">+</button></th>
                    </tr>
                </thead>
                <tbody>${createRow('team1', team1Name)}${createRow('team2', team2Name)}</tbody>
            </table>
        </div>`;
}
/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する（全ての機能を含む最終版）
 */
/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する（★常時縦並びレイアウト対応版）
 */
// 【完成版】openDetailsModal
/**
 * Opens the detailed input modal with the corrected vertical layout.
 */
/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する（★レイアウト問題を完全修正した最終版）
 */
/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する（★データ初期化の欠陥を修正した最終版）
 */
function openDetailsModal(matchId) {
    currentMatchIdForDetails = matchId;
    const match = findMatchById(matchId);
    if (!match) {
        console.error(`[openDetailsModal] エラー: ID ${matchId} の試合が見つかりません。`);
        return;
    }

    console.log("--- [モーダル表示 開始] ---", { matchId: matchId, 既存データ: match.details });

    let details = JSON.parse(JSON.stringify(match.details || {}));
    
    const numInnings = Math.max(9, ...Object.values(tournamentState.matches)
        .filter(m => m.details?.inningScore?.team1)
        .map(m => m.details.inningScore.team1.length));

    console.log(`[モーダル表示] 現在の最大イニング数を ${numInnings} と判断しました。`);

    // データ構造の初期化
    details.inningScore = details.inningScore || { team1: [], team2: [] };
    details.batting = details.batting || { team1: [], team2: [] };
    details.pitching = details.pitching || { team1: [], team2: [] };
    details.inningEvents = details.inningEvents || { team1: [], team2: [] };
    details.positionChanges = details.positionChanges || [];
    
    // 配列の長さを現在のイニング数に合わせる
    for(const teamKey of ['team1', 'team2']) {
        if (!details.inningEvents[teamKey]) details.inningEvents[teamKey] = [];
        while (details.inningScore[teamKey].length < numInnings) details.inningScore[teamKey].push('');
        while (details.inningEvents[teamKey].length < numInnings) details.inningEvents[teamKey].push('');
        if (details.batting[teamKey]) {
            details.batting[teamKey].forEach(player => {
                if (!player.results) player.results = [];
                while (player.results.length < numInnings) player.results.push('');
            });
        }
    }
    console.log("[モーダル表示] 表示用に準備したデータ:", JSON.parse(JSON.stringify(details)));


    // もし試合データが空で、かつチームの選手名簿(roster)が存在すれば、それを読み込む
    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (details.batting[teamKey].length === 0 && teamRecord && teamRecord.roster) {
            details.batting[teamKey] = teamRecord.roster.map(p => ({ ...p, results: Array(numInnings).fill('') }));
        }
    }
    
    const detailsBody = document.getElementById('details-modal-body');
    detailsBody.innerHTML = `
        <div class="space-y-4">
            ${createInningScoreTable(match.team1, match.team2, details)}
            <div class="text-center py-2 border-t border-b">
                <button id="swap-teams-btn" data-match-id="${matchId}" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded">先攻・後攻を入れ替え</button>
            </div>
            <div class="space-y-4">
                <h4 class="font-bold text-lg">${match.team1} 打撃成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPlayerBattingTable(match.team1, 'team1', details)}</div>
                <h4 class="font-bold text-lg mt-4">${match.team2} 打撃成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPlayerBattingTable(match.team2, 'team2', details)}</div>
            </div>
            <div class="space-y-4 mt-4">
                <h4 class="font-bold text-lg">${match.team1} 投手成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPitchingStatsTable('team1', details)}</div>
                 <h4 class="font-bold text-lg mt-4">${match.team2} 投手成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPitchingStatsTable('team2', details)}</div>
            </div>
        </div>
    `;

    detailsModal.classList.remove('hidden');
    updateTotalScores();
}
 

/**
 * 投手成績のテーブルHTMLを生成する
 * @param {string} teamKey - 'team1' または 'team2'
 * @param {object} details - 試合の詳細データ
 * @returns {string} - 生成されたHTML
 */
function createPitchingStatsTable(teamKey, details) {
    const pitchingData = details.pitching[teamKey] || [];
    let bodyRows = pitchingData.map((player, index) => `
        <tr data-pitcher-index="${index}">
            <td>
                <select>
                    <option value="" ${!player.result ? 'selected' : ''}>-</option>
                    <option value="W" ${player.result === 'W' ? 'selected' : ''}>○</option>
                    <option value="L" ${player.result === 'L' ? 'selected' : ''}>●</option>
                    <option value="S" ${player.result === 'S' ? 'selected' : ''}>S</option>
                    <option value="H" ${player.result === 'H' ? 'selected' : ''}>H</option>
                </select>
            </td>
            <td><input type="text" value="${player.name || ''}"></td>
            <td><input type="text" value="${player.innings || ''}"></td>
            <td><input type="number" value="${player.battersFaced || ''}"></td>
            <td><input type="number" value="${player.pitches || ''}"></td>
            <td><input type="number" value="${player.hits || ''}"></td>
            <td><input type="number" value="${player.strikeouts || ''}"></td>
            <td><input type="number" value="${player.walks || ''}"></td>
            <td><input type="number" value="${player.runs || ''}"></td>
            <td><input type="number" value="${player.earnedRuns || ''}"></td>
        </tr>
    `).join('');

    // もし投手が一人もいなければ、空の行を1つ追加しておく
    if (pitchingData.length === 0) {
        bodyRows = `
            <tr data-pitcher-index="0">
                <td><select><option value="" selected>-</option><option value="W">○</option><option value="L">●</option><option value="S">S</option><option value="H">H</option></select></td>
                <td><input type="text" value=""></td><td><input type="text" value=""></td><td><input type="number" value=""></td>
                <td><input type="number" value=""></td><td><input type="number" value=""></td><td><input type="number" value=""></td>
                <td><input type="number" value=""></td><td><input type="number" value=""></td><td><input type="number" value=""></td>
            </tr>
        `;
    }

    return `
        <div class="overflow-x-auto">
            <table class="details-table" id="pitching-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="w-12">勝敗</th><th class="col-player">選手名</th><th class="col-stat">回数</th>
                        <th class="col-stat">打者</th><th class="col-stat">球数</th><th class="col-stat">被安打</th>
                        <th class="col-stat">奪三振</th><th class="col-stat">与四球</th><th class="col-stat">失点</th>
                        <th class="col-stat">自責点</th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            <button class="add-row-btn text-xs mt-2" data-table-id="pitching-table-${teamKey}">+ 投手を追加</button>
        </div>
    `;
}

// ★★★ この関数を丸ごと置き換えてください ★★★
/**
 * 個人別打席結果のテーブルHTMLを生成する（交代選手表示バグ修正・最終版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（スタメン・交代選手の分離を修正した最終版）
 */
/**
 * Creates the batting stats table, with all dropdowns correctly implemented.
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（★列幅クラスを適用した最終版）
 */
// 【完成版】createPlayerBattingTable
/**
 * 個人別打席結果のテーブルHTMLを生成する（複数走者入力UI対応の最終版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（打者・走者入力分離の最終完成版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（複数打席ロジック統合版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（複数打席ロジック統合・最終版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（司令塔として再設計した最終版）
 */
function createPlayerBattingTable(teamName, teamKey, details) {
    const battingData = details.batting[teamKey] || [];
    const numInnings = details.inningScore?.[teamKey]?.length || 9;
    const playersOnField = battingData.filter(p => p.name);

    let numberOptions = '<option value=""></option>';
    for (let i = 1; i <= 20; i++) { numberOptions += `<option value="${i}">${i}</option>`; }
    const posOptions = ['投', '捕', '一', '二', '三', '遊', '左', '中', '右'].map(p => `<option value="${p}">${p}</option>`).join('');
    
    let inningsHeader = '';
    for (let i = 1; i <= numInnings; i++) {
        inningsHeader += `<th class="col-inning">${i}</th>`;
    }

    let bodyRows = '';

    for (let i = 1; i <= 9; i++) {
        let starterData = battingData.find(p => p.order && parseInt(p.order) === i) || { order: i, results: Array(numInnings).fill('') };
        if (!starterData.results) starterData.results = Array(numInnings).fill('');

        const starterNumberSelect = `<select class="player-number w-full bg-transparent">${numberOptions.replace(`value="${starterData.number}"`, `value="${starterData.number}" selected`)}</select>`;
        const starterPosSelect = `<select class="player-pos w-full bg-transparent"><option value=""></option>${posOptions.replace(`value="${starterData.pos}"`, `value="${starterData.pos}" selected`)}</select>`;
        
        let resultInputs = '';
        for (let j = 0; j < numInnings; j++) {
            const resultString = starterData.results[j] || '';
            const atBats = (resultString && resultString.split('、').length > 0) ? resultString.split('、') : [''];
            
            const atBatBlocksHTML = atBats.map(atBatString => 
                createBattingResultDropdowns(playersOnField, atBatString)
            ).join('');

            resultInputs += `
                <td class="col-inning batting-result-cell align-top p-1">
                    ${atBatBlocksHTML}
                    <button class="add-at-bat-btn text-xs mt-2 bg-blue-100 px-2 py-1 rounded hover:bg-blue-200 w-full font-semibold">＋ 2打席目を追加</button>
                </td>
            `;
        }
        bodyRows += `
            <tr data-order="${starterData.order}">
                <td class="col-order">${i}</td><td class="col-number">${starterNumberSelect}</td>
                <td class="col-player"><input type="text" class="player-name" value="${starterData.name || ''}"></td>
                <td class="col-pos flex items-center justify-between">${starterPosSelect}<button class="text-xs bg-gray-200 px-1 ml-1 rounded pos-change-btn" data-player-name="${starterData.name || ''}" data-team-key="${teamKey}">変更</button></td>
                <td class="col-sub-type"></td>${resultInputs}
            </tr>
        `;
        
        const substitutes = battingData.filter(p => p.order && p.order.toString().startsWith(`${i}-sub`));
        substitutes.forEach(subData => {
            if (!subData.results) subData.results = Array(numInnings).fill('');
            const subNumberSelect = `<select class="player-number w-full bg-transparent">${numberOptions.replace(`value="${subData.number}"`, `value="${subData.number}" selected`)}</select>`;
            const subPosSelect = `<select class="player-pos w-full bg-transparent"><option value=""></option>${posOptions.replace(`value="${subData.pos}"`, `value="${subData.pos}" selected`)}</select>`;
            
            let subResultInputs = '';
            for (let j = 0; j < numInnings; j++) {
                const resultString = subData.results[j] || '';
                const atBats = (resultString && resultString.split('、').length > 0) ? resultString.split('、') : [''];
                const atBatBlocksHTML = atBats.map(atBatString => 
                    createBattingResultDropdowns(playersOnField, atBatString)
                ).join('');
                subResultInputs += `
                    <td class="col-inning batting-result-cell align-top p-1">
                        ${atBatBlocksHTML}
                        <button class="add-at-bat-btn text-xs mt-2 bg-blue-100 px-2 py-1 rounded hover:bg-blue-200 w-full font-semibold">＋ 2打席目を追加</button>
                    </td>
                `;
            }
            
            bodyRows += `
                <tr data-order="${subData.order}">
                    <td class="col-order"></td><td class="col-number">${subNumberSelect}</td>
                    <td class="col-player pl-4"><input type="text" class="player-name" value="${subData.name || ''}"></td>
                    <td class="col-pos flex items-center justify-between">${subPosSelect}<button class="text-xs bg-gray-200 px-1 ml-1 rounded pos-change-btn" data-player-name="${subData.name || ''}" data-team-key="${teamKey}">変更</button></td>
                    <td class="col-sub-type">
                        <select class="sub-type-select w-full bg-transparent">
                            <option value="" ${!subData.sub_type ? 'selected' : ''}>-</option>
                            <option value="PH" ${subData.sub_type === 'PH' ? 'selected' : ''}>代打</option>
                            <option value="PR" ${subData.sub_type === 'PR' ? 'selected' : ''}>代走</option>
                            <option value="DEF" ${subData.sub_type === 'DEF' ? 'selected' : ''}>守備</option>
                            <option value="PITCHER" ${subData.sub_type === 'PITCHER' ? 'selected' : ''}>投手</option>
                        </select>
                    </td>
                    ${subResultInputs}
                </tr>
            `;
        });
    }

    return `
        <div class="overflow-x-auto">
            <table class="details-table batting-table" id="batting-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="col-order">打順</th><th class="col-number">#</th><th class="col-player">選手名</th>
                        <th class="col-pos">守備</th><th class="col-sub-type">出場</th>${inningsHeader}
                        <th class="w-10"><button class="add-inning-btn text-xs" data-team-key="${teamKey}">+ 回</button></th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            <button class="add-substitute-btn text-xs mt-2" data-team-key="${teamKey}">+ 交代選手を追加</button>
        </div>
    `;
}
    /**
 * 詳細データを保存し、通算成績を更新する
 * (★先攻後攻を入れ替えた場合にも対応した最終版)
 */
/**
 * 詳細データを保存し、通算成績を更新する（全ての機能を網羅した最終完成版）
 */
/**
 * 詳細データを保存し、通算成績を更新する（省略箇所を全て復元した最終完成版）
 */
/**
 * 詳細データを保存し、通算成績を更新する（データ構造の矛盾を解消した最終完成版）
 */
/**
 * 詳細データを保存し、通算成績を更新する（データ構造の矛盾を解消した最終完成版）
 */
function saveDetailedStats() {
    if (!currentMatchIdForDetails) return;
    const match = findMatchById(currentMatchIdForDetails);
    if (!match) return;

    // --- 1. 古い成績を一度リセット ---
    if (match.details && match.details.playerGameStats) {
        for (const teamKey of ['team1', 'team2']) {
            const teamName = match[teamKey];
            const teamRecord = tournamentState.teamRecords[teamName];
            if (!teamRecord || !teamRecord.playerStats) continue;

            const previousBattingStats = match.details.playerGameStats[teamKey];
            if (previousBattingStats) {
                for (const playerName in previousBattingStats) {
                    const careerStats = teamRecord.playerStats.batting[playerName];
                    const prevGameStats = previousBattingStats[playerName];
                    if (careerStats && prevGameStats) {
                        if(prevGameStats.played) careerStats.games = (careerStats.games || 1) - 1;
                        careerStats.pa -= prevGameStats.pa || 0;
                        careerStats.ab -= prevGameStats.ab || 0;
                        careerStats.h -= prevGameStats.h || 0;
                        careerStats.hr -= prevGameStats.hr || 0;
                        careerStats.rbi -= prevGameStats.rbi || 0;
                    }
                }
            }
            const previousPitchingStats = match.details.pitching?.[teamKey];
            if (previousPitchingStats) {
                previousPitchingStats.forEach(prevGameStats => {
                    const playerName = prevGameStats.name;
                    const careerStats = teamRecord.playerStats.pitching[playerName];
                    if (careerStats && prevGameStats && parseFloat(prevGameStats.innings) > 0) {
                        careerStats.games = (careerStats.games || 1) - 1;
                        if (prevGameStats.result === 'W') careerStats.w--;
                        if (prevGameStats.result === 'L') careerStats.l--;
                        careerStats.ip -= parseFloat(prevGameStats.innings || 0);
                        careerStats.so -= parseInt(prevGameStats.strikeouts || 0);
                        careerStats.er -= parseInt(prevGameStats.earnedRuns || 0);
                    }
                });
            }
        }
    }

    // --- 2. 新しい詳細データオブジェクトを作成 ---
    const details = { 
        inningScore: { team1: [], team2: [] }, 
        batting: { team1: [], team2: [] }, 
        pitching: { team1: [], team2: [] }, 
        playerGameStats: { team1: {}, team2: {} },
        positionChanges: match.details?.positionChanges || []
    };
    
    // --- 3. 画面から入力された値を読み取り、成績を再計算・加算 ---
    const scoreTable = document.getElementById('inning-score-table');
    if (scoreTable) {
        const rows = scoreTable.querySelectorAll('tbody tr');
        const team1Row = Array.from(rows).find(row => row.querySelector('th')?.textContent.trim() === match.team1);
        const team2Row = Array.from(rows).find(row => row.querySelector('th')?.textContent.trim() === match.team2);
        if (team1Row) details.inningScore.team1 = Array.from(team1Row.querySelectorAll('input')).map(input => parseInt(input.value) || 0);
        if (team2Row) details.inningScore.team2 = Array.from(team2Row.querySelectorAll('input')).map(input => parseInt(input.value) || 0);
    }
    match.score1 = details.inningScore.team1.reduce((sum, score) => sum + score, 0);
    match.score2 = details.inningScore.team2.reduce((sum, score) => sum + score, 0);

    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord) continue;
        if (!teamRecord.playerStats) teamRecord.playerStats = { batting: {}, pitching: {} };

        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (battingTable) {
            battingTable.querySelectorAll('tbody tr').forEach(row => {
                const nameInput = row.querySelector('.player-name');
                if (nameInput && nameInput.value.trim() !== '') {
                    
                    const resultCells = Array.from(row.querySelectorAll('td.col-inning'));
                    const results = resultCells.map(cell => {
                        const atBatBlocks = Array.from(cell.querySelectorAll('.at-bat-block'));
                        
                        const atBatsString = atBatBlocks.map(block => {
                            const container = block.querySelector('.batting-result-container');
                            if (!container) return ''; 

                            const resultType = container.querySelector('.result-type').value;
                            const direction = container.querySelector('.result-direction').value;
                            const rbi = container.querySelector('.result-rbi').value;
                            const runnerPlay = container.querySelector('.result-runner-play').value;
                            const batterPlay = [direction, resultType, rbi, runnerPlay].filter(Boolean).join('');
                            
                            // ▼▼▼【重要修正】区切り文字を「、」から「,」に変更▼▼▼
                            const runnerPlays = Array.from(block.querySelectorAll('.runner-play-input')).map(rpContainer => {
                                const name = rpContainer.querySelector('.runner-name').value;
                                const play = rpContainer.querySelector('.runner-play').value;
                                const base = rpContainer.querySelector('.runner-base').value;
                                if (!name || !play) return '';
                                return [name, play, base].filter(Boolean).join(' ');
                            }).filter(Boolean).join(',');
                            // ▲▲▲
                            
                            return [batterPlay, runnerPlays].filter(Boolean).join(';');
                        }).join('、');

                        return atBatsString;
                    });
                    
                    const playerData = {
                        order: row.dataset.order, name: nameInput.value.trim(),
                        number: row.querySelector('.player-number').value,
                        pos: row.querySelector('.player-pos').value,
                        sub_type: row.querySelector('.sub-type-select') ? row.querySelector('.sub-type-select').value : null,
                        results: results
                    };
                    details.batting[teamKey].push(playerData);
                    
                    const playerName = playerData.name;
                    if (!teamRecord.playerStats.batting[playerName]) {
                        teamRecord.playerStats.batting[playerName] = { games: 0, pa: 0, ab: 0, h: 0, hr: 0, rbi: 0 };
                    }
                    const careerStats = teamRecord.playerStats.batting[playerName];
                    const gameStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, played: false };

                    playerData.results.forEach(inningResultString => {
                        if (!inningResultString) return;
                        inningResultString.split('、').forEach(atBatString => {
                            if (!atBatString) return;
                            const [batterPlay] = atBatString.split(';');
                            if (!batterPlay) return;
                            
                            gameStats.played = true;
                            gameStats.pa++;
                            if (!batterPlay.includes('四球') && !batterPlay.includes('死球') && !batterPlay.includes('犠')) gameStats.ab++;
                            
                            const isHitWord = ['安', '本', '二', '三'].some(w => batterPlay.includes(w));
                            if (isHitWord) gameStats.h++;
                            if (batterPlay.includes('本')) gameStats.hr++;
                            if (batterPlay.includes('点')) {
                                const rbiMatch = batterPlay.match(/(\d+)点/);
                                gameStats.rbi += rbiMatch ? parseInt(rbiMatch[1]) : 1;
                            }
                        });
                    });

                    if(gameStats.played) careerStats.games++;
                    careerStats.pa += gameStats.pa;
                    careerStats.ab += gameStats.ab;
                    careerStats.h += gameStats.h;
                    careerStats.hr += gameStats.hr;
                    careerStats.rbi += gameStats.rbi;
                    
                    details.playerGameStats[teamKey][playerName] = gameStats;
                }
            });
        }

        const pitchingTable = document.getElementById(`pitching-table-${teamKey}`);
        if (pitchingTable) {
            pitchingTable.querySelectorAll('tbody tr').forEach(row => {
                const inputs = row.querySelectorAll('input');
                const select = row.querySelector('select');
                if (inputs[0] && inputs[0].value.trim() !== '') {
                    const pitcherData = {
                        result: select.value, name: inputs[0].value.trim(), innings: inputs[1].value,
                        battersFaced: inputs[2].value, pitches: inputs[3].value, hits: inputs[4].value,
                        strikeouts: inputs[5].value, walks: inputs[6].value, runs: inputs[7].value,
                        earnedRuns: inputs[8].value,
                    };
                    details.pitching[teamKey].push(pitcherData);

                    const pitcherName = pitcherData.name;
                    if (!teamRecord.playerStats.pitching[pitcherName]) {
                        teamRecord.playerStats.pitching[pitcherName] = { games: 0, w: 0, l: 0, ip: 0, so: 0, er: 0 };
                    }
                    const careerStats = teamRecord.playerStats.pitching[pitcherName];
                    if (parseFloat(pitcherData.innings) > 0) {
                        careerStats.games = (careerStats.games || 0) + 1;
                        if (pitcherData.result === 'W') careerStats.w++;
                        if (pitcherData.result === 'L') careerStats.l--;
                        careerStats.ip += parseFloat(pitcherData.innings) || 0;
                        careerStats.so += parseInt(pitcherData.strikeouts) || 0;
                        careerStats.er += parseInt(pitcherData.earnedRuns) || 0;
                    }
                }
            });
        }
    }

    match.details = details;
    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord) continue;
        const battingData = details.batting[teamKey];
        if (battingData && battingData.length > 0) {
            teamRecord.roster = battingData
                .filter(p => p.order && !p.order.toString().includes('sub'))
                .map(p => ({ order: p.order, number: p.number, name: p.name, pos: p.pos }));
        }
    }

    saveState();
    detailsModal.classList.add('hidden');
    renderTournament(tournamentState);
    alert('詳細を保存しました。');
}
/**
     * 【修正版】スキップ機能関連
     */
    function generateAutoScore(rankWinner, rankLoser) {
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        const diff = rankValues[rankWinner] - rankValues[rankLoser];
        let winnerScore, loserScore;

        if (diff >= 3) { // 大差
            winnerScore = 7 + Math.floor(Math.random() * 4);
            loserScore = Math.floor(Math.random() * 3);
        } else if (diff >= 2) { // 中差
            winnerScore = 5 + Math.floor(Math.random() * 3);
            loserScore = Math.max(0, winnerScore - (3 + Math.floor(Math.random() * 2)));
        } else if (diff >= 1) { // 小差
            winnerScore = 3 + Math.floor(Math.random() * 4);
            loserScore = Math.max(0, winnerScore - (1 + Math.floor(Math.random() * 2)));
        } else { // 同ランク
            winnerScore = 2 + Math.floor(Math.random() * 5);
            loserScore = winnerScore - 1;
        }
        return [winnerScore, loserScore];
    }

    /**
     * 【修正版】ラウンドを自動でスキップする
     */
    async function skipRound(roundNumber) {
        const btnId = `skip-r${roundNumber}-btn`;
        const btn = document.getElementById(btnId);
        if (btn) btn.disabled = true;

        const matchIds = [];
        const numMatchesInRoundSide = (tournamentState.teams.length / 2) / Math.pow(2, roundNumber - 1);

        ['L', 'R'].forEach(side => {
            for (let i = 1; i <= numMatchesInRoundSide; i++) {
                matchIds.push(`${side}-R${roundNumber}-M${i}`);
            }
        });

        const results = []; // このラウンドの結果を格納する配列

        // ステップ1：ラウンドの全試合の勝敗を決定
        for (const matchId of matchIds) {
            const match = tournamentState.matches[matchId];
            if (!match || match.winner || !match.team1 || !match.team2) continue;

            const { team1, team2 } = match;
            const rank1 = calculateRank(team1, tournamentState);
            const rank2 = calculateRank(team2, tournamentState);
            const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
            let winnerName, loserName;
            
            const upsetChance = 0.15 - (Math.abs(rankValues[rank1] - rankValues[rank2]) * 0.03);

            if (Math.random() < upsetChance) { // 番狂わせ
                winnerName = rankValues[rank1] < rankValues[rank2] ? team1 : team2;
            } else { // 順当
                winnerName = rankValues[rank1] >= rankValues[rank2] ? team1 : team2;
            }
            loserName = winnerName === team1 ? team2 : team1;
            
            const winnerRank = calculateRank(winnerName, tournamentState);
            const loserRank = calculateRank(loserName, tournamentState);

            const [winnerScore, loserScore] = generateAutoScore(winnerRank, loserRank);
            match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
            match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;
            match.winner = winnerName;
            
            if (tournamentState.teamRecords[winnerName]) tournamentState.teamRecords[winnerName].wins++;
            if (tournamentState.teamRecords[loserName]) tournamentState.teamRecords[loserName].losses++;
            
            // ダイジェスト記事用に結果を保存
            results.push({ winnerName, loserName, winnerScore, loserScore, rankDiff: Math.abs(rankValues[rank1] - rankValues[rank2]) });
        }
        
        // ステップ2：勝者を次のラウンドに進める
        const nextRoundNum = roundNumber + 1;
        const numTeams = tournamentState.teams.length;
        const finalRound = Math.log2(numTeams);

        if (nextRoundNum <= finalRound) {
            const numMatchesInNextRoundSide = numTeams / 2 / Math.pow(2, nextRoundNum - 1);
            for (const side of ['L', 'R']) {
                if (nextRoundNum < finalRound) {
                    for (let m = 1; m <= numMatchesInNextRoundSide; m++) {
                        const prevMatch1Id = `${side}-R${roundNumber}-M${(m * 2) - 1}`;
                        const prevMatch2Id = `${side}-R${roundNumber}-M${m * 2}`;
                        const winner1 = tournamentState.matches[prevMatch1Id]?.winner;
                        const winner2 = tournamentState.matches[prevMatch2Id]?.winner;
                        const nextMatchId = `${side}-R${nextRoundNum}-M${m}`;
                        
                        if (!tournamentState.matches[nextMatchId]) {
                            tournamentState.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
                        }
                        tournamentState.matches[nextMatchId].team1 = winner1;
                        tournamentState.matches[nextMatchId].team2 = winner2;
                    }
                } else { // 決勝戦への進出処理
                    const finalMatchId = 'F-R1-M1';
                    if (!tournamentState.matches[finalMatchId]) {
                         tournamentState.matches[finalMatchId] = { id: finalMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
                    }
                    const semiFinalWinner = tournamentState.matches[`${side}-R${roundNumber}-M1`]?.winner;
                    if (side === 'L') tournamentState.matches[finalMatchId].team1 = semiFinalWinner;
                    if (side === 'R') tournamentState.matches[finalMatchId].team2 = semiFinalWinner;
                }
            }
        }
        
        // ステップ3：UIの更新とダイジェスト記事の生成
        renderTournament(tournamentState);
        newsContainer.innerHTML = `<div class="loader">AI記者が${roundNumber}回戦のダイジェスト記事を執筆中...</div>`;

        const summaryArticle = await generateSkipRoundSummaryArticle(roundNumber, results);
        if (summaryArticle) {
            tournamentState.news.push(summaryArticle);
        }
        
        renderNews(tournamentState.news);
        saveState();
        if (btn) btn.classList.add('hidden');
    }
// --- NEW Autumn Tournament System ---

    /**
     * [秋季大会 ステージ1] 地区ブロック予選を開始する
     */
    async function setupAutumnRegionalBlocks() {
        tournamentState.autumnPhase = 'regional_blocks';
        
        const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
        INITIAL_TEAM_POOL.forEach(teamName => {
            const region = TEAM_DATA[teamName]?.region;
            if (region) teamsByRegion[region].push(teamName);
        });

        // 主要3地区のブロック分け
        ['東部', '中部', '西部'].forEach(region => {
            let regionalTeams = shuffleArray(teamsByRegion[region]);
            const blocks = [];
            for (let i = 0; i < 4; i++) { // 4ブロック作成
                const blockTeams = regionalTeams.splice(0, 5); // 5チームずつ
                if (blockTeams.length === 0) continue;

                const blockId = `${region}-B${i+1}`;
                
                const playInMatchId = `${blockId}-R0-M1`;
                const semi1Id = `${blockId}-R1-M1`;
                const semi2Id = `${blockId}-R1-M2`;
                const finalId = `${blockId}-R2-M1`;

                const matches = {
                    [playInMatchId]: { id: playInMatchId, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '', summary: '' },
                    [semi1Id]: { id: semi1Id, team1: null, team2: blockTeams[2], winner: null, score1: '', score2: '', summary: '' },
                    [semi2Id]: { id: semi2Id, team1: blockTeams[3], team2: blockTeams[4], winner: null, score1: '', score2: '', summary: '' },
                    [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '', summary: '' }
                };
                blocks.push({ id: blockId, teams: blockTeams, matches });
            }
            tournamentState.autumnData.regions[region].blocks = blocks;
        });

        // 伊豆地区は予選なしで県大会へ
        tournamentState.autumnData.regions['伊豆'].finalReps.push({ team: teamsByRegion['伊豆'][0], rank: 1 });

        renderTournament(tournamentState);
        saveState();
    }

    /**
     * [秋季大会 ステージ1 UI] 地区ブロック予選を描画する
     */
    function renderAutumnRegionalBlocks() {
        let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">秋季大会 地区ブロック予選</h2>`;
        html += '<div class="space-y-8">';

        for (const region of ['東部', '中部', '西部']) {
            const regionData = tournamentState.autumnData.regions[region];
            if (!regionData.blocks) continue;

            html += `
                <div class="p-4 border-2 rounded-lg shadow-md">
                    <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">${region}地区</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        ${regionData.blocks.map(block => `
                            <div class="p-3 border rounded-lg bg-gray-50">
                                <h4 class="font-bold text-center mb-2">ブロック ${block.id.split('-')[1]}</h4>
                                ${create5TeamBlockHTML(block)}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        html += '</div>';
        autumnRegionalContainer.innerHTML = html;
        checkAutumnRegionalBlocksComplete();
    }

    /**
     * 5チーム構成のブロックトーナメントHTMLを生成する
     * @param {object} blockData - 対象ブロックのデータ
     */
    // 【修正対象2】
function create5TeamBlockHTML(blockData) {
    const { id, matches } = blockData;
    const playIn = matches[`${id}-R0-M1`];
    const semi1 = matches[`${id}-R1-M1`];
    const semi2 = matches[`${id}-R1-M2`];
    const final = matches[`${id}-R2-M1`];

    // 試合の進行状況を更新
    semi1.team1 = playIn.winner;
    final.team1 = semi1.winner;
    final.team2 = semi2.winner;

    return `
        <div class="flex items-center justify-center space-x-2 text-xs">
            <div class="flex flex-col justify-around h-full space-y-4">
                <div class="w-40">${createMatchHTML(playIn.id, playIn.team1, playIn.team2, playIn, [])}</div>
                <div class="w-40">${createMatchHTML(semi2.id, semi2.team1, semi2.team2, semi2, [])}</div>
            </div>
            <div class="flex flex-col justify-center h-full w-40">
                ${createMatchHTML(semi1.id, semi1.team1, semi1.team2, semi1, [])}
            </div>
            <div class="flex flex-col justify-center h-full w-40">
                ${createMatchHTML(final.id, final.team1, final.team2, final, [])}
            </div>
        </div>
    `;
}

    /**
     * [秋季大会 ステージ2] 地区内順位決定戦を開始する
     */
    async function setupAutumnRankingTournaments() {
        tournamentState.autumnPhase = 'regional_ranking';

        for (const region of ['東部', '中部', '西部']) {
            const regionData = tournamentState.autumnData.regions[region];
            
            // 上位校トーナメント（1位～4位決定戦）
            const champBracketId = `${region}-CHAMP`;
            const champTeams = shuffleArray(regionData.blockWinners);
            regionData.champBracket = {
                id: champBracketId,
                teams: champTeams,
                matches: {
                    [`${champBracketId}-R1-M1`]: { id: `${champBracketId}-R1-M1`, team1: champTeams[0], team2: champTeams[1], winner: null, score1: '', score2: '', summary: '', type: 'semi' },
                    [`${champBracketId}-R1-M2`]: { id: `${champBracketId}-R1-M2`, team1: champTeams[2], team2: champTeams[3], winner: null, score1: '', score2: '', summary: '', type: 'semi' },
                    [`${champBracketId}-R2-M1`]: { id: `${champBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '', summary: '', type: 'final' }, // 1位決定戦
                    [`${champBracketId}-R2-M2`]: { id: `${champBracketId}-R2-M2`, team1: null, team2: null, winner: null, score1: '', score2: '', summary: '', type: 'third' }  // 3位決定戦
                }
            };

            // 第5代表決定トーナメント（敗者復活）
            const repechageBracketId = `${region}-REP`;
            const repTeams = shuffleArray(regionData.blockRunnersUp);
            regionData.repechageBracket = {
                id: repechageBracketId,
                teams: repTeams,
                matches: {
                    [`${repechageBracketId}-R1-M1`]: { id: `${repechageBracketId}-R1-M1`, team1: repTeams[0], team2: repTeams[1], winner: null, score1: '', score2: '', summary: '' },
                    [`${repechageBracketId}-R1-M2`]: { id: `${repechageBracketId}-R1-M2`, team1: repTeams[2], team2: repTeams[3], winner: null, score1: '', score2: '', summary: '' },
                    [`${repechageBracketId}-R2-M1`]: { id: `${repechageBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '', summary: '' } // 5位決定戦
                }
            };
        }
        
        renderTournament(tournamentState);
        saveState();
    }

    /**
     * [秋季大会 ステージ2 UI] 地区内順位決定戦を描画する
     */
   // 【修正対象3】
function renderAutumnRankingTournaments() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">秋季大会 地区内順位決定戦</h2>`;
    html += '<div class="space-y-8">';
    
    for (const region of ['東部', '中部', '西部']) {
         const regionData = tournamentState.autumnData.regions[region];
         if (!regionData.champBracket) continue;

         const champ = regionData.champBracket;
         const rep = regionData.repechageBracket;
         
         const champSemi1 = champ.matches[`${champ.id}-R1-M1`];
         const champSemi2 = champ.matches[`${champ.id}-R1-M2`];
         champ.matches[`${champ.id}-R2-M1`].team1 = champSemi1.winner;
         champ.matches[`${champ.id}-R2-M1`].team2 = champSemi2.winner;
         champ.matches[`${champ.id}-R2-M2`].team1 = champSemi1.winner === champSemi1.team1 ? champSemi1.team2 : champSemi1.team1;
         champ.matches[`${champ.id}-R2-M2`].team2 = champSemi2.winner === champSemi2.team1 ? champSemi2.team2 : champSemi2.team1;

         const repSemi1 = rep.matches[`${rep.id}-R1-M1`];
         const repSemi2 = rep.matches[`${rep.id}-R1-M2`];
         rep.matches[`${rep.id}-R2-M1`].team1 = repSemi1.winner;
         rep.matches[`${rep.id}-R2-M1`].team2 = repSemi2.winner;
         
         html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">${region}地区</h3>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div>
                        <h4 class="font-bold text-center text-lg mb-2">上位校トーナメント (1～4位)</h4>
                        <div class="flex items-center justify-center space-x-4">
                            <div class="space-y-4">
                                ${createMatchHTML(champSemi1.id, champSemi1.team1, champSemi1.team2, champSemi1, [])}
                                ${createMatchHTML(champSemi2.id, champSemi2.team1, champSemi2.team2, champSemi2, [])}
                            </div>
                            <div class="space-y-4">
                                <p class="text-center font-semibold">1位決定戦</p>
                                ${createMatchHTML(champ.matches[`${champ.id}-R2-M1`].id, champ.matches[`${champ.id}-R2-M1`].team1, champ.matches[`${champ.id}-R2-M1`].team2, champ.matches[`${champ.id}-R2-M1`], [])}
                                <p class="text-center font-semibold">3位決定戦</p>
                                ${createMatchHTML(champ.matches[`${champ.id}-R2-M2`].id, champ.matches[`${champ.id}-R2-M2`].team1, champ.matches[`${champ.id}-R2-M2`].team2, champ.matches[`${champ.id}-R2-M2`], [])}
                            </div>
                        </div>
                    </div>
                    <div>
                        <h4 class="font-bold text-center text-lg mb-2">第5代表決定トーナメント</h4>
                        <div class="flex items-center justify-center space-x-4">
                            <div class="space-y-4">
                                ${createMatchHTML(repSemi1.id, repSemi1.team1, repSemi1.team2, repSemi1, [])}
                                ${createMatchHTML(repSemi2.id, repSemi2.team1, repSemi2.team2, repSemi2, [])}
                            </div>
                            <div>
                                ${createMatchHTML(rep.matches[`${rep.id}-R2-M1`].id, rep.matches[`${rep.id}-R2-M1`].team1, rep.matches[`${rep.id}-R2-M1`].team2, rep.matches[`${rep.id}-R2-M1`], [])}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
         `;
    }
    html += '</div>';
    autumnRankingContainer.innerHTML = html;
    checkAutumnRankingTournamentsComplete();
}
    /**
     * [秋季大会 ステージ3] 県大会本戦を開始する
     */
   // 【修正対象4】
async function setupAutumnMainTournament() {
    tournamentState.autumnPhase = 'main';
    tournamentState.is16team = true;

    const allReps = [];
    for (const region of ['東部', '中部', '西部', '伊豆']) {
        tournamentState.autumnData.regions[region].finalReps.forEach(rep => {
            allReps.push({ ...rep, region });
        });
    }
    
    const qualifiedTeamNames = allReps.map(r => r.team);
    INITIAL_TEAM_POOL.forEach(teamName => {
        if (!qualifiedTeamNames.includes(teamName) && tournamentState.teamRecords[teamName]) {
            tournamentState.teamRecords[teamName].lastFinish = 32;
        }
    });

    const pots = { 1: [], 2: [], 3: [], 4: [], 5: [] };
    allReps.forEach(rep => {
        if (pots[rep.rank]) pots[rep.rank].push(rep);
    });
    
    for (const potNum in pots) {
        pots[potNum] = shuffleArray(pots[potNum]);
    }

    const matchups = [];
    let remainingTeams = [...allReps];
    const sortedPots = Object.keys(pots).sort((a,b) => parseInt(a) - parseInt(b));

    for (const potNum of sortedPots) {
        const teamsInPot = remainingTeams.filter(t => t.rank === parseInt(potNum));
        for (const teamA of teamsInPot) {
            if (!remainingTeams.some(t => t.team === teamA.team)) continue;

            let opponent = null;
            for (let i = sortedPots.length - 1; i >= 0; i--) {
                const opponentPotNum = sortedPots[i];
                const candidates = remainingTeams.filter(t => t.rank === parseInt(opponentPotNum) && t.region !== teamA.region && t.team !== teamA.team);
                if (candidates.length > 0) {
                    opponent = candidates[0];
                    break;
                }
            }
            if (!opponent) {
                opponent = remainingTeams.find(t => t.team !== teamA.team);
            }
            
            if (opponent) {
                matchups.push({ team1: teamA.team, team2: opponent.team });
                remainingTeams = remainingTeams.filter(t => t.team !== teamA.team && t.team !== opponent.team);
            }
        }
    }

    tournamentState.teams = matchups.flatMap(m => [m.team1, m.team2]);
    tournamentState.matches = {};
    tournamentState.seeds = pots[1].map(p => p.team);
    
    matchups.forEach((match, index) => { // ★修正点
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

    renderTournament(tournamentState);
    saveState();

    const currentTournamentName = "秋季県大会本戦";
    newsContainer.innerHTML = `<div class="loader">AI記者が${currentTournamentName}の展望記事を執筆中...</div>`;
    bbsCommentsContainer.innerHTML = `<div class="loader">AIが組み合わせを分析中...</div>`;

    const [previewArticle, bracketComments] = await Promise.all([
        generateNewsArticle(null, null, null, 'preview', null, null),
        generateBracketReactionComments(tournamentState)
    ]);

    if (previewArticle) tournamentState.news.unshift(previewArticle);
    if (bracketComments && bracketComments.length > 0) tournamentState.bbsComments.push(...bracketComments);
    
    renderNews(tournamentState.news);
    renderBbsComments(tournamentState.bbsComments);
    saveState();
}
    /**
     * 秋季地区ブロック予選がすべて終了したかチェックする
     */
    function checkAutumnRegionalBlocksComplete() {
        let allBlocksFinished = true;
        for (const region of ['東部', '中部', '西部']) {
            const regionData = tournamentState.autumnData.regions[region];
            if (!regionData.blocks) {
                allBlocksFinished = false;
                break;
            }
            for (const block of regionData.blocks) {
                const finalMatch = block.matches[`${block.id}-R2-M1`];
                if (!finalMatch.winner) {
                    allBlocksFinished = false;
                    break;
                }
            }
            if (!allBlocksFinished) break;
        }

        if (allBlocksFinished) {
            autumnControls.classList.remove('hidden');
            startRankingPlayoffsBtn.classList.remove('hidden');
        } else {
            autumnControls.classList.add('hidden');
            startRankingPlayoffsBtn.classList.add('hidden');
        }
    }

    /**
     * 秋季地区内順位決定戦がすべて終了したかチェックする
     */
    /**
     * 【修正版】秋季地区内順位決定戦がすべて終了したかチェックする
     */
    function checkAutumnRankingTournamentsComplete() {
        let allRankingsFinished = true;
        for (const region of ['東部', '中部', '西部']) {
            const regionData = tournamentState.autumnData.regions[region];
            if (!regionData.champBracket || !regionData.repechageBracket) {
                allRankingsFinished = false;
                break;
            }

            const champFinal = regionData.champBracket.matches[`${region}-CHAMP-R2-M1`]; // 1位/2位
            const thirdPlaceMatch = regionData.champBracket.matches[`${region}-CHAMP-R2-M2`]; // ★これが抜けていました
            const repechageFinal = regionData.repechageBracket.matches[`${region}-REP-R2-M1`]; // 5位

            // 1位, 3位, 5位決定戦のすべてが終わっているかチェック
            if (!champFinal.winner || !thirdPlaceMatch.winner || !repechageFinal.winner) {
                allRankingsFinished = false;
                break;
            }
        }
        
        if (allRankingsFinished) {
            autumnControls.classList.remove('hidden');
            startRankingPlayoffsBtn.classList.add('hidden'); // 前のボタンは隠す
            startMainTournamentBtn.classList.remove('hidden');
        } else {
            autumnControls.classList.add('hidden');
            startMainTournamentBtn.classList.add('hidden');
        }
    }
// --- NEW Spring Tournament System ---

/**
 * [春季大会 ステージ1] 地区予選を開始する
 */
async function setupSpringRegionalQualifiers() {
    tournamentState.springPhase = 'regional_qualifiers';
    const { qualifierTeams } = tournamentState.springData;

    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    qualifierTeams.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region && teamsByRegion[region]) {
            teamsByRegion[region].push(teamName);
        }
    });
    
    // 東部・中部・西部地区の予選設定
    for (const region of ['東部', '中部', '西部']) {
        let regionalTeams = shuffleArray(teamsByRegion[region]);
        const blockCount = 4;
        const regionBlocks = [];
        
        for (let i = 0; i < blockCount; i++) {
            const blockTeams = regionalTeams.splice(0, Math.ceil(regionalTeams.length / (blockCount - i)));
            if(blockTeams.length === 0) continue;
            
            const blockId = `${region}-SB${i+1}`; // Spring Block
            const blockMatches = {};
            
            // 4チームまたは5チームのトーナメントを生成
            if (blockTeams.length <= 4) { // 4チーム以下
                const semi1Id = `${blockId}-R1-M1`;
                const semi2Id = `${blockId}-R1-M2`;
                const finalId = `${blockId}-R2-M1`;
                Object.assign(blockMatches, {
                    [semi1Id]: { id: semi1Id, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '', summary: '' },
                    [semi2Id]: { id: semi2Id, team1: blockTeams[2], team2: blockTeams[3] || null, winner: null, score1: '', score2: '', summary: '' },
                    [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '', summary: '' }
                });
            } else { // 5チーム
                 const playInMatchId = `${blockId}-R0-M1`;
                 const semi1Id = `${blockId}-R1-M1`;
                 const semi2Id = `${blockId}-R1-M2`;
                 const finalId = `${blockId}-R2-M1`;
                 Object.assign(blockMatches, {
                    [playInMatchId]: { id: playInMatchId, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '', summary: '' },
                    [semi1Id]: { id: semi1Id, team1: null, team2: blockTeams[2], winner: null, score1: '', score2: '', summary: '' },
                    [semi2Id]: { id: semi2Id, team1: blockTeams[3], team2: blockTeams[4], winner: null, score1: '', score2: '', summary: '' },
                    [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '', summary: '' }
                 });
            }
            regionBlocks.push({ id: blockId, teams: blockTeams, matches: blockMatches });
            Object.assign(tournamentState.springData.allMatches, blockMatches);
        }
        tournamentState.springData.regions[region].blocks = regionBlocks;

        // 第5代表決定トーナメントの器を準備
        const repBracketId = `${region}-SREP`;
        tournamentState.springData.regions[region].repechageBracket = {
            id: repBracketId,
            teams: [], // ブロック準優勝校がここに入る
            matches: {
                [`${repBracketId}-R1-M1`]: { id: `${repBracketId}-R1-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' },
                [`${repBracketId}-R1-M2`]: { id: `${repBracketId}-R1-M2`, team1: null, team2: null, winner: null, score1: '', score2: '' },
                [`${repBracketId}-R2-M1`]: { id: `${repBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' }
            }
        };
        Object.assign(tournamentState.springData.allMatches, tournamentState.springData.regions[region].repechageBracket.matches);
    }
    
    // 伊豆地区の予選設定 (4チームトーナメント)
    const izuTeams = teamsByRegion['伊豆'];
    const izuBracketId = '伊豆-SIZU';
    const izuBracket = {
        id: izuBracketId,
        teams: izuTeams,
        matches: {
            [`${izuBracketId}-R1-M1`]: { id: `${izuBracketId}-R1-M1`, team1: izuTeams[0], team2: izuTeams[1], winner: null, score1: '', score2: '' },
            [`${izuBracketId}-R1-M2`]: { id: `${izuBracketId}-R1-M2`, team1: izuTeams[2], team2: izuTeams[3], winner: null, score1: '', score2: '' },
            [`${izuBracketId}-R2-M1`]: { id: `${izuBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' }
        }
    };
    tournamentState.springData.regions['伊豆'].izuBracket = izuBracket;
    Object.assign(tournamentState.springData.allMatches, izuBracket.matches);

    renderTournament(tournamentState);
    saveState();
}

/**
 * [春季大会 ステージ1 UI] 地区予選を描画する
 */
function renderSpringRegionalQualifiers() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">春季大会 地区予選</h2>`;
    html += '<div class="space-y-8">';

    // 東部・中部・西部
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.springData.regions[region];
        if (!regionData.blocks) continue;

        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-green-700">${region}地区 (5枠)</h3>
                <h4 class="font-bold text-center text-lg mb-2">代表決定ブロック</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    ${regionData.blocks.map(block => `
                        <div class="p-3 border rounded-lg bg-gray-50">
                            <h4 class="font-bold text-center mb-2">ブロック ${block.id.split('-')[1].slice(1)}</h4>
                            ${block.teams.length <= 4 ? create4TeamBlockHTML(block) : create5TeamBlockHTML(block)}
                        </div>
                    `).join('')}
                </div>
                <h4 class="font-bold text-center text-lg mb-2">第5代表決定トーナメント</h4>
                <div class="flex justify-center">
                   ${create4TeamBlockHTML(regionData.repechageBracket, true)}
                </div>
            </div>
        `;
    }

    // 伊豆
    const izuData = tournamentState.springData.regions['伊豆'];
    if (izuData.izuBracket) {
        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-green-700">伊豆地区 (1枠)</h3>
                <div class="flex justify-center">
                    ${create4TeamBlockHTML(izuData.izuBracket)}
                </div>
            </div>
        `;
    }
    
    html += '</div>';
    autumnRegionalContainer.innerHTML = html; // 秋のコンテナを流用
    checkSpringQualifiersComplete();
}

/**
 * 4チーム構成のブロックトーナメントHTMLを生成する
 */
function create4TeamBlockHTML(blockData, isRepechage = false) {
    if (!blockData || !blockData.matches) return '<div></div>';
    const { id, matches } = blockData;
    const semi1 = matches[`${id}-R1-M1`];
    const semi2 = matches[`${id}-R1-M2`];
    const final = matches[`${id}-R2-M1`];
    if (!semi1 || !semi2 || !final) return '<div></div>';

    // 試合の進行状況を更新
    final.team1 = semi1.winner;
    final.team2 = semi2.winner;

    const placeholder = isRepechage ? 'ブロック準優勝校' : '---';

    return `
        <div class="flex items-center justify-center space-x-2 text-xs">
            <div class="space-y-4 w-40">
                ${createMatchHTML(semi1.id, semi1.team1 || placeholder, semi1.team2 || placeholder, semi1, [])}
                ${createMatchHTML(semi2.id, semi2.team1 || placeholder, semi2.team2 || placeholder, semi2, [])}
            </div>
            <div class="w-40">
                ${createMatchHTML(final.id, final.team1, final.team2, final, [])}
            </div>
        </div>
    `;
}

/**
 * 春季地区予選がすべて終了したかチェックする
 */
function checkSpringQualifiersComplete() {
    let allFinished = true;
    for (const match of Object.values(tournamentState.springData.allMatches)) {
        // チームがセットされていて、まだ勝者が決まっていない試合があるか
        if (match.team1 && match.team2 && !match.winner) {
            allFinished = false;
            break;
        }
    }

    if (allFinished) {
        autumnControls.classList.remove('hidden');
        startMainTournamentBtn.classList.remove('hidden'); // 県大会へ進むボタン
        startRankingPlayoffsBtn.classList.add('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startMainTournamentBtn.classList.add('hidden');
    }
}/**
 * [春季大会 ステージ2-1] 県大会本戦1回戦を開始する
 */
async function setupSpringMainTournament_Round1() {
    tournamentState.springPhase = 'main_round1';
    
    // 各地区の代表校をfinalRepsから集計
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.springData.regions[region];
        // ブロック優勝校
        regionData.blocks.forEach(block => {
            const finalMatch = block.matches[`${block.id}-R2-M1`] || block.matches[`${block.id}-R1-M1`]; // 2,3チームブロック対応
            if(finalMatch && finalMatch.winner) regionData.finalReps.push(finalMatch.winner);
        });
        // 第5代表
        const repFinal = regionData.repechageBracket.matches[`${regionData.repechageBracket.id}-R2-M1`];
        if (repFinal.winner) regionData.finalReps.push(repFinal.winner);
    }
    const izuFinal = tournamentState.springData.regions['伊豆'].izuBracket.matches[`伊豆-SIZU-R2-M1`];
    if (izuFinal.winner) tournamentState.springData.regions['伊豆'].finalReps.push(izuFinal.winner);

    const qualifiedTeams = Object.values(tournamentState.springData.regions).flatMap(r => r.finalReps);
    
    // 予選敗退チームの成績を記録
    tournamentState.springData.qualifierTeams.forEach(team => {
        if (!qualifiedTeams.includes(team)) {
            tournamentState.teamRecords[team].lastFinish = 64; // 予選敗退
        }
    });

    tournamentState.teams = shuffleArray(qualifiedTeams); // 予選突破16校で1回戦
    tournamentState.matches = {};
    tournamentState.is16team = true; // 16チームトーナメントとして描画
    tournamentState.seeds = []; // 1回戦はシードなし

    const round1Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    round1Setup.forEach((match, index) => {
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

    renderTournament(tournamentState);
    saveState();
    
    // 展望記事などを生成...
    newsContainer.innerHTML = `<div class="loader">AI記者が県大会1回戦の展望記事を執筆中...</div>`;
    const previewArticle = await generateNewsArticle(null, null, null, 'preview');
    if(previewArticle) tournamentState.news.unshift(previewArticle);
    renderNews(tournamentState.news);
    saveState();
}

/**
 * [春季大会 ステージ2-2] 県大会本戦2回戦を開始する
 */
async function setupSpringMainTournament_Round2() {
    tournamentState.springPhase = 'main_round2_onwards';
    
    const round1Winners = [];
    Object.values(tournamentState.matches).forEach(match => {
        if(match.id.includes('-R1-') && match.winner) {
            round1Winners.push(match.winner);
        }
    });

    const seedTeams = tournamentState.springData.seedTeams;
    const shuffledSeeds = shuffleArray(seedTeams);
    const shuffledWinners = shuffleArray(round1Winners);

    // 2回戦の組み合わせを作成 (シード vs 1回戦勝者)
    let newTeamsForRound2 = [];
    for (let i = 0; i < 8; i++) {
        newTeamsForRound2.push(shuffledSeeds[i]);
        newTeamsForRound2.push(shuffledWinners[i]);
    }
    newTeamsForRound2 = shuffleArray(newTeamsForRound2); // 組み合わせをシャッフル

    tournamentState.teams = newTeamsForRound2;
    tournamentState.matches = {};
    tournamentState.is16team = true;
    tournamentState.seeds = seedTeams; // 2回戦からシード校として表示

    const round2Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    // R1として試合IDを生成するが、これは大会の「2回戦」にあたる
    round2Setup.forEach((match, index) => {
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });
    
    // 敗退チームの成績を記録
    Object.values(tournamentState.teamRecords).forEach(record => {
        if (record.lastFinish > 16 && record.lastFinish <=32) record.lastFinish = 32; // 1回戦敗退はベスト32扱い
    });
    
    renderTournament(tournamentState);
    saveState();

    // 2回戦の展望記事を生成
    newsContainer.innerHTML = `<div class="loader">AI記者が県大会2回戦の展望記事を執筆中...</div>`;
    const previewArticle = await generateNewsArticle(null, null, null, 'preview');
    if(previewArticle) tournamentState.news.unshift(previewArticle);
    renderNews(tournamentState.news);
    saveState();
}

// --- AI Content Generation & Helpers (Part A: Main Generators) ---

/**
 * Finds a specific team's final result in the tournament.
 */
function getTeamFateSummary(teamName) {
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            if (match.winner !== teamName) {
                const opponent = match.winner;
                const score1 = match.team1 === teamName ? match.score1 : match.score2;
                const score2 = match.team1 === teamName ? match.score2 : match.score1;
                const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 1;
                return `${roundNum}回戦で${opponent}に${score1}-${score2}で敗退した。`;
            }
        }
    }
    
    // Check if the team is still in the tournament
    const isStillIn = Object.values(allMatches).some(match => !match.winner && (match.team1 === teamName || match.team2 === teamName));
    if(isStillIn) {
        return "まだ勝ち残っている。";
    }

    return "（今大会には出場していないか、情報がありません）";
}
   



/**
 * スコアに基づき、試合の詳細データを自動生成する（リアルな試合展開シミュレーションの最終修正版）
 * @param {string} matchId - 対象の試合ID
 */
function autoFillMatchDetails(matchId) {
    const match = findMatchById(matchId);
    const matchEl = document.querySelector(`.matchup[data-match-id="${matchId}"]`);
    const score1El = matchEl.querySelector('[data-team-pos="1"]');
    const score2El = matchEl.querySelector('[data-team-pos="2"]');

    if (!match || !score1El.value || !score2El.value) {
        alert('先にトーナメント表にスコアを入力してください。');
        return;
    }
    
    // --- 1. ユーザーが入力した最終スコアを「目標」として設定 ---
    const finalScore1 = parseInt(score1El.value);
    const finalScore2 = parseInt(score2El.value);
    match.score1 = finalScore1;
    match.score2 = finalScore2;

    const isTeam1Winner = finalScore1 > finalScore2;
    const winnerKey = isTeam1Winner ? 'team1' : 'team2';
    const loserKey = isTeam1Winner ? 'team2' : 'team1';
    const winnerName = match[winnerKey];
    const loserName = match[loserKey];
    const winnerScore = isTeam1Winner ? finalScore1 : finalScore2;
    const loserScore = isTeam1Winner ? finalScore2 : finalScore1;
    
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const rankValues = { 'S': 6, 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1, 'G': 1 };
    const powerDiff = rankValues[winnerRank] - rankValues[loserRank];

    // --- 2. データと選手名簿の初期化 ---
    match.details = {
        batting: { team1: [], team2: [] }, 
        pitching: { team1: [], team2: [] },
        inningScore: { team1: Array(9).fill(0), team2: Array(9).fill(0) },
        playerGameStats: { team1: {}, team2: {} }
    };
    [ 'team1', 'team2' ].forEach(teamKey => {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord.roster || teamRecord.roster.length === 0) {
            const shuffledNames = shuffleArray(JAPANESE_SURNAMES);
            const shuffledPositions = shuffleArray(['投手', '捕手', '一塁手', '二塁手', '三塁手', '遊撃手', '左翼手', '中堅手', '右翼手']);
            teamRecord.roster = [];
            for (let i = 1; i <= 9; i++) {
                teamRecord.roster.push({ name: shuffledNames[i-1], order: i, position: shuffledPositions[i-1] });
            }
        }
        match.details.batting[teamKey] = teamRecord.roster.map(player => ({ ...player, results: Array(9).fill('') }));
    });
    
    // --- 3. 目標スコアを各イニングにリアルに配分 ---
    const distributeScores = (score) => {
        let innings = Array(9).fill(0);
        let remainingScore = score;
        if (score > 0) {
            while (remainingScore > 0) {
                const inning = Math.floor(Math.random() * 9);
                // 1イニングの得点は現実的に
                const runs = Math.min(remainingScore, Math.floor(Math.random() * 3) + 1);
                innings[inning] += runs;
                remainingScore -= runs;
            }
        }
        return innings;
    };
    match.details.inningScore['team1'] = distributeScores(finalScore1);
    match.details.inningScore['team2'] = distributeScores(finalScore2);
    
    // --- 4. 新しいリアルタイム試合シミュレーション ---
    let battingOrderIndex = { team1: 0, team2: 0 };
    const pitcherStats = {
        team1: { name: match.details.batting['team2'].find(p=>p.position==='投手')?.name || `${match['team2']}のエース`, hits: 0, strikeouts: 0, walks: 0 },
        team2: { name: match.details.batting['team1'].find(p=>p.position==='投手')?.name || `${match['team1']}のエース`, hits: 0, strikeouts: 0, walks: 0 }
    };

    for (let i = 0; i < 9; i++) { // 9イニング
        for (const currentTeamKey of ['team1', 'team2']) {
            const opponentTeamKey = currentTeamKey === 'team1' ? 'team2' : 'team1';
            const teamBatting = match.details.batting[currentTeamKey];
            const runsToScoreThisInning = match.details.inningScore[currentTeamKey][i];
            let outs = 0;
            let bases = [null, null, null]; // [一塁, 二塁, 三塁]
            let runsScoredInInning = 0;
            
            while (outs < 3) {
                const batter = teamBatting[battingOrderIndex[currentTeamKey]];
                battingOrderIndex[currentTeamKey] = (battingOrderIndex[currentTeamKey] + 1) % 9;

                const teamPower = (currentTeamKey === winnerKey) ? 5 + powerDiff : 5 - powerDiff;
                const isAggressive = (runsScoredInInning < runsToScoreThisInning);
                
                const outcomes = [
                    { result: '本塁打', weight: isAggressive ? 1.5 + teamPower * 0.1 : 0.5 + teamPower * 0.1 },
                    { result: '二塁打', weight: isAggressive ? 4 + teamPower * 0.2 : 2 + teamPower * 0.2 },
                    { result: '安', weight: isAggressive ? 20 + teamPower * 0.5 : 15 + teamPower * 0.5 },
                    { result: '四球', weight: 8 - powerDiff * 0.2 },
                    { result: '三振', weight: 2 - teamPower * 0.3 },
                    { result: 'ゴロ', weight: 27 },
                    { result: '飛', weight: 27 }
                ];
                
                const totalWeight = outcomes.reduce((sum, o) => sum + o.weight, 0);
                let random = Math.random() * totalWeight;
                let result = 'ゴロ';
                for(const outcome of outcomes) {
                    if (random < outcome.weight) {
                        result = outcome.result;
                        break;
                    }
                    random -= outcome.weight;
                }

                let rbi = 0;
                
                if (['安', '二塁打', '三塁打', '本塁打'].includes(result)) {
                    pitcherStats[opponentTeamKey].hits++;
                    const advanceMap = { '安': 1, '二塁打': 2, '三塁打': 3, '本塁打': 4 };
                    const basesAdvanced = advanceMap[result];
                    
                    for (let b = 2; b >= 0; b--) {
                        if (bases[b]) {
                            const newBase = b + basesAdvanced;
                            if (newBase >= 3) { rbi++; runsScoredInInning++; } 
                            else { bases[newBase] = bases[b]; }
                            bases[b] = null;
                        }
                    }
                    if (basesAdvanced >= 4) { rbi++; runsScoredInInning++; } 
                    else { bases[basesAdvanced - 1] = batter.name; }
                    if (rbi > 0) result += `${rbi}点`;
                } else if (result === '四球') {
                    pitcherStats[opponentTeamKey].walks++;
                    if (bases[0] && bases[1] && bases[2]) {
                        rbi++; runsScoredInInning++;
                    } else {
                        if (bases[0] && !bases[1]) { bases[1] = bases[0]; }
                        else if (bases[0] && bases[1] && !bases[2]) { bases[2] = bases[1]; bases[1] = bases[0]; }
                        bases[0] = batter.name;
                    }
                } else {
                    outs++;
                    if (result === '三振') pitcherStats[opponentTeamKey].strikeouts++;
                }

                batter.results[i] = (batter.results[i] ? batter.results[i] + '、' : '') + result;
                
                if (runsScoredInInning >= runsToScoreThisInning && outs < 3) {
                    while(outs < 3) {
                       const nextBatter = teamBatting[battingOrderIndex[currentTeamKey]];
                       nextBatter.results[i] = (nextBatter.results[i] ? nextBatter.results[i] + '、' : '') + '三振';
                       pitcherStats[opponentTeamKey].strikeouts++;
                       outs++;
                       battingOrderIndex[currentTeamKey] = (battingOrderIndex[currentTeamKey] + 1) % 9;
                    }
                }
            }
            match.details.inningScore[currentTeamKey][i] = runsScoredInInning;
        }
    }

    // --- 5. 投手成績と最終スコアを最終化 ---
    const finalSimScore1 = match.details.inningScore['team1'].reduce((a,b)=>a+b,0);
    const finalSimScore2 = match.details.inningScore['team2'].reduce((a,b)=>a+b,0);
    
    const winnerSimKey = finalSimScore1 > finalSimScore2 ? 'team1' : 'team2';
    const loserSimKey = finalSimScore1 > finalSimScore2 ? 'team2' : 'team1';

    match.details.pitching[winnerSimKey] = [{ 
        name: pitcherStats[winnerSimKey].name, result: 'W', innings: '9', 
        hits: pitcherStats[loserSimKey].hits, strikeouts: pitcherStats[winnerSimKey].strikeouts, walks: pitcherStats[loserSimKey].walks,
        earnedRuns: finalSimScore2 
    }];
    match.details.pitching[loserSimKey] = [{ 
        name: pitcherStats[loserSimKey].name, result: 'L', innings: '9', 
        hits: pitcherStats[winnerSimKey].hits, strikeouts: pitcherStats[loserSimKey].strikeouts, walks: pitcherStats[winnerSimKey].walks,
        earnedRuns: finalSimScore1 
    }];

    // --- 6. 最終処理 ---
    match.score1 = finalSimScore1;
    match.score2 = finalSimScore2;
    score1El.value = finalSimScore1;
    score2El.value = finalSimScore2;

    saveState();
    alert(`${winnerName} vs ${loserName} の試合結果（${match.score1}-${match.score2}）を自動生成しました。\n勝敗ボタン（▶）を押して、試合を確定してください。`);
}
/**
 * チームの紹介文を動的に生成する最終進化版。
 * TEAM_DATAの固定情報に、最新の成績情報を付け加える。
 * @param {string} teamName - チーム名
 * @param {object} teamData - TEAM_DATAから取得したそのチームの基本情報
 * @param {object} teamRecord - tournamentState.teamRecordsから取得したそのチームの成績記録
 * @returns {string} - 生成された最新の紹介文
 */
function generateDynamicTeamInfo(teamName, teamData, teamRecord) {
// ▼▼▼ この安全装置が、今後のあなたを助けます ▼▼▼
    if (!teamData) {
        // コンソールに、どのチーム名で失敗したかを出力
        console.error(`TEAM_DATAにチーム「${teamName}」が見つかりません。名前のタイプミスがないか確認してください。`);
        // 記事にはエラーメッセージを表示
        return `${teamName}のチーム情報が見つかりませんでした。`;
    }
    // ▲▲▲ ▲▲▲    
// teamData.info が基本の紹介文となる
    const baseInfo = teamData.info || `${teamName}の情報は不明です。`;

    // チームの成績記録がまだない（＝1年目の途中など）場合は、基本情報だけを返す
    if (!teamRecord || !teamRecord.history || teamRecord.history.length === 0) {
        return baseInfo;
    }

    const history = teamRecord.history;

    // --- ここからが追加情報の生成 ---
    let additionalNarrative = []; // 追加情報を入れる配列

    // 創部年数を計算 (2年目以降に意味を持つ情報)
    if (history.length > 0) {
        const establishedYear = history[history.length - 1].year;
        const yearsPassed = tournamentState.tournamentYear - establishedYear + 1;
        // 1年目の最初の大会では表示しないように、2年目以降の情報として扱う
        if (yearsPassed > 1) {
            additionalNarrative.push(`創部${yearsPassed}年目。`);
        }
    }
    
    // 昨年の成績を追加
    const lastFinishLabel = teamRecord.last?.label;
    if (lastFinishLabel && lastFinishLabel !== 'なし') {
        additionalNarrative.push(`昨年は${lastFinishLabel}。`);
    }

    // 過去最高成績を追加
    const bestFinishLabel = teamRecord.best?.label;
    if (bestFinishLabel && bestFinishLabel !== 'なし') {
        additionalNarrative.push(`過去最高は${bestFinishLabel}。`);
    }

    // 称号（Traits）を追加
    const traitDescriptions = {
        'GIANT_KILLER': '「ジャイアントキラー」の異名を持つ。',
        'REPECHAGE_KING': '「敗者復活の王」として知られる。',
    };
    if (teamRecord.teamTraits && teamRecord.teamTraits.length > 0) {
        teamRecord.teamTraits.forEach(traitId => {
            if (traitDescriptions[traitId]) {
                additionalNarrative.push(traitDescriptions[traitId]);
            }
        });
    }

    // --- 最終的な紹介文の組み立て ---
    // もし追加情報が何か一つでもあれば、基本情報に付け加える
    if (additionalNarrative.length > 0) {
        // 例：「（基本情報）。加えて、創部2年目。昨年は県大会2回戦。」のようになる
        return `${baseInfo} ${additionalNarrative.join(' ')}`;
    } 
    // 追加情報がなければ、基本情報だけを返す
    else {
        return baseInfo;
    }
}

 
/**
 * 選手の出場形式コードを、記事で使える自然な日本語に変換する（翻訳機）
 * @param {object} player - 選手のデータオブジェクト
 * @returns {string} - 出場形式を説明する文章
 */
function getSubstitutionDescription(player) {
    // 交代選手でない（スタメン）場合は "スタメン出場" とする
    if (!player.sub_type) {
        return 'スタメン出場';
    }

    // sub_typeの値に応じて、返す文章を切り替える
    switch (player.sub_type) {
        case 'PH':
            return '代打で出場';
        case 'PR':
            return '代走で出場';
        case 'DEF':
            return '守備固めで出場';
        // ▼▼▼ ADD THIS CASE ▼▼▼
        case 'PITCHER': return 'リリーフとして登板';
        // ▲▲▲ END OF ADDITION ▲▲▲
        default:
            return '途中出場'; // 何らかの理由でsub_typeが上記以外の場合
    }
}

/**
 * AI記者にニュース記事を執筆させるメイン関数（フィードバック機能付き・最終完全版）
 * @param {string|null} winnerName - 勝者名
 * @param {string|null} loserName - 敗者名
 * @param {object} dbMatch - 試合データ
 * @param {string} matchId - 試合ID
 * @param {object} winnerData - 勝者チームのマスターデータ
 * @param {object} loserData - 敗者チームのマスターデータ
 * @param {object} winnerDetailedData - 勝者チームの詳細選手データ
 * @param {object} loserDetailedData - 敗者チームの詳細選手データ
 * @param {Array} highlightsText - 試合のハイライト
 * @param {Array} keyPlayerNames - 注目選手名
 * @param {object|null} userFeedback - ユーザーからの追加指示
 * @returns {Promise<object|null>}
 */
async function generateNewsArticle(winnerName, loserName, dbMatch, matchId, winnerData, loserData, winnerDetailedData, loserDetailedData, highlightsText, keyPlayerNames, userFeedback = null) {    
 let prompt = '';
    // --- 1. 大会展望記事の生成ロジック ---
    if (matchId === 'preview') {
        let prompt;
        const { tournamentYear, seeds, teams, matches, currentTournament, is16team, autumnData } = tournamentState;
        const tournamentName = tournamentNameMap[currentTournament] || '大会';

        // --- 1A. 秋季大会の展望 ---
        if (is16team) { 
            const reps = autumnData;
            const repText = Object.entries(reps.regions).map(([region, data]) => {
                if (!data.finalReps || data.finalReps.length === 0) return null;
                if (region === '伊豆') return `- ${region} (1校): ${data.finalReps[0].team}`;
                const repNames = data.finalReps.sort((a,b) => a.rank - b.rank).map(r => `${r.team}(${r.rank}位)`);
                return `- ${region} (${data.finalReps.length}校): ${repNames.join(', ')}`;
            }).filter(Boolean).join('\n');
            
            const matchups = [];
            for(let i=0; i<teams.length; i+=2) {
                matchups.push(`- ${teams[i]} vs ${teams[i+1]}`);
            }

            prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。野球以外の話題(プログラミング等)には一切触れないでください。
間もなく開幕する「${tournamentYear}年度 秋季大会 県大会本戦」の展望記事を作成してください。
### 大会のポイント
- 秋季大会は新チームで挑む最初の県大会であり、来春のセンバツ出場を占う重要な大会です。
- 地区予選を勝ち上がった順位に応じてポット分けされ、1回戦は同地区対決が避けられるなど、独特の組み合わせが特徴です。
### 県大会出場校一覧 (地区順位順)
${repText}
### 県大会1回戦の組み合わせ
${matchups.join('\n')}
### 執筆指示
- 最も厳しいブロック、いわゆる「死のブロック」はどこか指摘してください。
- 地区1位校と下位ポットの強豪校が当たる、注目の1回戦カードをいくつか挙げてください。
- 地区間のレベル差や、新チームの仕上がりについて分析的な視点で記述してください。
### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
        } 
        // --- 1B. 春季大会の展望 ---
        else if (currentTournament === 'spring') {
            const qualifierWinners = teams.filter(team => !seeds.includes(team));
            const round1Matchups = Object.values(matches)
                .filter(match => match.id.includes('-R1-'))
                .map(match => `- ${match.team1} vs ${match.team2}`);

            const allPromisingSchools = [...seeds, ...qualifierWinners];
            let notablePlayersText = '';
            const notablePlayers = allPromisingSchools.filter(team => DETAILED_TEAM_DATA[team]);
            if (notablePlayers.length > 0) {
                notablePlayersText += '### 今大会の注目選手\n';
                notablePlayers.forEach(team => {
                    const players = DETAILED_TEAM_DATA[team].players.slice(0, 2);
                    notablePlayersText += `- **${team}**: ${players.map(p => `${p.name}(${p.year}年)`).join(', ')}\n`;
                });
            }

            prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。野球以外の話題(プログラミング等)には一切触れないでください。
間もなく開幕する「${tournamentYear}年度 ${tournamentName}」の展望記事を作成してください。
### 大会の見どころ
- 今大会は、秋季大会ベスト8の強豪【シード校】と、厳しい地区予選を勝ち抜いた【予選突破校】が覇を競います。
- 1回戦は予選突破校同士が対戦し、勝ち上がったチームが2回戦でシード校に挑むという、下剋上も期待される注目の形式です。
### シード校 (2回戦から登場)
${seeds.join(', ')}
### 地区予選突破校 (1回戦から登場)
${qualifierWinners.join(', ')}
### 1回戦の注目カード
${round1Matchups.slice(0, 4).join('\n')}
${notablePlayersText}
### 執筆指示
- 予選突破校の中から、シード校を脅かす存在となりそうな「ダークホース」を2～3校挙げてください。
- どのシード校が最も厳しいブロックに入ったか、逆に最も楽なブロックはどこかを分析してください。
- 記事の本文で「注目選手」に言及し、彼らの活躍が大会の鍵を握ることを示唆してください。
- 夏の大会を占う重要な大会として、各チームの仕上がり具合を分析する視点で記述してください。
### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
        } 
        // --- 1C. 夏季大会の展望 ---
        else { 
            const isPromising = (teamName) => {
                const rank = calculateRank(teamName, tournamentState);
                return ['A', 'B'].includes(rank) || seeds.includes(teamName) || TEAM_DATA[teamName].popularity;
            };

            const blockAnalyses = [];
            const numBlocks = 4;
            const blockSize = 16;
            for (let i = 0; i < numBlocks; i++) {
                const blockName = String.fromCharCode(65 + i);
                const start = i * blockSize;
                const end = (i + 1) * blockSize;
                const blockTeams = teams.slice(start, end);
                if (blockTeams.length === 0) continue;
                const promisingInBlock = blockTeams.filter(isPromising);
                blockAnalyses.push(`- ${blockName}ブロック (${blockTeams.length}校): ${promisingInBlock.join(', ')}`);
            }
            const blockAnalysis = blockAnalyses.join('\n');
            
            let notablePlayersText = '';
            const promisingSchools = teams.filter(isPromising);
            const notablePlayers = promisingSchools.filter(team => DETAILED_TEAM_DATA[team]);
            if (notablePlayers.length > 0) {
                notablePlayersText += '### 今大会の注目選手\n';
                notablePlayers.forEach(team => {
                    const players = DETAILED_TEAM_DATA[team].players.slice(0, 2);
                    notablePlayersText += `- **${team}**: ${players.map(p => `${p.name}(${p.year}年)`).join(', ')}\n`;
                });
            }

            prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。野球以外の話題(プログラミング等)には一切触れないでください。
間もなく開幕する「${tournamentYear}年度 ${tournamentName}」の展望記事を作成してください。
### 大会の見どころ
- 3年生にとっては最後の夏であり、甲子園出場をかけた最も熱い戦いです。
- 春の大会の結果などからシード校が決定されていますが、ノーシードの実力校も多く、波乱が予想されます。
### シード校
${seeds.join(', ')}
### 各ブロックの有力校
${blockAnalysis}
${notablePlayersText}
### 執筆指示
- 最も厳しいブロック、いわゆる「死のブロック」はどこか指摘し、その理由を分析してください。
- 有力校が少ない「恵まれたブロック」に入ったチームにも言及してください。
- 「注目選手」を記事に登場させ、彼らが大会の鍵を握る存在であることを示唆してください。
- ノーシードの実力校の中から、大会の「ダークホース」となりそうなチームを挙げてみてください。
### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
        }

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
                if (article) return { ...article, timestamp: Date.now() };
            }
            throw new Error("AI preview response format error.");
        } catch (error) {
            console.error("AI preview article generation failed:", error);
            return { title: "展望記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true, errorId: `preview-${Date.now()}` };
        }
return;
    }

    // --- 2. 試合後記事の生成ロジック ---

    // --- 準備フェーズ ---
    const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
    const loserRankDesc = getRankDescription(calculateRank(loserName, tournamentState));
    const winnerRecord = tournamentState.teamRecords[winnerName];
    const loserRecord = tournamentState.teamRecords[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, winnerRecord);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, loserRecord);
　　const winnerJourney = getCurrentTournamentPerformance(winnerName, matchId);
    const loserJourney = getCurrentTournamentPerformance(loserName, matchId);
    const winnerCoach = winnerData.coach;
    const loserCoach = loserData.coach;
    const battingFirstTeam = dbMatch.team1;
    const battingSecondTeam = dbMatch.team2;
    const winnerPrevRankStr = winnerRecord?.previousRank ? ` (前大会: ${getRankString(winnerRecord.previousRank)})` : '';
    const loserPrevRankStr = loserRecord?.previousRank ? ` (前大会: ${getRankString(loserRecord.previousRank)})` : '';
    const winnerTitles = winnerRecord?.teamTraits?.map(tId => Object.values(TITLES).find(t => t.id === tId)?.name).join(', ') || '';
    const loserTitles = loserRecord?.teamTraits?.map(tId => Object.values(TITLES).find(t => t.id === tId)?.name).join(', ') || '';
    let currentTournamentName = tournamentNameMap[tournamentState.currentTournament] || '大会';

    let roundAchievement = '';
    let seedingImplication = '';
    let specialNarrativeContext = '';
    if (tournamentState.currentTournament === 'autumn') {
        const phase = tournamentState.autumnPhase;
        if (matchId.includes('-')) {
            const [region, bracketType, roundStr] = matchId.split('-');
            const roundNum = parseInt(roundStr?.slice(1));
            if (phase === 'regional_blocks') {
                currentTournamentName = `秋季大会 ${region}地区ブロック予選`;
                if (roundNum === 2) roundAchievement = 'ブロック優勝';
            } else if (phase === 'regional_ranking') {
                currentTournamentName = `秋季大会 ${region}地区内順位決定戦`;
                if (bracketType === 'CHAMP' && roundNum === 2) {
                    roundAchievement = dbMatch.type === 'final' ? '地区1位通過' : '地区3位通過';
                } else if (bracketType === 'REP' && roundNum === 2) {
                    roundAchievement = '第5代表（敗者復活）';
                }
            } else if (phase === 'main') {
                currentTournamentName = '秋季大会 県大会本戦';
                const roundNumMain = parseInt(matchId.split('-')[1].slice(1));
                if (roundNumMain === 1) {
                    roundAchievement = '県大会初戦突破（ベスト8進出）';
                    seedingImplication = 'この勝利で、来季の春季大会のシード権獲得を確実なものとした。';
                    const winnerRank = calculateRank(winnerName, tournamentState);
                    if (winnerData.type === '公立' && (winnerRank === 'D' || winnerRank === 'E')) {
                        specialNarrativeContext = `### 【物語のハイライト】\n県大会出場だけでも快挙だった公立校「${winnerName}」が、初戦を突破し【来春のシード権】まで獲得しました！これは二重の奇跡です。この「シンデレラ・ストーリーの最高潮」をテーマに、歴史的快挙として記事を執筆してください。`;
                    }
                } else if (roundNumMain === 2) roundAchievement = '準々決勝突破(ベスト4進出)';
                else if (roundNumMain === 3) roundAchievement = '準決勝突破(決勝進出)';
            }
        }
    } else if (matchId.includes('-R')) {
        const roundNum = parseInt(matchId.split('-')[1].slice(1));
        const finalRound = tournamentState.is16team ? 4 : 6;
        if (roundNum === finalRound) roundAchievement = (tournamentState.currentTournament === 'summer') ? '甲子園出場決定！' : '優勝！';
        else if (roundNum === finalRound - 1) roundAchievement = '準決勝突破(決勝進出)';
        else if (roundNum === finalRound - 2) roundAchievement = '準々決勝突破(ベスト4進出)';
        else if (roundNum === finalRound - 3) {
            roundAchievement = '3回戦突破(ベスト8進出)';
            if (tournamentState.currentTournament === 'spring') {
                seedingImplication = 'この勝利で、夏の選手権大会のシード権獲得を確実なものとした。';
            }
        } else if (roundNum === 2) roundAchievement = '2回戦突破';
        else if (roundNum === 1) roundAchievement = '初戦突破';
    }
    
    

    // --- 詳細データがある場合 (Aルート) ---
    if (dbMatch.details) {
        
        // --- 準備フェーズ ---

        // 1. createHighlightsTextから「事実リストの配列」と「選手名リスト」を受け取る
        const { highlights, keyPlayerNames } = createHighlightsText(dbMatch, winnerName);

        // 2. 「事実リストの配列」を、AIが読みやすいテキスト形式に変換する
        const factListText = highlights.map(fact => {
            let text = `- `;
            if (fact.inning) text += `${fact.inning}回 `;
            if (fact.team) text += `${fact.team} `;
            if (fact.player) text += `${fact.player} `;
            text += `: ${fact.description}`;
            return text;
        }).join('\n');
        
        // 3. 選手名リストを元に、選手をチーム分けして、プロンプト用の「注目選手」セクションを作成する
        const winnerKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
        const winnerPlayersInGame = new Set(
            (dbMatch.details.batting?.[winnerKey] || []).map(p => p.name)
            .concat((dbMatch.details.pitching?.[winnerKey] || []).map(p => p.name))
        );
        const winnerKeyPlayers = keyPlayerNames.filter(name => winnerPlayersInGame.has(name));
        const loserKeyPlayers = keyPlayerNames.filter(name => !winnerPlayersInGame.has(name));

        const formatPlayerList = (playerNames, teamName, detailedTeamData) => {
            if (playerNames.length === 0) return '特になし';
            return playerNames.map(playerName => {
                const detailedInfo = detailedTeamData?.players.find(p => p.name === playerName);
                if (detailedInfo) {
                    return `- **${detailedInfo.name} (${detailedInfo.year}年・${detailedInfo.position})**: ${detailedInfo.desc}`;
                } else {
                    return `- **${playerName}**`;
                }
            }).join('\n');
        };
        const winnerPlayersPrompt = formatPlayerList(winnerKeyPlayers, winnerName, winnerDetailedData);
        const loserPlayersPrompt = formatPlayerList(loserKeyPlayers, loserName, loserDetailedData);

        // 4. スタメン変更を分析する (省略なし)
        let lineupChangesText = '両チームともに前試合からのスタメン変更はなし。';
        const changes = [];
        for (const teamName of [winnerName, loserName]) {
            const teamRecord = tournamentState.teamRecords[teamName];
            const teamKey = dbMatch.team1 === teamName ? 'team1' : 'team2';
            const currentStarters = dbMatch.details?.batting?.[teamKey];
            if (teamRecord && teamRecord.previousStarters && currentStarters) {
                const changedPlayers = [];
                for (let i = 1; i <= 9; i++) {
                    const prev = teamRecord.previousStarters.find(p => parseInt(p.order) === i);
                    const curr = currentStarters.find(p => parseInt(p.order) === i);
                    if (prev && curr && prev.name !== curr.name) {
                        changedPlayers.push(`${i}番(${curr.pos})に${curr.name}を起用`);
                    }
                }
                if (changedPlayers.length > 0) {
                    changes.push(`${teamName}は${changedPlayers.join('、')}といった変更を加えた。`);
                }
            }
        }
        if (changes.length > 0) lineupChangesText = changes.join(' ');
        
        // 5. イニングスコアをテキスト形式に変換
        let inningScoreText = '';
        if (dbMatch.details?.inningScore) {
            const winnerKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
            const loserKey = dbMatch.team1 === loserName ? 'team1' : 'team2';
            if (dbMatch.details.inningScore[winnerKey]?.length > 0) {
                inningScoreText += `- ${winnerName}: ${dbMatch.details.inningScore[winnerKey].map(s => s || '0').join('-')}\n`;
                inningScoreText += `- ${loserName}: ${dbMatch.details.inningScore[loserKey].map(s => s || '0').join('-')}`;
            }
        }
        
// --- 5. 試合中の守備変更を分析 ---
    if (dbMatch.details.positionChanges) {
        dbMatch.details.positionChanges.forEach(change => {
            const teamName = dbMatch[change.teamKey];
            // ★もし主軸選手がマウンドに上がったら、それは大事件
            if (change.newPos === '投' || change.newPos === '投手') {
                 highlights.push({
                    type: 'strategy',
                    inning: change.inning,
                    team: teamName,
                    player: change.playerName,
                    description: `主軸の${change.playerName}が${change.inning}回からマウンドに上がるという大胆な采配`
                });
                keyPlayerNames.add(change.playerName);
            }
        });
    }

        // --- プロンプト作成フェーズ ---
        prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。
あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。野球以外の話題(プログラミング等)には一切触れないでください。
---
### **【最重要】この記事の唯一の事実情報源**
以下は、この試合で実際に起きた出来事を、**正しい時系列で**リスト化した「事実リスト」です。あなたの記事は、**必ずこのリストに書かれている情報に厳密に基づいて**執筆されなければなりません。
**【厳重注意】事実リストに書かれていない出来事（例：三者凡退、好プレー、凡退の内容など）を、絶対に創作・推測してはいけません。**
${factListText}
### **参考情報：補足**

- 前試合からのスタメン変更: ${lineupChangesText}
- ユーザーによる試合の決め手: ${dbMatch.summary || 'なし'}
---
### **参考情報：チームと選手のプロフィール**
以下は、記事をより豊かにするための参考情報です。事実リストと矛盾しない範囲でのみ使用してください。
- **${winnerName}**: ${winnerDynamicInfo}
- **今大会の軌跡**: ${winnerJourney}
  - **監督**: ${winnerCoach ? `${winnerCoach.name} (${winnerCoach.style})` : '情報なし'}
  - **主な選手プロフィール**:
${formatPlayerList(winnerKeyPlayers, winnerName, winnerDetailedData)}
- **${loserName}**: ${loserDynamicInfo}
 - **今大会の軌跡**: ${loserJourney}
  - **監督**: ${loserCoach ? `${loserCoach.name} (${loserCoach.style})` : '情報なし'}
  - **主な選手プロフィール**:
${formatPlayerList(loserKeyPlayers, loserName, loserDetailedData)}

---
### **執筆指示**
1.  まず、「事実リスト」を熟読し、試合の全体像（勝敗、スコア、試合展開）を把握してください。
2.  次に、その試合展開の中で、どの選手のどのプレーが重要だったかを判断してください。
3.  「参考情報」を元に、それらの選手やチームの背景を肉付けし、物語性のある記事を作成してください。
4.  **【厳重注意】**: 「参考情報」に書かれている選手の前評判と、「事実リスト」に書かれている実際の打順や結果が異なる場合は、**必ず「事実リスト」を優先**してください。
- **監督の采配**: 「スタメン変更」があった場合、その采配が試合にどう影響したかに触れること。
- **インタビューコメント**: 試合後の両チーム監督のコメントを、試合内容やチームの背景を反映させて生成すること。
- **物語の連続性**: 「今大会の軌跡」情報を参考に、これまでの戦いと繋がりのある物語を描写すること。`;

        // ▼▼▼ ここからがユーザーフィードバックを反映させる追加ブロックです ▼▼▼
        let feedbackPrompt = '';
        if (userFeedback) {
            if (userFeedback.include && userFeedback.include.trim() !== '') {
                feedbackPrompt += `\n- **【最重要指示】** 以下の要素を必ず記事の中心に据えて、最もドラマチックに描写してください：\n${userFeedback.include}\n`;
            }
            if (userFeedback.exclude && userFeedback.exclude.trim() !== '') {
                feedbackPrompt += `\n- **【厳禁事項】** 以下の要素や表現は、絶対に記事に含めないでください：\n${userFeedback.exclude}\n`;
            }
        }
        
        prompt += `
### 編集長からの追加指示
${feedbackPrompt || '特になし'}
        
### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。
{
    "title": "（ここに記事のタイトル）",
    "body": "（ここに記事の本文）"
}`;
        // ▲▲▲ ここまでが追加ブロックです ▲▲▲
    }
    // --- 詳細データがない場合 (Bルート) ---
    else {
        prompt = `あなたは、高校野球専門のAI記者です。
以下の試合結果に基づき、簡潔で分かりやすいニュース記事を作成してください。
### 試合情報
- **大会**: ${currentTournamentName}
- **先攻**: ${battingFirstTeam}
- **後攻**: ${battingSecondTeam}
- **勝利チーム**: ${winnerName} (${winnerRankDesc})
- **敗北チーム**: ${loserName} (${loserRankDesc})
- **スコア**: ${winnerScore} - ${loserScore}
- **ユーザーによる試合の決め手**: ${dbMatch.summary || 'なし'}
### チームの背景
- **${winnerName}**: ${winnerDynamicInfo}
- **${loserName}**: ${loserDynamicInfo}
### 執筆指示
- もし「ユーザーによる試合の決め手」に記述があれば、それを中心に記事を構成してください。
- 事実の厳守: 勝敗や先攻・後攻の情報を間違えないでください。
- 試合結果を客観的に伝えてください。
- 想像で選手のコメントなどを入れず、事実に基づいた内容にしてください。
- 記事のタイトルと本文をJSON形式で出力してください。`;
    }

    // --- AIへのリクエスト ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                const isNewspaperWorthy = (dbMatch.details && (tournamentState.currentTournament !== 'autumn' || tournamentState.autumnPhase === 'main'));
                const newspaperHtml = isNewspaperWorthy ? createNewspaperHtml(article, { winnerName, loserName, dbMatch, matchId }) : null;
                return { ...article, isNewspaper: isNewspaperWorthy, timestamp: Date.now(), newspaperHtml };
            }
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI記事の生成に失敗しました:", error);
        return { 
            title: "記事生成エラー", body: "AI記者との通信に失敗しました。", 
            timestamp: Date.now(), error: true, errorId: matchId,
            context: { winnerName, loserName, dbMatch, matchId, winnerData, loserData, winnerDetailedData, loserDetailedData, summary: dbMatch.summary }
        };
    }
}
/**
     * AIにスキップしたラウンドのダイジェスト記事を生成させる
     */
    async function generateSkipRoundSummaryArticle(roundNumber, results) {
        // 最も番狂わせが大きかった試合を1つ選出
        const biggestUpset = results.filter(r => r.rankDiff >= 2).sort((a,b) => b.rankDiff - a.rankDiff)[0];
        
        let highlightText = "シード校や有力校が順当に勝ち進みました。";
        if (biggestUpset) {
            highlightText = `最大の波乱は${biggestUpset.winnerName}が強豪${biggestUpset.loserName}を${biggestUpset.winnerScore}-${biggestUpset.loserScore}で破った一戦でした。`;
        }

        const prompt = `あなたは高校野球専門のAI記者です。
現在、${tournamentState.tournamentYear}年度${tournamentNameMap[tournamentState.currentTournament]}が進行中です。
${roundNumber}回戦の全試合が終了しました。以下のハイライトを元に、簡潔なダイジェスト記事を生成してください。

### ${roundNumber}回戦ハイライト
- ${highlightText}
- 次のラウンドでは、勝ち上がった猛者たちによる更なる激戦が期待されます。

### 執筆指示
- 上記のハイライトを自然な文章にまとめてください。
- タイトルは「${roundNumber}回戦が終了！波乱は起きるか？」のように、次への期待感を煽るものにしてください。

### 出力形式
JSON形式で出力してください: {"title": "記事のタイトル", "body": "記事の本文"}`;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
                if (article) return { ...article, timestamp: Date.now() };
            }
            throw new Error("AI summary response format error.");
        } catch (error) {
            console.error("AI summary article generation failed:", error);
            return { title: "ダイジェスト記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true, errorId: `skip-summary-${roundNumber}` };
        }
    }

/**
 * AIに掲示板のコメントを生成させるメイン関数（準備フェーズを記事AIと統一した最終版）
 */
async function generateBbsComments(winnerName, loserName, dbMatch, matchId, winnerData, loserData, winnerDetailedData, loserDetailedData, highlightsText) {
    
    // --- 準備フェーズ (generateNewsArticleと完全に同じロジック) ---
    const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
    const loserRankDesc = getRankDescription(calculateRank(loserName, tournamentState));
    const winnerRecord = tournamentState.teamRecords[winnerName];
    const loserRecord = tournamentState.teamRecords[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, winnerRecord);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, loserRecord);
    let currentTournamentName = tournamentNameMap[tournamentState.currentTournament] || '大会';
    let specialNarrativeContext = '';
    
    if (tournamentState.currentTournament === 'autumn' && tournamentState.autumnPhase === 'main' && matchId.includes('-R1-')) {
        const winnerRank = calculateRank(winnerName, tournamentState);
        if (winnerData.type === '公立' && (winnerRank === 'D' || winnerRank === 'E')) {
            specialNarrativeContext = `### 【掲示板の話題】\n衝撃！無名の公立「${winnerName}」が県大会初戦を勝ち、【来春のシード権獲得】だ！この快進撃に驚きと嫉妬のコメントを生成せよ。`;
        }
    }

    let prompt = '';


// --- Aルート：詳細入力がある場合 ---
    if (dbMatch.details) {
        // ▼▼▼ この関数の中で、自分でハイライトを生成する ▼▼▼
        const { highlights } = createHighlightsText(dbMatch, winnerName);
        const highlightsText = highlights.map(fact => {
            let text = '';
            if (fact.inning) text += `${fact.inning}回 `;
            if (fact.team) text += `${fact.team} `;
            if (fact.player) text += `${fact.player} `;
            text += `: ${fact.description}`;
            return text;
        }).join('、');
        // ▲▲▲ ▲▲▲

        prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下の試合結果と詳細なハイライトに基づき、各キャラクターになりきって、辛辣でリアルな短いコメントを5つ生成してください。
### 試合情報
- 勝利チーム: ${winnerName} (${winnerRankDesc})
- 敗北チーム: ${loserName} (${loserRankDesc})
- スコア: ${winnerScore} - ${loserScore}
- **ユーザーが語る試合の決め手**: ${dbMatch.summary || '特になし'}
### 試合の主なハイライト
- ${highlightsText}
### チームの背景
- **${winnerName}**: ${winnerDynamicInfo}
- **${loserName}**: ${loserDynamicInfo}
${specialNarrativeContext}
### あなたがなりきるべきキャラクターと指示
- **熱狂的な勝者チームのOB**: 「試合のハイライト」で活躍した自チームの選手を熱烈に称賛してください。
- **上から目線の野球解説者**: 「試合のハイライト」のプレーを玄人っぽく分析してください。
- **アンチ**: 「試合のハイライト」で活躍した相手選手を「まぐれだ」と貶してください。
- **ライバル校のファン**: 「試合のハイライト」の選手を自チームの選手と比較してください。
- **単なる野球好き**: 「試合のハイライト」で最も印象的だったプレーの感想を述べてください。
### 出力形式
(JSON形式の指示)`;
    } else {
        // Bルート：詳細なハイライトがない場合
        prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下の試合結果について、それぞれのキャラクターになりきって、辛辣でリアルな短いコメントを5つ生成してください。
### 試合情報
- 勝利チーム: ${winnerName} (${winnerRankDesc})
- 敗北チーム: ${loserName} (${loserRankDesc})
- スコア: ${winnerScore} - ${loserScore}
- **ユーザーが語る試合の決め手**: ${dbMatch.summary || '特になし'}
### チームの背景
- **${winnerName}**: ${winnerDynamicInfo}
- **${loserName}**: ${loserDynamicInfo}
${specialNarrativeContext}
### あなたがなりきるべきキャラクターと指示
- **熱狂的な勝者チームのOB**: 勝利を喜び、チームの伝統や背景に触れてコメントしてください。
- **上から目線の野球解説者**: 試合結果だけを見て、順当な結果か、意外な結果かを分析してください。
- **アンチ**: 負けたチームや、スコアが僅差だったチームを批判してください。
- **ライバル校のファン**: 試合結果を見て、自チームとの力関係を測るようなコメントをしてください。
- **単なる野球好き**: スコアを見て、接戦だったか、一方的だったかなどの感想を述べてください。
### 出力形式
(JSON形式の指示)`;
    }

    // --- AIへのリクエスト (変更なし) ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AIからの応答が、正しい配列形式ではありません。");
    } catch (error) {
        console.error("AI掲示板コメントの生成に失敗しました:", error);
        return [{
            id: `error-${matchId}-bbs`,
            error: true,
            title: `掲示板コメント生成エラー`,
            context: { winnerName, loserName, dbMatch, matchId, winnerData, loserData, winnerDetailedData, loserDetailedData, highlightsText }
        }];
    }
}
/**
     * AIに代矢東応援掲示板のコメントを生成させる
     */
    async function generateDaiyaBbsComments(winnerName, loserName, dbMatch, nextOpponentInfo) {
        const isDaiyaWinner = winnerName === '代矢東';
        const opponentName = isDaiyaWinner ? loserName : winnerName;
        const opponentRank = calculateRank(opponentName, tournamentState);
        const resultContext = isDaiyaWinner ? '勝利' : '敗北';
        const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
        const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;
        const score = `${winnerScore} - ${loserScore}`;
        
        const prompt = `あなたは、静岡の古豪「代矢東」高校野球部の熱狂的なファンです。あなたは野球に非常に詳しく、常に冷静に試合を分析し、どうすればチームが甲子園に行けるかを考えています。
以下の試合結果について、あなたらしいコメントを5つ生成してください。

### 試合情報
- 試合結果: 代矢東の${resultContext}
- 対戦相手: ${opponentName} (${getRankDescription(opponentRank)})
- スコア: ${score}

### あなたのキャラクターと指示
- あなたは生粋の野球好きで、代矢東のファンが集う特設掲示板の常連です。
- **もし代矢東が勝利した場合:**
  - 喜びつつも、冷静に勝因を分析してください（例：「今日の勝因は継投のタイミングだな」「あの場面のスクイズは見事だった」）。
  - すぐに次の対戦相手に目を向け、どうすれば勝てるかの戦略を語ってください（例：「次は〇〇か…キーマンは相手の3番打者だ。徹底的にインコースを攻めるべき」）。
  - 決して浮かれず、常に甲子園への道を冷静に見据えてください。
- **もし代矢東が敗北した場合:**
  - 非常に落胆し、性格の悪さを露呈してください。
  - 敗因を厳しく追及してください（例：「なぜあの場面でピッチャーを変えなかったんだ」「監督の采配ミスだろ」）。
  - 「【悲報】代矢東、今年も甲子園いけず…」のような、絶望的なスレッドタイトルを必ず一つ生成してください。
  - 来年に向けての不安や、チームの課題を辛辣に指摘してください。

### 出力形式
必ず以下のJSON配列形式で出力してください。
[
  {"personality": "代矢東ファン", "comment": "（コメント本文）"},
  {"personality": "代矢東ファン", "comment": "（コメント本文）"},
  {"personality": "代矢東ファン", "comment": "（コメント本文）"},
  {"personality": "代矢東ファン", "comment": "（コメント本文）"},
  {"personality": "代矢東ファン", "comment": "（コメント本文）"}
]`;
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const commentsJson = parseJsonFromText(rawText);
                if (Array.isArray(commentsJson)) {
                    return commentsJson.map(c => ({
                        id: crypto.randomUUID(),
                        personality: c.personality,
                        text: c.comment,
                        timestamp: Date.now(),
                        replies: []
                    }));
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("代矢東 掲示板コメントの生成に失敗しました:", error);
            return [];
        }
    }

   /**
 * AIに組み合わせ決定時の掲示板の反応を生成させる
 * ★★★ 春・夏・秋の大会進行度に応じて指示を切り替える完成版 ★★★
 */
async function generateBracketReactionComments(state) {
    const { teams, seeds } = state;
    // チーム数が少ない場合はコメントを生成しない
    if (teams.length < 8) return []; 

    let analysis = ''; // 組み合わせ分析を入れる変数
    let commentDirections = ''; // AIへの指示を入れる変数

    // --- 1. 秋季大会の処理 ---
    if (state.currentTournament === 'autumn' && state.autumnPhase === 'main') {
        const pots = { 1: [], 2: [], 3: [], 4: [], 5: [] };
        state.teams.forEach(team => {
            for (const region of ['東部', '中部', '西部', '伊豆']) {
                const rep = state.autumnData.regions[region].finalReps.find(r => r.team === team);
                if (rep) {
                    pots[rep.rank].push(`${team}(${region}${rep.rank}位)`);
                    break;
                }
            }
        });
        
        analysis = `秋季県大会の組み合わせが決定！
- ポット1(地区1位): ${pots[1].join(', ')}
- ポット2(地区2位): ${pots[2].join(', ')}
- ポット3(地区3位): ${pots[3].join(', ')}
- ポット4(地区4位): ${pots[4].join(', ')}
- ポット5(敗者復活): ${pots[5].join(', ')}`;

        commentDirections = `
- 「地区1位と敗者復活組がいきなり当たるのか！」「地区間のレベル差が試されるな」といったポット制や地区対決に関する反応。
- ポット1の強豪校がどこに入るか、そのブロックの他のチームへの同情。
- 自分の応援するチームがどのポットから、どのブロックに入ったかに対する一喜一憂。`;

    // --- 2. 春季大会の処理 ---
    } else if (state.currentTournament === 'spring') {
        
        // --- 2A. 地区予選 ---
        if (state.springPhase === 'regional_qualifiers') {
            analysis = `春季地区予選の組み合わせが決定！県大会本戦への出場権16枠をかけた戦いが始まる。`;
            commentDirections = `
- 「うちの地区、激戦区すぎだろ…」「県大会出るの大変だな」といった、地区予選の厳しさに関するコメント。
- シード校以外の有力校がどの地区にいるかについての言及。「〇〇と△△が同じ地区とかマジかよ」など。
- 無名校にとってはチャンスであることへの期待や感想。`;
        } 
        // --- 2B. 県大会1回戦 ---
        else if (state.springPhase === 'main_round1') {
            analysis = `春季県大会1回戦、予選を勝ち上がった16校の組み合わせが決定！シード校への挑戦権を掴むのはどこだ。`;
            commentDirections = `
- 「予選突破組同士の潰し合いか、面白いな」「ここ勝てばシード校とやれるのか」といった、1回戦ならではの反応。
- 地区予選を勝ち上がってきた勢いのあるチームへの注目。「予選で〇〇を倒した△△、どこまで行くか楽しみ」など。
- どのチームがシード校を脅かす存在になりそうかという予想。`;
        } 
        // --- 2C. 県大会2回戦 (シード校登場) ---
        else if (state.springPhase === 'main_round2') {
            const numBlocks = Math.ceil(teams.length / 16);
            let blockAnalyses = [];
            for(let i=0; i<numBlocks; i++){
                const blockName = String.fromCharCode(65+i);
                const blockTeams = teams.slice(i*16, (i+1)*16);
                if(blockTeams.length === 0) continue;
                const isStrong = (team) => seeds.includes(team) || DETAILED_TEAM_DATA[team] || TEAM_DATA[team].popularity;
                const strongTeams = blockTeams.filter(isStrong);
                blockAnalyses.push(`- ${blockName}ブロック: 有力校 ${strongTeams.length}チーム (${strongTeams.join(', ')})`);
            }
            analysis = `春季県大会2回戦、シード校と予選突破校の組み合わせが決定！\n${blockAnalyses.join('\n')}`;
            commentDirections = `
- 「シード校 vs 予選突破組」という構図への期待感。「〇〇（シード校）といきなり当たるとかクジ運なさすぎだろ」など。
- 有力校が固まった「死のブロック」への反応。「Aブロック、事実上の決勝戦じゃねえか」など。
- シード校が順当に勝つか、予選を勝ち上がったチームが「ジャイキリ」を起こすかという予想。`;
        }

    // --- 3. 夏季大会 (および上記以外のケース) の処理 ---
    } else {
        const numBlocks = Math.ceil(teams.length / 16);
        let blockAnalyses = [];
        for(let i=0; i<numBlocks; i++){
            const blockName = String.fromCharCode(65+i);
            const blockTeams = teams.slice(i*16, (i+1)*16);
            if(blockTeams.length === 0) continue;
            const isStrong = (team) => seeds.includes(team) || DETAILED_TEAM_DATA[team] || TEAM_DATA[team].popularity || TEAM_DATA[team].best.includes('甲子園');
            const strongTeams = blockTeams.filter(isStrong);
            blockAnalyses.push(`- ${blockName}ブロック: 有力校 ${strongTeams.length}チーム (${strongTeams.join(', ')})`);
        }
        analysis = `夏の選手権、組み合わせが決定！\n${blockAnalyses.join('\n')}`;
        commentDirections = `
- 「ここのブロックやばすぎる」「死のブロックだな」といった、有力校が固まったブロックへの反応。
- 「〇〇は決勝までフリーパスかよ」といった、有力校が少ないブロックへの反応。
- 自分の応援するチームが厳しいブロックに入ったことへの絶望や、楽なブロックに入ったことへの期待。
- 3年生最後の夏、という文脈でのドラマへの期待。`;
    }

    // --- プロンプトの組み立て ---
    const prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下のトーナメントの組み合わせ分析を読んで、ファンらしいリアルな短いコメントを5～7個生成してください。

### 組み合わせ分析
${analysis}

### コメントの方向性
${commentDirections}

### 出力形式
必ず以下のJSON配列形式で出力してください。
[
  {"personality": "匿名ファン", "comment": "（コメント本文）"},
  {"personality": "野球通", "comment": "（コメント本文）"},
  {"personality": "悲観的なファン", "comment": "（コメント本文）"}
]`;

    // --- AIへのリクエストと結果の処理 ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI組み合わせ反応コメントの生成に失敗しました:", error);
        return [];
    }
}
    
/**
 * Takes a user's comment and generates multiple AI fan replies to it.
 */
/**
 * Generates multiple AI fan replies to a user's top-level comment,
 * using the same advanced logic as the in-thread reply function.
 */
/**
 * ユーザーのコメント一つに対して、複数のAIファンからの返信を一度に生成する
 * (★チームの敗退状況も認識する最終版)
 */
async function generateMultipleReplies(userCommentText) {
    const conversationHistory = `あなた: 「${userCommentText}」`;

    // --- AIに与える「知識」の部分を作成（完全版） ---
    const mentionedTeams = new Set();
    const mentionedPlayers = new Set(); // ★言及された選手名を保存するSet

    INITIAL_TEAM_POOL.forEach(team => {
        if (userCommentText.includes(team)) {
            mentionedTeams.add(team);
            // チーム名が言及されたら、そのチームの全選手を潜在的な調査対象とする
            const detailedData = DETAILED_TEAM_DATA[team];
            if (detailedData) {
                detailedData.players.forEach(p => mentionedPlayers.add({name: p.name, team: team}));
            }
        } else {
            // チーム名がなくても、選手名単体で言及されている場合
            const detailedData = DETAILED_TEAM_DATA[team];
            if(detailedData) {
                detailedData.players.forEach(p => {
                    if (userCommentText.includes(p.name)) {
                        mentionedPlayers.add({name: p.name, team: team});
                    }
                });
            }
        }
    });

    let teamInfoPromptPart = '### 参考情報：関連チームと選手の状況\n';
    
    // チーム全体の状況
    mentionedTeams.forEach(teamName => {
        const teamData = TEAM_DATA[teamName];
        const teamRecord = tournamentState.teamRecords[teamName];
        const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord);
        const fate = getTeamFateSummary(teamName);
        teamInfoPromptPart += `- **${teamName}**: ${dynamicInfo} (今大会の状況: ${fate})\n`;
    });

    // 言及された全選手の個人成績
    if (mentionedPlayers.size > 0) {
        teamInfoPromptPart += `\n- **主な選手の今大会成績**:\n`;
        mentionedPlayers.forEach(playerInfo => {
            const statsSummary = getPlayerTournamentStatsSummary(playerInfo.name, playerInfo.team);
            if (statsSummary) {
                teamInfoPromptPart += `  - ${statsSummary}\n`;
            }
        });
    }

    // --- プロンプト作成 ---
    const prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
ユーザー「あなた」の投稿した以下のコメントに対し、4人の異なるキャラクターとして返信してください。
### **ユーザーのコメント**: 「${userCommentText}」
### **現在の大会状況**: ${getTournamentStatusSummary()}
${teamInfoPromptPart}
### **指示**:
- 各キャラクターの返信は、必ずユーザーのコメント内容に直接関連していること。
- **【重要】**: あなたの知識である「参考情報」を最大限に活用し、具体的なチーム状況や選手成績に触れながら、的確な返信をすること。
- **【注意】**: まだ大会序盤である（例：2試合しか終わっていない）ことを考慮し、「本塁打が少ない」といった早計な批判は避けること。
---
---### **ステップ4：出力形式**
【最重要】必ず以下のJSON配列形式"のみ"で出力すること。
[
    {"personality": "熱狂的なファン", "comment": "（コメント本文）"},
    {"personality": "上から目線の解説者", "comment": "（コメント本文）"},
    {"personality": "アンチ", "comment": "（コメント本文）"},
    {"personality": "ライバル校のファン", "comment": "（コメント本文）"}
]`;
    
    // --- 4. Call AI and Process Response ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI multi-reply generation failed:", error);
        return [];
    }
}

/**
     * AIにナムコグループからのお知らせを生成させる
     */
    async function generateNamcoNews(state, type, matchData = null) {
        const namcoSchools = ["初星学園", "765総合高校", "283学園", "美城学園", "283学園B"];
        let prompt = '';

        if (type === 'bracket') {
            const participatingSchools = state.teams.filter(t => namcoSchools.includes(t));
            if(participatingSchools.length === 0) return null;

            const matchups = participatingSchools.map(school => {
                const schoolIndex = state.teams.indexOf(school);
                if (schoolIndex === -1) return null;
                const opponentIndex = schoolIndex % 2 === 0 ? schoolIndex + 1 : schoolIndex - 1;
                const opponentName = state.teams[opponentIndex];
                return `- ${school} の初戦は ${opponentName} と対戦します。`;
            }).filter(item => item !== null).join('\n');

            prompt = `あなたはナムコグループの広報担当者です。
夏の高校野球選手権大会の組み合わせが決定しました。
以下の情報に基づき、グループの公式サイトに掲載する、プロフェッショナルで丁寧な「お知らせ」記事を生成してください。

### 各校の初戦の組み合わせ
${matchups}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）組み合わせ決定のお知らせ」とする。
- 本文では、抽選会が行われたことと、上記の組み合わせが決定したことを報告してください。
- 最後に、系列校野球部への応援をお願いする言葉で締めくくる。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}`;
        } else if (type === 'matchResult') {
            const { winnerName, loserName, dbMatch } = matchData;
            const isCivilWar = (winnerName === '283学園' && loserName === '283学園B') || (winnerName === '283学園B' && loserName === '283学園');

            if (isCivilWar) {
                // ... (省略)
            } else {
                const namcoTeam = namcoSchools.includes(winnerName) ? winnerName : loserName;
                const opponent = namcoSchools.includes(winnerName) ? loserName : winnerName;
                const result = namcoSchools.includes(winnerName) ? '勝利' : '敗北';
                const score = namcoSchools.includes(winnerName) ? `${dbMatch.score1}-${dbMatch.score2}` : `${dbMatch.score2}-${dbMatch.score1}`;

                prompt = `あなたはナムコグループの広報担当者です。
本日行われた、夏の高校野球選手権大会の試合結果について、公式サイトに掲載する「お知らせ」記事を生成してください。

### 試合情報
- 系列校: ${namcoTeam}
- 対戦相手: ${opponent}
- 結果: ${namcoTeam}の${result}
- スコア: ${score}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）試合結果のお知らせ」とする。
- 本文では、まず試合が行われたことと、結果を簡潔に報告する。
- **もし勝利した場合:**
  - 応援への感謝を述べ、次の試合への意気込みを語る（例：「次戦もチーム一丸となって勝利を目指します」）。
- **もし敗北した場合:**
  - 選手たちの健闘を称え、応援への感謝を深く述べる（例：「皆様の熱い声援が、選手の力となりました。心より感謝申し上げます」）。
  - 新チームでの再起を誓う言葉で締めくくる。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}`;
            }
        }

        if (!prompt) return null;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const newsJson = parseJsonFromText(rawText);
                if (newsJson) {
                    return { ...newsJson, timestamp: Date.now() };
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("ナムコニュースの生成に失敗しました:", error);
            return null;
        }
    }
/**
     * AIにスポーツ新聞の一面を生成させる
     */
    /**
     * AIが生成した新聞データからHTMLを生成する
     */
    function createNewspaperHtml(articleData, matchData) {
        const { winnerName, loserName, dbMatch, matchId } = matchData;
        const idParts = matchId.split('-');
        const roundNum = idParts[0] === 'F' ? Math.log2(tournamentState.teams.length) : parseInt(idParts[1].slice(1));

        const isLateRound = roundNum >= 4;
        const containerClass = isLateRound ? 'newspaper-late' : 'newspaper-early';
        const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
        const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;

        return `
            <div class="newspaper-container ${containerClass}">
                <div class="newspaper-header">
                    <h2 class="newspaper-title">熱闘高校野球</h2>
                    <p class="newspaper-date">${new Date(articleData.timestamp).toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                </div>
                <div class="newspaper-content">
                    <h1 class="newspaper-main-headline">${winnerName.slice(0, 4)}</h1>
                    <div class="newspaper-body-content">
                        <h2 class="newspaper-sub-headline">${articleData.title}</h2>
                        ${isLateRound ? '<div class="newspaper-image-placeholder">[試合の様子の写真]</div>' : ''}
                        <p class="newspaper-text">${articleData.body.replace(/\\n/g, '\n')}</p>
                        <div class="newspaper-score-box">
                            <h3>最終スコア</h3>
                            <p class="score">${winnerName} ${winnerScore} - ${loserScore} ${loserName}</p>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
async function generateSportsNewspaper(roundNumber) {
        const numTeams = tournamentState.is16team ? 16 : 64;
        const finalRound = Math.log2(numTeams);

        const roundNameMap = {
            [finalRound]: '決勝',
            [finalRound-1]: '準決勝',
            [finalRound-2]: '準々決勝',
            [finalRound-3]: '3回戦'
        };

        const roundName = roundNameMap[roundNumber];
        if (!roundName) return null;

        const matchIdsInRound = Object.keys(tournamentState.matches).filter(id => 
            (id.includes(`-R${roundNumber}-`)) || (roundNumber === finalRound && id.includes('F-R1-'))
        );
        const results = matchIdsInRound.map(id => tournamentState.matches[id]);

        const resultsText = results.map(match => {
            const winnerRank = getRankDescription(calculateRank(match.winner, tournamentState));
            const loser = match.team1 === match.winner ? match.team2 : match.team1;
            const loserRank = getRankDescription(calculateRank(loser, tournamentState));
            const winnerScore = match.team1 === match.winner ? match.score1 : match.score2;
            const loserScore = match.team1 === match.winner ? match.score2 : match.score1;
            return `${winnerRank}・${match.winner}が${loserRank}・${loser}に ${winnerScore}-${loserScore} で勝利。`;
        }).join('\n');

        const prompt = `あなたは、読者の購買意欲を掻き立てるのが得意な、日本のスポーツ新聞の編集長です。
現在、高校野球の${tournamentState.tournamentYear}年度大会が進行中です。${roundName}の全試合が終了しました。
以下の試合結果を基に、最も衝撃的でドラマチックな出来事を一つ選び出し、それに対応する新聞の一面を飾るテキストを生成してください。

### ${roundName} 全試合結果
${resultsText}

### あなたが作成するテキスト
以下の4つの要素を、JSON形式で出力してください。
1.  **mainHeadline**: 最も重要な結果を伝える、短く、衝撃的で、扇情的な大見出し。（例：「怪物散る！」「王者、盤石の決勝へ」）
2.  **subHeadline**: mainHeadlineを補足する、少し詳しい小見出し。
3.  **photoCaption**: その日のハイライトシーンを切り取った架空の写真に対する、情景が目に浮かぶようなキャプション。（例：「あと一歩及ばず、マウンドに崩れ落ちる〇〇高校のエース△△」）
4.  **otherResults**: その他の注目すべき結果を2つ、簡潔にまとめたもの。

### 出力形式
{"mainHeadline": "...", "subHeadline": "...", "photoCaption": "...", "otherResults": ["...", "..."]}`;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const newspaperData = parseJsonFromText(rawText);
                if (newspaperData) return newspaperData;
            }
            throw new Error("AI newspaper response format error.");
        } catch (error) {
            console.error("AI newspaper generation failed:", error);
            return null;
        }
    }

    /**
     * ラウンド終了時に新聞発行などのイベントを処理する
     */
    async function handleRoundCompletion(roundNumber) {
        const numTeams = tournamentState.is16team ? 16 : 64;
        const finalRound = Math.log2(numTeams);
        const significantRounds = [finalRound, finalRound - 1, finalRound - 2, finalRound - 3].filter(r => r > 0);
        if (!significantRounds.includes(roundNumber)) return;

        const alreadyExists = tournamentState.news.some(n => n.roundNumber === roundNumber && n.isNewspaper);
        if (alreadyExists) return;

        const newspaperData = await generateSportsNewspaper(roundNumber);
        if (newspaperData) {
            const roundNameMap = { 3: '3回戦', 4: '準々決勝', 5: '準決勝', 6: '決勝' };
            const roundName = tournamentState.is16team ? {1: '1回戦', 2: '準々決勝', 3: '準決勝', 4: '決勝'}[roundNumber] : roundNameMap[roundNumber];

            tournamentState.news.push({
                title: `【熱闘新聞】${roundName}特集号が発行されました！`,
                body: newspaperData.subHeadline,
                timestamp: Date.now(),
                isNewspaper: true,
                roundNumber: roundNumber,
                newspaperData: newspaperData
            });
            renderNews(tournamentState.news);
            saveState();
        }
    }

    /**
     * 新聞モーダルを描画する
     */
    function renderNewspaperModal(newspaperData) {
        const { mainHeadline, subHeadline, photoCaption, otherResults, imageUrl } = newspaperData;
        
        const imageHtml = imageUrl 
            ? `<img src="${imageUrl}" alt="${photoCaption}" class="w-full h-auto my-4 border">` 
            : `<div class="newspaper-image-placeholder my-4"><p class="text-sm p-4">${photoCaption}</p></div>`;

        newspaperModalBody.innerHTML = `
            <div class="newspaper-container newspaper-late">
                <div class="newspaper-header">
                    <h2 class="newspaper-title">熱闘スポーツ</h2>
                    <p class="newspaper-date">${new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                </div>
                <div class="newspaper-content">
                    <h1 class="newspaper-main-headline">${mainHeadline}</h1>
                    <div class="newspaper-body-content">
                        <h2 class="newspaper-sub-headline">${subHeadline}</h2>
                        ${imageHtml}
                        <div class="newspaper-score-box">
                            <h3>その他の主な結果</h3>
                            ${otherResults.map(r => `<p>${r}</p>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
 * AIに掲示板の返信を生成させる（最終版）
 * 最新のデータ構造と、脱線防止を強化したプロンプトを使用する
 */
/**
 * AIに掲示板の返信を生成させる（最新の環境に適合した最終版）
 */
async function generateBbsReply(parentCommentId, userReplyText, bbsType, aiPersona, context) {
    const commentSource = bbsType === 'general' ? tournamentState.bbsComments : tournamentState.daiyaBbsComments;
    const parentComment = findCommentById(commentSource, parentCommentId);
    if (!parentComment) return null;

    // --- 1. AIに渡すための「文脈」を収集する ---
    const userReplyObject = { id: 'temp_user_reply', personality: 'あなた', text: userReplyText, replies: [] };
    parentComment.replies.push(userReplyObject);
    const conversationHistory = formatConversationHistory(commentSource, 'temp_user_reply');
    parentComment.replies.pop();

    const mentionedTeams = new Set();
    conversationHistory.split('\n').forEach(line => {
        INITIAL_TEAM_POOL.forEach(team => {
            if (line.includes(team)) {
                mentionedTeams.add(team);
            }
        });
    });

    // --- 2. AIに与える「知識」の部分を作成する ---
    let teamInfoPromptPart = '';
    if (mentionedTeams.size > 0) {
        teamInfoPromptPart = '### 関連チームの背景情報\n';
        mentionedTeams.forEach(teamName => {
            const teamData = TEAM_DATA[teamName];
            const teamRecord = tournamentState.teamRecords[teamName];
            // ★最新のアナウンサー関数を活用
            const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord);
            teamInfoPromptPart += `- **${teamName}**: ${dynamicInfo}\n`;
        });
    }

    // --- 3. 最終的なプロンプトを組み立てる（★脱線防止策を適用） ---
    const prompt = `あなたは、匿名掲示板のキャラクター「${aiPersona}」です。あなたは今、他のユーザーと日本の高校野球について会話しています。
あなたの唯一の仕事は、会話の流れとあなたの知識に基づき、キャラクターになりきって自然な返信をすることです。野球以外の話題には絶対に触れないでください。
---
### **ステップ1：現在の会話状況を理解する**
- **これまでの会話の流れ**:
${conversationHistory}
- **あなたのキャラクター**: ${aiPersona}
- **現在の大会状況**: ${context.tournamentSummary}
---
### **ステップ2：関連情報を思い出す**
${teamInfoPromptPart}
---
### **ステップ3：返信する**
上記のステップ1と2の情報を元に、会話の最後の発言「${userReplyText}」に対して、あなたのキャラクターとして最も自然で的を射た返信を生成してください。
- **指示**:
  - 必ず相手の発言に直接応答することから始めること。
  - 応答の根拠として、ステップ2の「関連情報」を自然な形で会話に含めること。
  - 相手が話していない無関係なチームや試合の情報を一方的に解説しないこと。
---
### **ステップ4：出力形式**
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"comment": "（あなたの返信本文）"}`;
    
    // --- 4. AIを呼び出し、結果を処理する ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const replyJson = parseJsonFromText(rawText);
            if (replyJson && replyJson.comment) {
                return {
                    id: crypto.randomUUID(),
                    personality: aiPersona,
                    text: replyJson.comment,
                    timestamp: Date.now(),
                    replies: []
                };
            }
        }
        throw new Error("AIの応答形式が不正です。");
    } catch (error) {
        console.error("AI返信コメントの生成に失敗しました:", error);
        return null;
    }
}
/**
     * AIからの応答テキストからJSONオブジェクトを安全に抽出する
     */
    function parseJsonFromText(text) {
        try {
            const cleanedText = text.replace(/```json/g, '').replace(/```/g, '').trim();
            const jsonMatch = cleanedText.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch (e) {
            console.error("Failed to parse JSON from text:", text, e);
        }
        return null;
    }

    /**
     * リトライ機能付きでバックエンドAPI(Netlify Function)を呼び出す
     */
    async function fetchWithRetry(payload, maxRetries = 3) {
        const functionUrl = '/.netlify/functions/generateApiContent'; // Netlify Functionのエンドポイント
        let lastError;

        for (let i = 0; i < maxRetries; i++) {
            try {
                const response = await fetch(functionUrl, {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    return response;
                }
                
                if (response.status >= 400 && response.status < 500 && response.status !== 429) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error}`);
                }

                lastError = new Error(`API Error: ${response.status}`);
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));

            } catch (error) {
                lastError = error;
                const delay = Math.pow(2, i) * 1000;
                if (i < maxRetries - 1) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        throw lastError;
    }

    /**
     * チームランク（A～E）から説明的な文字列を取得する
     */
    function getRankDescription(rank) {
        switch(rank) {
            case 'A': return '名門校';
            case 'B': return '強豪校';
            case 'C': return '中堅校';
            case 'D': return '発展途上のチーム';
            case 'E': return '挑戦者';
            default: return '実力不明';
        }
    }
    
    /**
 * Generates a team's tournament path history, compatible with all tournament types.
 */
function getTournamentPath(teamName, startingMatchId) {
    if (!teamName) return "（不明）";
    const path = [];
    
    // Combine all matches from all tournaments into one list
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    // Determine the current round number to analyze up to that point
    const idParts = startingMatchId.split('-');
    if (idParts.length < 3) return '（地区予選突破）'; // Not a main tournament match
    let currentRoundNum = parseInt(idParts[1].slice(1));

    // Loop from the first round up to the current round
    for (let r = 1; r < currentRoundNum; r++) {
        // Find the match the team won in that round
        const matchInRound = Object.values(allMatches).find(match =>
            match.id && 
            match.id.includes(`-R${r}-`) && // Belongs to the correct round
            match.winner === teamName
        );

        if (matchInRound) {
            const opponent = matchInRound.team1 === teamName ? matchInRound.team2 : matchInRound.team1;
            const winnerScore = matchInRound.team1 === teamName ? matchInRound.score1 : matchInRound.score2;
            const loserScore = matchInRound.team1 === teamName ? matchInRound.score2 : matchInRound.score1;
            path.push(`${r}回戦 vs ${opponent} (${winnerScore}-${loserScore})`);
        }
    }

    return path.length > 0 ? path.join(' → ') : '（今大会初戦）';
}
    /**
     * AIプロンプト用に、チームの次の対戦相手情報を生成する
     */
    /**
 * Generates the next opponent info, compatible with all tournament structures.
 */
function getNextOpponentInfoForPrompt(teamName) {
    // Combine all matches from all tournaments into one list
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    let latestMatch = null;
    let maxRound = -1;

    // Find the most recent game this team played in
    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (match.team1 === teamName || match.team2 === teamName) {
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 0;
            if (roundNum > maxRound) {
                maxRound = roundNum;
                latestMatch = match;
            }
        }
    }

    if (!latestMatch) return "（まだ試合なし）";
    if (latestMatch.winner !== teamName) return "（この試合で敗退）";
    
    // Find the next game this team is in
    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        
        // Look for a future game where this team is slotted but the opponent is not yet decided
        if ((match.team1 === teamName && !match.team2) || (match.team2 === teamName && !match.tran1)) {
             return "（次の対戦相手は未定）";
        }
        
        // Look for a future game where the opponent is known
        if (match.team1 === teamName && match.team2 && !match.winner) {
             return `次の対戦相手は${match.team2}です。`;
        }
        if (match.team2 === teamName && match.team1 && !match.winner) {
            return `次の対戦相手は${match.team1}です。`;
        }
    }

    return "（優勝、または次のステージへ）";
}
    /**
     * AIプロンプト用に、掲示板の会話履歴をフォーマットする
     */
    function formatConversationHistory(comments, targetId) {
        let history = [];
        function findPath(currentComments, currentPath) {
            for(const comment of currentComments) {
                const newPath = [...currentPath, comment];
                if(comment.id === targetId) {
                    history = newPath;
                    return true;
                }
                if(comment.replies && findPath(comment.replies, newPath)) {
                    return true;
                }
            }
            return false;
        }
        findPath(comments, []);
        return history.map(c => `${c.personality}:「${c.text}」`).join('\n');
    }

    /**
     * AIプロンプト用に、現在の大会状況の要約を生成する
     */
    function getTournamentStatusSummary() {
        if (tournamentState.currentTournament === 'autumn') {
            return `現在、${tournamentState.tournamentYear}年度 秋季大会が進行中です。フェーズ: ${tournamentState.autumnPhase}`;
        }
        
        const finalMatch = tournamentState.matches['F-R1-M1'];
        if (finalMatch?.winner) return `${finalMatch.winner}が優勝しました。`;
        if (finalMatch?.team1 && finalMatch.team2) return `決勝戦の組み合わせは ${finalMatch.team1} vs ${finalMatch.team2} です。`;
        
        const numRounds = Math.log2(tournamentState.teams.length);
        for (let r = numRounds - 1; r >= 1; r--) {
            const roundIds = Object.keys(tournamentState.matches).filter(id => id.includes(`-R${r}-`));
            if (roundIds.some(id => tournamentState.matches[id]?.team1 && tournamentState.matches[id]?.team2)) {
                 const roundNameMap = { 5: "準決勝", 4: "準々決勝", 3: "3回戦", 2: "2回戦", 1: "1回戦"};
                 return `現在、${roundNameMap[r] || r + '回戦'}が進行中です。`;
            }
        }
        return '大会はまもなく開始されます。';
    }

    /**
     * IDを元に、入れ子構造のコメントデータから特定のコメントを見つけ出す
     */
    function findCommentById(comments, id) {
        for (const comment of comments) {
            if (comment.id === id) return comment;
            if (comment.replies && comment.replies.length > 0) {
                const found = findCommentById(comment.replies, id);
                if (found) return found;
            }
        }
        return null;
    }
/**
 * AIに甲子園（または東海大会）の結果を総括する記事を生成させる
 */
async function generateKoshienSummaryArticle(teamName, resultLabel, type) {
    let context, titleInstruction;

    if (type === 'summer') {
        context = `夏の甲子園、全国の頂点を目指した${teamName}の戦いが終わりました。`;
        titleInstruction = `「${teamName}、聖地での戦いの軌跡」のような、夏の終わりを感じさせる感動的なタイトルにしてください。`;
    } else if (type === 'spring') {
        context = `選抜高校野球大会に出場した${teamName}の最終結果が確定しました。`;
        titleInstruction = `「${teamName}、春の聖地に爪痕」のように、来たる夏への期待を感じさせるタイトルにしてください。`;
    } else { // tokai
        context = `秋季東海大会で、静岡県代表の${teamName}が見事な戦いを見せました。`;
        titleInstruction = `「${teamName}、センバツ当確！」のように、速報らしく、喜びが伝わるタイトルにしてください。`;
    }

    const prompt = `あなたは、情熱的な高校野球専門のAI記者です。
以下の情報に基づき、読者の心を打つような総括記事を生成してください。

### 大会結果
- チーム: ${teamName}
- 最終成績: ${resultLabel}
- 文脈: ${context}

### 執筆指示
- ${titleInstruction}
- チームのこれまでの努力や、県大会での戦いぶりを称え、今回の結果が持つ意味をドラマチックに描写してください。
- 最後に、選手たちへの賛辞や、今後のチームへの期待を述べて締めくくってください。

### 出力形式
JSON形式で出力してください: {"title": "記事のタイトル", "body": "記事の本文"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) return { ...article, timestamp: Date.now() };
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI甲子園記事の生成に失敗しました:", error);
        return { title: "記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true };
    }
}
// --- Match Processing & Event Listeners ---

/**
 * 延長イニングを全ての関連テーブルに追加する
 */
function addExtraInning() {
    // --- 1. イニングスコアのテーブルを更新 ---
    const scoreTable = document.getElementById('inning-score-table');
    if (scoreTable) {
        const headerRow = scoreTable.querySelector('thead tr');
        // 現在の最終イニング番号を取得し、1を足す
        const lastInningHeader = headerRow.children[headerRow.children.length - 3];
        const newInningNum = parseInt(lastInningHeader.textContent) + 1;

        // 新しいヘッダーを追加
        const newTh = document.createElement('th');
        newTh.className = 'w-10';
        newTh.textContent = newInningNum;
        headerRow.insertBefore(newTh, headerRow.children[headerRow.children.length - 2]);

        // 各チームの行に新しい入力欄を追加
        scoreTable.querySelectorAll('tbody tr').forEach(row => {
            const newTd = document.createElement('td');
            newTd.innerHTML = `<input type="text" value="">`;
            row.insertBefore(newTd, row.children[row.children.length - 1]);
        });
    }

    // --- 2. 両チームの打撃成績テーブルを更新 ---
    for (const teamKey of ['team1', 'team2']) {
        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (!battingTable) continue;

        // ヘッダーを更新
        const headerRow = battingTable.querySelector('thead tr');
        const lastInningHeader = headerRow.lastElementChild.previousElementSibling;
        const newInningNum = parseInt(lastInningHeader.textContent) + 1;
        const newTh = document.createElement('th');
        newTh.className = 'col-inning';
        newTh.textContent = newInningNum;
        headerRow.insertBefore(newTh, headerRow.lastElementChild);

        // 全ての選手行（スタメン・交代）に新しい入力欄を追加
        battingTable.querySelectorAll('tbody tr').forEach(row => {
            const newTd = document.createElement('td');
            newTd.innerHTML = `<input type="text" placeholder="-">`;
            row.appendChild(newTd);
        });

        // イニング出来事入力欄のcolspanを更新し、新しい入力欄を追加
        const tfoot = battingTable.querySelector('tfoot');
        if (tfoot) {
            const targetCell = tfoot.querySelector('td[colspan]');
            const currentNumInnings = parseInt(targetCell.getAttribute('colspan')) - 1;
            targetCell.setAttribute('colspan', currentNumInnings + 2);

            const newEventTd = document.createElement('td');
            newEventTd.className = 'border-t-2';
            newEventTd.innerHTML = `<input type="text" class="inning-events-input w-full text-left px-1 text-xs" data-team-key="${teamKey}" data-inning-index="${newInningNum - 1}" placeholder="例: 鈴木 盗塁">`;
            
            const eventRow = tfoot.querySelector('tr');
            eventRow.insertBefore(newEventTd, eventRow.lastElementChild);
        }
    }
}

/**
 * ニュースティッカーの表示を更新する
 */
function updateTicker() {
    const tickerContainer = document.querySelector('.ticker-content');
    const oldTickerText = document.getElementById('ticker-text');
    if (!tickerContainer || !oldTickerText) return;

    let headlines = tournamentState.tickerHeadlines || [];
    
    // 表示するヘッドラインがなければ、デフォルトのものを表示
    if (headlines.length === 0) {
        const defaultHeadlines = [
            "昨年度王者・283学園、連覇に向け盤石の仕上がり", "公立の雄・代矢東、悲願の甲子園へ『今年こそ』",
            "プロ注目右腕、大船渡・斎藤擁する布陣に死角なしか", "ノーシードからの下剋上なるか。ダークホース・豊中學園に注目",
            "新設校・緑山、初めての夏へ。全員野球で挑む", "765総合高校、2年前の栄光再び。聖地を知るメンバーがチームを牽引"
        ];
        headlines = new Array(5).fill(defaultHeadlines).flat().sort(() => Math.random() - 0.5);
    }

    const newTextContent = headlines.join('　／／　');
    
    // アニメーションをリセットするために要素を再生成
    const newTickerText = oldTickerText.cloneNode(false);
    newTickerText.textContent = newTextContent;
    oldTickerText.remove();
    tickerContainer.appendChild(newTickerText);
}

/**
 * 試合結果からニュースティッカー用の短いヘッドラインを生成する
 * @param {object} matchData - 試合のデータオブジェクト
 * @returns {string | null} - 生成されたヘッドラインの文字列、またはnull
 */
function generateTickerHeadline(matchData) {
    const { winnerName, loserName, score1, score2 } = matchData;
    const winnerScore = Math.max(parseInt(score1), parseInt(score2));
    const loserScore = Math.min(parseInt(score1), parseInt(score2));
    const scoreDiff = winnerScore - loserScore;

    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    const rankDiff = rankValues[winnerRank] - rankValues[loserRank];

    // パターン1：大番狂わせ（ジャイアントキリング）
    if (rankDiff <= -2) {
        return `【波乱】${getRankDescription(loserRank)}・${loserName}が初戦で散る！ ${winnerName}が金星挙げる`;
    }
    // パターン2：接戦
    if (scoreDiff <= 2 && rankDiff <= 1 && rankDiff >= -1) {
        return `手に汗握る接戦！ ${winnerName}が${loserName}を${winnerScore}-${loserScore}で振り切る`;
    }
    // パターン3：圧勝
    if (scoreDiff >= 8 && rankDiff >= 2) {
        return `王者・${winnerName}、盤石の試合運びで${loserName}を圧倒。${winnerScore}対${loserScore}でコールド勝ち級の快勝`;
    }
    // パターン4：ライバル対決
    const rivalry = RIVALRIES.find(r => r.teams.includes(winnerName) && r.teams.includes(loserName));
    if (rivalry) {
        return `因縁の${rivalry.type}は${winnerName}に軍配！ ${loserName}を下す`;
    }
    // デフォルト
    return `${winnerName}が${loserName}を下し、次のラウンドへ駒を進める`;
}

/**
 * 試合の詳細データから「事実オブジェクトの配列」と活躍選手リストを返す最終版
 */
/**
 * 試合の詳細データから「事実オブジェクトの配列」と活躍選手リストを返す（全ての分析機能を搭載した最終完成版）
 */
/**
 * 試合の詳細データから「事実オブジェクトの配列」と活躍選手リストを返す（全ての分析機能を搭載した最終完成版）
 */
/**
 * 試合の詳細データから「事実オブジェクトの配列」と活躍選手リストを返す（投手分析・全機能統合版）
 */
function createHighlightsText(dbMatch, winnerName) {
    if (!dbMatch.details) {
        return { highlights: [], keyPlayerNames: [] };
    }

    // --- 内部ヘルパー関数：打席結果を日本語に翻訳 ---
    const translateResult = (res, playerInfo, eventType) => {
        if (!res) return null;
        let description = `${playerInfo}が`;
        const rbiMatch = res.match(/(\d+)点/);
        const rbiText = rbiMatch ? (parseInt(rbiMatch[1]) > 1 ? `${rbiMatch[1]}点` : '') : '';
        if (res.includes('本塁打')) description = `${playerInfo}が${eventType}となる${rbiText}本塁打を放った`;
        else if (res.includes('三塁打')) description = `${playerInfo}が${eventType}となる${rbiText}三塁打を放った`;
        else if (res.includes('二塁打')) description = `${playerInfo}が${eventType}となる${rbiText}二塁打を放った`;
        else if (res.includes('安')) description = `${playerInfo}が${eventType}となる${rbiText}ヒットを放った`;
        else if (res.includes('犠飛')) description = `${playerInfo}が犠牲フライで${eventType}となる${rbiText || '1'}点を挙げた`;
        else if (res.includes('犠失')) description = `${playerInfo}が犠牲バントエラーで出塁した`;
        else if (res.includes('ゴロ') && res.includes('点')) description = `${playerInfo}の内野ゴロの間に${eventType}となる${rbiText || '1'}点を挙げた`;
        else if ((res.includes('エラー') || res.includes('失')) && res.includes('点')) description = `相手エラーの間に${eventType}となる${rbiText || '1'}点を記録した`;
        else if (res.includes('犠打')) description = `${playerInfo}が送りバントを決めた`;
        else if (res.includes('四球')) description = `${playerInfo}が四球を選んだ`;
        else if (res.includes('死球')) description = `${playerInfo}が死球で出塁した`;
        else if (res.includes('エラー')) description = `${playerInfo}がエラーで出塁した`;
        else if (res.includes('野選')) description = `${playerInfo}が野選で出塁した`;
        else if (res.includes('三振')) description = `${playerInfo}が三振に倒れた`;
        else if (res.includes('併殺')) description = `${playerInfo}が併殺打に倒れた`;
        else if (res.includes('ゴロ')) description = `${playerInfo}が内野ゴロに倒れた`;
        else if (res.includes('飛')) description = `${playerInfo}が外野フライに倒れた`;
        else if (res.includes('直')) description = `${playerInfo}がライナーに倒れた`;
        else return null;
        return description.replace(/1点/g, '');
    };
    
    const highlights = [];
    const keyPlayerNames = new Set();
    const winningTeamKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
    const losingTeamKey = winningTeamKey === 'team1' ? 'team2' : 'team1';
    const numInnings = dbMatch.details.inningScore?.team1?.length || 9;

    let hasScored = false;
    let isReversed = false;
    let scores = { team1: 0, team2: 0 };

    // --- 1. イニングごとのプレーを解析 ---
    for (let i = 0; i < numInnings; i++) {
        for (const teamKey of ['team1', 'team2']) {
            const teamName = dbMatch[teamKey];
            const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
            const allBattingData = dbMatch.details.batting?.[teamKey] || [];

            allBattingData.forEach(player => {
                const resultString = player.results?.[i];
                if (!resultString) return;

                resultString.split('、').forEach(atBatString => {
                    if (!atBatString) return;
                    
                    const [batterPlay, runnerPlaysString] = atBatString.split(';');
                    const playerInfo = `${player.name}(${player.order.includes('sub') ? '交代' : player.order + '番'})`;

                    if (batterPlay && batterPlay.trim() !== '') {
                        if (batterPlay.includes('点') || batterPlay.toLowerCase().includes('hr') || batterPlay.includes('本')) {
                            const prevTotalScore = scores[teamKey];
                            const rbiMatch = batterPlay.match(/(\d+)点/);
                            let addedScore = rbiMatch ? parseInt(rbiMatch[1]) : (batterPlay.includes('点') ? 1 : 0);
                            if (batterPlay.includes('本')) addedScore = Math.max(1, addedScore);
                            scores[teamKey] += addedScore;

                            let eventType = '追加点';
                            if (!hasScored) { eventType = '先制'; hasScored = true; }
                            else if (teamKey === winningTeamKey && prevTotalScore <= scores[opponentTeamKey] && scores[teamKey] > scores[opponentTeamKey] && !isReversed) { eventType = '逆転'; isReversed = true; }
                            
                            const description = translateResult(batterPlay, playerInfo, eventType);
                            if (description) {
                                highlights.push({ inning: i + 1, team: teamName, player: player.name, description });
                                keyPlayerNames.add(player.name);
                            }
                        } else {
                            const description = translateResult(batterPlay, playerInfo, '');
                            if (description) {
                                highlights.push({ inning: i + 1, team: teamName, player: player.name, description: description.replace(/がとなる/g, 'が') });
                                keyPlayerNames.add(player.name);
                            }
                        }
                    }
                    
                    if (runnerPlaysString) {
                        // ▼▼▼【重要修正】区切り文字を「、」から「,」に変更▼▼▼
                        runnerPlaysString.split(',').forEach(runnerPlay => {
                        // ▲▲▲
                            if (!runnerPlay) return;
                            const runnerPlayParts = runnerPlay.trim().split(' ');
                            if (runnerPlayParts.length < 2) return;

                            const runnerName = runnerPlayParts[0];
                            const play = runnerPlayParts[1];
                            const detail = runnerPlayParts.slice(2).join(' ') || '';
                            let description = `${runnerName}が`;

                            if (play === '盗塁') description += `盗塁を成功させ${detail}！`;
                            else if (play === 'タッチアップ') description += `タッチアップから${detail}！`;
                            else if (play === '生還' || (play === '進塁' && detail.includes('生還'))) description += `好走塁でホームイン！`;
                            else if (play.includes('死') || play.includes('アウト')) description += `走塁ミスでアウトになった`;
                            else if (play === '進塁') description += `進塁し${detail}。`;
                            
                            highlights.push({ type: 'baserunning', inning: i + 1, team: teamName, player: runnerName, description: description });
                            keyPlayerNames.add(runnerName);
                        });
                    }
                });
            });
        }
    }    
    // --- 2. 試合全体の個別要素を分析 ---
    const loserName = dbMatch[losingTeamKey];
    const losingPitchers = dbMatch.details.pitching?.[losingTeamKey] || [];
    if (losingPitchers.length === 1) {
        const ace = losingPitchers[0];
        if (ace.result === 'L' && parseFloat(ace.innings) >= 8 && parseInt(ace.earnedRuns) <= 2) {
             highlights.push({ type: 'tough_loss', team: loserName, player: ace.name, description: `${ace.name}投手は${ace.innings}回を${ace.earnedRuns}失点と好投したが、打線の援護に恵まれなかった` });
             keyPlayerNames.add(ace.name);
        }
    }

    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const teamBatting = dbMatch.details.batting?.[teamKey] || [];
        const substitutes = teamBatting.filter(p => p.sub_type);

        substitutes.forEach(subPlayer => {
            for (let i = 0; i < numInnings; i++) {
                const resultInInning = subPlayer.results[i];
                if (resultInInning) {
                    if (subPlayer.sub_type === 'PH' && (resultInInning.includes('安') || resultInInning.includes('本') || resultInInning.includes('二') || resultInInning.includes('三'))) {
                        const subDescription = getSubstitutionDescription(subPlayer);
                        highlights.push({ type: 'substitute_hit', inning: i + 1, team: teamName, player: subPlayer.name, description: `${subDescription}し、起用に応えるヒットを放った` });
                        keyPlayerNames.add(subPlayer.name);
                    }
                    if (subPlayer.sub_type === 'PITCHER') {
                         highlights.push({ type: 'pitching_change', inning: i + 1, team: teamName, player: subPlayer.name, description: `リリーフとしてマウンドに上がった` });
                         keyPlayerNames.add(subPlayer.name);
                    }
                    break; 
                }
            }
        });
    }
    
    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const pitchingData = dbMatch.details.pitching?.[teamKey] || [];
        if (!pitchingData) continue;

        pitchingData.forEach((pitcher) => {
            if (!pitcher.name) return;
            const innings = parseFloat(pitcher.innings || 0);
            const runs = parseInt(pitcher.runs || 0);
            const strikeouts = parseInt(pitcher.strikeouts || 0);
            if (pitcher.result === 'W' && runs === 0 && innings >= 7) {
                highlights.push({ type: 'pitching_feat', team: teamName, player: pitcher.name, description: '圧巻の投球で完封勝利' });
                keyPlayerNames.add(pitcher.name);
            } else if (strikeouts >= 10) {
                highlights.push({ type: 'pitching_feat', team: teamName, player: pitcher.name, description: `${strikeouts}奪三振の快投` });
                keyPlayerNames.add(pitcher.name);
            }
        });
    }

    if (dbMatch.details.pitching) {
        for (const teamKey of ['team1', 'team2']) {
            const teamName = dbMatch[teamKey];
            const pitchingData = dbMatch.details.pitching[teamKey] || [];
            if (pitchingData.length > 1) {
                const pitcherNames = pitchingData.map(p => `${p.name}(${p.innings}回)`);
                highlights.push({ type: 'pitching_relay', team: teamName, description: `投手リレーは ${pitcherNames.join(' → ')} だった` });
            }
        }
    }

    // --- 3. 試合全体の物語性を分析し、総括ハイライトを生成 ---
    let summaryHighlight = null;
    const winnerScore = parseInt(dbMatch[winningTeamKey === 'team1' ? 'score1' : 'score2']);
    const loserScore = parseInt(dbMatch[losingTeamKey === 'team1' ? 'score1' : 'score2']);
    const totalRuns = winnerScore + loserScore;
    const winnerBatting = dbMatch.details.batting?.[winningTeamKey] || [];
    const loserBatting = dbMatch.details.batting?.[losingTeamKey] || [];
    const winnerPitching = dbMatch.details.pitching?.[winningTeamKey] || [];
    const countHits = (battingData) => battingData.reduce((sum, p) => sum + (p.results?.reduce((inningSum, res) => inningSum + (res && (res.includes('安') || res.includes('塁打')) ? 1 : 0), 0) || 0), 0);
    const winnerHits = countHits(winnerBatting);
    const totalHits = winnerHits + countHits(loserBatting);
    const inningScores = dbMatch.details.inningScore;
    let scoreAfter6th = { team1: 0, team2: 0 };
    for(let i = 0; i < numInnings; i++) {
        if (i < 6) {
             scoreAfter6th.team1 += parseInt(inningScores?.team1[i] || 0);
             scoreAfter6th.team2 += parseInt(inningScores?.team2[i] || 0);
        }
    }
    const winnerScoreAfter6th = scoreAfter6th[winningTeamKey];
    const loserScoreAfter6th = scoreAfter6th[losingTeamKey];
    const lastInning = numInnings - 1;
    const lastInningScore = parseInt(inningScores?.[winningTeamKey][lastInning] || 0);
    
    if (lastInning >= 8 && lastInningScore > 0 && scores[losingTeamKey] < scores[winningTeamKey]) {
        summaryHighlight = { type: 'summary', description: `劇的なサヨナラ勝ちで、${winnerName}が熱戦に終止符を打った` };
    } else if (winnerScoreAfter6th < loserScoreAfter6th && numInnings >= 7) {
        summaryHighlight = { type: 'summary', description: `${winnerName}が終盤に試合をひっくり返す、劇的な逆転勝利となった` };
    } else if (totalRuns <= 5 && totalHits <= 12) {
        summaryHighlight = { type: 'summary', description: `両チームの投手が好投し、1点を争う緊迫した投手戦となった` };
    } else if (totalRuns >= 13 && totalHits >= 20) {
        summaryHighlight = { type: 'summary', description: `両チーム合わせて${totalHits}安打${totalRuns}得点が乱れ飛ぶ、壮絶な乱打戦となった` };
    } else if (winnerScore - loserScore >= 7) {
        summaryHighlight = { type: 'summary', description: `${winnerName}が投打に圧倒し、一方的な試合展開で勝利を収めた` };
    }
    
    if (summaryHighlight) {
        highlights.unshift(summaryHighlight);
    }
    
    return { highlights: highlights, keyPlayerNames: Array.from(keyPlayerNames) };
}
/**
 * 3連携の打撃結果プルダウンメニューのHTMLを生成する
 */
/**
 * 3連携の打撃結果プルダウンメニューのHTMLを生成する（保存値の再現機能付き）
 */
/**
 * 3連携の打撃結果プルダウンメニューのHTMLを生成する（★データ属性を追加した最終版）
 */
/**
 * 3連携の打撃結果プルダウンメニューのHTMLを生成する（打者一巡対応版）
 */
/**
 * 3連携の打席結果プルダウンメニューのHTMLを生成する（シンプルな3連バージョン・完全版）
 */
/**
 * 3連携の打席結果プルダウンと、それに付随する走塁入力欄のHTMLを生成する（参照エラー修正版）
/**
 * 1打席分の入力ブロックHTMLを生成する（役割を単機能化した最終版）
 * @param {Array<object>} playersOnField - 現在出場中の選手リスト
 * @param {string} atBatString - 1打席分の保存済み文字列 (例: "中安1点好走塁;田中 進塁 二塁へ")
 * @returns {string} - 生成されたHTML
 */
/**
 * 1打席分の入力ブロックHTMLを生成する（役割を単機能化した最終版）
 */
function createBattingResultDropdowns(playersOnField, atBatString = '') {
    const [batterPlay, runnerPlaysString] = (atBatString || '').split(';');
    
    let selectedResult = '', selectedDirection = '', selectedRbi = '', selectedRunnerPlay = '';
    let tempResult = (batterPlay || '').trim();

    if (tempResult) {
        const rbiMatch = tempResult.match(/(\d+点)/);
        if (rbiMatch) {
            selectedRbi = rbiMatch[0];
            tempResult = tempResult.replace(selectedRbi, '').trim();
        }
        if (tempResult.includes('好走塁')) {
            selectedRunnerPlay = '好走塁';
            tempResult = tempResult.replace('好走塁', '').trim();
        }
        const allResultTypes = [ ...BATTING_RESULTS.hits, ...BATTING_RESULTS.outs, ...BATTING_RESULTS.walks, ...BATTING_RESULTS.sacrifices, ...BATTING_RESULTS.other ];
        for (const type of allResultTypes) {
            if (tempResult.includes(type)) {
                selectedResult = type;
                tempResult = tempResult.replace(type, '').trim();
                break;
            }
        }
        if (tempResult.length > 0 && DIRECTIONS.includes(tempResult)) {
            selectedDirection = tempResult;
        }
    }

    const resultOptions = [ ...BATTING_RESULTS.hits, ...BATTING_RESULTS.outs, ...BATTING_RESULTS.walks, ...BATTING_RESULTS.sacrifices, ...BATTING_RESULTS.other ]
        .map(r => `<option value="${r}" ${selectedResult === r ? 'selected' : ''}>${r}</option>`).join('');
    const directionOptions = DIRECTIONS.map(d => `<option value="${d}" ${selectedDirection === d ? 'selected' : ''}>${d}</option>`).join('');
    const rbiOptions = RBIS.map(r => `<option value="${r}" ${selectedRbi === r ? 'selected' : ''}>${r}</option>`).join('');
    const runnerPlayOptions = ['好走塁'].map(r => `<option value="${r}" ${selectedRunnerPlay === r ? 'selected' : ''}>${r}</option>`).join('');

    return `
        <div class="at-bat-block border-t border-dashed pt-2 mt-2 first:mt-0 first:pt-0 first:border-t-0">
            <div class="flex items-center gap-1 batting-result-container mb-1">
                <div class="flex-grow flex gap-1">
                    <select class="batting-result-part w-[28%] text-xs p-1 border rounded result-type"><option value="">-結果-</option>${resultOptions}</select>
                    <select class="batting-result-part w-[22%] text-xs p-1 border rounded result-direction"><option value="">-方向-</option>${directionOptions}</select>
                    <select class="batting-result-part w-[22%] text-xs p-1 border rounded result-rbi"><option value="">-打点-</option>${rbiOptions}</select>
                    <select class="batting-result-part w-[28%] text-xs p-1 border rounded result-runner-play bg-yellow-50"><option value="">-打者走塁-</option>${runnerPlayOptions}</select>
                </div>
            </div>
            ${createRunnerInputsHTML(playersOnField, runnerPlaysString)}
        </div>
    `;
}
  /**
 * 特定チームの、今大会におけるここまでの戦績を要約する
 * @param {string} teamName - チーム名
 * @returns {string} - AIプロンプト用の要約テキスト
 */
/**
 * 特定チームの、今大会におけるここまでの戦績を要約する
 * (★本塁打や猛打賞も記憶する最終版)
 */
/**
 * 特定チームの、今大会におけるここまでの戦績を要約する
 * (★選手の打率を評価し「好調・不調」を記憶する最終版)
 */
/**
 * Creates a summary of a team's performance in the current tournament.
 * (Corrected to fix the 'team_name2' typo)
 */
/**
 * チームの今大会の軌跡を要約する
 * (★試合ごとの記録を参照して、正確に猛打賞を判断する最終版)
 */
function getCurrentTournamentPerformance(teamName, currentMatchId) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) return "今大会初戦。";

    const path = [];
    const keyPerformances = new Set();
    const currentTournamentMatchIds = Object.keys(tournamentState.matches);

    for (const matchId of currentTournamentMatchIds) {
        if (matchId === currentMatchId) continue;
        const match = tournamentState.matches[matchId];
        
        if (match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            const opponent = match.team1 === teamName ? match.team2 : match.team1;
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 1;
            
            if (match.winner === teamName) {
                path.push(`${roundNum}回戦 vs ${opponent}`);
            }

            if (match.details) {
                const teamKey = match.team1 === teamName ? 'team1' : 'team2';
                
                // 投手の好投（変更なし）
                const pitchers = match.details.pitching?.[teamKey] || [];
                pitchers.forEach(p => {
                    if (p.name && p.result === 'W' && parseFloat(p.innings) >= 6) {
                        keyPerformances.add(`${p.name}が${roundNum}回戦で好投`);
                    }
                });

                // ▼▼▼ このブロックが修正箇所です ▼▼▼
                // 保存された「試合ごとの成績」を参照して猛打賞を判断
                if (match.details.playerGameStats) {
                    const gameStats = match.details.playerGameStats[teamKey];
                    for (const playerName in gameStats) {
                        // この試合で3安打以上打っていたかをチェック
                        if (gameStats[playerName].h >= 3) {
                            keyPerformances.add(`${playerName}が${roundNum}回戦で猛打賞を記録`);
                        }
                    }
                }
                // ▲▲▲ ▲▲▲
            }
        }
    }
    
    let summary = "";
    if (path.length === 0) {
        return "今大会初戦。";
    } else {
        summary += `ここまでの勝ち上がり: ${path.join(' → ')}。`;
    }
    
    // 大会通算打率の分析（変更なし）
    const playerBattingStats = teamRecord.playerStats?.batting || {};
    for (const playerName in playerBattingStats) {
        const stats = playerBattingStats[playerName];
        if (stats.ab >= 5) {
            const battingAverage = stats.h / stats.ab;
            if (battingAverage >= 0.4) {
                keyPerformances.add(`${playerName}が打率4割超えと絶好調`);
            } else if (battingAverage <= 0.2) {
                keyPerformances.add(`${playerName}が打率2割以下と不振`);
            }
        }
    }
    
    if (keyPerformances.size > 0) {
        summary += `今大会の主な活躍: ${Array.from(keyPerformances).join('、')}。`;
    }

    return summary;
}

/**
 * 複数走者に対応した走塁入力欄のHTMLを生成する
 * @param {Array<object>} playersOnField - 現在出場中の選手リスト
 * @param {string} currentResult - 保存済みの打席結果文字列
 * @returns {string} - 生成されたHTML
 */
/**
 * 複数走者に対応した走塁入力欄のHTMLを生成する（区切り文字バグ修正版）
 */
function createRunnerInputsHTML(playersOnField, runnerPlaysString = '') {
    const baserunningPlays = ['盗塁', '盗塁死', 'タッチアップ', '進塁', '生還', '走塁死', '牽制死', '挟殺プレーでアウト'];
    const bases = ['一塁へ', '二塁へ', '三塁へ', '本塁へ(生還)'];
    
    // ▼▼▼【重要修正】区切り文字を「、」から「,」に変更▼▼▼
    const runnerEvents = runnerPlaysString ? runnerPlaysString.split(',') : [];
    // ▲▲▲

    let html = '<div class="runner-plays-container space-y-1 mt-1">';
    
    runnerEvents.forEach(event => {
        const parts = event.trim().split(' ');
        const name = parts[0] || '';
        const play = parts[1] || '';
        const base = parts.slice(2).join(' ') || '';
        
        const nameOptions = playersOnField.map(p => `<option value="${p.name}" ${p.name === name ? 'selected' : ''}>${p.name}</option>`).join('');
        const playOptions = baserunningPlays.map(p => `<option value="${p}" ${p === play ? 'selected' : ''}>${p}</option>`).join('');
        const baseOptions = bases.map(b => `<option value="${b}" ${b === base ? 'selected' : ''}>${b}</option>`).join('');

        html += `
            <div class="runner-play-input flex gap-1 items-center mt-1">
                <select class="runner-name w-1/3 text-xs p-1 border rounded"><option value="">-誰が-</option>${nameOptions}</select>
                <select class="runner-play w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-何をした-</option>${playOptions}</select>
                <select class="runner-base w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-どこへ-</option>${baseOptions}</select>
                <button class="remove-runner-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </div>
        `;
    });

    html += '</div>';
    html += '<button class="add-runner-play-btn text-xs mt-1 bg-gray-200 px-2 py-0.5 rounded hover:bg-gray-300">+ 走者プレーを追加</button>';
    return html;
}

/**
 * 選手の大会通算成績を、AIプロンプト用の短い文章に要約する
 * @param {string} playerName - 選手名
 * @param {string} teamName - チーム名
 * @returns {string | null} - "姫川: 打率.500, 3本塁打, 10打点" のような要約文。成績がなければnull。
 */
function getPlayerTournamentStatsSummary(playerName, teamName) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord || !teamRecord.playerStats) return null;

    const battingStats = teamRecord.playerStats.batting[playerName];
    const pitchingStats = teamRecord.playerStats.pitching[playerName];
    
    let summaries = [];

    if (battingStats && battingStats.ab > 0) {
        const avg = (battingStats.h / battingStats.ab).toFixed(3);
        summaries.push(`打率${avg}, ${battingStats.hr}本塁打, ${battingStats.rbi}打点`);
    }

    if (pitchingStats && pitchingStats.ip > 0) {
        const era = pitchingStats.er > 0 ? ((pitchingStats.er * 9) / pitchingStats.ip).toFixed(2) : "0.00";
        summaries.push(`${pitchingStats.w}勝${pitchingStats.l}敗, 防御率${era}, ${pitchingStats.so}奪三振`);
    }

    if (summaries.length > 0) {
        return `${playerName}: ${summaries.join(' / ')}`;
    }
    
    return null;
}

/**
 * Analyzes the results of a half-inning, counts outs, and updates the UI (colors and disabled state).
 */
function updateInningState(teamKey, inningIndex) {
    const battingTable = document.getElementById(`batting-table-${teamKey}`);
    if (!battingTable) return;

    let outCount = 0;
    
    // --- 1. Analyze Batting Results ---
    battingTable.querySelectorAll('tbody tr').forEach(row => {
        const resultCell = row.children[5 + inningIndex];
        if (!resultCell) return;
        
        const atBatContainers = resultCell.querySelectorAll('.batting-result-container');
        atBatContainers.forEach(container => {
            const resultTypeSelect = container.querySelector('.result-type');
            const resultText = resultTypeSelect.value;
            
            // Count outs
            if (BATTING_RESULTS.outs.includes(resultText)) {
                outCount += (resultText === '併殺') ? 2 : 1;
            }

            // Color-code the dropdowns
            const dropdowns = container.querySelectorAll('select');
            dropdowns.forEach(dd => dd.classList.remove('result-hit', 'result-out', 'result-on-base'));

            if (BATTING_RESULTS.hits.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-hit'));
            } else if (BATTING_RESULTS.walks.includes(resultText) || BATTING_RESULTS.other.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-on-base'));
            } else if (BATTING_RESULTS.outs.includes(resultText) || BATTING_RESULTS.sacrifices.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-out'));
            }
        });
    });

    // --- 2. Count Outs from "Inning Events" (Baserunning) ---
    const eventsInput = document.querySelector(`.inning-events-input[data-team-key="${teamKey}"][data-inning-index="${inningIndex}"]`);
    if (eventsInput && eventsInput.value) {
        const events = eventsInput.value.split('、');
        events.forEach(event => {
            if (event.includes('盗塁死') || event.includes('走塁死')) {
                outCount++;
            }
        });
    }

    // --- 3. Lock the Inning if 3 Outs are Reached ---
    const isLocked = outCount >= 3;
    battingTable.querySelectorAll('tbody tr').forEach(row => {
        const resultCell = row.children[5 + inningIndex];
        if (!resultCell) return;
        
        const dropdowns = resultCell.querySelectorAll('.batting-result-container select');
        const addButtons = resultCell.querySelectorAll('.add-at-bat-btn');
        
        dropdowns.forEach(dd => {
            dd.disabled = isLocked;
            if (isLocked) dd.classList.add('bg-gray-100');
        });
        addButtons.forEach(btn => {
            btn.disabled = isLocked;
            if (isLocked) btn.style.visibility = 'hidden';
        });
    });
     if (eventsInput) {
        eventsInput.disabled = isLocked;
        if (isLocked) eventsInput.classList.add('bg-gray-100');
     }
}

/**
 * 生成された記事と元の「事実リスト」を比較し、内容が矛盾していないかAIに確認させる
 * @param {object} article - AI記者が生成した記事オブジェクト
 * @param {Array} facts - createHighlightsTextから生成された元の事実オブジェクトの配列
 * @returns {boolean} - 矛盾がなければtrue、あればfalseを返す
 */
async function factCheckArticle(article, facts) {
 // ▼▼▼ この安全装置がクラッシュを防ぎます ▼▼▼
    if (!article || !article.body) {
        console.error("事実確認エラー: 記事データ、または記事の本文がありません。");
        return false; // 不完全な記事は「矛盾あり」とみなして処理を中断
    }
    // AIが読みやすいように、事実リストをテキストに変換
    const factListText = facts.map(fact => {
        let text = `- `;
        if (fact.inning) text += `${fact.inning}回 `;
        if (fact.team) text += `${fact.team} `;
        if (fact.player) text += `${fact.player} `;
        text += `: ${fact.description}`;
        return text;
    }).join('\n');

    const prompt = `あなたは、非常に厳格で注意深い「事実確認（ファクトチェッカー）」です。
以下の【事実リスト】と【AI記者が書いた記事】を比較し、記事の内容が事実に忠実かどうかを判定してください。

### 事実リスト
${factListText}

### AI記者が書いた記事
**タイトル:** ${article.title}
**本文:** ${article.body.replace(/\\n/g, '\n')}

### あなたの仕事
記事が、事実リストの内容と**完全に一致**しているか？選手名、チーム名、イニング、プレー内容などの重要な情報に**一切の矛盾がない**か？
あなたの答えは、以下のいずれか一つだけにしてください。
- **はい** (矛盾がない場合)
- **いいえ** (一つでも矛盾がある場合)

説明や理由は一切不要です。「はい」か「いいえ」の二文字だけで回答してください。`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const aiResponse = result.candidates[0].content.parts[0].text.trim();
            console.log("事実確認AIの応答:", aiResponse); // デバッグ用にコンソールに応答を表示
            return aiResponse.includes('はい'); // 応答に「はい」が含まれていればtrue
        }
        return false; // よく分からない応答の場合は、安全のためfalse（矛盾あり）と判断
    } catch (error) {
        console.error("事実確認AIの呼び出しに失敗しました:", error);
        return false; // エラー時も安全のためfalseと判断
    }
}

/**
     * 試合の勝者を処理する中心的関数。
     * 状態を更新し、次の試合を準備し、AIコンテンツ生成をトリガーする。
     */
    // 【修正対象5】
/**
     * 【修正版】試合の勝者を処理する中心的関数
     */
    /**
 * 試合の勝者を処理する中心的関数（全ての機能を統合した最終完成版）
 */
/**
 * 試合の勝者を処理する中心的関数（全てのロジックを統合した最終完成版）
 */
async function processMatchWin(matchId, winnerName) {
    // --- 1. 試合データの特定と基本情報の設定 ---
    let dbMatch = findMatchById(matchId);
    if (!dbMatch || !dbMatch.team1 || !dbMatch.team2 || dbMatch.winner) return;
    
    const loserName = dbMatch.team1 === winnerName ? dbMatch.team2 : dbMatch.team1;
    dbMatch.winner = winnerName;
    
    const matchEl = document.querySelector(`.matchup[data-match-id="${matchId}"]`);
    if (matchEl) {
        const score1El = matchEl.querySelector('[data-team-pos="1"]');
        const score2El = matchEl.querySelector('[data-team-pos="2"]');
        if (score1El && score2El && score1El.value !== '' && score2El.value !== '') {
            dbMatch.score1 = score1El.value;
            dbMatch.score2 = score2El.value;
        }
        dbMatch.summary = matchEl.querySelector('.match-summary-input')?.value || '';
    }

    const newHeadline = generateTickerHeadline({ winnerName, loserName, score1: dbMatch.score1, score2: dbMatch.score2 });
    if (newHeadline) {
        tournamentState.tickerHeadlines.unshift(newHeadline);
        if (tournamentState.tickerHeadlines.length > 20) {
            tournamentState.tickerHeadlines.pop();
        }
        updateTicker();
    }
    
    // ▼▼▼【重要修正】スタメン情報の記録を、AI呼び出しの「前」に移動しました▼▼▼
    if (dbMatch.details && dbMatch.details.batting) {
        const winnerTeamKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
        if (tournamentState.teamRecords[winnerName] && dbMatch.details.batting[winnerTeamKey]) {
            tournamentState.teamRecords[winnerName].previousStarters = dbMatch.details.batting[winnerTeamKey]
                .filter(p => p.order && !p.order.toString().includes('sub'))
                .map(p => ({ order: p.order, name: p.name, pos: p.pos }));
        }
        const loserTeamKey = dbMatch.team1 === loserName ? 'team1' : 'team2';
        if (tournamentState.teamRecords[loserName] && dbMatch.details.batting[loserTeamKey]) {
            tournamentState.teamRecords[loserName].previousStarters = dbMatch.details.batting[loserTeamKey]
                .filter(p => p.order && !p.order.toString().includes('sub'))
                .map(p => ({ order: p.order, name: p.name, pos: p.pos }));
        }
    }
    // ▲▲▲ここまで▲▲▲

    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    if ((rankValues[loserRank] - rankValues[winnerRank]) >= 2) {
        const winnerRecord = tournamentState.teamRecords[winnerName];
        if (winnerRecord && !winnerRecord.teamTraits.includes('giant_killer')) {
            winnerRecord.teamTraits.push('giant_killer');
        }
    }

    // --- 2. チームデータの存在チェック（安全装置）---
    const winnerData = TEAM_DATA[winnerName];
    const loserData = TEAM_DATA[loserName];
    if (!winnerData || !loserData) {
        console.error(`チームデータが見つかりません。勝者: ${winnerName}, 敗者: ${loserName}`);
        showAlert(`チームデータが見つかりませんでした。TEAM_DATA内のチーム名と、入力したチーム名（${winnerName}, ${loserName}）が完全に一致しているか確認してください。`);
        return;
    }

    newsContainer.innerHTML = `<div class="loader">AI記者が記事を執筆中...</div>`;
    bbsCommentsContainer.innerHTML = `<div class="loader">AIが掲示板を監視中...</div>`;

    // --- 3. トーナメント進行ロジック ---
    if (tournamentState.currentTournament === 'spring' && tournamentState.springPhase === 'regional_qualifiers') {
        const [region, bracketType, roundStr, matchStr] = matchId.split('-');
        if (bracketType.startsWith('SB')) {
            const block = tournamentState.springData.regions[region].blocks.find(b => b.id === `${region}-${bracketType}`);
            if (matchId.includes('-R1-') || matchId.includes('-R0-')) {
                const finalMatchKey = Object.keys(block.matches).find(k => k.includes('-R2-') || (block.teams.length <= 4 && k.includes('-R1-') && !k.includes(matchId.slice(-2))));
                const finalMatch = block.matches[finalMatchKey];
                if (finalMatch) {
                    if (matchId.endsWith('M1')) finalMatch.team1 = winnerName;
                    else finalMatch.team2 = winnerName;
                }
            } else {
                const repBracket = tournamentState.springData.regions[region].repechageBracket;
                const repTeams = repBracket.teams;
                repTeams.push(loserName);
                if (repTeams.length === 1) repBracket.matches[`${repBracket.id}-R1-M1`].team1 = loserName;
                if (repTeams.length === 2) repBracket.matches[`${repBracket.id}-R1-M1`].team2 = loserName;
                if (repTeams.length === 3) repBracket.matches[`${repBracket.id}-R1-M2`].team1 = loserName;
                if (repTeams.length === 4) repBracket.matches[`${repBracket.id}-R1-M2`].team2 = loserName;
            }
        } else if (bracketType.startsWith('SREP')) {
            const repBracket = tournamentState.springData.regions[region].repechageBracket;
            const finalMatch = repBracket.matches[`${repBracket.id}-R2-M1`];
            if (matchId.endsWith('M1')) finalMatch.team1 = winnerName;
            if (matchId.endsWith('M2')) finalMatch.team2 = winnerName;
        } else if (bracketType.startsWith('SIZU')) {
            const izuBracket = tournamentState.springData.regions['伊豆'].izuBracket;
            const finalMatch = izuBracket.matches[`${izuBracket.id}-R2-M1`];
            if (matchId.endsWith('M1')) finalMatch.team1 = winnerName;
            if (matchId.endsWith('M2')) finalMatch.team2 = winnerName;
        }
    } else if (tournamentState.currentTournament === 'autumn' && tournamentState.autumnPhase !== 'main') {
        const [region, bracketId, roundStr, matchStr] = matchId.split('-');
        const roundNum = parseInt(roundStr.slice(1));
        const matchNum = parseInt(matchStr.slice(1));
        if (bracketId.startsWith('B')) {
            if (roundNum === 0) {
                const semiFinalMatch = tournamentState.autumnData.regions[region].blocks.find(b=>b.id === `${region}-${bracketId}`).matches[`${region}-${bracketId}-R1-M1`];
                semiFinalMatch.team1 = winnerName;
            } else if (roundNum === 1) {
                const finalMatch = tournamentState.autumnData.regions[region].blocks.find(b=>b.id === `${region}-${bracketId}`).matches[`${region}-${bracketId}-R2-M1`];
                if(matchNum === 1) finalMatch.team1 = winnerName; else finalMatch.team2 = winnerName;
            } else if (roundNum === 2) {
                tournamentState.autumnData.regions[region].blockWinners.push(winnerName);
                tournamentState.autumnData.regions[region].blockRunnersUp.push(loserName);
            }
        } else if (bracketId === 'CHAMP' || bracketId === 'REP') {
            const isChamp = bracketId === 'CHAMP';
            const bracket = isChamp ? tournamentState.autumnData.regions[region].champBracket : tournamentState.autumnData.regions[region].repechageBracket;
            if (roundNum === 1) {
                const finalMatch = bracket.matches[`${bracket.id}-R2-M1`];
                if (matchNum === 1) finalMatch.team1 = winnerName; else finalMatch.team2 = winnerName;
                if (isChamp) {
                    const thirdMatch = bracket.matches[`${bracket.id}-R2-M2`];
                    if (matchNum === 1) thirdMatch.team1 = loserName; else thirdMatch.team2 = loserName;
                }
            } else if (roundNum === 2) {
                if (isChamp) {
                    if (dbMatch.type === 'final') {
                        tournamentState.autumnData.regions[region].finalReps.push({ team: winnerName, rank: 1 });
                        tournamentState.autumnData.regions[region].finalReps.push({ team: loserName, rank: 2 });
                    } else {
                        tournamentState.autumnData.regions[region].finalReps.push({ team: winnerName, rank: 3 });
                        tournamentState.autumnData.regions[region].finalReps.push({ team: loserName, rank: 4 });
                    }
                } else {
                    tournamentState.autumnData.regions[region].finalReps.push({ team: winnerName, rank: 5 });
                    const winnerRecord = tournamentState.teamRecords[winnerName];
                    if (winnerRecord && !winnerRecord.teamTraits.includes('repechage_king')) {
                        winnerRecord.teamTraits.push('repechage_king');
                    }
                }
            }
        }
    } else { 
        if(tournamentState.teamRecords[winnerName]) tournamentState.teamRecords[winnerName].wins++;
        if(tournamentState.teamRecords[loserName]) tournamentState.teamRecords[loserName].losses++;
        const idParts = matchId.split('-');
        const side = idParts[0];
        if (side !== 'F') {
            const roundStrMain = idParts[1];
            const roundNum = parseInt(roundStrMain.slice(1));
            const numTeamsInTournament = tournamentState.teams.length;
            const finalRound = Math.log2(numTeamsInTournament);
            if (roundNum < finalRound) {
                const matchNum = parseInt(idParts[2].slice(1));
                const nextRoundNum = roundNum + 1;
                let nextMatchId = (nextRoundNum === finalRound) ? 'F-R1-M1' : `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
                if (!tournamentState.matches[nextMatchId]) {
                    tournamentState.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
                }
                let slot = (nextRoundNum === finalRound) ? (side === 'L' ? 1 : 2) : (matchNum % 2 !== 0 ? 1 : 2);
                tournamentState.matches[nextMatchId][`team${slot}`] = winnerName;
            }
        } else {
            updateTournamentFinishRecords();
            if (tournamentState.currentTournament === 'summer') {
                const winnerRecord = tournamentState.teamRecords[winnerName];
                const winnerRank = calculateRank(winnerName, tournamentState);
                const koshienResultKey = simulateKoshien(winnerRank);
                const koshienResult = KOSHIEN_RESULTS[koshienResultKey];
                winnerRecord.lastFinish = koshienResult.rank;
                const newHistoryRecord = { year: tournamentState.tournamentYear, tournament: 'summer', rank: koshienResult.rank };
                winnerRecord.history.unshift(newHistoryRecord);
                if (!winnerRecord.best || newHistoryRecord.rank < winnerRecord.best.rank) {
                    winnerRecord.best = newHistoryRecord;
                }
                const article = await generateKoshienSummaryArticle(winnerName, koshienResult.label, 'summer');
                if(article) tournamentState.news.push(article);
                renderNews(tournamentState.news);
            }
            if (tournamentState.currentTournament === 'autumn') {
                tournamentState.senbatsuTeams = [];
                const finalists = [winnerName, loserName];
                for (const teamName of finalists) {
                    const teamRank = calculateRank(teamName, tournamentState);
                    if (Math.random() < 0.70) { 
                        tournamentState.senbatsuTeams.push(teamName);
                        const article = await generateKoshienSummaryArticle(teamName, 'センバツ出場決定', 'tokai');
                        if(article) tournamentState.news.push(article);
                    }
                }
                renderNews(tournamentState.news);
            }
        }
    }

    renderTournament(tournamentState);

    if (tournamentState.currentTournament === 'spring' && tournamentState.springPhase === 'main_round1') {
        const round1Matches = Object.values(tournamentState.matches).filter(m => m.id.includes('-R1-'));
        if (round1Matches.length === 8 && round1Matches.every(m => m.winner)) {
            const confirmed = await showConfirm("1回戦がすべて終了しました。シード校が登場する2回戦に進みますか？");
            if (confirmed) {
                await setupSpringMainTournament_Round2();
                return; 
            }
        }
    }

    // --- 4. AIコンテンツ生成と結果処理 ---
    const winnerDetailedData = DETAILED_TEAM_DATA[winnerName];
    const loserDetailedData = DETAILED_TEAM_DATA[loserName];
    const { highlights, keyPlayerNames } = createHighlightsText(dbMatch, winnerName);
    const highlightsText = highlights.map(fact => {
        let text = '';
        if (fact.inning) text += `${fact.inning}回 `;
        if (fact.team) text += `${fact.team} `;
        if (fact.player) text += `${fact.player} `;
        text += `: ${fact.description}`;
        return text;
    }).join('、');

     let articlePromise;
    const documentary = tournamentState.documentary;
const matchContext = { winnerName, loserName, dbMatch, matchId, winnerData, loserData, winnerDetailedData, loserDetailedData };
    if (documentary.target && (documentary.target === winnerName || documentary.target === loserName)) {
        const isWin = documentary.target === winnerName;

        // ▼▼▼ ここがエラーの原因でした。変数を明確に定義します ▼▼▼
        const round = matchId.includes('-R') ? parseInt(matchId.split('-')[1].slice(1)) : 1;
        const opponent = isWin ? loserName : winnerName;
        const score = isWin 
            ? `${dbMatch.score1}-${dbMatch.score2}` 
            : (dbMatch.team1 === loserName ? `${dbMatch.score2}-${dbMatch.score1}` : `${dbMatch.score1}-${dbMatch.score2}`);

        const matchInfoForArticle = { 
            round: round,
            opponent: opponent,
            score: score,
            highlights: highlightsText
        };
        // ドキュメンタリー記事を生成（typeも渡す）
        articlePromise = generateDocumentaryArticle(isWin ? 'win' : 'lose', documentary.type, documentary.target, { round, opponent, score });
        
        if (!isWin) {
            // 敗退した場合、密着取材は終了するのでターゲットをリセット
            tournamentState.documentary = { target: null, type: null };
        }

    } else {
        // 通常の試合の場合
        // 元々の通常記事を生成する関数を、必要な全ての引数を渡して呼び出す
        articlePromise = generateNewsArticle(
            winnerName, 
            loserName, 
            dbMatch, 
            matchId, 
            winnerData, 
            loserData, 
            winnerDetailedData, 
            loserDetailedData, 
            highlights, 
            keyPlayerNames
        );
    }    
    // 掲示板コメントの生成は、どちらの分岐でも共通して行う
    const commentsPromise = generateBbsComments(
        winnerName, loserName, dbMatch, matchId, 
        winnerData, loserData, winnerDetailedData, loserDetailedData, 
        highlightsText
    );

    // 記事（ドキュメンタリー or 通常）とコメントの生成を並行して実行
    const [article, newComments] = await Promise.all([
        articlePromise,
        commentsPromise
    ]);

    if (newComments && newComments.length > 0) {
        tournamentState.bbsComments.push(...newComments);
    } else if (dbMatch.winner) {
        tournamentState.bbsComments.push({
            id: `error-${matchId}`,
            error: true,
            title: `掲示板コメント生成エラー`,
            context: { winnerName, loserName, dbMatch, matchId, winnerData, loserData, winnerDetailedData, loserDetailedData, highlightsText }
        });
    }
    renderBbsComments(tournamentState.bbsComments);

    if (article) {
if (!article.error) {
            article.context = matchContext; 
        }
        newsContainer.innerHTML = `<div class="loader">AIが記事を執筆完了。事実確認を実行中...</div>`;
        const isVerified = await factCheckArticle(article, highlights);
        if (isVerified) {
            showArticleReviewModal(article);
        } else {
            const errorArticle = {
                title: "記事生成エラー（事実矛盾の可能性）",
                body: "AI記者が生成した記事に、元の試合データとの矛盾が含まれている可能性があります。",
                timestamp: Date.now(),
                error: true,
                errorId: matchId, 
                context: { winnerName, loserName, dbMatch, matchId, winnerData, loserData, winnerDetailedData, loserDetailedData }
            };
            tournamentState.news.push(errorArticle);
            renderNews(tournamentState.news);
        }
    } else {
        renderNews(tournamentState.news);
    }
    
    if (!tournamentState.activeScandal && Math.random() < 0.1) { // 10%の確率で発生チェック
        triggerScandalEvent(winnerName, loserName);
    }

saveState();
}

// ▼▼▼ この関数をまるごと追加 ▼▼▼
/**
 * スキャンダルイベントを発生させる
 * @param {string} winnerName 
 * @param {string} loserName 
 */
function triggerScandalEvent(winnerName, loserName) {
    const potentialTargets = [winnerName, loserName];
    const eligibleScandals = [];

    for (const team of potentialTargets) {
        for (const scandal of SCANDAL_DEFINITIONS) {
            if (scandal.condition(team)) {
                eligibleScandals.push({ team, scandal });
            }
        }
    }

    if (eligibleScandals.length > 0) {
        const selected = eligibleScandals[Math.floor(Math.random() * eligibleScandals.length)];
        
        tournamentState.activeScandal = {
            teamName: selected.team,
            scandalId: selected.scandal.id
        };

        // ▼▼▼ この部分を修正 ▼▼▼
        const rumorArticle = {
            title: selected.scandal.rumorTitle(selected.team), // 関数として呼び出し、teamNameを渡す
            body: selected.scandal.rumorBody(selected.team),   // 関数として呼び出し、teamNameを渡す
            timestamp: Date.now(),
            isScandalRumor: true
        };
        // ▲▲▲ ここまで修正 ▲▲▲

        tournamentState.news.push(rumorArticle);
        renderNews(tournamentState.news);
        saveState();
    }
}
// ▲▲▲ ここまで追加 ▲▲▲

// --- 編集モーダル用のグローバル変数 ---
let articleForReview = null; // レビュー中の記事データを一時的に保持する

/**
 * AIが生成した記事を確認・編集するためのモーダルを表示する
 * @param {object} article - AIが生成した記事オブジェクト
 */
function showArticleReviewModal(article) {
    articleForReview = article; // 記事データを一時保存

    document.getElementById('review-title').value = article.title;
    document.getElementById('review-body').value = article.body.replace(/\\n/g, '\n');
    
    document.getElementById('review-modal').classList.remove('hidden');
}

/**
 * 編集モーダルを閉じる
 */
function closeReviewModal() {
    articleForReview = null;
    document.getElementById('review-modal').classList.add('hidden');
}

// --- 遊び方説明書モーダルのイベントリスナー ---
    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('help-modal');
    const helpModalClose = document.getElementById('help-modal-close');

    helpBtn.addEventListener('click', () => {
        helpModal.classList.remove('hidden');
    });
    helpModalClose.addEventListener('click', () => {
        helpModal.classList.add('hidden');
    }); 


// ▼▼▼ 抽選会イベント関連の関数群 ▼▼▼

const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

/**
 * 効果音を読み込む
 */
async function loadSoundEffects() {
    try {
        const drumroll = new Audio("https://actions.google.com/sounds/v1/sports/drum_roll_long.ogg");
        const cheer = new Audio("https://actions.google.com/sounds/v1/crowds/battle_crowd_cheer_med.ogg");
        const gasp = new Audio("https://actions.google.com/sounds/v1/human_sounds/gasp.ogg");
        soundEffects = { drumroll, cheer, gasp };
    } catch (e) {
        console.error("効果音の読み込みに失敗しました:", e);
    }
}

/**
 * 抽選会イベントを開始する
 */
/**
 * 抽選会イベントを開始する（BGM再生機能付き・完全版）
 */
async function startLotteryEvent() {
    const lotteryModal = document.getElementById('lottery-modal');
    lotteryModal.classList.remove('hidden');
    lotteryModal.classList.add('flex');

    // 抽選順を決める（トーナメントの組み合わせの元）
    const seeds = INITIAL_TEAM_POOL.map(teamName => ({
        name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last)
    })).sort((a, b) => a.rank - b.rank).slice(0, 8).map(t => t.name);
    
    const nonSeeds = INITIAL_TEAM_POOL.filter(t => !seeds.includes(t));
    const lotteryOrder = [...seeds, ...shuffleArray(nonSeeds)];

    // 簡易トーナメント表を作成
    const leftBracket = document.getElementById('lottery-bracket-left');
    const rightBracket = document.getElementById('lottery-bracket-right');
    leftBracket.innerHTML = '';
    rightBracket.innerHTML = '';
    for(let i=0; i<64; i++){
        const slot = document.createElement('div');
        slot.className = 'lottery-slot';
        slot.dataset.index = i;
        slot.innerHTML = `<span>${i+1}.</span> <span class="team-name-placeholder">---</span>`;
        document.getElementById(i < 32 ? 'lottery-bracket-left' : 'lottery-bracket-right').appendChild(slot);
    }

    // ボタンのイベントリスナーを設定
    document.getElementById('start-lottery-btn').onclick = () => runLotteryAnimation(lotteryOrder, seeds);
    
    document.getElementById('skip-lottery-btn').onclick = () => {
        lotteryModal.classList.add('hidden');
        SoundManager.stopBgm(); // スキップ時もBGMを停止
        createNewTournament(false, 'summer');
    };

    // BGM再生開始
    SoundManager.startBgm();
}
/**
 * 抽選会のアニメーションを実行する（強豪校の禍々しい雰囲気演出付き・完全版）
 * @param {Array<string>} lotteryOrder - シード校と、シャッフル済みのノーシード校を含む全チームの配列
 * @param {Array<string>} seeds - シード校8チームの配列
 */
/**
 * 抽選会のアニメーションを実行する（サウンドマネージャー対応の最終完成版）
 */
async function runLotteryAnimation(lotteryOrder, seeds) {
    // --- 1. 初期設定 ---
    document.getElementById('lottery-pot').onclick = null;
    document.getElementById('skip-lottery-btn').style.display = 'none';

    const commentaryEl = document.getElementById('lottery-commentary').querySelector('p');
    const drawnTeamContainer = document.getElementById('drawn-team-container');
    const drawnTeamEl = document.getElementById('drawn-team');
    const potEl = document.getElementById('lottery-pot');
    const potNameEl = document.getElementById('pot-name');
    
    const teamPositions = Array(64).fill(null);
    const seedPositionsTemplate = [0, 32, 16, 48, 8, 40, 24, 56];
    let availableSeedSlots = [...seedPositionsTemplate];
    let availableNonSeedSlots = Array.from({length: 64}, (_, i) => i).filter(p => !availableSeedSlots.includes(p));
    
    const blockDeathAnnounced = { A: false, B: false, C: false, D: false };

    // --- 内部ヘルパー関数：安全に音声を再生する ---
    const playSound = (id) => {
        const soundElement = document.getElementById(id);
        if (soundElement) {
            soundElement.currentTime = 0;
            soundElement.play().catch(e => console.warn(`Audio play failed for ${id}:`, e));
        }
    };
    
    const isStrongRank = (team) => ['S', 'A'].includes(calculateRank(team, {}));

    const checkDeathBlock = (position) => {
        const blockName = position < 16 ? 'A' : position < 32 ? 'B' : position < 48 ? 'C' : 'D';
        const startIdx = position < 16 ? 0 : position < 32 ? 16 : position < 48 ? 32 : 48;
        if (blockDeathAnnounced[blockName]) return false;
        const teamsInBlock = teamPositions.slice(startIdx, startIdx + 16);
        const strongTeamsCount = teamsInBlock.filter(team => team && isStrongRank(team)).length;
        if (strongTeamsCount >= 3) {
            commentaryEl.textContent = `これは...！ ${blockName}ブロックは有力校が集中する「死のブロック」になりました！`;
            blockDeathAnnounced[blockName] = true;
            playSound('sound-gasp');
            return true;
        }
        return false;
    };

    // --- 2. 抽選会フェーズ1：シード校の配置 ---
    potNameEl.textContent = "シード校";
    for (const teamName of seeds) {
        let dreadBg = null;
        if (isStrongRank(teamName)) {
            dreadBg = document.createElement('div');
            dreadBg.className = 'dread-mode-bg';
            document.body.appendChild(dreadBg);
            potEl.classList.add('dread');
            commentaryEl.textContent = `会場が静まり返る... 次は ${teamName} です...`;
            await sleep(2500);
        }

        commentaryEl.textContent = `${teamName}がクジを引きます...`;
        playSound('sound-drumroll');
        await sleep(1500);

        drawnTeamEl.textContent = teamName;
        drawnTeamContainer.classList.add('fade-in-out');

        const slotIndex = Math.floor(Math.random() * availableSeedSlots.length);
        const position = availableSeedSlots.splice(slotIndex, 1)[0];
        teamPositions[position] = teamName;

        await sleep(1250);

        const targetSlot = document.querySelector(`.lottery-slot[data-index="${position}"]`);
        targetSlot.querySelector('.team-name-placeholder').textContent = teamName;
        targetSlot.classList.add('filled');
        playSound('sound-cymbal');
        
        if (dreadBg) {
            dreadBg.remove();
            potEl.classList.remove('dread');
            playSound('sound-gasp');
        }
        
        const opponentIndex = position % 2 === 0 ? position + 1 : position - 1;
        if (teamPositions[opponentIndex]) {
            commentaryEl.textContent = `${teamName}の相手は${teamPositions[opponentIndex]}に決定！`;
        } else {
            commentaryEl.textContent = `${teamName}は ${position + 1}番！ 相手はまだ決まりません！`;
        }
        await sleep(1500);
        drawnTeamContainer.classList.remove('fade-in-out');
    }

    // --- 3. 抽選会フェーズ2：ノーシード校の配置 ---
    potNameEl.textContent = "ノーシード校";
    const nonSeeds = lotteryOrder.filter(t => !seeds.includes(t));
    for (const teamName of nonSeeds) {
        let dreadBg = null;
        if (isStrongRank(teamName)) {
            dreadBg = document.createElement('div');
            dreadBg.className = 'dread-mode-bg';
            document.body.appendChild(dreadBg);
            potEl.classList.add('dread');
            commentaryEl.textContent = `会場が静まり返る... 強豪 ${teamName} が登場...`;
            await sleep(2500);
        }

        commentaryEl.textContent = `${teamName}がクジを引きます...`;
        playSound('sound-drumroll');
        await sleep(250);

        drawnTeamEl.textContent = teamName;
        drawnTeamContainer.classList.add('fade-in-out');

        const slotIndex = Math.floor(Math.random() * availableNonSeedSlots.length);
        const position = availableNonSeedSlots.splice(slotIndex, 1)[0];
        teamPositions[position] = teamName;
        
        await sleep(200);

        const targetSlot = document.querySelector(`.lottery-slot[data-index="${position}"]`);
        targetSlot.querySelector('.team-name-placeholder').textContent = teamName;
        targetSlot.classList.add('filled');
        playSound('sound-cymbal');
        
        if (dreadBg) {
            dreadBg.remove();
            potEl.classList.remove('dread');
            playSound('sound-gasp');
        }
        
        commentaryEl.textContent = `${teamName}は ${position + 1}番 に決定！`;
        let didComment = checkDeathBlock(position);

        if (!didComment) {
            const opponentIndex = position % 2 === 0 ? position + 1 : position - 1;
            if(teamPositions[opponentIndex]) {
                const opponentName = teamPositions[opponentIndex];
                const isRival = RIVALRIES.some(r => r.teams.includes(teamName) && r.teams.includes(opponentName));
                if (isRival || (isStrongRank(teamName) && isStrongRank(opponentName))) {
                    commentaryEl.textContent = `決まったー！1回戦から屈指の好カード！ ${teamName} vs ${opponentName}`;
                    playSound('sound-gasp');
                    document.querySelector(`.lottery-slot[data-index="${opponentIndex}"]`).classList.add('highlight');
                    targetSlot.classList.add('highlight');
                    await sleep(1500);
                }
            }
        }
        await sleep(250);
        drawnTeamContainer.classList.remove('fade-in-out');
    }

    // --- 4. 終了処理 ---
    commentaryEl.textContent = '全ての組み合わせが決定しました！';
    await sleep(2000);
    
    await generateCaptainInterviews(teamPositions);
 // 最後に、決定した組み合わせを渡してトーナメントを生成
    document.getElementById('lottery-modal').classList.add('hidden');
    createNewTournament(false, 'summer', teamPositions); 
}

/**
 * 抽選会後の主将インタビューを生成・表示する（BGM停止機能付き・完全版）
 * @param {Array<string>} teamPositions - 抽選会で決定した最終的なチームの組み合わせ
 */
async function generateCaptainInterviews(teamPositions) {
    const interviewModal = document.getElementById('interview-modal');
    const interviewContent = document.getElementById('interview-content');
    interviewContent.innerHTML = `<div class="loader">AI記者が主将インタビューを作成中...</div>`;
    interviewModal.classList.remove('hidden');

    const matchups = [];
    for(let i=0; i<64; i+=2){
        matchups.push({team1: teamPositions[i], team2: teamPositions[i+1]});
    }

    const isStrong = (team) => ['S', 'A', 'B'].includes(calculateRank(team, {}));
    const strongMatchups = matchups.filter(m => isStrong(m.team1) && isStrong(m.team2));
    const notableMatchups = shuffleArray(strongMatchups).slice(0, 2);

    // 注目カードがない場合でも、少なくとも1カードは選ぶ
    if (notableMatchups.length === 0 && matchups.length > 0) {
        notableMatchups.push(shuffleArray(matchups)[0]);
    }

    const prompt = `あなたは高校野球専門のAI記者です。夏の大会の組み合わせ抽選会が終了しました。
以下の注目カードについて、両チームの主将になりきって、抽選結果に対する意気込みを簡潔に語ってください。

### 注目カード
${notableMatchups.map(m => `- ${m.team1} vs ${m.team2}`).join('\n')}

### 指示
- チームの背景（例：王者、古豪、ライバル）を考慮したコメントにしてください。
- 対戦相手への敬意と、自チームの闘志の両方を含めてください。
- 全ての注目カードについて、両校の主将のコメントを生成してください。

### 出力形式 (JSON配列)
[
    {"team": "〇〇高校", "captain_comment": "（主将のコメント）"},
    {"team": "△△高校", "captain_comment": "（主将のコメント）"}
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        const interviews = parseJsonFromText(result.candidates[0].content.parts[0].text);

        if (interviews && Array.isArray(interviews)) {
            interviewContent.innerHTML = interviews.map(iv => `
                <div class="p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-bold text-lg text-gray-800">${iv.team} 主将</h4>
                    <p class="mt-1 text-gray-700">「${iv.captain_comment}」</p>
                </div>
            `).join('');
        } else {
            throw new Error("Parsed JSON is not an array or is null.");
        }
    } catch (e) {
        interviewContent.innerHTML = `<p class="text-center text-red-600">インタビューの生成に失敗しました。</p>`;
        console.error(e);
    }
    
    document.getElementById('close-interview-btn').onclick = () => {
        interviewModal.classList.add('hidden');
        document.getElementById('lottery-modal').classList.add('hidden');
        SoundManager.stopBgm(); // ▼▼▼ この行を追加 ▼▼▼
        createNewTournament(false, 'summer', teamPositions);
    };
}
     
    async function initializeApp() {
  SoundManager.init(); 
 // --- 1. Preload the background image ---
    const bgContainer = document.querySelector('.ballpark-background');
    if (bgContainer) {
        const img = new Image();
        const imageUrl = 'ballpark.jpg'; // The local image path
        
        img.onload = function() {
            // Image loaded successfully, set it as the background and start the dust effect
            bgContainer.style.backgroundImage = `url(${imageUrl})`;
            createDustEffect();
        };
        img.onerror = function() {
            // If the image fails to load, log an error but still start the dust effect
            console.error('Failed to load the background image.');
            createDustEffect();
        };
        
        img.src = imageUrl; // This starts the image download
    } else {
        // If the background container doesn't exist, just start the dust effect
        createDustEffect();
    }
       
 // --- ここから診断コード ---
        try {
            alert('デバッグ開始：initializeApp関数が実行されました。');
            
            if (teamsTextarea) {
                alert('成功：チーム一覧を表示するテキストエリアが見つかりました。');
            } else {
                alert('エラー：チーム一覧を表示するテキストエリアが見つかりません！ id="teams-list" を確認してください。');
                return;
            }

            if (INITIAL_TEAM_POOL && INITIAL_TEAM_POOL.length > 0) {
                alert(`成功：${INITIAL_TEAM_POOL.length}件のチームデータが読み込まれました。`);
            } else {
                alert('エラー：チームデータが読み込めていません！ TEAM_DATAの定義を確認してください。');
                return;
            }

            teamsTextarea.value = INITIAL_TEAM_POOL.join('\n');
            alert('成功：チーム一覧をテキストエリアに表示しました。');

        } catch (e) {
            alert('致命的なエラーが発生しました： ' + e.message);
        }

        // --- ここまで診断コード ---

        
    const savedStateJSON = localStorage.getItem('tournamentState');
    if (savedStateJSON) {
        try {
            const lastState = JSON.parse(savedStateJSON);
            if (lastState && lastState.tournamentYear) {
                const confirmed = await showConfirm("前回の続きから再開しますか？\n（「いいえ」で最初から、または「合い言葉」で再開）");
                
                if (confirmed) { // 「はい」が押された場合
                    tournamentState = lastState;
                    setupEl.classList.add('hidden');
                    tournamentDisplayEl.classList.remove('hidden');
                    renderTournament(tournamentState);
                    return; 
                } else { // ▼▼▼ 「いいえ」が押された場合の処理を追加 ▼▼▼
                    // 古いセーブデータを完全に消去する
                    localStorage.removeItem('tournamentState');
                }
            }
        } catch (e) {
            console.error("保存されたデータの読み込みに失敗:", e);
            localStorage.removeItem('tournamentState'); 
        }
    }        
        setupEl.classList.remove('hidden');
        tournamentDisplayEl.classList.add('hidden');
　　　　teamsTextarea.value = INITIAL_TEAM_POOL.join('\n');

 updateTicker();
}

    // --- Event Listeners ---
    
    generateBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("新しいトーナメントを開始すると、現在の進行状況は失われます。よろしいですか？");
    if (confirmed) startLotteryEvent();
});
    resumeBtn.addEventListener('click', () => {
        saveLoadModal.classList.remove('hidden');
        loadTabBtn.click();
    });

    nextTournamentBtn.addEventListener('click', async () => {
        const confirmed = await showConfirm("現在の大会を終了し、次の大会へ進みますか？");
        if(confirmed) {
            let nextTournamentType;
            if (tournamentState.currentTournament === 'summer') nextTournamentType = 'autumn';
            else if (tournamentState.currentTournament === 'autumn') nextTournamentType = 'spring';
            else nextTournamentType = 'summer';
            createNewTournament(true, nextTournamentType);
        }
    });

    resetBtn.addEventListener('click', async () => {
        const confirmed = await showConfirm("すべての大会記録をリセットして、最初の状態に戻しますか？");
        if(confirmed){
            localStorage.clear();
            location.reload();
        }
    });

    saveBtn.addEventListener('click', () => {
        document.getElementById('save-code-area').classList.add('hidden');
        saveLoadModal.classList.remove('hidden');
        saveTabBtn.click();
    });
    
    startRankingPlayoffsBtn.addEventListener('click', async () => {
         const confirmed = await showConfirm("全ブロックの予選が終了しました。地区内順位決定戦に進みますか？");
         if(confirmed) setupAutumnRankingTournaments();
    });
    
    // startMainTournamentBtn のイベントリスナー内

startMainTournamentBtn.addEventListener('click', async () => {
    // ★★★ 春季大会用の分岐を追加 ★★★
    if (tournamentState.currentTournament === 'spring') {
        const confirmed = await showConfirm("全代表校が決定しました。県大会本戦に進みますか？");
        if (confirmed) setupSpringMainTournament_Round1();
    } 
    // ★★★ ここまで追加 ★★★
    else { // 秋季大会の既存ロジック
        const confirmed = await showConfirm("全代表校が決定しました。県大会本戦に進みますか？");
        if (confirmed) setupAutumnMainTournament();
    }
});

    skipR1Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("1回戦を自動で進行しますか？");
        if (confirmed) skipRound(1);
    });
    skipR2Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("2回戦を自動で進行しますか？");
        if (confirmed) skipRound(2);
    });
    skipR3Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("3回戦を自動で進行しますか？");
        if (confirmed) skipRound(3);
    });
    
    generateSummaryBtn.addEventListener('click', async () => {
        generateSummaryBtn.disabled = true;
        generateSummaryBtn.textContent = '記事を生成中...';
        newsContainer.innerHTML = `<div class="loader">AI記者がハイライト記事を執筆中...</div>`;
        const summaryArticle = await generateBest8PreviewArticle();
        if (summaryArticle) {
            tournamentState.news.push(summaryArticle);
            saveState();
            renderNews(tournamentState.news);
        }
        generateSummaryBtn.classList.add('hidden');
        generateSummaryBtn.disabled = false;
        generateSummaryBtn.textContent = 'ベスト8ハイライト記事を生成';
    });

document.body.addEventListener('click', async (e) => {

    // --- 試合進行ボタン (▶) ---
    if (e.target.matches('.win-btn')) {
        const teamSlot = e.target.closest('.team-slot');
        const matchEl = e.target.closest('[data-match-id]');
        if (!teamSlot || !matchEl || teamSlot.classList.contains('empty')) return;

        const matchId = matchEl.dataset.matchId;
        const winnerName = teamSlot.dataset.teamName;
        if (!winnerName) return;

        const score1El = matchEl.querySelector('[data-team-pos="1"]');
        const score2El = matchEl.querySelector('[data-team-pos="2"]');

        if(!score1El || !score2El || score1El.value === '' || score2El.value === '') {
            showAlert('スコアを入力してください。');
            return;
        }

        let dbMatch = findMatchById(matchId);
        if (dbMatch) {
            dbMatch.score1 = score1El.value;
            dbMatch.score2 = score2El.value;
            dbMatch.summary = matchEl.querySelector('.match-summary-input')?.value || '';
        }

        await processMatchWin(matchId, winnerName);
    }

    // --- 試合詳細入力ボタン ---
    else if (e.target.matches('.details-btn')) {
        openDetailsModal(e.target.dataset.matchId);
    }

    // --- 【詳細モーダル内】イニング追加ボタン ---
    else if (e.target.matches('.add-inning-btn') || e.target.matches('#add-inning-score-btn')) {
        e.preventDefault();
        addExtraInning();
    }
    
    // --- 天候ボタン ---
    else if (e.target.matches('.weather-btn')) {
        const weatherType = e.target.dataset.weather;
        setWeather(weatherType);
    }


    
    // --- まとめサイト内の記事リンクがクリックされた時の処理 ---
   // document.body.addEventListener('click', ...) 内の、まとめサイト関連の if ブロックを全てこれで置き換える

    // ▼▼▼ このブロックで、まとめサイト関連の処理を全て書き換える ▼▼▼

    // --- 「まとめサイトを見る」ボタン ---
    const showMatomeBtn = e.target.closest('#show-matome-site-btn');
    if (showMatomeBtn) {
        const modal = document.getElementById('matome-site-modal');
        const contentEl = document.getElementById('matome-site-content');
        modal.classList.remove('hidden');
        contentEl.innerHTML = `<div class="loader">最新ニュースと試合結果をまとめています...</div>`;
        
        (async () => {
            const matomeHtml = await generateMatomeSiteHtml();
            contentEl.innerHTML = matomeHtml;
        })();
    }

    // --- まとめサイトのモーダルを閉じるボタン ---
    if (e.target.closest('#matome-site-close-btn')) {
        document.getElementById('matome-site-modal').classList.add('hidden');
    }
    
    // --- まとめサイト内の記事リンククリック ---
    const matomeLink = e.target.closest('.matome-article-link');
    if (matomeLink) {
        e.preventDefault();
        const headline = matomeLink.dataset.headline;
        const type = matomeLink.dataset.type;
        const category = matomeLink.dataset.category;
        const matchId = matomeLink.dataset.matchId;

        // 新しいスレッド表示用モーダルを準備
        const threadModal = document.getElementById('bbs-thread-modal');
        const threadTitleEl = document.getElementById('bbs-thread-title');
        const threadContentEl = document.getElementById('bbs-thread-content');
        
        threadTitleEl.textContent = headline;
        threadContentEl.innerHTML = `<div class="loader">AIが掲示板の反応を生成中...</div>`;
        
        // まとめサイトを隠し、スレッドモーダルを表示
        document.getElementById('matome-site-modal').classList.add('hidden');
        threadModal.classList.remove('hidden');

        (async () => {
            let result;
            if (type === 'game' && matchId) {
                const match = findMatchById(matchId);
                if (match && match.winner) {
                    const context = {
                        winnerName: match.winner,
                        loserName: match.team1 === match.winner ? match.team2 : match.team1,
                        dbMatch: match,
                        highlightsText: createHighlightsText(match, match.winner).highlights.map(h => h.description).join('、')
                    };
                    result = await generateGameMatchBbsComments(context);
                }
            } else if (type === 'real') {
                const comments = await generateRealNewsBbsComments(headline, category);
                if (comments) {
                    result = { title: headline, comments: comments };
                }
            }

            if (result && result.comments) {
                threadTitleEl.textContent = `【スレ】${result.title}`;
                threadContentEl.innerHTML = ''; // ローダーを消す
                result.comments.forEach(comment => {
                    const commentEl = document.createElement('div');
                    commentEl.className = 'bbs-comment bg-white'; // スタイルを少し調整
                    commentEl.innerHTML = `
                        <p class="font-semibold text-gray-700 text-sm">${comment.personality}</p>
                        <p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>
                    `;
                    threadContentEl.appendChild(commentEl);
                });
            } else {
                threadContentEl.innerHTML = `<p class="text-center text-red-500">スレッドの生成に失敗しました。</p>`;
            }
        })();
    }

    // --- スレッド表示モーダルの閉じるボタン ---
    if (e.target.closest('#bbs-thread-close-btn')) {
        document.getElementById('bbs-thread-modal').classList.add('hidden');
        // まとめサイトのリストに再び表示を戻す
        document.getElementById('matome-site-modal').classList.remove('hidden');
    }
    // ▲▲▲ ここまで置き換え ▲▲▲

 // --- スキャンダル告発/無視ボタン ---
   // --- スキャンダル告発/無視ボタン ---
    const scandalBtn = e.target.closest('.report-scandal-btn, .ignore-scandal-btn');
    if (scandalBtn && tournamentState.activeScandal) {
        const { teamName, scandalId } = tournamentState.activeScandal; // teamNameをここで取得
        const scandalDef = SCANDAL_DEFINITIONS.find(s => s.id === scandalId);
        if (!scandalDef) return;

        const choice = scandalBtn.classList.contains('report-scandal-btn') ? 'report' : 'ignore';
        const consequence = scandalDef.consequences[choice];

        // 効果を適用
        consequence.applyEffect(teamName, tournamentState);

        // 結果記事を生成
        const outcomeArticle = {
            title: consequence.outcomeTitle(teamName), // ← 関数として呼び出し
            body: consequence.outcomeBody(teamName),   // ← 関数として呼び出し
            timestamp: Date.now()
        };
        
        // 噂記事をニュースリストから削除し、結果記事を追加
        tournamentState.news = tournamentState.news.filter(n => !n.isScandalRumor);
        tournamentState.news.push(outcomeArticle);
        
        // スキャンダルを解決済みにする
        tournamentState.activeScandal = null;

        renderTournament(tournamentState);
        saveState();
    }

// --- ドキュメンタリー密着取材ボタン ---
    // --- ドキュメンタリー密着取材ボタン（逆境） ---
    else if (e.target.matches('.underdog-doc-btn')) { // ← クラス名を変更
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？...`);
        if (confirmed) {
            startDocumentary('underdog', teamName); // ← type を渡すように変更
        }
    }

    // ▼▼▼ ここから追加 ▼▼▼
    // --- ドキュメンタリー密着取材ボタン（強豪） ---
    else if (e.target.matches('.powerhouse-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) {
            startDocumentary('powerhouse', teamName);
        }
    }

// ▼▼▼ ここから追加 ▼▼▼
    // --- ドキュメンタリー密着取材ボタン（古豪復活） ---
    else if (e.target.matches('.powerhouse-revival-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) {
            startDocumentary('powerhouse_revival', teamName);
        }
    }

 else if (e.target.matches('.one-man-team-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) {
            startDocumentary('one_man_team', teamName);
        }
    }

    // --- 「＋ 走者プレーを追加」ボタン ---
    else if (e.target.matches('.add-runner-play-btn')) {
        e.preventDefault();
        const container = e.target.closest('.at-bat-block').querySelector('.runner-plays-container');
        if (!container) return;

        if (container.children.length >= 3) {
            alert('一度に追加できる走者プレーは3つまでです。');
            return;
        }

        const table = e.target.closest('.batting-table');
        const playersOnField = Array.from(table.querySelectorAll('.player-name')).map(input => ({name: input.value.trim()})).filter(p => p.name);
        const nameOptions = playersOnField.map(p => `<option value="${p.name}">${p.name}</option>`).join('');

        const baserunningPlays = ['盗塁', '盗塁死', 'タッチアップ', '進塁', '生還', '走塁死', '牽制死', '挟殺プレーでアウト'];
        const bases = ['一塁へ', '二塁へ', '三塁へ', '本塁へ(生還)'];
        const playOptions = baserunningPlays.map(p => `<option value="${p}">${p}</option>`).join('');
        const baseOptions = bases.map(b => `<option value="${b}">${b}</option>`).join('');

        const newPlayHTML = `
            <div class="runner-play-input flex gap-1 items-center mt-1">
                <select class="runner-name w-1/3 text-xs p-1 border rounded"><option value="">-誰が-</option>${nameOptions}</select>
                <select class="runner-play w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-何をした-</option>${playOptions}</select>
                <select class="runner-base w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-どこへ-</option>${baseOptions}</select>
                <button class="remove-runner-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </div>
        `;
        container.insertAdjacentHTML('beforeend', newPlayHTML);
    }
    
    // --- 走者プレーの「×」削除ボタン ---
    else if (e.target.matches('.remove-runner-play-btn')) {
        e.target.closest('.runner-play-input').remove();
    }

    // --- おまかせ入力ボタン ---
    else if (e.target.matches('.quick-sim-btn')) {
        e.preventDefault();
        autoFillMatchDetails(e.target.dataset.matchId);
    }

    // --- 1イニングに複数打席を追加するボタン ---
    else if (e.target.matches('.add-at-bat-btn')) {
        e.preventDefault();
        const table = e.target.closest('.batting-table');
        const playersOnField = Array.from(table.querySelectorAll('.player-name')).map(input => ({ name: input.value.trim() })).filter(p => p.name);
        
        // 新しい空の打席ブロック（打者入力欄＋走者入力欄の正しいセット）を生成
        const newAtBatHTML = createBattingResultDropdowns(playersOnField, '');
        
        // クリックされたボタンの直前に、新しいブロックを挿入
        e.target.insertAdjacentHTML('beforebegin', newAtBatHTML);
    }

    // --- 交代選手追加ボタン ---
    else if (e.target.matches('.add-substitute-btn')) {
        e.preventDefault();
        const teamKey = e.target.dataset.teamKey;
        const tableBody = document.getElementById(`batting-table-${teamKey}`).querySelector('tbody');
        if (!tableBody) return;

        const orderInput = prompt("何番打者の交代選手を追加しますか？（例：3）");
        if (!orderInput || isNaN(orderInput) || orderInput < 1 || orderInput > 9) {
            alert("1から9の正しい打順を入力してください。");
            return;
        }
        const order = parseInt(orderInput);

        const allOrderRows = Array.from(tableBody.querySelectorAll(`tr[data-order^="${order}"]`));
        if (allOrderRows.length === 0) {
            alert(order + '番打者が見つかりません。');
            return;
        }
        const targetRow = allOrderRows[allOrderRows.length - 1];

        const newRow = document.createElement('tr');
        const subCount = allOrderRows.filter(row => row.dataset.order.includes('sub')).length + 1;
        newRow.dataset.order = `${order}-sub-${subCount}`;
        
        const numInnings = tableBody.parentElement.querySelector('thead tr').children.length - 6;
        let resultInputs = '';
        for (let j = 0; j < numInnings; j++) {
            resultInputs += `<td class="col-inning batting-result-cell align-top p-1">
                                ${createBattingResultDropdowns('')}
                                ${createRunnerInputsHTML([], '')}
                             </td>`;
        }
        
        newRow.innerHTML = `
            <td class="col-order"></td>
            <td><select class="player-number w-full bg-transparent"><option value=""></option>${Array.from({length:20},(_,i)=>`<option value="${i+1}">${i+1}</option>`).join('')}</select></td>
            <td class="pl-4"><input type="text" class="player-name" placeholder="交代選手名"></td>
            <td><select class="player-pos w-full bg-transparent"><option value=""></option>${['投', '捕', '一', '二', '三', '遊', '左', '中', '右'].map(p=>`<option value="${p}">${p}</option>`).join('')}</select></td>
            <td>
                <select class="sub-type-select w-full bg-transparent">
                    <option value="" selected>-</option><option value="PH">代打</option><option value="PR">代走</option>
                    <option value="DEF">守備</option><option value="PITCHER">投手</option>
                </select>
            </td>
            ${resultInputs}
        `;
        targetRow.parentNode.insertBefore(newRow, targetRow.nextSibling);
    }

    // --- 守備変更ボタン ---
    else if (e.target.matches('.pos-change-btn')) {
        const playerName = e.target.dataset.playerName;
        const teamKey = e.target.dataset.teamKey;
        const inning = prompt(`${playerName}選手が何回からポジションを変更しましたか？`);
        if (!inning || isNaN(inning)) return;
        const newPos = prompt(`${inning}回から、${playerName}選手の守備位置はどこになりましたか？ (例: 投, 一, 中)`);
        if (!newPos) return;

        const match = findMatchById(currentMatchIdForDetails);
        if (match) {
            if (!match.details) match.details = {};
            if (!match.details.positionChanges) match.details.positionChanges = [];
            match.details.positionChanges.push({ inning: parseInt(inning), teamKey, playerName, newPos });
            alert(`${inning}回から${playerName}選手が${newPos}を守るように記録しました。`);
        }
    }

    // --- 投手追加ボタン ---
    else if (e.target.matches('.add-row-btn')) {
        e.preventDefault();
        const tableId = e.target.dataset.tableId;
        const table = document.getElementById(tableId).querySelector('tbody');
        const newRow = table.insertRow();
        newRow.innerHTML = `
            <td><select><option value="" selected>-</option><option value="W">○</option><option value="L">●</option><option value="S">S</option><option value="H">H</option></select></td>
            <td><input type="text" value=""></td><td><input type="text" value=""></td><td><input type="number" value=""></td>
            <td><input type="number" value=""></td><td><input type="number" value=""></td><td><input type="number" value=""></td>
            <td><input type="number" value=""></td><td><input type="number" value=""></td><td><input type="number" value=""></td>
        `;
    }

    // --- 先攻後攻入れ替えボタン ---
    else if (e.target.matches('#swap-teams-btn')) {
        swapTeamDetails(e.target.dataset.matchId);
    }

    // --- チーム名クリック（ステータス表示） ---
    else if (e.target.matches('.clickable-team-name')) {
        const teamName = e.target.dataset.teamName;
        if(teamName && teamName !== 'null' && teamName !== '') {
            showTeamStatusModal(teamName);
        }
    }
    // --- 記事表示ボタン（通常記事の「本文」） ---
    else if (e.target.matches('.news-article-btn')) {
        const article = tournamentState.news[parseInt(e.target.dataset.index, 10)];
        if (article && article.body) {
            document.getElementById('modal-title').textContent = article.title;
            document.getElementById('modal-body').textContent = article.body;
            document.getElementById('modal-meta').innerHTML = `<p>${new Date(article.timestamp).toLocaleDateString('ja-JP')}</p>`;
            newsModal.classList.remove('hidden');
            newsModal.classList.add('flex');
        } else {
            alert('記事の本文データを取得できませんでした。');
        }
    }

    // --- 記事表示ボタン（新聞の「新聞を読む」） ---
    else if (e.target.matches('.newspaper-view-btn')) {
        const article = tournamentState.news[parseInt(e.target.dataset.index, 10)];
        if (article.isNewspaper && article.newspaperData) {
            renderNewspaperModal(article.newspaperData);
            newspaperModal.classList.remove('hidden');
        }
    }

 // ▼▼▼ 抜け落ちていたのは、このブロックです ▼▼▼
    // --- 掲示板の「返信する」ボタン ---
    const replyBtn = e.target.closest('.reply-btn');
    if (replyBtn) {
        e.preventDefault();
        const commentId = replyBtn.dataset.commentId;
        const formContainer = document.getElementById(`reply-form-container-${commentId}`);
        if (formContainer) {
            formContainer.classList.toggle('hidden');
        }
        return;
    }
    // ▲▲▲ ▲▲▲

// document.body.addEventListener('click', ...) の中

    
    // document.body.addEventListener('click', ...) 内の該当箇所を、以下のように修正・追記

    // ▼▼▼ 既存の「.retry-btn」の else if ブロックを、以下の内容にまるごと置き換える ▼▼▼
    // --- AI記事の再生成ボタン（エラー記事・成功記事の両方に対応） ---
    const regenerateBtn = e.target.closest('.regenerate-btn');
    if (regenerateBtn) {
        const originalIndex = parseInt(regenerateBtn.dataset.index, 10);
        const articleIndex = tournamentState.news.length - 1 - originalIndex;
        const originalArticle = tournamentState.news[articleIndex];

        if (!originalArticle || !originalArticle.context) {
            alert("この記事は再生成できません。");
            return;
        }

        // 再生成する記事の情報を一時的に保存
        articleForRegeneration = {
            index: articleIndex,
            article: originalArticle
        };

        // フィードバックモーダルを開く
        document.getElementById('feedback-include').value = '';
        document.getElementById('feedback-exclude').value = '';
        document.getElementById('feedback-modal').classList.remove('hidden');
    }
    // ▲▲▲ ここまでが置き換え部分 ▲▲▲


    // ▼▼▼ このブロックを新たに追加 ▼▼▼
    // --- フィードバックモーダルの「この指示で再生成」ボタン ---
    const feedbackSubmitBtn = e.target.closest('#feedback-submit-btn');
    if (feedbackSubmitBtn) {
        if (!articleForRegeneration) return;

        const { index, article } = articleForRegeneration;
        const context = article.context;
        
        feedbackSubmitBtn.textContent = '生成中...';
        feedbackSubmitBtn.disabled = true;

        const userFeedback = {
            include: document.getElementById('feedback-include').value,
            exclude: document.getElementById('feedback-exclude').value
        };

        // 即座にモーダルを閉じ、裏で処理を開始
        document.getElementById('feedback-modal').classList.add('hidden');
        articleForRegeneration = null;
        
        newsContainer.innerHTML = `<div class="loader">AI記者があなたの指示を基に記事を再執筆中です...</div>`;

        // 非同期で再生成処理を実行
        (async () => {
            const { winnerName, loserName, dbMatch, matchId, winnerData, loserData, winnerDetailedData, loserDetailedData } = context;
            const { highlights, keyPlayerNames } = createHighlightsText(dbMatch, winnerName);
            
            let articlePromise;
            const documentary = tournamentState.documentary;

            if (documentary.target && (documentary.target === winnerName || documentary.target === loserName)) {
                const isWin = documentary.target === winnerName;
                const matchInfo = { 
                    round: matchId.includes('-R') ? parseInt(matchId.split('-')[1].slice(1)) : 1,
                    opponent: isWin ? loserName : winnerName,
                    score: `${dbMatch.score1}-${dbMatch.score2}`,
                    highlights: highlights.map(h => h.description).join('、')
                };
                articlePromise = generateDocumentaryArticle(isWin ? 'win' : 'lose', documentary.type, documentary.target, matchInfo, userFeedback);
            } else {
                articlePromise = generateNewsArticle(
                    winnerName, loserName, dbMatch, matchId,
                    winnerData, loserData, winnerDetailedData, loserDetailedData,
                    highlights, keyPlayerNames, userFeedback
                );
            }
            
            const newArticle = await articlePromise;

            tournamentState.news.splice(index, 1);

            if (newArticle && !newArticle.error) {
                newArticle.context = context;
                const isVerified = await factCheckArticle(newArticle, highlights);
                if (isVerified) {
                    showArticleReviewModal(newArticle);
                } else {
                    // エラー処理
                }
            } else {
                // エラー処理
            }
            
            saveState();
            renderNews(tournamentState.news);
            feedbackSubmitBtn.textContent = 'この指示で再生成';
            feedbackSubmitBtn.disabled = false;
        })();
    }

    // --- フィードバックモーダルの「キャンセル」ボタン ---
    if (e.target.matches('#feedback-cancel-btn')) {
        document.getElementById('feedback-modal').classList.add('hidden');
        articleForRegeneration = null;
    }
    // ▲▲▲ ここまで追加 ▲▲▲    // ▲▲▲ ここまで追加 ▲▲▲

// ▼▼▼ ADD THE NEW BLOCK HERE ▼▼▼
    // --- BBS Comment Retry Button ---
    else if (e.target.matches('.retry-bbs-btn')) {
        const btn = e.target;
        const index = parseInt(btn.dataset.index, 10);
        const errorComment = tournamentState.bbsComments[index];
        if (!errorComment || !errorComment.context) return;

        btn.textContent = '生成中...';
        btn.disabled = true;

        const { winnerName, loserName, dbMatch, matchId, winnerData, loserData, winnerDetailedData, loserDetailedData, highlightsText } = errorComment.context;
        
        const newComments = await generateBbsComments(winnerName, loserName, dbMatch, matchId, winnerData, loserData, winnerDetailedData, loserDetailedData, highlightsText);

        if (newComments && newComments.length > 0) {
            tournamentState.bbsComments.splice(index, 1, ...newComments);
        } else {
            btn.textContent = '再生成';
            btn.disabled = false;
            alert('再生成に失敗しました。');
        }
        
        renderBbsComments(tournamentState.bbsComments);
        saveState();
    }
    // ▲▲▲ ▲▲▲

});
    
   // ==========================================================
//  2.「送信」イベントを処理するリスナー (新設)
// ==========================================================
document.body.addEventListener('submit', async (e) => {
    
    // --- 掲示板の「返信フォーム」が送信された場合 ---
    if (e.target.matches('.reply-form')) {
        e.preventDefault();
        const form = e.target;
        const parentCommentId = form.dataset.commentId;
        const bbsType = form.dataset.bbsType;
        const textarea = form.querySelector('textarea');
        const userReplyText = textarea.value;

        if (!userReplyText.trim()) return;

        form.innerHTML = `<div class="loader text-xs">AIが返信を考えています...</div>`;
        
        const commentSource = bbsType === 'general' ? tournamentState.bbsComments : tournamentState.daiyaBbsComments;
        const parentComment = findCommentById(commentSource, parentCommentId);
        const aiPersona = parentComment.personality;
        const context = { tournamentSummary: getTournamentStatusSummary() };
        
        const aiReply = await generateBbsReply(parentCommentId, userReplyText, bbsType, aiPersona, context);

        if (aiReply) {
            const freshParentComment = findCommentById(commentSource, parentCommentId);
            if (freshParentComment) {
                if (!freshParentComment.replies) {
                    freshParentComment.replies = [];
                }
                freshParentComment.replies.push(aiReply);
            }
            if (bbsType === 'general') renderBbsComments(tournamentState.bbsComments);
            else renderDaiyaBbsComments(tournamentState.daiyaBbsComments);
            saveState();
        } else {
            form.innerHTML = `<textarea class="w-full p-2 border rounded text-sm" placeholder="返信を入力..." required></textarea><button type="submit" class="mt-1 bg-blue-500 text-white px-3 py-1 text-xs rounded hover:bg-blue-600">送信</button>`;
            alert("AIが返信を生成できませんでした。");
        }
    } 
    // --- メインのコメント投稿フォームが送信された場合 ---
    else if (e.target.matches('#main-comment-form')) {
        e.preventDefault();
        const textarea = document.getElementById('main-comment-textarea');
        const userCommentText = textarea.value;
        if (!userCommentText.trim()) return;

        textarea.disabled = true;
        e.target.querySelector('button').disabled = true;
        e.target.querySelector('button').textContent = 'AIが返信中...';

        const userComment = {
            id: crypto.randomUUID(),
            personality: 'あなた',
            text: userCommentText,
            timestamp: Date.now(),
            replies: []
        };
        
        const aiReplies = await generateMultipleReplies(userCommentText);
        userComment.replies = aiReplies;

        tournamentState.bbsComments.push(userComment);
        renderBbsComments(tournamentState.bbsComments);
        saveState();

        textarea.value = '';
        textarea.disabled = false;
        e.target.querySelector('button').disabled = false;
        e.target.querySelector('button').textContent = '投稿する';
    }

}); // ★★★ 閉じカッコ } の正しい位置はここです ★★★

// --- 編集モーダルの「この記事で確定」ボタン ---
    document.getElementById('review-save-btn').addEventListener('click', () => {
        if (articleForReview) {
            // テキストボックスの現在の内容で記事データを更新
            articleForReview.title = document.getElementById('review-title').value;
            articleForReview.body = document.getElementById('review-body').value.replace(/\n/g, '\\n');
            
            // 更新した記事をニュースリストに追加
            tournamentState.news.push(articleForReview);
            renderNews(tournamentState.news);
            saveState();
            
            closeReviewModal();
        }
    });

    // --- 編集モーダルの「キャンセル」ボタン ---
    document.getElementById('review-cancel-btn').addEventListener('click', () => {
        closeReviewModal();
    });

document.body.addEventListener('input', (e) => {
        if (e.target.matches('.match-summary-input')) {
            const matchId = e.target.dataset.matchId;
            let match;
            if (tournamentState.matches[matchId]) {
                match = tournamentState.matches[matchId];
            } else {
                 const [region, bracketId] = matchId.split('-');
                 if (tournamentState.autumnData?.regions[region]) {
                    const regionData = tournamentState.autumnData.regions[region];
                    if(bracketId.startsWith('B')) match = regionData.blocks.find(b=>b.id === `${region}-${bracketId}`).matches[matchId];
                    else if(bracketId === 'CHAMP') match = regionData.champBracket.matches[matchId];
                    else if(bracketId === 'REP') match = regionData.repechageBracket.matches[matchId];
                 }
            }
            if (match) {
                match.summary = e.target.value;
                saveState();
            }
        }



// イニングスコアが入力された場合
    else if (e.target.closest('#inning-score-table')) {
        updateTotalScores();
    }


    
// ▼▼▼ THIS IS THE NEW BLOCK TO ADD ▼▼▼
    // --- When an "Inning Event" is typed in ---
    else if (e.target.matches('.inning-events-input')) {
        const teamKey = e.target.dataset.teamKey;
        const inningIndex = parseInt(e.target.dataset.inningIndex, 10);
        if (inningIndex >= 0) {
            updateInningState(teamKey, inningIndex); // Instantly update the out count
        }
    }
    // ▲▲▲ END OF ADDITION ▲▲▲
});
// ==========================================================
//  プルダウン変更イベントの監視 (change)
// ==========================================================
document.body.addEventListener('change', (e) => {
    // --- 打席結果プルダウンが変更された場合 ---
    if (e.target.matches('.batting-result-part')) {
        const cell = e.target.closest('td.batting-result-cell');
        if (!cell) return;
        
        const inningIndex = Array.from(cell.parentElement.children).indexOf(cell) - 5;
        const teamKey = e.target.closest('table.batting-table').id.includes('team1') ? 'team1' : 'team2';
        
        if (inningIndex >= 0) {
            updateInningState(teamKey, inningIndex); // 即座にアウトカウントを更新
        }
    }
});

    modalBg.addEventListener('click', () => newsModal.classList.add('hidden'));
    modalClose.addEventListener('click', () => newsModal.classList.add('hidden'));
    document.getElementById('details-save').addEventListener('click', saveDetailedStats);
    document.getElementById('details-close').addEventListener('click', () => detailsModal.classList.add('hidden'));
    saveLoadCloseBtn.addEventListener('click', () => saveLoadModal.classList.add('hidden'));
    newspaperCloseBtn.addEventListener('click', () => newspaperModal.classList.add('hidden'));
document.getElementById('status-modal-close').addEventListener('click', () => {
    document.getElementById('team-status-modal').classList.add('hidden');
});

    saveTabBtn.addEventListener('click', () => {
        saveTabBtn.classList.add('border-blue-500'); saveTabBtn.classList.remove('text-gray-500');
        loadTabBtn.classList.remove('border-blue-500'); loadTabBtn.classList.add('text-gray-500');
        saveTabContent.classList.remove('hidden'); loadTabContent.classList.add('hidden');
    });
    loadTabBtn.addEventListener('click', () => {
        loadTabBtn.classList.add('border-blue-500'); loadTabBtn.classList.remove('text-gray-500');
        saveTabBtn.classList.remove('border-blue-500'); saveTabBtn.classList.add('text-gray-500');
        loadTabContent.classList.remove('hidden'); saveTabContent.classList.add('hidden');
    });
    generateSaveCodeBtn.addEventListener('click', () => {
        const jsonString = JSON.stringify(tournamentState);
        const compressed = pako.deflate(jsonString);
        const base64 = uint8ArrayToBase64(compressed);
        document.getElementById('save-code-output').textContent = base64;
        document.getElementById('save-code-area').classList.remove('hidden');
    });
    copySaveCodeBtn.addEventListener('click', () => {
        navigator.clipboard.writeText(document.getElementById('save-code-output').textContent);
        const feedback = document.getElementById('copy-feedback');
        feedback.textContent = 'コピーしました！';
        setTimeout(() => { feedback.textContent = '' }, 2000);
    });
    loadFromCodeBtn.addEventListener('click', () => {
        try {
            const code = document.getElementById('load-code-input').value;
            const binaryString = atob(code);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) { bytes[i] = binaryString.charCodeAt(i); }
            const decompressed = pako.inflate(bytes, { to: 'string' });
            const loadedState = JSON.parse(decompressed);
            tournamentState = loadedState;
            saveState();
            location.reload();
        } catch (e) {
            showAlert('データの読み込みに失敗しました。');
        }
    });
    // アプリケーション起動
    initializeApp();
</script>
    </body>
</html>