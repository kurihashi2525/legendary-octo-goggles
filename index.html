<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【最終実装版】AI記者付きトーナメント表</title>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&family=Noto+Serif+JP:wght@700&display=swap" rel="stylesheet">
 <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Yuji+Syuku&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
/* styleタグ内の分かりやすい場所に追加 */

/* ▼▼▼ 勢力図分析アニメーション用のCSS（レイアウト修正版）▼▼▼ */
#analysis-stage {
    background: radial-gradient(ellipse at center, rgba(15, 23, 42, 1) 0%, rgba(0, 0, 0, 1) 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    padding: 2rem; /* 内側に余白を追加 */
}
.round-column {
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    height: 100%;
}
.analysis-matchup {
    margin: 10px 0;
    position: relative;
}
.analysis-team {
    padding: 4px 10px;
    background-color: rgba(0, 183, 255, 0.2);
    border: 1px solid rgba(0, 183, 255, 0.7);
    color: #e0f2fe;
    border-radius: 4px;
    font-weight: bold;
    font-size: 0.9rem;
    margin: 4px 0;
    transition: all 0.5s ease-in-out;
    opacity: 0;
    width: 150px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    /* ▼▼▼ 以下の2行を削除、またはコメントアウト ▼▼▼ */
    /* position: absolute; */
    /* ▲▲▲ */
}
.analysis-team.show {
    opacity: 1;
}
.analysis-team.highlight {
    background-color: rgba(255, 204, 0, 0.4);
    border-color: rgba(255, 204, 0, 1);
    color: white;
    transform: scale(1.1);
    box-shadow: 0 0 15px rgba(255, 204, 0, 0.7);
}

/* 勝ち上がり線のスタイル */
.matchup-connector {
    position: absolute;
    top: 50%;
    right: -20px;
    width: 20px;
    height: 2px;
    background-color: rgba(0, 183, 255, 0.5);
}
.round-connector {
    position: absolute;
    top: 25%;
    right: -30px;
    width: 2px;
    height: 50%;
    background-color: rgba(0, 183, 255, 0.5);
}
/* ▲▲▲ ここまで ▲▲▲ */

/* まとめサイトのロゴスタイル */
.matome-site-logo-container {
    position: relative;
    width: 80px; /* ロゴの幅 */
    height: 50px; /* ロゴの高さ */
    overflow: hidden;
    border-radius: 5px; /* 角を少し丸める */
    box-shadow: 0 2px 4px rgba(0,0,0,0.3); /* 影で立体感を出す */
}

.matome-site-logo-bg {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 画像をコンテナに合わせて表示 */
    position: absolute;
    top: 0;
    left: 0;
    filter: brightness(0.7) blur(1px); /* 少し暗く、ぼかして文字を読みやすく */
}

.matome-site-logo-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-weight: bold;
    font-size: 0.9rem; /* 文字サイズ調整 */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8); /* 文字の視認性を高める影 */
    white-space: nowrap; /* テキストの折り返しを防ぐ */
}

/* 新しいまとめサイトモーダルのためのスタイル */
/* スクロールバーのカスタマイズ (TailwindCSS JIT mode with plugins is better, but this is a quick fix) */
.scrollbar-thin {
    scrollbar-width: thin;
    scrollbar-color: #a0aec0 #edf2f7; /* thumb color track color */
}

.scrollbar-thin::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.scrollbar-thin::-webkit-scrollbar-thumb {
    background-color: #a0aec0; /* gray-400 */
    border-radius: 10px;
    border: 2px solid #edf2f7; /* gray-200 */
}

.scrollbar-thin::-webkit-scrollbar-track {
    background-color: #edf2f7; /* gray-200 */
    border-radius: 10px;
}

/* ヘッダーのロゴ画像とタイトルを縦方向に中央揃え */
#integrated-matome-modal .flex.justify-between.items-center img {
    vertical-align: middle;
}

/* タブボタンのアニメーション */
.matome-tab-btn {
    position: relative;
    z-index: 1;
    margin-right: -1px; /* タブ間の隙間をなくす */
    border: 1px solid #e2e8f0; /* gray-300 */
    border-bottom: none;
    background-color: #f7fafc; /* gray-50 */
}
.matome-tab-btn.active {
    background-color: #2563eb; /* blue-600 */
    color: white;
    border-color: #2563eb; /* active tab border color */
    border-bottom-color: transparent;
    z-index: 2;
}

/* 記事リンクのホバーエフェクト */
.matome-article-link p.font-bold:hover {
    color: #2563eb; /* blue-600 */
    text-decoration: underline;
}

/* BBSコメントのスタイル */
.bbs-comment {
    background-color: #ffffff;
    border: 1px solid #e2e8f0;
    padding: 1rem;
    border-radius: 0.5rem;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
}
.bbs-comment p.font-semibold {
    color: #4a5568; /* gray-700 */
    font-size: 0.875rem; /* text-sm */
    margin-bottom: 0.25rem;
}
.bbs-comment p.text-gray-800 {
    color: #2d3748; /* gray-800 */
    line-height: 1.5;
}

/* ▼▼▼ 新しいローダー用のCSS ▼▼▼ */
.loader {
    text-align: center;
    padding: 40px 20px;
    font-style: italic;
    color: #4b5563; /* gray-600 */
    font-size: 1.1rem;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 8px;
    margin: 1rem 0;
}

.loader .ellipsis span {
    opacity: 0;
    animation: pulse-ellipsis 1.4s infinite;
}
.loader .ellipsis span:nth-child(1) { animation-delay: 0s; }
.loader .ellipsis span:nth-child(2) { animation-delay: 0.2s; }
.loader .ellipsis span:nth-child(3) { animation-delay: 0.4s; }

@keyframes pulse-ellipsis {
    0% { opacity: 0.2; }
    50% { opacity: 1; }
    100% { opacity: 0.2; }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ 禍々しい雰囲気用のCSS ▼▼▼ */
.dread-mode-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(127, 29, 29, 0.5); /* 不気味な赤色のオーバーレイ */
    z-index: 199; /* 抽選会モーダルのすぐ下 */
    pointer-events: none;
    animation: fadeIn 0.5s forwards;
}

#lottery-pot.dread {
    background-color: #7f1d1d; /* red-900 */
    border-color: #fca5a5; /* red-300 */
    animation: pulse-dread 1s infinite;
}

@keyframes pulse-dread {
    0%, 100% {
        transform: scale(1.05);
        box-shadow: 0 0 15px 5px rgba(255, 100, 100, 0.7);
    }
    50% {
        transform: scale(1.1);
        box-shadow: 0 0 30px 15px rgba(255, 100, 100, 0.9);
    }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ 抽選会イベント用のCSS ▼▼▼ */
#drawn-team-container.fade-in-out {
    animation: fadeInOut 2.5s ease-in-out forwards;
}

@keyframes fadeInOut {
    0% { opacity: 0; transform: scale(0.8); }
    20%, 80% { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(0.8); }
}

.lottery-slot {
    border: 1px solid #d1d5db;
    background-color: #f3f4f6;
    padding: 4px 8px;
    font-size: 14px;
    font-weight: 500;
    border-radius: 4px;
    transition: all 0.3s ease-in-out;
}
.lottery-slot.filled {
    background-color: #fffbeb; /* amber-100 */
    border-color: #f59e0b; /* amber-500 */
    font-weight: 700;
    transform: scale(1.05);
}
.lottery-slot.highlight {
    background-color: #ef4444; /* red-500 */
    color: white;
    border-color: #b91c1c; /* red-700 */
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}
.animate-fade-in-up {
    animation: fadeInUp 0.5s ease-out forwards;
}
@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* Weather Effects */
.rain {
    position: absolute;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
}
.drop {
    position: absolute;
    bottom: 100%;
    width: 1px;
    height: 50px;
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.4));
    animation: drop 0.5s linear infinite;
}
@keyframes drop {
    to { transform: translateY(100vh); }
}

.sunshine {
    position: absolute;
    top: -50px;
    left: -50px;
    width: 100px;
    height: 100px;
    z-index: 2;
}
.sun {
    position: absolute;
    width: 100px;
    height: 100px;
    background: radial-gradient(circle, rgba(255,255,220,0.8) 0%, rgba(255,255,220,0) 60%);
    border-radius: 50%;
}
.sun-flare {
    position: absolute;
    width: 200px;
    height: 200px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    animation: flare 5s infinite;
}
@keyframes flare {
    0% { transform: scale(1); opacity: 0.1; }
    50% { transform: scale(1.2); opacity: 0.2; }
    100% { transform: scale(1); opacity: 0.1; }
}

/* Weather Control Buttons */
.weather-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.5);
    background-color: rgba(255, 255, 255, 0.2);
    font-size: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
}
.weather-btn:hover {
    background-color: rgba(255, 255, 255, 0.4);
    border-color: white;
}

/* ▼▼▼ このブロックを追加 ▼▼▼ */
        .subtitle-text {
            color: white;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
        }
        .setup-header {
            color: white !important; /* Tailwind CSSより優先させる */
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            border-bottom-color: rgba(255, 255, 255, 0.5) !important; /* 下線も白っぽくする */
        }
        /* ▲▲▲ ▲▲▲ */

/* ▼▼▼ このブロックを追加 ▼▼▼ */
     .main-title {
            font-family: 'Yuji Syuku', serif;
            font-size: 3rem; /* 少し大きくして迫力を出す */
            letter-spacing: 0.2em; /* 文字間を調整 */
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7);
            animation: fadeIn 2s ease-in-out; /* フェードインアニメーション */
        }

        .subtitle-text {
            color: white;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            animation: fadeIn 2.2s ease-in-out; /* アニメーションを追加 */
        }

        /* メインコンテンツエリアをガラスパネル風に */
        .setup-card {
            background-color: rgba(10, 10, 20, 0.65) !important; /* 半透明背景を優先 */
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px); /* 背景をぼかす（対応ブラウザのみ） */
            padding: 2.5rem !important; /* paddingを調整 */
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            animation: fadeIn 1.5s ease-in-out;
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .setup-header {
            color: white !important;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            border-bottom-color: rgba(255, 255, 255, 0.5) !important;
        }

        /* チーム一覧エリアを名簿風に */
        #teams-list {
            background-color: rgba(0, 0, 0, 0.2) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            color: #f0f0f0 !important;
            font-size: 0.9rem;
            line-height: 1.6;
            padding: 1.5rem !important;
        }

        /* ボタンエリアにアニメーションを追加 */
        #setup .mt-8 {
            animation: fadeIn 2.5s ease-in-out;
        }

        /* フェードイン用アニメーションの定義 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ このブロックを追加 ▼▼▼ */
#news-ticker-container {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    display: flex;
    align-items: center;
    z-index: 50; /* 他の要素より手前に */
    height: 30px;
    font-family: 'Noto Sans JP', sans-serif;
    border-top: 1px solid rgba(255, 255, 255, 0.3);
}
.ticker-label {
    background-color: #e53935; /* 赤色 */
    font-weight: bold;
    padding: 0 12px;
    height: 100%;
    display: flex;
    align-items: center;
    font-size: 0.9rem;
}
.ticker-content {
    flex-grow: 1;
    overflow: hidden; /* はみ出したテキストを隠す */
    padding-left: 1rem;
}
#ticker-text {
    white-space: nowrap; /* テキストを改行させない */
    /* アニメーション時間を少し長めに設定してゆっくり流す */
    animation: scroll-ticker 40s linear infinite;
}
@keyframes scroll-ticker {
    0% { transform: translateX(100%); }
    100% { transform: translateX(-100%); }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* 写実的な天候アニメーション用のスタイル */
   /* 写実的な天候アニメーション用のスタイル（★調査モード★） */
/* 背景画像 */
.ballpark-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* Layer 1 (Bottom) */
    /* ▼▼▼ This line is the only change ▼▼▼ */
    background-image: url('ballpark.jpg'); /* Use the local image */
    /* ▲▲▲ END OF CHANGE ▲▲▲ */
    background-size: cover;
    background-position: center;
    filter: blur(2px) brightness(0.7);
    animation: subtle-breathing 20s ease-in-out infinite;
}
/* 土埃のアニメーション用コンテナ */
#dust-container {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; /* クリックの邪魔をしない */
    z-index: 2; /* 階層2（中間） */
}
/* メインコンテンツのコンテナ */
#app-container {
    position: relative; /* z-indexを有効にするため */
    z-index: 3; /* 階層3（一番手前） */
}
@keyframes subtle-breathing {
    0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); }
}
.dust-particle {
    position: absolute; background-color: rgba(255, 255, 255, 0.5);
    border-radius: 50%; opacity: 0; animation: drift-up linear infinite;
}
@keyframes drift-up {
    0% { transform: translateY(100vh) translateX(var(--x-start)); opacity: 0; }
    10% { opacity: 1; } 90% { opacity: 1; }
    100% { transform: translateY(-100px) translateX(var(--x-end)); opacity: 0; }
}
/* Input field color-coding */
.result-hit { background-color: #eff6ff !important; color: #1d4ed8; } /* Blue for hits */
.result-out { background-color: #fee2e2 !important; color: #b91c1c; } /* Red for outs */
.result-on-base { background-color: #f0fdf4 !important; color: #15803d; } /* Green for walks, etc. */

.clickable-team-name {
    cursor: pointer;
    transition: color 0.2s;
}
.clickable-team-name:hover {
    color: #1d4ed8; /* blue-700 */
}
        body { 
    font-family: 'Inter', 'Noto Sans JP', sans-serif; 
}
.setup-card { 
    background-color: transparent; /* 背景を透明に */
    padding: 24px; 
    border-radius: 12px; 
    box-shadow: none; /* 影を削除 */
    margin-bottom: 24px;
}
.display-card {
    background-color: #fff; padding: 24px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); margin-bottom: 24px;
}
        #main-bracket-container { display: flex; justify-content: center; padding: 20px; font-size: 12px; overflow-x: auto; border: 1px solid #e5e7eb; background-color: #f9fafb; border-radius: 8px;}
        .bracket-half { display: flex; }
        .bracket-half.right { flex-direction: row-reverse; }
        .bracket-final { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0 10px; flex-shrink: 0; min-width: 60px; }
        .bracket-final .final-matchup { border: 2px solid #f59e0b; background-color: #fffbeb; border-radius: 6px; padding: 5px; margin-top: 10px; }
        .bracket-final .winner-box { font-weight: bold; color: #b45309; text-align: center; padding: 10px 20px; white-space: nowrap; font-size: 1.25rem; }
        .bracket-final .final-title { font-weight: 600; color: #4b5563; margin-bottom: 10px; writing-mode: vertical-rl; letter-spacing: 2px; }
        .round { display: flex; flex-direction: column; justify-content: space-around; flex-shrink: 0; width: 230px; padding: 0 10px; }
        .matchup { margin: 8px 0; position: relative; display: flex; flex-direction: column; justify-content: center; flex-grow: 1; }
        .team-slot { display: flex; align-items: center; background-color: #ffffff; border: 1px solid #e5e7eb; border-radius: 4px; margin-bottom: 4px; transition: background-color 0.3s; position: relative; }
        .team-slot:last-of-type { margin-bottom: 0; }
        .team-name { flex-grow: 1; padding: 6px 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .team-name .rank { font-weight: bold; margin-right: 4px; }
        .team-name .rank-A { color: #ef4444; }
        .team-name .rank-B { color: #f97316; }
        .team-name .rank-C { color: #eab308; }
        .team-name .rank-D { color: #3b82f6; }
        .team-name .rank-E { color: #6b7280; }
        .team-name.seed { font-weight: bold; color: #ca8a04; }
        .score-input { width: 40px; padding: 6px 4px; border-left: 1px solid #e5e7eb; text-align: center; background-color: #fff; }
        .win-btn { background-color: #d1d5db; color: #fff; border: none; padding: 6px 8px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; cursor: pointer; font-weight: bold; transition: background-color 0.2s; }
        .team-slot:not(.empty) .win-btn { background-color: #3b82f6; }
        .team-slot:not(.empty):hover .win-btn { background-color: #2563eb; }
        .team-slot.winner { background-color: #dbeafe; border-color: #93c5fd; font-weight: 600; }
        .team-slot.loser { background-color: #f3f4f6; opacity: 0.6; }
        .team-slot.empty .team-name { color: #9ca3af; }
        .team-slot.empty .score-input, .team-slot.empty .win-btn, .team-slot.empty .details-btn { display: none; }
        .matchup::after { content: ''; position: absolute; top: 50%; width: 10px; height: 2px; background-color: #cbd5e1; }
        .bracket-half.left .matchup::after { right: -10px; }
        .bracket-half.right .matchup::after { left: -10px; }
        .round.subsequent-round .matchup::before { content: ''; position: absolute; top: -8px; height: calc(100% + 16px); width: 2px; background-color: #cbd5e1; }
        .bracket-half.left .round.subsequent-round .matchup::before { right: -10px; }
        .bracket-half.right .round.subsequent-round .matchup::before { left: -10px; }
        .hidden { display: none; }
        .news-article { border-left: 4px solid #3b82f6; cursor: pointer; transition: background-color 0.2s; }
        #modal-bg { background-color: rgba(0,0,0,0.5); }
        .confirm-modal, .details-modal, .save-load-modal, .newspaper-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .confirm-modal-content, .details-modal-content, .save-load-modal-content, .newspaper-modal-content { background-color: white; padding: 24px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .details-modal-content { width: 95%; max-width: 1000px; max-height: 90vh; overflow-y: auto;}
        .save-load-modal-content { width: 95%; max-width: 500px; }
        .newspaper-modal-content { width: 95%; max-width: 800px; max-height: 95vh; overflow-y: auto; }
        .confirm-modal-content { text-align: center; }
        .loader { text-align: center; padding: 20px; font-style: italic; color: #6b7280; }
        .details-btn { background-color: #6b7280; color: white; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: auto; margin-right: 2px; }
        .details-btn:hover { background-color: #4b5563; }
        .matchup-footer { text-align: center; margin-top: 2px; display: flex; justify-content: center; align-items: center; gap: 4px;}
        .stats-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .stats-table th, .stats-table td { border: 1px solid #e5e7eb; padding: 4px 6px; text-align: center; }
        .stats-table th { background-color: #f3f4f6; }
        .stats-table input { width: 100%; border: none; text-align: center; background: transparent;}
        .stats-table input:focus { outline: 1px solid #3b82f6; }
        .modal-body-scroll { max-height: 70vh; overflow-y: auto; }
        #save-code-output { word-break: break-all; background-color: #f3f4f6; padding: 8px; border-radius: 4px; max-height: 200px; overflow-y: auto; user-select: all; }
        .bbs-comment { background-color: #ffffff; border: 1px solid #e5e7eb; padding: 8px 12px; border-radius: 8px; font-size: 14px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .match-summary-input { resize: none; height: 40px; }
        .article-error { background-color: #fee2e2; border-left: 4px solid #ef4444; color: #b91c1c; padding: 1rem; border-radius: 0.5rem; display: flex; justify-content: space-between; align-items: center; }
        .retry-btn { background-color: #ef4444; color: white; padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-weight: 600; cursor: pointer; }
        .retry-btn:hover { background-color: #dc2626; }
        .namco-news-item { cursor: pointer; transition: background-color 0.2s; }
        .namco-news-tag { background-color: #f97316; color: white; font-size: 0.75rem; padding: 2px 8px; border-radius: 9999px; margin-left: 8px; }
      
.region-map-scroll-container {
    display: flex;
    overflow-x: auto;
    padding-bottom: 16px; /* Space for the scrollbar */
    gap: 16px;
}
.region-column { 
    flex: 0 0 250px; /* Prevent cards from shrinking */
    background-color: #ffffff; 
    border: 1px solid #e5e7eb; 
    border-radius: 8px; 
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
}
.region-header { 
    padding: 12px 16px; 
    background-color: #f9fafb; 
    border-bottom: 1px solid #e5e7eb; 
}
.region-title { 
    font-weight: 700; 
    font-size: 1.1rem; 
    color: #1f2937; 
}
.region-stats { 
    font-size: 0.8rem; 
    color: #4b5563; 
    font-weight: 500;
}
.region-team-list { 
    list-style: none; 
    padding: 12px 16px; 
    margin: 0;
    flex-grow: 1; /* Allow list to fill space */
}
.region-team { 
    padding: 6px 0; 
    font-size: 0.9rem;
    border-bottom: 1px solid #f3f4f6;
}
.region-team:last-child {
    border-bottom: none;
}
.team-surviving { 
    font-weight: 500; 
    color: #1f2937; 
}
.team-eliminated { 
    color: #9ca3af; 
    text-decoration: line-through; 
}
         .scorebook-font {
            font-family: 'Yuji Syuku', serif;
        }
        .newspaper-container { font-family: 'Noto Serif JP', serif; padding: 2rem; background-color: #fdfdf8; }
        .newspaper-early { filter: grayscale(100%); border: 2px solid #333; }
        .newspaper-late { border: 2px solid #a10e25; }
        .newspaper-header { text-align: center; border-bottom: 4px double #333; padding-bottom: 0.5rem; margin-bottom: 1rem; }
        .newspaper-title { font-size: 1.2rem; font-weight: 700; }
        .newspaper-date { font-size: 0.8rem; }
        .newspaper-content { display: flex; gap: 1.5rem; }
        .newspaper-main-headline { writing-mode: vertical-rl; text-orientation: mixed; font-size: 2.5rem; font-weight: 700; letter-spacing: 0.2em; border-right: 2px solid #333; padding-right: 1rem; margin-right: 1rem; }
        .newspaper-late .newspaper-main-headline { color: #a10e25; border-right-color: #a10e25;}
        .newspaper-body-content { flex-grow: 1; }
        .newspaper-sub-headline { font-size: 1.5rem; font-weight: 700; margin-bottom: 1rem; border-bottom: 1px solid #666; padding-bottom: 0.5rem; }
        .newspaper-late .newspaper-sub-headline { color: #333; }
        .newspaper-text { font-family: 'Noto Sans JP', sans-serif; column-count: 3; column-gap: 1.5rem; text-align: justify; font-size: 0.9rem; line-height: 1.8; }
        .newspaper-early .newspaper-text { column-count: 2; }
        .newspaper-score-box { border: 2px solid #333; padding: 1rem; text-align: center; margin-top: 1rem; }
        .newspaper-score-box h3 { font-weight: 700; margin-bottom: 0.5rem; font-size: 1.1rem; }
        .newspaper-score-box .score { font-size: 2rem; font-weight: 700; }
        .newspaper-late .newspaper-score-box { background-color: #fff8f8; border-color: #a10e25; }
        .newspaper-image-placeholder { width: 100%; height: 200px; background-color: #e0e0e0; margin: 1rem 0; display: flex; align-items: center; justify-content: center; font-family: 'Noto Sans JP', sans-serif; color: #888; border: 1px dashed #aaa; }
        .rivalry-match .team-slot { border: 2px solid #ef4444 !important; background-color: #fff1f2; }
        .feud-match .team-slot { border: 2px solid #8b5cf6 !important; background-color: #f5f3ff; }
        .rivalry-match .team-slot.winner { background-color: #fecaca; }
        .feud-match .team-slot.winner { background-color: #ddd6fe; }
    
/* 詳細入力テーブル用のスタイル */
/* 詳細入力テーブル用のスタイル（最終版） */

/* ▼▼▼ アニメーション説明用のCSS ▼▼▼ */
#animation-stage {
    font-size: 0.75rem; /* 全体の文字サイズを小さめに */
    transition: background-color 0.5s ease;
}
.anim-region, .anim-block, .anim-bracket {
    border: 1px solid #ccc;
    background-color: white;
    padding: 8px;
    margin: 5px;
    border-radius: 4px;
    text-align: center;
    opacity: 0;
    transition: all 0.5s ease-in-out;
    position: relative; /* 子要素の絶対配置基準 */
}
.anim-team {
    display: inline-block;
    background-color: #e0f2fe; /* blue-100 */
    border: 1px solid #7dd3fc; /* blue-300 */
    color: #0c4a6e; /* blue-800 */
    padding: 2px 5px;
    margin: 1px;
    border-radius: 3px;
    font-weight: 500;
    opacity: 0;
    transform: scale(0.8);
    transition: all 0.3s ease-in-out;
}
.anim-team.seed {
    background-color: #fef9c3; /* yellow-100 */
    border-color: #facc15; /* yellow-400 */
    color: #713f12; /* yellow-900 */
    font-weight: bold;
}
.anim-team.winner {
    background-color: #dcfce7; /* green-100 */
    border-color: #4ade80; /* green-400 */
    color: #14532d; /* green-900 */
    font-weight: bold;
}
.anim-team.loser {
    background-color: #f1f5f9; /* slate-100 */
    border-color: #cbd5e1; /* slate-300 */
    color: #64748b; /* slate-500 */
    opacity: 0.6 !important;
    text-decoration: line-through;
}
.anim-team.show, .anim-region.show, .anim-block.show, .anim-bracket.show {
    opacity: 1;
    transform: scale(1);
}
.anim-highlight {
    box-shadow: 0 0 15px 5px rgba(251, 191, 36, 0.7); /* amber-400 */
    transform: scale(1.1) !important;
    z-index: 10;
}
.anim-arrow {
    position: absolute;
    width: 0;
    height: 0;
    border-top: 5px solid transparent;
    border-bottom: 5px solid transparent;
    opacity: 0;
    transition: opacity 0.5s ease-in-out 0.5s; /* 少し遅れて表示 */
}
.anim-arrow.right {
    border-left: 8px solid #60a5fa; /* blue-400 */
}
.anim-arrow.show {
    opacity: 1;
}

.details-table { 
    border-collapse: collapse; 
    font-size: 12px; 
    
}
/* ▼▼▼ この新しいルールを追加 ▼▼▼ */
.details-table th {
    white-space: nowrap; /* ヘッダーの文字が折り返さないようにする */
}
/* ▲▲▲ ▲▲▲ */
.details-table td { 
    border: 1px solid #e5e7eb; 
    padding: 4px; 
    text-align: center; 
    vertical-align: middle; 
}
.details-table th { background-color: #f9fafb; font-weight: 600; }
.details-table input, .details-table select { width: 100%; border: none; text-align: center; background: transparent; font-size: 12px; }
.details-table input:focus, .details-table select:focus { outline: 1px solid #3b82f6; }

/* ★列幅設定★ */
/* イニングスコアテーブル */
#inning-score-table { table-layout: auto; width: auto; } /* スコアボードは自動幅 */
#inning-score-table .col-team { min-width: 120px; text-align: left; padding-left: 8px; }
#inning-score-table .col-inning-score { width: 40px; }
#inning-score-table .col-total { width: 50px; }
#inning-score-table .col-add-inning { width: 40px; }

/* 打撃成績テーブル */
/* ★列幅設定（min-widthで最低幅を保証）★ */
.batting-table .col-order { min-width: 40px; }
.batting-table .col-number { min-width: 60px; }
.batting-table .col-player { min-width: 120px; }
.batting-table .col-pos { min-width: 100px; }
.batting-table .col-sub-type { min-width: 80px; }
.batting-table .col-inning { min-width: 300px; }  /* ←お好みの幅に調整してください */
/* ▲▲▲ ▲▲▲ */
        .add-row-btn { background-color: #e5e7eb; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-top: 4px; }

        .add-row-btn:hover { background-color: #d1d5db; }　



　 </style>
</head>
<body class="p-4 md:p-8">
     <audio id="lottery-bgm" src="./bgm.mp3" loop preload="auto"></audio>
    <div class="ballpark-background"></div>
    <div id="dust-container"></div>
 <div id="rain-container" class="rain hidden"></div>
    <div id="sun-container" class="sunshine hidden">
        <div class="sun"></div>
        <div class="sun-flare"></div>
    </div>
    <div id="app-container" class="max-w-full mx-auto">
/div>

<div id="news-ticker-container">
    <div class="ticker-label">NEWS</div>
    <div class="ticker-content">
        <p id="ticker-text"></p>
    </div>
</div>

    <div id="weather-controls" class="fixed bottom-4 right-4 z-10">
        <div class="flex gap-2 p-2 bg-black bg-opacity-20 rounded-lg">
            <button id="unmute-btn" class="weather-btn">🔇</button>
            <button class="weather-btn" data-weather="sun">☀️</button>
            <button class="weather-btn" data-weather="rain">🌧️</button>
            <button class="weather-btn" data-weather="none">💨</button>
        </div>
    </div>
        
<div id="settings-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[200]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 class="text-xl font-bold">設定</h3>
            <button id="settings-modal-close-btn" class="text-gray-400 hover:text-gray-600">&times;</button>
        </div>
        <div class="space-y-4">
            <div class="flex items-center justify-between">
                <span class="font-semibold">試合記事の自動生成</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-article-generation" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
            </div>
            <div class="flex items-center justify-between">
                <span class="font-semibold">掲示板の自動生成</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-bbs-generation" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
            </div>
        </div>
    </div>
</div>



        <div class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white main-title">AI記者付きトーナメント表</h1>
            <p id="tournament-year-display" class="mt-2 subtitle-text">（最終実装版）</p>
        </div>

        <div id="setup" class="setup-card">
             <div class="w-full">
                 <h2 class="text-xl font-semibold mb-4 border-b pb-2 setup-header">参加チーム (64チーム)</h2>
                 <textarea id="teams-list" class="w-full h-96 p-3 border border-gray-300 rounded-lg" readonly></textarea>
             </div>
             <div class="mt-8 text-center">
                 <button id="resume-btn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-green-700 shadow-md mb-4 w-full md:w-auto">
                   再開（合い言葉入力）
                 </button>
                 <button id="generate-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 shadow-md w-full md:w-auto">
                     新しいトーナメントを開始
                 </button>
　　　　　　　　<button id="help-btn" class="bg-gray-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-gray-600 shadow-md mt-4 w-full md:w-auto">
    遊び方
</button>
 <button id="show-matome-site-btn" class="bg-orange-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-orange-600 shadow-md mt-4 w-full md:w-auto">
    📰 まとめサイトを見る
    </button>            
 </div>
        </div>




        <div id="tournament-display" class="hidden">
            <div id="autumn-regional-blocks-container" class="display-card hidden"></div>
            <div id="autumn-ranking-playoffs-container" class="display-card hidden"></div>
            <button id="skip-autumn-blocks-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 shadow-md hidden">地区ブロック予選をスキップ</button>
<button id="skip-autumn-ranking-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 shadow-md hidden">地区順位決定戦をスキップ</button>
<button id="skip-autumn-main-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 shadow-md hidden">県大会本戦をスキップ</button>
<button id="skip-spring-qualifiers-btn" class="bg-teal-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-600 shadow-md hidden">春季地区予選をスキップ</button>
<button id="skip-spring-round1-btn" class="bg-teal-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-600 shadow-md hidden">春季県大会1回戦をスキップ</button>
<button id="skip-spring-main-btn" class="bg-teal-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-600 shadow-md hidden">春季県大会2回戦以降をスキップ</button>


            <div id="autumn-controls" class="text-center my-4 hidden">
                <button id="start-ranking-playoffs-btn" class="bg-purple-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-purple-700 shadow-md hidden">
                    地区内順位決定戦へ進む
                </button>
                <button id="start-main-tournament-btn" class="bg-teal-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-teal-700 shadow-md hidden">
                    県大会本戦へ進む
                </button>

            </div>

            

<div id="region-map-section" class="display-card hidden scorebook-font">
                 <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">地区別 勝ち残り状況</h2>
                 <div id="region-map-container" class="w-full"></div>
            </div>
             <div id="namco-news-section" class="hidden display-card border-2 border-orange-400">
                 <h2 class="text-xl font-bold text-orange-600 mb-3 text-center">ナムコグループからのお知らせ</h2>
                 <div id="namco-news-content" class="space-y-2"></div>
             </div>
            <div class="flex justify-between items-start mb-4">
                <div>
                    <button id="generate-summary-btn" class="hidden bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 shadow-md">
                        ここまでの大会ハイライト記事を生成
                    </button>
                    <button id="next-tournament-btn" class="hidden bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 shadow-md">
                        次の大会へ進む
                    </button>
                </div>
               <div class="ml-auto">
                    <div class="flex items-center justify-end space-x-2">
                        <button id="skip-r1-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">1回戦スキップ</button>
                        <button id="skip-r2-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">2回戦スキップ</button>
                        <button id="skip-r3-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">3回戦スキップ</button>
<button id="skip-r4-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">準々決勝スキップ</button>
<button id="skip-r5-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">準決勝スキップ</button>
<button id="skip-final-btn" class="hidden bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 shadow-md">決勝スキップ</button>

                        <span id="save-feedback" class="text-gray-600 font-bold opacity-0 transition-opacity duration-500"></span>
<button id="show-matome-site-btn" class="bg-orange-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-600 shadow-md">
    📰 まとめ
    </button>
                        

   <button id="open-settings-btn" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 shadow-md">⚙️ 設定</button>
<button id="save-btn" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-700 shadow-md">セーブ</button>
                        <button id="reset-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 shadow-md">リセット</button>
                    </div>
                    <div id="skip-loader-container" class="h-6 text-right mt-1">
                         <span id="skip-loader" class="hidden text-sm text-gray-600 font-bold">試合を進行しています...</span>
                    </div>
                </div>
            </div>
            <div id="main-bracket-wrapper" class="display-card scorebook-font">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">トーナメント表</h2>
                <div class="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4 rounded-md text-sm">
                    <p><b>PCでの表示について:</b> トーナメント表の全体が表示されない場合は、表のエリア内でマウスのホイールを回しながら <b>Shiftキー</b> を押すか、表の下に表示されるスクロールバーを直接ドラッグすることで、左右にスクロールできます。</p>
                </div>
                <div id="main-bracket-container"></div>
            </div>
            <div id="news-section" class="display-card">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">注目ニュース</h2>
                <div id="news-articles" class="space-y-4">
                    <p class="text-gray-500 text-center">まだニュースはありません。</p>
                </div>
            </div>
             <div id="daiya-bbs-section" class="hidden display-card border-4 border-green-600">
                 <h2 id="daiya-bbs-title" class="text-2xl font-bold text-green-800 mb-4 text-center">【特設】代矢東 応援掲示板</h2>
                 <div id="daiya-bbs-comments" class="space-y-3">
                     <p class="text-gray-500 text-center">まだ反応はありません。</p>
                 </div>
             </div>
             <div id="bbs-section" class="display-card">
                 <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">掲示板の反応</h2>
<div class="mb-4 p-4 border rounded-lg bg-white">
    <form id="main-comment-form">
        <textarea id="main-comment-textarea" class="w-full p-2 border rounded" rows="2" placeholder="コメントを書き込む... (例: 今日の姫川はレベチだったわ！)" required></textarea>
        <div class="text-right mt-2">
            <button type="submit" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">投稿する</button>
        </div>
    </form>
</div>
                 <div id="bbs-comments" class="space-y-3">
                     <p class="text-gray-500 text-center">まだ反応はありません。</p>
                 </div>
             </div>
        </div>
    </div>

    <div id="news-modal" class="fixed inset-0 z-50 hidden items-center justify-center">
        <div id="modal-bg" class="absolute inset-0"></div>
        <div class="relative bg-white rounded-lg shadow-xl max-w-2xl w-full m-4">
            <div class="p-6 modal-body-scroll">
                <h3 id="modal-title" class="text-2xl font-bold text-gray-900"></h3>
                <div id="modal-meta" class="text-gray-400 text-sm mt-2 flex items-center gap-4"></div>
                <p id="modal-body" class="mt-4 text-gray-600 whitespace-pre-wrap"></p>
            </div>
            <button id="modal-close" class="absolute top-3 right-3 text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    
  
<div id="integrated-matome-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 hidden items-center justify-center z-[200]">
    <div class="bg-gray-100 p-2 md:p-4 rounded-lg shadow-xl w-full max-w-7xl max-h-[95vh] flex flex-col overflow-hidden">
        
        <div class="flex justify-between items-center mb-2 px-2 md:px-0">
            <h2 class="text-2xl md:text-3xl font-extrabold text-red-700 font-sans tracking-wide">
                <img src="koshien.jpg" alt="なんJスタジアム" class="h-10 md:h-12 inline-block mr-2">
                俺たちの甲子園速報＠なんJまとめ
            </h2>
            <button id="matome-modal-close-btn" class="text-gray-400 hover:text-gray-600">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>

        <div class="flex border-b border-gray-300 bg-white shadow-sm mb-3 text-sm md:text-base sticky top-0 z-10">
            <button class="matome-tab-btn active bg-blue-600 text-white py-2 px-4 rounded-t hover:bg-blue-700 transition-colors" data-tab="top">トップ</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="blog">このブログについて</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="twitter">Twitter</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="antenna">なんJアンテナ</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="baseball-mag">BaseBall MAG</button>
            </div>

        <div id="matome-content-area" class="flex-grow overflow-y-auto bg-gray-50 p-2 md:p-4 rounded-b-lg scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200">
            
            <div id="matome-tab-top" class="matome-tab-content grid grid-cols-1 md:grid-cols-3 gap-4 active">
                
                <div class="md:col-span-2 space-y-4">
                    <div class="bg-white p-4 rounded-lg shadow-md">
                        <h3 class="text-lg font-bold text-gray-800 border-b pb-2 mb-3">🔥 本日の注目記事</h3>
                        <div id="matome-articles-container" class="space-y-2">
                            <div class="loader text-center py-8">記事を読み込んでいます...</div>
                        </div>
                    </div>

                    <div class="bg-white p-4 rounded-lg shadow-md">
                        <h3 class="text-lg font-bold text-gray-800 border-b pb-2 mb-3">✅ まとめ</h3>
                        <ul class="list-none space-y-1">
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">野球部員(14)「甲子園は興味ない」</a></li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">DeNA・ジャクソン、衝撃のスリーランホームランｗｗｗｗｗｗ</a></li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">【画像】「下着ディズニー」パスｗｗｗｗｗｗｗｗｗ</a></li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">【悲報】レンチンで簡単に旨いポテチ味付けられるライフハックがヤバイ</a></li>
                        </ul>
                    </div>
                </div>
                
                <div class="space-y-4">
                    <div class="bg-white p-2 rounded-lg shadow-md text-center">
                        <h3 class="text-md font-bold text-gray-800 border-b pb-1 mb-2">他社から乗り換えで</h3>
                        <img src="sumaho.jpg" alt="広告" class="w-full h-auto rounded">
                        <p class="text-sm text-gray-600 mt-1">人気スマホ<span class="text-xl font-bold text-red-600">500</span>円！</p>
                        <p class="text-xs text-gray-500">2025/8/31まで</p>
                    </div>

                    <div class="bg-white p-4 rounded-lg shadow-md">
                        <h3 class="text-lg font-bold text-gray-800 border-b pb-2 mb-3">💡 なんJアンテナ</h3>
                        <ul class="list-none space-y-1 text-sm">
                            <li><a href="#" class="text-gray-700 hover:text-blue-600">なんJ PRIDE: 巨人岡本和真(28) .300 40本 100打点</a></li>
                            <li><a href="#" class="text-gray-700 hover:text-blue-600">MLB NEWS: 大谷翔平、本日も二刀流で大活躍</a></li>
                            <li><a href="#" class="text-gray-700 hover:text-blue-600">まとめヒストリア: 昔のなんJスレを振り返る</a></li>
                        </ul>
                    </div>
                    
                </div>
            </div>

            <div id="matome-tab-blog" class="matome-tab-content hidden p-4 bg-white rounded-lg shadow-md">
                <h3 class="text-xl font-bold">このブログについて</h3>
                <p class="mt-2 text-gray-700">当ブログ「俺たちの甲子園速報＠なんJまとめ」は、架空の高校野球トーナメントと現実世界のなんJネタを融合させた、唯一無二のまとめサイトです。</p>
                <p class="mt-2 text-gray-700">野球に関する話題を中心に、時事ネタや芸能ニュース、学歴コンプレックスから派生する議論まで、なんJで話題になった様々なスレッドを独自の視点でまとめています。</p>
                <p class="mt-2 text-gray-700">管理人「甲子園の申し子」が、日夜巡回し、ホットな情報をお届けします。</p>
            </div>
            <div id="matome-tab-twitter" class="matome-tab-content hidden p-4 bg-white rounded-lg shadow-md">
                <h3 class="text-xl font-bold">Twitter</h3>
                <p class="mt-2 text-gray-700">@koshien_nanjのアカウントで、日々熱い実況をしています！</p>
                <div class="mt-4 bg-gray-100 p-3 rounded">
                    <p class="font-bold">なんJまとめ速報 @koshien_nanj</p>
                    <p class="text-sm mt-1">今日の試合も熱すぎる！○○高校、まさかの逆転サヨナラ勝ちｗｗｗ #高校野球 #甲子園 <span class="text-blue-500">#なんJ</span></p>
                    <p class="text-xs text-gray-500 mt-2">1時間前</p>
                </div>
                <div class="mt-4 bg-gray-100 p-3 rounded">
                    <p class="font-bold">なんJまとめ速報 @koshien_nanj</p>
                    <p class="text-sm mt-1">【悲報】ワイの応援してた高校、初戦敗退…今年はもう終わりや… <span class="text-blue-500">#甲子園の夏</span></p>
                    <p class="text-xs text-gray-500 mt-2">3時間前</p>
                </div>
            </div>
            <div id="bbs-thread-display-area" class="hidden p-4 bg-white rounded-lg shadow-md flex flex-col h-full">
                <div class="flex justify-between items-center border-b pb-3 mb-4">
                    <h3 id="bbs-thread-title" class="text-xl md:text-2xl font-bold text-gray-800"></h3>
                    <button id="bbs-thread-back-btn" class="bg-blue-500 text-white font-bold py-1 px-3 rounded hover:bg-blue-600 text-sm">
                        一覧に戻る
                    </button>
                </div>
                <div id="bbs-thread-content" class="overflow-y-auto space-y-4 flex-grow">
                    <div class="loader text-center py-8">スレッドを読み込んでいます...</div>
                </div>
                <div class="mt-4 p-3 bg-gray-50 rounded-lg border-t text-sm text-gray-600">
                    <p>コメントは、AIによる自動生成です。特定の意見や人物を意図するものではありません。</p>
                </div>
            </div>

        </div>
    </div>
</div>

  <div id="confirm-modal" class="confirm-modal hidden">
        <div class="confirm-modal-content">
            <p id="confirm-modal-text" class="mb-4 text-lg"></p>
            <button id="confirm-ok" class="bg-red-600 text-white px-6 py-2 rounded-lg mr-2">はい</button>
            <button id="confirm-cancel" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">いいえ</button>
        </div>
    </div>

    <div id="details-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="details-modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-6xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">試合詳細入力</h3>
        <div id="details-modal-body" class="overflow-y-auto space-y-6 flex-grow pr-2"> {/* pr-2 を追加してスクロールバーとの隙間を作る */}
            </div>
        
                <div class="mt-6 text-center border-t pt-4">
            <button id="details-save" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 mr-4">
                この内容で保存
            </button>
            <button id="details-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-400">
                キャンセル
            </button>
        </div>
               
    </div>
</div>
            



    
    <div id="save-load-modal" class="save-load-modal hidden">
        <div class="save-load-modal-content">
            <div class="flex border-b">
                <button id="save-tab-btn" class="px-4 py-2 font-semibold border-b-2 border-blue-500">セーブ (合い言葉の発行)</button>
                <button id="load-tab-btn" class="px-4 py-2 text-gray-500">ロード (合い言葉の入力)</button>
            </div>
            <div id="save-tab-content" class="py-4">
                <p class="text-sm mb-2">現在の進行状況を保存するための「合い言葉」を発行します。下のボタンを押してください。</p>
                <button id="generate-save-code-btn" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700">合い言葉を発行</button>
                <div id="save-code-area" class="hidden mt-4">
                    <p class="text-sm font-bold text-green-600">合い言葉が発行されました。以下をコピーして安全な場所に保管してください。</p>
                    <div class="flex items-center mt-2">
                        <div id="save-code-output" class="flex-grow text-xs"></div>
                        <button id="copy-save-code-btn" class="ml-2 bg-gray-200 px-3 py-1 rounded text-xs font-semibold hover:bg-gray-300">コピー</button>
                    </div>
                    <p id="copy-feedback" class="text-xs text-green-600 mt-1 h-4"></p>
                </div>
            </div>
            <div id="load-tab-content" class="py-4 hidden">
                <p class="text-sm mb-2">保存した「合い言葉」を以下に貼り付けてください。</p>
                <textarea id="load-code-input" placeholder="合い言葉をここに貼り付け" class="w-full h-32 p-2 border rounded mb-2"></textarea>
                <button id="load-from-code-btn" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">このデータで再開する</button>
            </div>
             <div class="mt-4 text-right">
                 <button id="save-load-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
             </div>
        </div>
    </div>

    <div id="newspaper-modal" class="newspaper-modal hidden">
        <div class="newspaper-modal-content">
            <div id="newspaper-modal-body"></div>
            <div class="mt-4 text-center">
                <button id="newspaper-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
            </div>
        </div>
    </div>


<div id="feedback-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-[150]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記者への追加指示</h3>
        <div class="space-y-4">
            <div>
                <label for="feedback-include" class="block text-sm font-medium text-gray-700">✅ この要素を必ず含めてください</label>
                <textarea id="feedback-include" rows="4" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="例：殊勲打を放った〇〇選手のコメントを中心に。&#10;例：敗れた△△高校のエースの涙にも触れてほしい。"></textarea>
            </div>
            <div>
                <label for="feedback-exclude" class="block text-sm font-medium text-gray-700">❌ この要素・展開は避けてください</label>
                <textarea id="feedback-exclude" rows="3" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="例：監督の采配ミスという論調はもういい。&#10;例：ありきたりな「全員野球」という言葉は使わないで。"></textarea>
            </div>
        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="feedback-submit-btn" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">この指示で再生成</button>
            <button id="feedback-cancel-btn" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="review-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記事の最終確認・編集</h3>
        <div class="overflow-y-auto space-y-4 flex-grow">
            <div>
                <label for="review-title" class="block text-sm font-medium text-gray-700">タイトル</label>
                <input type="text" id="review-title" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div>
                <label for="review-body" class="block text-sm font-medium text-gray-700">本文</label>
                <textarea id="review-body" rows="15" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 whitespace-pre-wrap"></textarea>
            </div>
        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="review-save-btn" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">この記事で確定</button>
            <button id="review-cancel-btn" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="lottery-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 hidden items-center justify-center z-[200] font-sans">
    <div id="lottery-content" class="bg-white rounded-lg shadow-2xl w-full max-w-6xl h-[95vh] flex flex-col p-6">
        <h2 class="text-4xl font-bold text-center mb-4 scorebook-font text-gray-800 tracking-widest">夏の高校野球 組み合わせ抽選会</h2>
        <div id="lottery-stage" class="flex-grow bg-gray-800 rounded p-4 flex gap-4 overflow-hidden relative border-4 border-gray-600">
            <div class="w-1/3 flex flex-col items-center justify-between bg-gray-200 rounded-lg shadow-inner p-4">
                <div id="lottery-pot-container" class="w-full flex flex-col items-center">
                    <p id="pot-name" class="text-2xl font-bold text-gray-700 mb-2">Aシード</p>
                    <div id="lottery-pot" class="w-48 h-48 bg-red-800 border-4 border-yellow-400 text-white flex items-center justify-center text-5xl font-bold shadow-lg rounded-full cursor-pointer transition-transform duration-200 hover:scale-105">
                        抽選
                    </div>
                </div>
                <div id="drawn-team-container" class="w-full h-32 border-4 border-dashed border-gray-400 rounded-lg flex items-center justify-center opacity-0 bg-white">
                    <p id="drawn-team" class="text-4xl font-bold text-gray-800"></p>
                </div>
            </div>
            <div id="lottery-bracket" class="w-2/3 grid grid-cols-2 gap-x-4 h-full overflow-y-auto p-2 bg-gray-100 rounded-lg shadow-inner">
                <div id="lottery-bracket-left" class="space-y-1"></div>
                <div id="lottery-bracket-right" class="space-y-1"></div>
            </div>
        </div>
        <div class="h-32 flex flex-col justify-between pt-4">
            <div id="lottery-commentary" class="h-20 text-center text-2xl font-semibold text-gray-800 bg-yellow-100 border-2 border-yellow-300 rounded p-2 flex items-center justify-center">
                <p>静岡大会 抽選会へようこそ。主将は抽選箱をクリックしてクジを引いてください。</p>
            </div>
            <div id="lottery-controls" class="text-center">
    <button id="start-lottery-btn" class="bg-blue-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-blue-700">抽選を開始</button>
    <button id="skip-lottery-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 ml-4">スキップ</button>
</div>
        </div>
    </div>
</div>

<div id="analysis-modal" class="fixed inset-0 bg-black bg-opacity-90 hidden flex flex-col items-center justify-center z-[250] p-4 font-sans">
    <div class="w-full max-w-6xl h-full flex flex-col">
        <div class="flex-shrink-0 flex justify-between items-center mb-4">
            <div id="analysis-block-tabs" class="flex space-x-1 p-1 bg-gray-800 rounded-lg">
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="A">Aブロック</button>
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="B">Bブロック</button>
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="C">Cブロック</button>
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="D">Dブロック</button>
            </div>
            <button id="analysis-modal-close-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
        </div>
        
        <div id="analysis-stage" class="flex-grow bg-gray-900 rounded-lg relative overflow-hidden">
            </div>

        <div id="analysis-narration-box" class="flex-shrink-0 h-28 mt-4 bg-gray-800 border-t-2 border-cyan-500 rounded-b-lg p-4 overflow-y-auto">
            <p id="analysis-narration-text" class="text-white text-lg leading-relaxed whitespace-pre-wrap"></p>
        </div>
    </div>
</div>

<div id="interview-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-[300]">
    <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full p-6 m-4 animate-fade-in-up">
        <h3 class="text-2xl font-bold text-gray-900 mb-4 border-b pb-2">抽選会後 主将インタビュー</h3>
        <div id="interview-content" class="space-y-4 max-h-[60vh] overflow-y-auto"></div>
        <div class="text-center mt-6">
            <button id="close-interview-btn" class="bg-blue-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-blue-700">大会を始める</button>
        </div>
    </div>
</div>

<div id="help-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記者付きトーナメント表 取扱説明書 (Ver. 秋/春対応版)</h3>
        <div class="overflow-y-auto space-y-6 flex-grow pr-4 text-gray-700">

            <div>
                <h4 class="font-bold text-lg text-blue-700 mb-2">はじめに：あなただけの高校野球史を創る</h4>
                <p class="text-sm">
                    このシミュレーターの目的は、単に試合の勝ち負けを決めることではありません。あなたの采配や入力した詳細な試合内容に基づき、AIがリアルタイムで「ニュース記事」「掲示板の反応」「まとめサイト風スレッド」、時には「密着ドキュメンタリー」を生成します。夏の甲子園、秋の新チーム、春の選抜へと続く一年間のドラマを通じて、あなただけの唯一無二の高校野球の歴史を創り上げ、その目撃者となることが、このゲームの最大の醍醐味です。
                </p>
            </div>

            <div>
                <h4 class="font-bold text-lg text-blue-700 mb-2">基本的なゲームの流れ</h4>
                <ol class="list-decimal list-inside space-y-2 text-sm">
                    <li><strong>トーナメント開始:</strong> 「新しいトーナメントを開始」ボタンでゲームを始めます。初回は夏の静岡県大会からスタートします。抽選会イベントを経て、組み合わせが決定されます。</li>
                    <li><strong>スコア入力:</strong> トーナメント表の各試合カードに、半角数字で最終スコアを入力します。</li>
                    <li><strong>勝者決定:</strong> スコア入力後、勝った方のチームの青い「▶」ボタンを押します。</li>
                    <li><strong>AIコンテンツ生成:</strong> 勝者が決まると、AIが自動で試合に関する「ニュース記事」や「掲示板の反応」を生成します。（設定でON/OFF可能）</li>
                    <li><strong>詳細入力 (任意・推奨):</strong> 試合カードの「詳細入力」ボタンから、イニングスコアや個人成績を入力すると、AIが生成する物語のリアリティと深みが格段に向上します。</li>
                    <li><strong>大会進行:</strong> 全ての試合が終了すると、優勝チームが決定します。夏の大会終了後は自動的に秋の大会へ、秋の後は春へ、春の後は次の年の夏へと進みます。</li>
                    <li><strong>セーブ＆ロード:</strong> 「セーブ」ボタンでいつでも進行状況を「合い言葉」として保存できます。「再開」ボタンから「合い言葉」を入力すれば、中断したところから再開できます。</li>
                </ol>
            </div>

            <div>
                <h4 class="font-bold text-lg text-orange-700 mb-2">【重要】一年間の大会サイクルとルール</h4>
                <p class="text-sm mb-3">
                    この世界では、高校野球の一年間（夏→秋→春）が自動で進行します。各大会には異なる目的とルールがあり、それぞれが次の大会のシード権などに影響します。
                </p>
                <div class="space-y-4">
                    <div class="p-4 border rounded-lg bg-yellow-50">
                        <h5 class="font-semibold text-gray-800">夏の大会 (甲子園への道)</h5>
                        <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                            <li>3年生にとって最後の大会。64校による一発勝負のトーナメント。</li>
                            <li>春季大会のベスト8がシード校となります。</li>
                            <li>優勝校は夏の甲子園に出場したとみなされ、AIがその全国での戦績（例: 全国ベスト8、甲子園初戦敗退など）を自動でシミュレートし、記録します。</li>
                            <li>大会前には組み合わせ抽選会イベントが発生します。</li>
                        </ul>
                    </div>

                    <div class="p-4 border rounded-lg bg-purple-50">
                        <h5 class="font-semibold text-gray-800">秋の大会 (新チーム始動・センバツへの序章)</h5>
                        <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                            <li>1,2年生の新チームで挑む最初の公式戦。</li>
                            <li>まず、東部・中部・西部・伊豆の4地区に分かれて地区予選を行います。
                                <div class="mt-2 mb-2 p-2 bg-purple-100 rounded text-xs border border-purple-300">
                                    <p class="font-semibold mb-1">地区予選の仕組み:</p>
                                    <p class="mb-1"><strong>東部・中部・西部地区 (各5枠):</strong></p>
                                    <pre class="whitespace-pre-wrap leading-tight">
[地区20チーム]
    │
    ├─▶ [ブロックA (5)] ─▶ 優勝 (県) / 準優勝 ┐
    ├─▶ [ブロックB (5)] ─▶ 優勝 (県) / 準優勝 ┤
    ├─▶ [ブロックC (5)] ─▶ 優勝 (県) / 準優勝 ┼─▶ [第5代表決定戦 (4)] ─▶ 優勝 (県)
    └─▶ [ブロックD (5)] ─▶ 優勝 (県) / 準優勝 ┘   (敗者復活)</pre>
                                    <p class="mt-1"><strong>伊豆地区 (1枠):</strong></p>
                                    <pre class="whitespace-pre-wrap leading-tight">[伊豆4チーム] ─▶ [トーナメント] ─▶ 優勝 (県)</pre>
                                </div>
                            </li>
                            <li>各地区予選を勝ち抜いた計16チームが県大会本戦 (トーナメント) に進出します。
                                <div class="mt-2 mb-2 p-2 bg-purple-100 rounded text-xs border border-purple-300">
                                    <p class="font-semibold mb-1">県大会本戦 (16チーム):</p>
                                    <pre class="whitespace-pre-wrap leading-tight">
    ┌─ 東部代表 (5) ┐
    ├─ 中部代表 (5) ┤
    ├─ 西部代表 (5) ┼─▶ [県大会 (16チームT)] ─▶ 優勝/準優勝 (センバツ有力)
    └─ 伊豆代表 (1) ┘                       └─▶ ベスト8以上 (春季シード)</pre>
                                </div>
                            </li>
                            <li>県大会の**優勝・準優勝校**は、春のセンバツ甲子園への出場権を得る可能性があります（AIが確率で判定）。</li>
                            <li>県大会ベスト8以上の成績を収めると、次の**春季大会のシード権**を獲得できます。</li>
                        </ul>
                    </div>

                    <div class="p-4 border rounded-lg bg-green-50">
                        <h5 class="font-semibold text-gray-800">春の大会 (夏のシード権獲得戦)</h5>
                        <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                            <li>夏の大会の前哨戦となる重要な大会。</li>
                            <li>秋季大会ベスト8のチームはシード校となり、県大会2回戦から登場します。</li>
                            <li>それ以外の全チームは、まず地区予選に参加し、各地区代表枠 (東5, 中5, 西5, 伊豆1) を争います。</li>
                            <li>地区予選を突破した16チームが、県大会1回戦で対戦します。</li>
                            <li>1回戦の勝者8チームが、2回戦で待つシード8チームと対戦します（計16チームによる本戦トーナメント）。</li>
                            <li>この大会で**ベスト8**以上の成績を収めると、次の**夏の大会のシード権**を獲得できます。
                                <div class="mt-2 mb-2 p-2 bg-green-100 rounded text-xs border border-green-300">
                                    <p class="font-semibold mb-1">県大会の仕組み:</p>
                                    {/* Mermaid Diagram Code Block - Requires Mermaid.js library */}
                                    <pre><code class="language-mermaid">
graph TD
    subgraph 県大会
        R1[1回戦 (予選突破16チーム)] --> |勝者8チーム| R2
        subgraph 本戦トーナメント
            S[シード8チーム (秋ベスト8)] --> R2{2回戦 (16チーム)}
            R2 --> QF{準々決勝 (ベスト8)}
            QF --> SF{準決勝 (ベスト4)}
            SF --> F{決勝}
        end
        QF --▶ |夏のシード権獲得| SumSeed(夏の大会シード権)
    end

    subgraph 地区予選
        O[シード以外のチーム] --> RegQ{地区予選}
        RegQ --> |16チーム| R1
    end

    style S fill:#f9f,stroke:#333,stroke-width:2px
    style SumSeed fill:#ccf,stroke:#333,stroke-width:2px
                                    </code></pre>
                                    <p class="mt-1 text-gray-500">(図の説明) シード校は2回戦から登場。地区予選突破組は1回戦から戦い、勝ち上がるとシード校と対戦。ベスト8以上で夏のシード権獲得。</p>
                                </div>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>

            <div>
                <h4 class="font-bold text-lg text-teal-700 mb-2">【最重要】詳細入力：物語を深化させる鍵</h4>
                <p class="text-sm mb-3">
                    試合結果のスコアだけでなく、「詳細入力」を行うことで、AIが生成する記事やコメントの質が劇的に向上し、より深みのある物語が生まれます。面倒でも、ぜひ入力してみてください。
                </p>
                <ul class="list-disc list-inside space-y-2 text-sm bg-teal-50 p-4 rounded-lg">
                    <li><strong>イニングスコア:</strong> 試合展開をAIに伝えます。「初回に大量得点した試合」と「9回に逆転サヨナラした試合」では、生成される記事のドラマ性が全く異なります。延長戦は「+回」ボタンで追加できます。</li>
                    <li><strong>打撃成績:</strong>
                        <ul class="list-circle list-inside ml-4 text-xs">
                            <li>**打席結果:** プルダウンから結果・方向・打点などを選択します。1イニングに複数打席あった場合は「+2打席目を追加」で入力できます。</li>
                            <li>**走塁:** 「+走者プレーを追加」で盗塁、進塁、走塁死などを入力できます。</li>
                            <li>**出場:** 代打・代走・守備交代などの情報は、交代選手の活躍を描写する上で重要です。</li>
                            <li>AIはここでの入力に基づき、その試合のヒーローを特定し、記事の中心人物として描写します。</li>
                        </ul>
                    </li>
                    <li><strong>投手成績:</strong> 投手名、投球回、失点、奪三振などを入力します。先発完投、リリーフ成功、炎上など、投手の活躍や苦闘が記事に反映されます。「+投手を追加」で継投も記録できます。</li>
                    <li><strong>試合の決め手 (トーナメント表のテキストエリア):</strong> スコア入力欄の下にある小さなテキストエリアです。ここに**最も伝えたい試合のハイライト**（例：「エース〇〇、気迫の150球完投勝利」「伏兵△△のサヨナラ打」など）を簡潔に入力すると、AIは他のどの情報よりもこれを**最優先**し、記事全体のテーマとして扱います。</li>
                </ul>
                <p class="text-xs mt-2 text-gray-600">※詳細入力画面の「先攻・後攻を入れ替え」ボタンで、入力内容ごとチームを入れ替えられます。</p>
                <p class="text-xs mt-1 text-gray-600">※スコア入力欄の横にある「🎲」ボタンで、現在のスコアに基づいてAIがおまかせで詳細内容を自動生成することも可能です。</p>
            </div>

            <div>
                <h4 class="font-bold text-lg text-indigo-700 mb-2">AIが生成するコンテンツ</h4>
                <ul class="list-disc list-inside space-y-2 text-sm">
                    <li><strong>ニュース記事:</strong> 試合結果や大会の展望、時にはスキャンダル疑惑(!)など、様々な記事が自動生成されます。「本文」ボタンで内容を読めます。記事にカーソルを合わせると表示される「再生成」ボタンから、AIに追加指示を与えて記事を書き直させることも可能です（フィードバック機能）。</li>
                    <li><strong>掲示板の反応:</strong> AIが匿名掲示板のファンになりきり、試合結果やニュースに対してリアルなコメントを生成します。あなたもコメントを投稿でき、AIファンがそれに返信してくれます。</li>
                    <li><strong>まとめサイト風スレッド:</strong> 「📰 まとめ」ボタンからアクセスできるモーダル内で、現実のニュースとゲーム内の試合結果が混在した、なんJまとめサイト風の表示が楽しめます。各記事をクリックすると、その話題に関するAI生成の掲示板スレッドを読むことができます。</li>
                    <li><strong>ナムコグループニュース:</strong> 系列校（765総合、283学園など）の試合結果や組み合わせに関する、企業公式発表風のお知らせが表示されることがあります。</li>
                    <li><strong>スポーツ新聞:</strong> 大会が進むと（準々決勝以降）、AIがその日のハイライトを一面記事にしたスポーツ新聞風のコンテンツを生成することがあります。「新聞を読む」ボタンで表示できます。</li>
                    <li><strong>密着ドキュメンタリー:</strong> 特定のチーム（強豪、古豪、逆境校など）に焦点を当てたドキュメンタリー記事が生成されることがあります。試合の勝敗に応じて連載形式で物語が進行します。</li>
                </ul>
            </div>

             <div>
                <h4 class="font-bold text-lg text-pink-700 mb-2">その他の機能</h4>
                <ul class="list-disc list-inside space-y-2 text-sm">
                    <li><strong>チームステータス:</strong> トーナメント表のチーム名をクリックすると、そのチームの過去の最高成績や直近の成績、獲得した称号（例：ジャイアントキラー）などを確認できます。</li>
                    <li><strong>スキップ機能:</strong> 各大会やラウンドごとに用意された「スキップ」ボタンを使うと、試合結果を自動で（ランク差などを考慮して）生成し、大会を高速で進行させることができます。</li>
                    <li><strong>設定:</strong> 画面右上の「⚙️ 設定」ボタンから、ニュース記事や掲示板コメントの自動生成をON/OFFできます。</li>
                    <li><strong>抽選会/勢力図分析:</strong> 夏の大会開始時には抽選会イベントが、抽選後には各ブロックの勢力図をAIが分析・解説するアニメーションが表示されます。</li>
                 </ul>
            </div>

            <div>
                <h4 class="font-bold text-lg text-red-700 mb-2">トラブルシューティング</h4>
                <ul class="list-disc list-inside space-y-2 text-sm">
                    <li><strong>エラーで動作がおかしくなった / クラッシュする:</strong> 最も多い原因は、ブラウザに保存されている古いセーブデータと、最新版のゲームコードの間で矛盾が生じていることです。**「リセット」ボタンを押して一度完全にデータを消去してから**「新しいトーナメントを開始」すると解決することがほとんどです。開発中の仕様変更後は特にリセットをお試しください。</li>
                    <li><strong>AIの記事やコメントがおかしい / 事実と違う:</strong> AIに与える情報が不足しているか、AIが稀に勘違いをしている可能性があります。
                        <ul class="list-circle list-inside ml-4 text-xs">
                            <li>記事の場合は、「再生成」ボタンからフィードバックを与えてみてください。</li>
                            <li>思ったような記事にならない場合、詳細入力でより多くの情報（特に敗れたチームの成績や、活躍した選手名）を具体的に入力したり、「試合の決め手」欄を活用したりすると改善されることがあります。</li>
                        </ul>
                    </li>
                     <li><strong>セーブデータ（合い言葉）が読み込めない:</strong> コードが更新されると、古いバージョンの合い言葉は読み込めなくなる場合があります。ご了承ください。</li>
                </ul>
            </div>

       </div> <div id="tournament-animation-section" class="mt-6 border-t pt-4">

                <h4 class="font-bold text-lg text-purple-700 mb-3 text-center">図解アニメーションで見る大会システム</h4>

                <div class="flex justify-center space-x-4 mb-4">

                    <button id="show-autumn-anim-btn" class="bg-purple-500 text-white px-4 py-2 rounded hover:bg-purple-600">🍂 秋季大会を見る</button>

                    <button id="show-spring-anim-btn" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">🌸 春季大会を見る</button>

                </div>

                <div id="animation-stage" class="bg-gray-100 p-4 rounded min-h-[300px] border relative overflow-hidden flex flex-col justify-center items-center">

                    <p id="anim-placeholder" class="text-gray-500">上のボタンを押してアニメーションを開始</p>

                </div>

                <p id="animation-narration" class="mt-3 text-center text-sm font-semibold h-10"></p>

                <div class="flex justify-center space-x-4 mt-3">

                    <button id="prev-step-btn" class="bg-gray-400 text-white px-4 py-1 rounded hover:bg-gray-500 disabled:opacity-50" disabled>＜ 前へ</button>

                    <button id="next-step-btn" class="bg-blue-500 text-white px-4 py-1 rounded hover:bg-blue-600 disabled:opacity-50" disabled>次へ ＞</button>

                </div>

            </div>

            </div> <div class="mt-6 text-center border-t pt-4">

            <button id="help-modal-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>

        </div>

    </div> </div>

<div id="team-status-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 id="status-modal-team-name" class="text-2xl font-bold text-gray-800"></h3>
            <button id="status-modal-close" class="text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        <div class="space-y-4">
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">最高戦績</h4>
                <p id="status-modal-best" class="text-lg text-amber-600 font-bold"></p>
            </div>
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">直近の成績</h4>
                <div id="status-modal-history" class="space-y-1 text-gray-700"></div>
            </div>
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">称号</h4>
                <div id="status-modal-traits" class="flex flex-wrap gap-2"></div>
            </div>
            
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">監督</h4>
                <div id="status-modal-coach" class="text-gray-700"></div>
            </div>
            </div>
    </div>
</div>
<script type="module">

const BATTING_RESULTS = {
    hits: ['安', '二塁打', '三塁打', '本塁打'],
    outs: ['三振', 'ゴロ', '飛', '直', '併殺'],
    walks: ['四球', '死球'],
    sacrifices: ['犠打', '犠飛', '犠失'], // ← ここに追加
    other: ['野選', 'エラー']
};
const DIRECTIONS = ['投', '捕', '一', '二', '三', '遊', '左', '中', '右'];
const RBIS = ['1点', '2点', '3点', '4点'];

    // --- ライバル関係と称号の定義 ---
    const RIVALRIES = [
        { teams: ["代矢東", "雷門南"], type: "公立の覇権争い" },
        { teams: ["283学園", "稲城実業"], type: "私立の王者対決" },
        { teams: ["765総合高校", "代矢東"], type: "新旧王者対決" },
        { teams: ["青道", "稲城実業"], type: "西東京ライバル対決" }
    ];
    const TITLES = {
        GIANT_KILLER: { id: 'giant_killer', name: 'ジャイアントキラー', desc: '格上の強豪校を倒した実績を持つ。' },
        REPECHAGE_KING: { id: 'repechage_king', name: '不屈の敗者復活組', desc: '敗者復活戦から這い上がってきた実績があり、非常に粘り強い。' },
        WALL_OF_TOKYO: { id: 'wall_of_tokyo', name: '西東京の壁', desc: '西東京地区に立ちはだかる絶対的強者。' } // 例
    };
const tournamentNameMap = { summer: '夏季大会', autumn: '秋季大会', spring: '春季大会' };

// ▼▼▼ このブロックをまるごと置き換える ▼▼▼
const SCANDAL_DEFINITIONS = [
    {
        id: 'overpractice',
        condition: (teamName) => ['A', 'B'].includes(calculateRank(teamName, tournamentState)),
        
        // 文字列から関数に変更
        rumorTitle: (teamName) => `【週刊熱闘】${teamName}に「違法練習」疑惑か？`,
        rumorBody: (teamName) => `強豪として知られる${teamName}だが、その強さの裏には、高校野球連盟が定める練習時間規定を大幅に超過するほどの猛練習があるというタレコミが本誌に寄せられた。深夜までバットの音が鳴り響くという近隣住民の証言もあり、今後の動向が注目される。`,
        
        consequences: {
            report: {
                // こちらも同様に関数に変更
                outcomeTitle: (teamName) => `【速報】${teamName}、練習規定違反で公式戦を辞退`,
                outcomeBody: (teamName) => `先日、週刊誌で報じられた${teamName}の練習時間規定違反問題で、高野連は調査の結果、違反の事実を認定。同校は事態を重く受け止め、今大会の残り試合を辞退することを発表した。`,
                applyEffect: (teamName, state) => {
        if (state.teamRecords[teamName]) {
            state.teamRecords[teamName].penalty = 'forfeit';
        }

        const currentMatch = findCurrentMatchForTeam(teamName, state);
        if (!currentMatch) return; // 該当する試合がなければ何もしない

        const opponent = currentMatch.team1 === teamName ? currentMatch.team2 : currentMatch.team1;

        // 相手がいない場合（シードなど）は、単に負け扱いにする
        if (!opponent) {
            currentMatch.winner = `(不戦敗)`;
            currentMatch.team1 = teamName;
            currentMatch.team2 = null;
            return;
        }

        // 不戦勝として試合結果を記録
        currentMatch.winner = opponent;
        currentMatch.summary = `${teamName}の不祥事による不戦勝`;

        if (currentMatch.team1 === opponent) {
            currentMatch.score1 = 'W'; // Win
            currentMatch.score2 = 'L'; // Lose
        } else {
            currentMatch.score1 = 'L';
            currentMatch.score2 = 'W';
        }

        // チーム記録を更新
        if(state.teamRecords[opponent]) state.teamRecords[opponent].wins++;
        if(state.teamRecords[teamName]) state.teamRecords[teamName].losses++;
        
        // 勝者を次のラウンドへ自動で進める
        advanceWinnerToNextRound(currentMatch, opponent, state);
    }
            },
            ignore: {
                outcomeTitle: (teamName) => `${teamName}の練習問題、高野連は「事実確認できず」`,
                outcomeBody: (teamName) => `先日、一部週刊誌で報じられた${teamName}の練習時間に関する疑惑に対し、高野連は「現時点で違反の事実は確認できなかった」と発表。噂は噂のまま、球児たちの夏は続く。`,
                applyEffect: (teamName, state) => { /* 何もしない */ }
            }
        }
    }
];
// ▲▲▲ ここまで置き換え ▲▲▲
    // --- DOM Elements ---
    const setupEl = document.getElementById('setup');
    const tournamentDisplayEl = document.getElementById('tournament-display');
    const teamsTextarea = document.getElementById('teams-list');
    const generateBtn = document.getElementById('generate-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const resetBtn = document.getElementById('reset-btn');
    const nextTournamentBtn = document.getElementById('next-tournament-btn');
    const saveBtn = document.getElementById('save-btn');
    const mainBracketContainer = document.getElementById('main-bracket-container');
    const mainBracketWrapper = document.getElementById('main-bracket-wrapper');
    const newsContainer = document.getElementById('news-articles');
    const bbsCommentsContainer = document.getElementById('bbs-comments');
    const daiyaBbsSection = document.getElementById('daiya-bbs-section');
    const daiyaBbsCommentsContainer = document.getElementById('daiya-bbs-comments');
    const namcoNewsSection = document.getElementById('namco-news-section');
    const namcoNewsContent = document.getElementById('namco-news-content');
    const tournamentYearDisplay = document.getElementById('tournament-year-display');
    const generateSummaryBtn = document.getElementById('generate-summary-btn');
    const skipR1Btn = document.getElementById('skip-r1-btn');
    const skipR2Btn = document.getElementById('skip-r2-btn');
    const skipR3Btn = document.getElementById('skip-r3-btn');

    const skipLoader = document.getElementById('skip-loader');
const skipR4Btn = document.getElementById('skip-r4-btn');
const skipR5Btn = document.getElementById('skip-r5-btn');
const skipFinalBtn = document.getElementById('skip-final-btn');
    // Autumn Tournament UI
    const autumnRegionalContainer = document.getElementById('autumn-regional-blocks-container');
    const autumnRankingContainer = document.getElementById('autumn-ranking-playoffs-container');
    const autumnControls = document.getElementById('autumn-controls');
    const startRankingPlayoffsBtn = document.getElementById('start-ranking-playoffs-btn');
    const startMainTournamentBtn = document.getElementById('start-main-tournament-btn');
// ▼▼▼ ここから3行追加 ▼▼▼
const skipAutumnBlocksBtn = document.getElementById('skip-autumn-blocks-btn');
const skipAutumnRankingBtn = document.getElementById('skip-autumn-ranking-btn');
const skipAutumnMainBtn = document.getElementById('skip-autumn-main-btn');
// ▲▲▲ ここまで追加 ▲▲▲
// ▼▼▼ ここから3行追加 ▼▼▼
const skipSpringQualifiersBtn = document.getElementById('skip-spring-qualifiers-btn');
const skipSpringRound1Btn = document.getElementById('skip-spring-round1-btn');
const skipSpringMainBtn = document.getElementById('skip-spring-main-btn');
// ▲▲▲ ここまで追加 ▲▲▲
    // Modals
    const newsModal = document.getElementById('news-modal');
    const modalBg = document.getElementById('modal-bg');
    const modalClose = document.getElementById('modal-close');
    const confirmModal = document.getElementById('confirm-modal');
    const detailsModal = document.getElementById('details-modal');
    const saveLoadModal = document.getElementById('save-load-modal');
    const saveTabBtn = document.getElementById('save-tab-btn');
    const loadTabBtn = document.getElementById('load-tab-btn');
    const saveTabContent = document.getElementById('save-tab-content');
    const loadTabContent = document.getElementById('load-tab-content');
    const generateSaveCodeBtn = document.getElementById('generate-save-code-btn');
    const loadFromCodeBtn = document.getElementById('load-from-code-btn');
    const saveLoadCloseBtn = document.getElementById('save-load-close');
    const copySaveCodeBtn = document.getElementById('copy-save-code-btn');
    const newspaperModal = document.getElementById('newspaper-modal');
    const newspaperModalBody = document.getElementById('newspaper-modal-body');
    const newspaperCloseBtn = document.getElementById('newspaper-close');

    
    // --- State Management ---
    let tournamentState = {};
    let currentMatchIdForDetails = null;
    let articleForRegeneration = null; 
    let soundEffects = {};
let currentBlock = 'A';
    const UNDERDOG_TEAMS = ["虎府島総合", "浜松特支", "川根", "伊豆総合", "湖西", "小山", "新居", "熱海", "伊豆中央", "島田", "島田工業", "裾野"];
    const POWERHOUSE_TEAMS = ["283学園", "常葉菊川", "静岡", "掛川西", "静岡商業", "聖隷クリストファー", "765総合高校"];
　　const POWERHOUSE_REVIVAL_TEAMS = ["浜松商業", "静清", "飛龍"];
　　const ONE_MAN_TEAMS = ["富士宮北"];

// ▼▼▼ このオブジェクトで、既存のSoundManagerを完全に置き換えてください ▼▼▼
// ▼▼▼ サウンド管理システム ▼▼▼
// ▼▼▼ サウンド管理システム（ローカルファイル対応・最終完成版）▼▼▼
// ▼▼▼ BGM管理に特化した新しいサウンドマネージャー ▼▼▼
// ▼▼▼ BGMの音量調整機能付きサウンドマネージャー ▼▼▼
const SoundManager = {
    bgm: null,
    isReady: false,
    volume: 0.07, // BGMの音量を設定 (0.0がミュート, 1.0が最大)

    init() {
        this.bgm = document.getElementById('lottery-bgm');
        
        const unlockAudio = () => {
            if (!this.isReady && this.bgm) {
                this.isReady = true;
                this.bgm.volume = this.volume; // 初期音量を設定
                this.bgm.play().catch(e => console.error("BGM unlock failed:", e));
                this.bgm.pause();
                console.log("BGM ready.");
            }
            document.body.removeEventListener('click', unlockAudio);
        };
        
        document.body.addEventListener('click', unlockAudio, { once: true });
    },

    startBgm() {
        if (this.isReady && this.bgm) {
            this.bgm.volume = this.volume; // 再生前に音量を設定
            this.bgm.currentTime = 0;
            this.bgm.play().catch(e => console.error("BGM play failed:", e));
        }
    },

    stopBgm() {
        if (this.bgm) {
            this.bgm.pause();
            this.bgm.currentTime = 0;
        }
    }
};
// ▲▲▲
// ▲▲▲
// ▲▲▲ ▲▲▲
// ▲▲▲

    // ▼▼▼ 100種類の日本の苗字リスト ▼▼▼
const JAPANESE_SURNAMES = [
    "佐藤", "鈴木", "高橋", "田中", "伊藤", "渡辺", "山本", "中村", "小林", "加藤",
    "吉田", "山田", "佐々木", "山口", "松本", "井上", "木村", "林", "斎藤", "清水",
    "山崎", "森", "池田", "橋本", "阿部", "石川", "山下", "中島", "石井", "小川",
    "前田", "岡田", "長谷川", "藤田", "後藤", "村上", "近藤", "坂本", "遠藤", "青木",
    "藤井", "西村", "三浦", "岡本", "松田", "中川", "中野", "原田", "小野", "田村",
    "竹内", "金子", "和田", "中山", "石田", "上田", "森田", "原", "柴田", "酒井",
    "工藤", "横山", "宮崎", "宮本", "内田", "高木", "安藤", "谷口", "大野", "丸山",
    "今井", "高田", "藤原", "武田", "松井", "杉山", "村田", "大塚", "千葉", "岩崎",
    "桜井", "野口", "松尾", "菊地", "野村", "新井", "渡部", "佐野", "安田", "宮田",
    "小島", "大西", "杉本", "市川", "古川", "久保", "川崎", "飯田", "中田", "堀"
];

// ▼▼▼ サウンド管理システム ▼▼▼

// ▲▲▲

// --- Team Master Data ---
    const TEAM_DATA = {
    "天竜": {
        name_yomi: "てんりゅう",
        region: "西部",
        type: "公立",
        deviation: 38,
        best: "県大会ベスト16",
        last: "県大会ベスト16",
        info: "創部3年目にしてベスト16入りを果たした期待の新興勢力。新任の志賀監督の下、挑戦者としてのびのびとプレーした昨年とは一転、今年は他校からのマークも厳しくなる。昨年の躍進がフロックでなかったことを証明できるか、真価が問われる夏となる。西部地域の学校からの甲子園での成績が乏しいため、突如現れた彗星に期待の声も多い。エースの三橋やリードオフマンの田島を筆頭に部員数は少ないながらも力のある選手も多い。チームとしての目標は昨年を超えるベスト8ではなく甲子園出場。西部地域の雄となるために、まずは今年、どこまで上位勢に食らいつけるかが正念場である。。",
        coach: { name: '志賀 剛', style: '育成上手', experience: '新任' }
    },
    "桐陽": {
        name_yomi: "とうよう",
        region: "東部",
        type: "私立",
        deviation: 80,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "元プロの元木監督を招聘し、強化に乗り出した新興私立。プロ流の厳しい練習はチーム内に軋轢も生んでいるが、個々の能力は飛躍的に向上しており、140km以上を計測する選手が6人もいるなど、そのポテンシャルは計り知れない。監督の指導方針がチームとして完全に噛み合った時、一気に大会の主役へ躍り出る可能性を秘めている。",
        coach: { name: '元木 大介', style: '積極打撃', experience: 'プロOB' }
    },
    "浜松商業": {
        name_yomi: "はままつしょうぎょう",
        region: "西部",
        type: "公立",
        deviation: 32,
        best: "甲子園優勝",
        last: "県大会2回戦",
        info: "30年前の甲子園優勝校として野球ファンの間では知名度のある高校。近年はナムコグループや新興私立の台頭により低迷しており、昔のような圧倒的な強さはないが、今もなお中堅レベルの実力校として虎視眈々と聖地を狙っている。輝かしい栄光を取り戻すべく、今大会での躍進に期待したいい。",
        coach: { name: '伊武 雅之', style: 'データ野球', experience: 'ベテラン' }
    },
    "初星学園": {
        name_yomi: "はつぼしがくえん",
        region: "中部",
        type: "私立",
        deviation: 98,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "全国で唯一アイドル科を持つ学校として知られている創立3年目のナムコグループ系列校。全国からアイドル科目当てに受験する人も多く、学校としての注目度も高い。男女比では学校の特色も相まって驚異の8割が女子である。創部3年目の野球部としての設備はナムコグループ系列ということもあり整っており、直近の練習試合ではホームランも複数飛び出すなど、選手のポテンシャルも低くはない。練習ではアイドル科の生徒との合同トレーニングを組むこともあり、違う学科であれど、お互いアスリートの視点でアドバイスを送りあうなど学校の特色を活かした練習メニューもある。野球部で目立った実績はないが、アイドル科ではなく「野球の初星」と呼ばれるように躍進してほしい",
        coach: { name: '石川 実', style: '育成上手', experience: '中堅' }
    },
    "浜松特支": {
        name_yomi: "はままつとくし",
        region: "中部",
        type: "公立",
        deviation: 45,
        best: "なし",
        last: "なし",
        info: "創部一年目、全員1年生。県内初の試みとして、特別支援学校に設立された野球部。視覚障害、聴覚障害、知的障害、肢体不自由、病弱・身体虚弱の子どもを対象とした特別支援学校は、全国におよそ1100校ある。その中で高野連に加盟し、単独チームとして公式戦に出場しているのは、この浜松特別支援学校だけだ。部員たちは、野球のルールを覚えることや、仲間と声を掛け合うこと、その一つ一つが大きな挑戦だ。北村監督は、野球の技術以前に、彼らが野球というスポーツを心から楽しみ、自分を表現する喜びを知ってもらうにはどうすれば良いのか、答えのない問いに日々向き合っている。しかし、春の練習試合で今大会第一シードの283学園との招待試合で喫した『52-0』の大敗は、彼らから野球の楽しさを根こそぎ奪い去った。部室代わりの理科準備室には、彼らの野球ノートが置かれており、中を見ると「たのしくない」「こわい」といった文面が多く見受けられた。エラーをすれば下を向いて泣き出し、打席ではデッドボールを怖がって腰が引ける。そして、なにより知的障害を持った子が硬式野球を行うことについての安全性を問われる声が多々あった。北村監督は勝利ではなく『試合を成立させること』の絶望的な難しさに直面している。夏の目標は9回を戦い抜き、スコアボードに『0』以外の数字を灯すこと。それは甲子園出場よりも遥かに高く、そして切実な壁だ。",
        coach: { name: '北村 大輔', style: '全員野球', experience: '新任' }
    },
    "765総合高校": {
        name_yomi: "なむこそうごう",
        region: "中部",
        type: "私立",
        deviation: 75,
        best: "甲子園ベスト16",
        last: "県大会2回戦",
        info: "大手ナムコグループが母体となる、県内屈指の資金力と設備を誇る私立校。黒井監督の徹底した管理野球の下、個々の能力が高く、大崩れしない安定した戦いぶりが特徴。２年前には甲子園初出場も果たし、破竹の勢いでベスト16まで勝ち進み、一躍有名校となったのは記憶に新しいだろう。しかし昨年の夏は２回戦敗退、秋は初戦敗退、春も初戦敗退と苦しい時期が続いている。聖地を知るメンバーは今の3年生のみとなった今、逆襲を誓い再び甲子園を目指す。ノーシードではあるがその実力はシード校級であり今大会のダークホースと言っても過言ではないだろう",
        popularity: true,
        coach: { name: '黒井 崇男', style: '総合力', experience: 'ベテラン' }
    },
    "川根": {
        name_yomi: "かわね",
        region: "中部",
        type: "公立",
        deviation: 53,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "今年度限りでの閉校が決まっており、野球部にとってはこれが最後の夏となる。グラウンド脇では校舎の解体作業が進むという異例の環境だが、選手たちは動揺を見せず練習に打ち込む。監督・選手ともに大会終了後はそれぞれ別の道を歩むことになる。「母校の名を刻みたい」という想いは一つ。有終の美を飾るべく、チームの士気は非常に高い。",
        coach: { name: '鈴木 誠', style: '堅実', experience: 'ベテラン' }
    },
    "283学園": {
        name_yomi: "つばさがくえん",
        region: "西部",
        type: "私立",
        deviation: 60,
        best: "甲子園1回戦",
        last: "県優勝(甲子園初戦敗退)",
        info: "昨年度の県大会王者。エース白瀬、二刀流の姫川や十王、花海咲など１年次からのレギュラーメンバーを軸に投打のバランスが取れた強豪校。。しかし、初出場となった昨年の夏の甲子園では初戦の浦和学院戦に7-9で敗戦し涙を飲み、全国の壁を痛感した。新チームになってからは樋口や花海佑などの新戦力も台頭し、春の大会では圧倒的な戦いで優勝し、第１シードに君臨。名将・天井監督は、昨年の経験を糧に、県内連覇とその先の「全国での一勝」を見据える。王者としてのプレッシャーをはねのけ、再び頂点に立てるか注目が集まる。",
        popularity: true,
        coach: { name: '天井 努', style: 'ID野球', experience: '名将' }
    },
    "島田工業": {
        name_yomi: "しまだこうぎょう",
        region: "中部",
        type: "公立",
        deviation: 41,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "県内でも有数の工業高校で、部員の多くが技術職を目指している。実習などで練習時間が限られるハンデを、田中監督が叩き込む「根性野球」でカバー。最後まで諦めない粘り強さがチームの持ち味。スター選手は不在だが、一丸となった時の結束力は高く、強豪校にとってはやりにくい相手として知られる。。",
        coach: { name: '田中 鉄平', style: '根性野球', experience: 'ベテラン' }
    },
    "磐田南": {
        name_yomi: "いわたみなみ",
        region: "西部",
        type: "公立",
        deviation: 63,
        best: "甲子園出場",
        last: "初戦敗退",
        info: "全国トップクラスの進学校。野球は「文武両道」を掲げる課外活動の一環だが、その実力は侮れない。選手個々の野球IQが高く、データを駆使した緻密な戦術を得意とする。知性派集団が、夏のトーナメントに旋風を巻き起こす。余談だが、全国制覇の経験を持つサッカー部が応援に駆けつけることもあり、その独特の応援スタイルも名物となっている。ちなみにサッカー形式の野球応援が珍しいということで、これを目当てに試合に見に来るという隠れファンも多い。",
        coach: { name: '中田 譲二', style: '守備重視', experience: '中堅' }
    },
    "三島北": {
        name_yomi: "みしまきた",
        region: "東部",
        type: "公立",
        deviation: 20,
        best: "県大会ベスト8",
        last: "県大会ベスト8",
        info: "2年生エース左腕・榛名を擁する公立の実力校。max148キロの球速を持つ榛名の投球が試合の鍵を握るが、打線がエースを援護できるかが長年の課題。絶対的エースの存在に頼るだけでなく、チーム全体で得点を奪う総合力が試される。安定して上位に進出する力は十分に持っている。",
        coach: { name: '大川 透', style: '投手中心', experience: '中堅' }
    },
    "静岡": {
        name_yomi: "しずおか",
        region: "中部",
        type: "公立",
        deviation: 65,
        best: "甲子園3回戦",
        last: "県大会ベスト4",
        info: "創立93年、甲子園出場13回。そしてスポーツに力を入れながらも勉学でも優秀。その輝かしい歴史、実績は地元民のみならず県民の誇り、また憧れでもあり、老若男女問わず地元民に愛される伝統校である。近年は他校の私立やナムコグループとの選手獲得競争に一つ遅れをとっており、甲子園からは遠ざかっているが、歴史は厚く、私立並みの設備とOBからの厚い支援、そして、なによりも代矢東の試合がある際には球場に多くのOBが駆け付け、大応援団を結成し、相手を圧倒する。近年はナムコグループが県内を牛耳りかけているため、公立の希望の星としてメディアに取り上げられることも多い。県内を席巻するナムコグループへの『公立最後の砦』として、その存在は象徴的な意味を持ち始めた。名将・高島は伝統と現代野球の融合に腐心する。これは単なる高校野球ではない。地域の誇りと未来をかけた代理戦争なのだ。",
        popularity: true,
        coach: { name: '高島 礼', style: '伝統野球', experience: '名将' }
    },
    "飛龍": {
        name_yomi: "ひりゅう",
        region: "東部",
        type: "私立",
        deviation: 99,
        best: "甲子園2回戦",
        last: "初戦敗退",
        info: "かつては甲子園出場経験もある私立校だが、数年前に起きた不祥事の影響でチームは低迷。現在は若き林田監督と共に、失われた信頼を取り戻すべく再建の道を歩んでいる。地域への清掃活動などを通じて地道な努力を続けており、グラウンドでの結果で完全復活をアピールしたいところだ。。",
        coach: { name: '林田 健太郎', style: '機動力野球', experience: '期待の若手' }
    },
    "聖隷クリストファー": {
        name_yomi: "せいれいくりすとふぁー",
        region: "西部",
        type: "私立",
        deviation: 54,
        best: "県大会準優勝",
        last: "県大会ベスト8",
        info: "毎年優勝候補に挙げられる西部地区の雄。名将・片岡監督が築き上げた投手を中心とした堅守は全国レベルと評される。しかし、その堅実さゆえに打線が湿りがちで、トーナメント終盤で涙を飲む展開が続く。タレントは揃っており、悲願の甲子園出場に向けて、伝統の守備力に加えて得点力をどう向上させるか。長年の課題である「ベスト8の壁」を越えられるかが今大会の焦点となる。",
        popularity: true,
        coach: { name: '片岡 鉄心', style: '守備重視', experience: '名将' }
    },
    "裾野": {
        name_yomi: "すその",
        region: "東部",
        type: "公立",
        deviation: 48,
        best: "なし",
        last: "なし",
        info: "エースの茂野が中心となって創部された新しいチーム。部員のほとんどが高校から野球を始めた初心者であり、戦力としては未知数。茂野の圧倒的な個人技でどこまで勝ち上がれるかが注目される。チームとしての一体感が生まれれば、面白い存在になるかもしれない。",
        coach: { name: '茂野 吾郎', style: '超攻撃型', experience: '新任' }
    },
    "富士宮北": {
        name_yomi: "ふじのみやきた",
        region: "東部",
        type: "公立",
        deviation: 51,
        best: "甲子園出場",
        last: "初戦敗退",
        info: "プロ注目のmax158kmの本格派右腕・斎藤を擁する公立校。彼の存在により、例年以上の注目を集めている。佐々木監督はエースへの負担を考慮しつつ、チーム全体の底上げを図る。斎藤の快投はもちろん、彼を支える野手陣の奮起が、上位進出への鍵となる。",
        coach: { name: '佐々木 朗', style: '投手中心', experience: '中堅' }
    },
    "美城学園": {
        name_yomi: "みしろがくえん",
        region: "中部",
        type: "私立",
        deviation: 81,
        best: "県大会ベスト4",
        last: "県大会2回戦",
        info: "ナムコグループ系列校の草分け的存在。かつてはグループの中心だったが、近年は同じ系列の765総合や283学園に有力選手が集まり、苦戦を強いられている。三城監督の下、プライドをかけた戦いで古豪の意地を見せ、グループ内での序列を覆したいところだ。",
        coach: { name: '三城 常務', style: 'エリート野球', experience: 'ベテラン' }
    },
    "沼津高専": {
        name_yomi: "ぬまづこうせん",
        region: "東部",
        type: "公立",
        deviation: 18,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "全国トップクラスの偏差値を誇る超進学校。相手チームのデータを徹底的に分析し、確率に基づいた戦術を組み立てる「シンキング・ベースボール」が持ち味。身体能力では他校に劣る部分もあるが、その知性で補って余りある。セオリーの穴を突く戦い方は、どんな強豪にとっても脅威となる。。",
        coach: { name: '京大 一郎', style: 'データ野球', experience: '中堅' }
    },
    "三島南": {
        name_yomi: "みしまみなみ",
        region: "東部",
        type: "公立",
        deviation: 42,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "数年前に21世紀枠として甲子園に出場した経験を持つ。数年前ほどの力はないが、今年のチームは全員野球で相手に挑み、守備でリズムを作りながら、つなぐバッティングで得点する野球が特長。エースの吉田と主砲の打川を中心に、泥臭い野球でこの夏は下克上で甲子園まで勝ち上がる。",
        popularity: true,
        coach: { name: '吉田 輝夫', style: '全員野球', experience: 'ベテラン' }
    },
    "御殿場南": {
        name_yomi: "ごてんばみなみ",
        region: "東部",
        type: "公立",
        deviation: 34,
        best: "県大会ベスト16",
        last: "県大会ベスト16",
        info: "50年ぶりとなるベスト16に進出した昨年の躍進で、地元を大いに沸かせた公立校。データ分析を得意とする山内監督の指導の下、派手さはないが堅実な野球で勝ち上がった。周囲の「まぐれ」という声を覆し、自分たちの実力が本物であることを証明したい今大会は、真価を問われる重要な夏となる。。",
        coach: { name: '山内 浩司', style: '堅実', experience: '中堅' }
    },
    "掛川西": {
        name_yomi: "かけがわにし",
        region: "西部",
        type: "公立",
        deviation: 61,
        best: "甲子園2回戦",
        last: "県大会ベスト4",
        info: "静岡高校と並ぶスポーツが盛んな県内二大公立校。サッカー部などが全国的に有名なスポーツ強豪校であり、野球部も毎年安定して上位に進出する実力を持つが、あと一歩で甲子園に届かないシーズンが続く。名将・円堂監督が掲げる、常識にとらわれない大胆な采配は、多くのファンを魅了している。今年こそ他競技の輝かしい実績に追いつきたい。。",
        coach: { name: '円堂 守', style: '超次元野球', experience: '名将' }
    },
    "浜松市立": {
        name_yomi: "はままついちりつ",
        region: "西部",
        type: "公立",
        deviation: 55,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "毎年安定した力を持つ中堅公立校だが、トーナメント中盤で強豪校と当たり敗退することが多く、「壁」を越えられずにいる。この状況を打破すべく、ベテランの山口監督は今年は機動力野球に特化。塁に出れば積極的に次の塁を狙う、しつこい野球で番狂わせを狙う。。",
        coach: { name: '山口 一', style: '機動力野球', experience: 'ベテラン' }
    },
    "浜松学院": {
        name_yomi: "はままつがくいん",
        region: "西部",
        type: "私立",
        deviation: 52,
        best: "県大会ベスト16",
        last: "県大会ベスト16",
        info: "体育科のみで構成される通信制の私立校。全国から選手が集まり、寮生活を送りながら野球に打ち込んでいる。サッカー界で実績のある岡田監督が、競技の垣根を越えて指導にあたっており、その育成手腕に注目が集まる。独特の環境で育った選手たちが、チームとしてどう機能するかが鍵。",
        coach: { name: '岡田 武史', style: '育成上手', experience: 'ベテラン' }
    },
    "焼津水産": {
        name_yomi: "やいづすいさん",
        region: "中部",
        type: "公立",
        deviation: 44,
        best: "県大会ベスト16",
        last: "県大会2回戦",
        info: "港町に根ざした水産高校で、スタンドに翻る大漁旗がチームのシンボル。一昨年のベスト16進出という実績もあり、地元の期待は大きい。浜田監督が率いるチームは、チャンスでの集中打を得意とする攻撃的な野球が持ち味。昨年の不振を乗り越え、再び「大漁」を狙う。",
        coach: { name: '浜田 大吉', style: '積極打撃', experience: '中堅' }
    },
    "袋井": {
        name_yomi: "ふくろい",
        region: "中部",
        type: "公立",
        deviation: 59,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "県内有数のマンモス校で、毎年一定数の有望な新入生が入部する。突出したスター選手はいないものの、全部員のレベルが高く、総合力で勝負するチーム。ベテラン千葉監督の下、選手層の厚さを活かした多彩な戦術が強み。昨年の初戦敗退の雪辱を誓う。。",
        coach: { name: '千葉 繁', style: '総合力', experience: 'ベテラン' }
    },
    "浜松城北工業": {
        name_yomi: "はままつじょうほくこうぎょう",
        region: "西部",
        type: "公立",
        deviation: 66,
        best: "県大会ベスト4",
        last: "初戦敗退",
        info: "県大会ベスト4の経験もある公立校。元プロの金本監督が注入する、積極果敢なフルスイング野球がチームの代名詞。その攻撃的なスタイルは、時にラフプレーと批判されることもあるが、勝利への執念はどのチームよりも強い。昨年の初戦敗退から這い上がり、再び頂点を目指す。。",
        coach: { name: '金本 知憲', style: '積極打撃', experience: 'プロOB' }
    },
    "磐田東": {
        name_yomi: "いわたひがし",
        region: "西部",
        type: "私立",
        deviation: 90,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "轟監督の「打撃こそ正義」という哲学に基づき、練習の大部分を打撃練習に費やす超攻撃型チーム。その破壊力は県内トップクラスで、大量得点で試合をひっくり返す力を持つ。一方で、守備力に課題を残しており、試合展開が非常に不安定なのが特徴。観客を魅了する、スリリングな試合運びで勝ち上がりを狙う。。",
        coach: { name: '轟 雷蔵', style: '打撃偏重', experience: 'ベテラン' }
    },
    "静岡商業": {
        name_yomi: "しずおかしょうぎょう",
        region: "中部",
        type: "公立",
        deviation: 57,
        best: "甲子園優勝",
        last: "県大会ベスト8",
        info: "甲子園優勝経験もある伝統校で、毎年優勝候補の筆頭に挙げられる。エース成宮を筆頭とする投手力は全国屈指のレベルを誇る。昨年の大会では準々決勝で敗退しており、今年は王座奪還を目指す。名将・国友監督の下、投打に隙がなく、総合力は県内トップクラス。。",
        popularity: true,
        coach: { name: '国友 広重', style: '総合力', experience: '名将' }
    },
    "御殿場西": {
        name_yomi: "ごてんばにし",
        region: "東部",
        type: "私立",
        deviation: 96,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "トーナメント中盤の大きな壁として、毎年安定した力を見せる私立の実力校。ベテラン田崎監督が築き上げた堅実な野球は、どのチームにとってもやりにくい。一方で、近年はベスト8前後での敗退が続き、上位進出には課題も残る。強豪校にとっては厄介な「門番」から脱却し、頂点を狙えるかが問われる。。",
        coach: { name: '田崎 圭介', style: '堅実', experience: 'ベテラン' }
    },
    "誠恵": {
        name_yomi: "せいけい",
        region: "東部",
        type: "私立",
        deviation: 38,
        best: "甲子園出場",
        last: "初戦敗退",
        info: "かつては甲子園にも出場した古豪だが、近年は部員不足に悩み低迷している。勝利のためなら手段を選ばないベテラン影山監督の非情な采配は、物議を醸すことも少なくない。しかし、恵まれない戦力で勝ち上がるため、綺麗事だけでは済まされないというチームの現実も表している。。",
        coach: { name: '影山 秀路', style: 'ラフプレー', experience: 'ベテラン' }
    },
    "科学技術": {
        name_yomi: "かがくぎじゅつ",
        region: "中部",
        type: "私立",
        deviation: 23,
        best: "県大会ベスト4",
        last: "県大会ベスト16",
        info: "VRトレーニングやAIによるデータ解析など、最新技術を積極的に導入している新時代の私立校。その先進的な取り組みはメディアでも度々取り上げられ、知名度は高い。速水監督の下、科学的なアプローチで選手の能力を最大限に引き出す。データ野球が伝統的な強豪校にどこまで通用するのか、注目が集まる。。",
        coach: { name: '速水 奨', style: 'データ野球', experience: '中堅' }
    },
    "小山": {
        name_yomi: "おやま",
        region: "東部",
        type: "公立",
        deviation: 49,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "人口1万人の小さな町にある、全校生徒100人にも満たない小規模校。町の期待を一身に背負い、彼らはグラウンドに立つ。チャンス時に全校生徒と町民が一体となって踊る『小山舞踊』は、相手チームを呑み込む独特の雰囲気を生み出す。ベテラン猫田監督の下、体格では劣る選手たちが機動力で掻き回す。町全体の想いが、奇跡を起こすかもしれない。",
        coach: { name: '猫田 権蔵', style: '機動力野球', experience: 'ベテラン' }
    },
    "虎府島総合": {
        name_yomi: "こふとうそうごう",
        region: "西部",
        type: "公立",
        deviation: 47,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "本土から定期船で4時間。台風が来れば1週間は孤島と化す。それが虎府島だ。グラウンドは塩害で芝生がまだらに枯れ、雨が降れば沼地と化す。練習相手は漁の合間に集まる島の草野球チームの地元の方々。彼らから教わるのは『気合』と『潮の流れの読み方』だ。本土の他校の情報は、月に一度届く野球雑誌だけ。しかし、この絶望的なハンデが彼らの魂を鋼鉄に変えた。その逆境が「虎府島スピリッツ」と呼ばれる強靭な精神力とチームの結束を育んだ。試合の日には島民が大挙して応援に駆けつけるなど、地域との絆はどこよりも強い。噂によると島民の約半数にも及ぶらしい。もはやこれは単なるスポーツではない。島が、生きるために戦う物語だ。",
        coach: { name: '島袋 譲二', style: '全員野球', experience: 'ベテラン' }
    },
    "知徳": {
        name_yomi: "ちとく",
        region: "東部",
        type: "私立",
        deviation: 71,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "『力こそ全て』を校訓に掲げ、練習のほとんどをウエイトトレーニングに費やす脳筋集団。金剛監督の指導の下、全選手がベンチプレス100kg以上を誇るパワーは本物だ。しかし、その大味な野球は、栄養管理や科学的トレーニングを取り入れる強豪校の前に、いつもあと一歩で屈してきた。筋肉は裏切らない。その言葉を信じ、彼らは今日も鉄アレイを握る。",
        coach: { name: '金剛 毅', style: 'パワー野球', experience: '中堅' }
    },
    "静清": {
        name_yomi: "せいせい",
        region: "中部",
        type: "私立",
        deviation: 55,
        best: "甲子園優勝",
        last: "初戦敗退",
        info: "半世紀前に甲子園5連覇を達成した伝説的な古豪。近年は低迷が続くが、その名前は今も高校野球ファンに畏敬の念を抱かせている。かつての名将の血を引く犬飼監督が、伝統の堅守を復活させ、「帝国の再建」を目指す。古豪復活への道のりは険しいが、その一挙手一投足に注目が集まる。。",
        coach: { name: '犬飼 賢人', style: '守備重視', experience: '名将' }
    },
    "日大三島": {
        name_yomi: "にちだいみしま",
        region: "東部",
        type: "私立",
        deviation: 96,
        best: "甲子園出場",
        last: "県大会ベスト16",
        info: "2022年の春夏連続甲子園出場が記憶に新しい日大三島。昨秋は県大会3回戦で敗退し、気合を入れ直したところだ。指揮をとるのは永田裕治監督だ。報徳学園（兵庫）時代には全国制覇を含む、春夏通算18回の甲子園出場。2020年に日大三島に赴任すると、2022年には春夏連続で甲子園に導いた。今チームも百戦錬磨の名将から全員野球の大切さ、勝負に対する厳しさを学び、選手たちの顔つきが少しずつ変わってきた。名将の就任から4年が過ぎようとしている。。",
        coach: { name: '小和田 雅人', style: '堅実', experience: 'ベテラン' }
    },
    "浜松開誠館": {
        name_yomi: "はままつかいせいかん",
        region: "西部",
        type: "私立",
        deviation: 60,
        best: "県大会ベスト4",
        last: "県大会ベスト16",
        info: "「強豪キラー」として知られる、トーナメント屈指のダークホース。策士・豊臣監督が率いるチームは、相手チームの徹底的な分析に基づいた奇策を得意とする。その予測不能な戦いぶりは、格上の強豪校にとって大きな脅威。安定感に欠ける面もあるが、ひとたび波に乗れば一気に勝ち上がる力を持っている。。",
        coach: { name: '豊臣 秀幸', style: '奇策', experience: '策士' }
    },
    "東海大翔洋": {
        name_yomi: "とうかいだいしょうよう",
        region: "中部",
        type: "私立",
        deviation: 61,
        best: "県準優勝",
        last: "県大会ベスト16",
        info: "一昨年の夏はノーシードから県内強豪チームに勝利し準優勝。新しいスタイルで今夏こそ甲子園へ！勝利への執念を引き継ぐ現チームの特徴は「機動力」。前チームとはまた違ったスタイルに期待がかかる。機動力以外もレベルアップしている。投手は140キロ右腕の甘田圭澄（2年）が君臨。課題だった2番手も、1年生を中心に台頭しつつある。一方の攻撃力は7試合計90安打を叩き出した昨年のチームに比べて劣るが、機動力を使った野球を展開。チームナンバーワンの俊足・松下揮人（2年＝外野手）や岸川を筆頭に足の速い選手が多いのも追い風となっている。守りからリズムを作り、1点ずつ積み重ねていくニュースタイルが浸透してきた「タテジマ軍団」。2004年夏以来となる甲子園に向けて牙を研ぐ。。",
        coach: { name: '須田 幸雄', style: '総合力', experience: 'ベテラン' }
    },
    "283学園B": {
        name_yomi: "つばさがくえんB",
        region: "西部",
        type: "私立",
        deviation: 59,
        best: "なし",
        last: "なし",
        info: "王者・283学園の『二軍』。昨年の優勝により部員数が急激に増加した283学園。一時は100人も超えたため、それに伴い、異例の措置として設立されたBチーム。Aチームに上がれなかった選手で構成されているが、監督に就任した七草の手腕もあり、その実力は侮れない。「打倒Aチーム」を掲げ、ハングリー精神は本家以上。公式戦での兄弟対決が実現すれば、大きな注目を集めるだろう。県内からは同じ県内に同じ高校のチームの二つ目を作り大会に参加させるのは違反行為なのでは、という声が多く上がったが、県内はナムコグループが牛耳っているため、ごり押しで可決させた。",
        coach: { name: '七草 はづき', style: '育成上手', experience: '期待の若手' }
    },
    "伊豆伊東": {
        name_yomi: "いずいとう",
        region: "伊豆",
        type: "公立",
        deviation: 43,
        best: "県大会2回戦",
        last: "県大会2回戦",
        info: "数年前に共学化した元女子高で、野球部は創部まもない新しいチーム。学校側の全面的なバックアップを受け、期待の若手、伊集院監督が指導にあたる。全国レベルと名高い吹奏楽部の応援もチームの大きな武器。まだ発展途上だが、今後の成長が期待される注目株だ。。",
        coach: { name: '伊集院 隼人', style: '機動力野球', experience: '期待の若手' }
    },
    "富士東": {
        name_yomi: "ふじひがし",
        region: "東部",
        type: "公立",
        deviation: 63,
        best: "県大会2回戦",
        last: "県大会2回戦",
        info: "富士東は最上級生の奮起に注目だ。昨年は４人しかいない３年生全員が活躍を見せ、初戦で甲子園出場経験もある富士宮北を７―６で破った。一緒にプレーした岩田主将（３年）は「そういう上級生の姿を今年も後輩たちに見せたい」と意気込む。エースの眞山（３年）は、４日の招待試合で日大三島に１失点完投勝利。自信を胸に「チームを鼓舞する投球をしたい」と大舞台を見据える。。",
        coach: { name: '高橋 留美', style: '守備重視', experience: '中堅' }
    },
    "常葉菊川": {
        name_yomi: "とこはきくがわ",
        region: "西部",
        type: "私立",
        deviation: 55,
        best: "甲子園準優勝",
        last: "県準優勝",
        info: "織田監督が率いる、超攻撃的な野球を標榜する私立校。昨年の県大会では、その圧倒的な打撃力で準優勝に輝いた。守備に課題を残すものの、「点を取られたら取り返す」というスタイルは多くのファンを魅了している。今年もその破壊的な打線は健在で、頂点を目指す。。",
        coach: { name: '織田 信長', style: '超攻撃型', experience: 'ベテラン' }
    },
    "加藤学園": {
        name_yomi: "かとうがくえん",
        region: "東部",
        type: "私立",
        deviation: 92,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "投手陣は緩急をつける三浦、思い切りのいい山口らが主戦を争う。打線は長打力があるブランコ、中村ら中軸が信頼できる。石川、モーガンら上位が出て、得点機をつくりたい。下位打線の充実が鍵。守備は一年生の時から試合に出ている遊撃梶谷、昨年を経験した捕手鶴岡らセンターラインが軸。確実にアウトを取れる安定感が持ち味だ。",
        coach: { name: '渡辺 元智', style: '総合力', experience: '名将' }
    },
    "藤枝明誠": {
        name_yomi: "ふじえだめいせい",
        region: "西部",
        type: "私立",
        deviation: 90,
        best: "県大会準優勝",
        last: "県大会ベスト8",
        info: "「雑草軍団」として知られ、エリート校への強い対抗心とハングリー精神がチームの原動力。ベテラン猪狩監督の指導の下、個々の選手の能力は非常に高い。チームとして噛み合った時の爆発力は、優勝候補をも脅かす。近年着々と結果を出しており、今大会は春の大会で上位の成績を収めたことにより、シード校として君臨している。「革命」の時は近い。",
        coach: { name: '猪狩 茂', style: '投手中心', experience: 'ベテラン' }
    },
    "駿河総合": {
        name_yomi: "するがそうごう",
        region: "中部",
        type: "私立",
        deviation: 47,
        best: "県大会準優勝",
        last: "県大会2回戦",
        info: "2019年夏に初の県決勝進出を果たした駿河総合。昨夏の「2020年夏季静岡県高等学校野球大会結果」でもベスト4入り。悲願の甲子園が手の届く位置まできている。同校はチーム力が年々上昇すると同時に、上のカテゴリーで活躍する卒業生が増えている。2018年に社会人野球を経てOBの杉山一樹（福岡ソフトバンク）がプロ入り。最速157キロの剛速球を武器に今季はローテーションの一角として期待される。さらに、2019年のドラフトで指名された紅林弘太郎（オリックス）はプロ1年目から1軍戦に出場。将来の主軸候補として注目を集めている。期待の若手・藤崎監督が持ち込んだデータ野球を武器に、着実に力をつけている。相手の油断を突く情報戦を得意とし、下馬評を覆すポテンシャルは十分。校名とは裏腹に、冷静沈着な野球で番狂わせを狙う。。",
        coach: { name: '藤崎 詩織', style: 'データ野球', experience: '期待の若手' }
    },
    "静岡大成": {
        name_yomi: "しずおかたいせい",
        region: "中部",
        type: "私立",
        deviation: 49,
        best: "県大会ベスト16",
        last: "県大会2回戦",
        info: "突出した選手こそいないものの、堅実な守備と、出塁率を武器にしている。選手たちは限られた環境の中でも、年間を通して一生懸命に取り組んでいる。直近の練習試合では東海大翔洋にも勝利するなど実力は侮れない。今大会のダークホースになるかもしれない",
        coach: { name: '鰯水 等', style: '堅実', experience: '中堅' }
    },
    "浜松工業": {
        name_yomi: "はままつこうぎょう",
        region: "西部",
        type: "公立",
        deviation: 64,
        best: "甲子園ベスト8",
        last: "県大会2回戦",
        info: "約30年前に甲子園ベスト8に進出し、「浜工旋風」を巻き起こしたことで知られる。近年は低迷していたが、当時のエースだった青葉が監督に就任し、再建に乗り出した。かつての英雄の帰還に、OBや地元の期待も高まっている。新しい世代の選手たちと共に、再び聖地を目指す。。",
        coach: { name: '青葉 健司', style: '育成上手', experience: '期待の若手' }
    },
    "伊豆総合": {
        name_yomi: "いずそうごう",
        region: "東部",
        type: "公立",
        deviation: 43,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "エースは最速１３６キロの力のあるストレートで勝負する。打撃陣に派手さはないものの走塁や戦術に磨きをかけ、足りない長打力をカバーする。落ち着いた雰囲気で野球に取り組んでいる。尾島太郎監督の指導は、堅実な守備と確実なバントなどを重視するスタイル。派手さはないが、大崩れしない安定感がある。。",
        coach: { name: '尾島 太郎', style: '守備重視', experience: 'ベテラン' }
    },
    "富士宮西": {
        name_yomi: "ふじのみやにし",
        region: "東部",
        type: "公立",
        deviation: 58,
        best: "甲子園ベスト16",
        last: "初戦敗退",
        info: "約30年前に甲子園出場経験のある古豪。近年は私立校の台頭に押され、上位進出から遠ざかっている。OBや地元ファンの「復活を」という期待が、時に選手たちのプレッシャーになることも。ベテラン拳崎監督は、選手たちが気負わずに実力を発揮できる環境作りに努めている。",
        coach: { name: '拳崎 史郎', style: '積極打撃', experience: 'ベテラン' }
    },
    "富士市立": {
        name_yomi: "ふじいちりつ",
        region: "西部",
        type: "私立",
        deviation: 61,
        best: "県大会ベスト8",
        last: "県大会2回戦",
        info: "セイバーメトリクスをいち早く導入し、データに基づいた野球を徹底する私立校。赤嶺監督の采配は、選手のコンディションや相手との相性など、あらゆる情報を分析した上で決定される。その合理的なアプローチは、時に非情とも映るが、着実に結果を残している。",
        coach: { name: '赤嶺 譲二', style: 'データ野球', experience: '中堅' }
    },
    "オイスカ浜松国際": {
        name_yomi: "おいすかはままつこくさい",
        region: "西部",
        type: "私立",
        deviation: 49,
        best: "県大会ベスト4",
        last: "県大会2回戦",
        info: "県内を牛耳る巨大資本『ナムコグループ』に対抗すべく、地元の有志『オイスカグループ』が設立した異色の高校。潤沢な資金を持つナムコ系列校とは対照的に、彼らが持つのは反骨精神と結束力だけだ。「伝説」と称される桐生監督の指導は、技術よりも精神的な強さを重視する。その熱いプレースタイルと反骨精神は多くのファンを惹きつけており、大会の波乱要因として注目されている。",
        coach: { name: '桐生 一馬', style: '根性野球', experience: '伝説' }
    },
    "新居": {
        name_yomi: "あらい",
        region: "中部",
        type: "公立",
        deviation: 48,
        best: "県大会初戦敗退",
        last: "初戦敗退",
        info: "夏の大会、公式戦通算0勝32敗。それがこの学校の歴史の全てだ。長年公式戦での勝利から遠ざかっており、部員数も常にギリギリという厳しい状況が続く公立校。練習環境も恵まれているとは言えないが、選手たちは野球が好きだという純粋な気持ちで白球を追い続けている。チームの悲願は、まず「公式戦で一勝」を挙げること。その瞬間に向けて、ひたむきな努力を重ねる。",
        coach: { name: '田中 一郎', style: '堅実', experience: '中堅' }
    },
    "韮山": {
        name_yomi: "にらやま",
        region: "東部",
        type: "公立",
        deviation: 68,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "県のシンボル『伊豆山』の麓にある県内屈指の進学校。彼らの名物は、険しい山道を毎日駆け上がる地獄のトレーニングだ。それで鍛え上げられた強靭な足腰は、他校の脅威。ベテラン山路監督が率いる機動力野球は、一度出塁を許すと止まらない。山の民の誇りを胸に、グラウンドを嵐のように駆け巡る。",
        coach: { name: '山路 和弘', style: '機動力野球', experience: 'ベテラン' }
    },
    "静岡学園": {
        name_yomi: "しずおかがくえん",
        region: "中部",
        type: "私立",
        deviation: 61,
        best: "甲子園出場",
        last: "県大会ベスト16",
        info: "創部19年の新興勢力ながら、甲子園出場経験を持つ実力校。しかし更なる飛躍のため、学校は大きな賭けに出た。かつて帝王実業を甲子園5連覇に導いた伝説の名将・國村監督を招聘したのだ。規律を重んじるベテラン監督の下、才能ある選手たちがどう融合するのか、優勝候補の一角として大きな注目を集めている。。",
        coach: { name: '國村 隼', style: '総合力', experience: '名将' }
    },
    "市立沼津": {
        name_yomi: "いちりつぬまづ",
        region: "東部",
        type: "公立",
        deviation: 62,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "全国レベルの吹奏楽部が奏でる応援は『市沼サウンド』として有名。その美しくも力強い音圧は、相手チームの集中力を削ぎ、味方を鼓舞する。ベテラン猫又監督が率いるチームは、その応援をバックに、粘り強い守備でリズムを作る。派手な選手はいないが、繋ぐ意識は県内随一。音の魔術師たちが、静かに、しかし確実に相手を追い詰めていく。",
        coach: { name: '猫又 育史', style: '守備重視', experience: 'ベテラン' }
    },
    "沼津城北": {
        name_yomi: "ぬまづじょうほく",
        region: "東部",
        type: "公立",
        deviation: 55,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "生徒の自主性を重んじる自由な校風で知られる公立校。野球部も西垣監督の指導方針の下、選手たちが自ら練習メニューや戦術を考える「考える野球」を実践している。その型にはまらないプレースタイルは、時にセオリーを覆す大きな波乱を巻き起こす可能性を秘めている。",
        coach: { name: '西垣 奈々', style: '奇策', experience: '期待の若手' }
    },
    "下田": {
        name_yomi: "しもだ",
        region: "伊豆",
        type: "公立",
        deviation: 50,
        best: "県大会初戦敗退",
        last: "初戦敗退",
        info: "過疎化が進む静かな港の町。全校生徒80人、野球部員は奇跡的に集まったが、グラウンドには雑草が生い茂り、練習は紅白戦もできず、監督が打つボールをただ延々と追いかけるだけ。昨年、町で唯一のスポーツ用品店がシャッターを下ろし、今は破れたボールを自分たちで縫って使うしかない。町の大人たちは、彼らが野球をしていることすら知らないかもしれない。消えゆく町で、誰にも知られず消えていく野球部。彼らが夏の大会に出場するのは、勝利のためではない。自分たちが『下田高校野球部』として確かにここに存在したという、たった一つの証を夏の青空に刻み込むためだけの、あまりにも切ない戦いだ。",
        coach: { name: '水上 善次', style: '堅実', experience: '中堅' }
    },
    "湖西": {
        name_yomi: "こさい",
        region: "西部",
        type: "公立",
        deviation: 57,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "大会ごとに成績が大きく変動する、ムラッ気のあるチームとして知られる。上位進出経験もありポテンシャルは高いが、格下相手への取りこぼしも少なくない。ベテラン海野監督は、長年の課題である精神的な安定感をチームにもたらそうと指導。今大会で安定した戦いぶりを見せられるかが躍進の鍵となる。。",
        coach: { name: '海野 平', style: '機動力野球', experience: 'ベテラン' }
    },
    "熱海": {
        name_yomi: "あたみ",
        region: "伊豆",
        type: "公立",
        deviation: 46,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "創立70年を迎える地域の伝統校だが、近年は過疎化の波に飲まれ、活気を失いつつある。野球部の活躍は、町に残された数少ない希望だ。『俺たちが勝てば、町が元気になる』。その想いを胸に、選手たちはグラウンドに立つ。選手は全員が地元出身。育成に定評のある根本監督の下、郷土愛を力に変えて戦う。そのひたむきなプレーには、多くの地元ファンがついている。地元出身の選手たちが、愛する故郷に勝利を届ける。",
        coach: { name: '根本 陸夫', style: '育成上手', experience: 'ベテラン' }
    },
    "静岡東": {
        name_yomi: "しずおかひがし",
        region: "中部",
        type: "公立",
        deviation: 53,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "毎年投打にバランスの取れた好チームを編成するが、トーナメントの組み合わせに恵まれず、実力以上の結果を残せていない「悲運の公立校」。井上監督はどんな相手にも自分たちの野球を貫くことを選手に求める。今年こそ、厳しい組み合わせを乗り越えて上位進出を果たしたい。。",
        coach: { name: '井上 和彦', style: '総合力', experience: '中堅' }
    },
    "城南静岡": {
        name_yomi: "じょうなんしずおか",
        region: "中部",
        type: "公立",
        deviation: 59,
        best: "県大会ベスト4",
        last: "初戦敗退",
        info: "かつて県ベスト4の実績を持つ公立の実力校。昨年の初戦敗退の屈辱から、チームは「原点回帰」をテーマに伝統の積極打撃を徹底的に磨き直した。伊藤監督の下、古豪復活を目指すチームの士気は高い。ノーシードからの下剋上を狙う。。",
        coach: { name: '伊藤 健太郎', style: '積極打撃', experience: 'ベテラン' }
    },
    "浜松南": {
        name_yomi: "はままつみなみ",
        region: "西部",
        type: "公立",
        deviation: 56,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "近年、校舎が新築され、練習環境が大幅に改善された公立校。学校全体の期待が高まる中、期待の若手・高木監督がチームを率いる。まだ目立った実績はないが、最新の設備と新しいユニフォームで心機一転、新たな歴史を作るべく今大会に挑む。。",
        coach: { name: '高木 渉', style: '育成上手', experience: '期待の若手' }
    },
    "島田": {
        name_yomi: "しまだ",
        region: "中部",
        type: "公立",
        deviation: 53,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "大正8年創立という長い歴史を持つ伝統校だが、近年は部員不足から連合チームを組むなど、苦しい時期が続いている。今季から再び単独チームとして出場するが、戦力はまだ整っていない。まずは大会で一勝を挙げ、チームの新たな一歩を踏み出すことが目標となる。。",
        coach: { name: '島本 宏', style: '堅実', experience: '中堅' }
    },
    "伊豆中央": {
        name_yomi: "いずちゅうおう",
        region: "伊豆",
        type: "公立",
        deviation: 51,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "長年の部員不足から昨年まで連合チームとして出場していたが、今年から待望の単独出場を果たす。部員の多くが野球経験の浅い1年生で、チームはまだ発展途上。中田監督は、まずは公式戦で戦う経験を積ませ、チームの土台作りを進めている段階。今大会は未来への第一歩となる。。",
        coach: { name: '中田 島蔵', style: '全員野球', experience: '中堅' }
    }
};

    const DETAILED_TEAM_DATA = {
        "283学園": {
            summary: "夏の連覇の先に、聖地での勝利を目指す。昨年王者、守備の一体感と打線のつながりを強みに、試合ごとに成長。チームスローガンは『強』。個の技量に頼らず、一人ひとりの力を集めて戦う。",
            players: [
                { name: "姫川", year: 3, position: "ピッチャー", desc: "投打の中心。MAX151kmの直球とスプリット、高校通算42本塁打の怪物。" },
                { name: "花海咲", year: 3, position: "センター", desc: "1年夏からベンチ入りを果たしている、経験豊富な走攻守三拍子揃ったリードオフマン。攻守の要として監督からの信頼は厚い。" },
                { name: "鈴木", year: 2, position: "ファースト", desc: "芯で捉える技術を持つ打者。守備でも存在感。" },
                { name: "十王", year: 3, position: "ショート", desc: "鉄壁の守備を誇る名手。チャンスメイクも得意な打者。" },
                { name: "浅倉享", year: 2, position: "レフト", desc: "2年生ながら5番に座ることもあるクラッチヒッター。ポテンシャルが高い。" },
                { name: "樋口", year: 3, position: "サード", desc: "強肩強打のパワーヒッター。勝負強い打撃が光る。" },
                { name: "有栖川", year: 3, position: "キャッチャー", desc: "大舞台に強い主軸。変化球打ちの技術はチームトップクラス。" },
                { name: "芹沢", year: 2, position: "セカンド", desc: "小技と守備センスが光る二塁手。チャンスでの一打も。" },
                { name: "花海佑", year: 1, position: "ライト", desc: "1年生のスーパースター。兄・咲との連携も抜群。既に通算13本塁打。" },
                { name: "黛", year: 2, position: "ピッチャー", desc: "チーム最速の直球を持つ。春はメンバー外の悔しさをバネに復調を目指す。" },
                { name: "白瀬", year: 3, position: "ピッチャー", desc: "春の大会で完全試合を達成。伸び上がるストレートが武器。" }
            ]
        },
        "常葉菊川": {
            summary: "個々のレベルアップが結実し昨年は準優勝。個人成績の可視化と実力主義でチーム内の競争を活性化させ、初の甲子園を目指す。スローガンは『個々の能力重視』。",
            players: [
                { name: "沖田", year: 3, position: "ピッチャー", desc: "投打の大黒柱。MAX157kmの速球を持つ主砲。" },
                { name: "土方", year: 3, position: "キャッチャー", desc: "グラウンド上の監督。高いスローイング技術と高校通算28本塁打のパワーを持つ。" },
                { name: "宮本", year: 3, position: "ファースト", desc: "力強い打撃と勝負強さが魅力の3番打者。" },
                { name: "柳生", year: 2, position: "セカンド", desc: "バッティングセンスに優れる2年生。落ち着いたプレーが光る。" },
                { name: "近藤", year: 3, position: "サード", desc: "ガッツあふれるプレーでチームを引っ張る5番打者。高校通算46本塁打。" },
                { name: "坂本", year: 3, position: "ショート", desc: "走攻守三拍子揃った抜群の身体能力を持つショート。" },
                { name: "岡田", year: 3, position: "ライト", desc: "高校通算71本塁打を誇る絶対的な4番。恵まれた体格からの強打が武器。" },
                { name: "森", year: 2, position: "センター", desc: "50m6秒フラットの俊足。攻守にわたり抜群の勝負強さを見せる。" },
                { name: "上泉", year: 3, position: "レフト", desc: "バランスと勝負強い打撃が武器。逆転劇のきっかけを作る。" },
                { name: "拝", year: 3, position: "ピッチャー", desc: "巧みな投球術と強い精神力を持つ控え投手。MAX155km。" },
                { name: "疋田", year: 2, position: "ピッチャー", desc: "クレバーさと強気を兼ね備えた2年生投手。昨夏も登板経験あり。" }
            ]
        },
        "掛川西": {
            summary: "昨年ベスト4。選手の長所を活かす野球で、磨き上げた守備力とタイプの違う3年生投手3人の継投を武器に、2005年以来の夏の聖地を目指す。",
            players: [
                { name: "豪炎寺", year: 3, position: "ピッチャー", desc: "最速158kmの直球と縦スライダーで打者を打ち取る絶対的エース。" },
                { name: "円堂", year: 3, position: "キャッチャー", desc: "冷静なリードで多彩な投手陣を引っ張る扇の要。3番打者としても活躍。" },
                { name: "壁山", year: 3, position: "ファースト", desc: "190cmの長身を生かした守備と長打力が魅力。" },
                { name: "半田", year: 3, position: "セカンド", desc: "小柄ながら攻守に堅実なプレーでチームに貢献。" },
                { name: "一ノ瀬", year: 3, position: "サード", desc: "チーム一の打球の速さを誇る2番打者。" },
                { name: "土門", year: 3, position: "ショート", desc: "ミスの少ない堅実な守備で試合のリズムを作る内野の要。" },
                { name: "染岡", year: 3, position: "レフト", desc: "監督も絶大な信頼を寄せる大砲。気持ちの強さも魅力。" },
                { name: "風丸", year: 3, position: "センター", desc: "サイクルヒット達成経験もあるリードオフマン。ミート力が格段にアップ。" },
                { name: "栗松", year: 2, position: "ライト", desc: "力強いスイングから放たれる長打が魅力の2年生。" },
                { name: "鬼道", year: 3, position: "ピッチャー", desc: "キレのある縦スライダーと内角への直球が魅力の右腕。" },
                { name: "松野", year: 2, position: "ピッチャー", desc: "MAX144kmのストレートとカットボールが武器の2年生。奪三振能力が高い。" }
            ]
        },
        "静岡": {
            summary: "投打の大黒柱を中心にダイナミックなベースボールを展開。攻めの姿勢を貫き、1999年以来の聖地を見据える伝統校。どこからでも得点できる打線が強み。",
            players: [
                { name: "渋谷", year: 3, position: "ピッチャー", desc: "常時150km超の速球を投げる本格派エース。" },
                { name: "片野坂", year: 3, position: "キャッチャー", desc: "小柄ながら強肩強打の司令塔。盗塁阻止率は随一。" },
                { name: "郷野", year: 3, position: "ファースト", desc: "高校通算63本塁打のプロ注目スラッガー。得点圏での勝負強さが光る。" },
                { name: "片倉", year: 3, position: "セカンド", desc: "俊足と広い守備範囲が武器の機動力内野手。" },
                { name: "島津", year: 3, position: "サード", desc: "反応速度と強肩が武器の守備の要。広角に打ち分ける打撃も。" },
                { name: "藤原", year: 3, position: "ショート", desc: "軽快なフットワークが光る守備職人。つなぎ役もこなす。" },
                { name: "倉科", year: 3, position: "レフト", desc: "小柄ながら高い身体能力を持つ。クリーンアップの前を打つ。" },
                { name: "滝川", year: 3, position: "センター", desc: "抜群の走力でセンターラインを統率するリードオフマン。" },
                { name: "川又", year: 3, position: "ライト", desc: "安定した打率を誇る右打者。正確な返球も魅力。" },
                { name: "六反田", year: 3, position: "ピッチャー", desc: "最速152kmの剛腕。リリーフも先発もこなす万能型。" },
                { name: "鳥羽", year: 3, position: "ピッチャー", desc: "左腕から多彩な変化球を投げるクローザー的存在。" }
            ]
        },
        "聖隷クリストファー": {
            summary: "昨年ベスト8。選手の長所を活かした攻撃力と堅守を武器に雪辱を期す。タイプの異なる3人の投手による継投が強み。",
            players: [
                { name: "沢村", year: 2, position: "ピッチャー", desc: "最速140kmの直球と多彩な変化球で三振を奪う次世代エース左腕。" },
                { name: "降谷", year: 3, position: "ピッチャー", desc: "長身から投げ下ろすスライダーとシュートが武器の大型右腕。" },
                { name: "御幸", year: 3, position: "キャッチャー", desc: "攻守にわたる高い野球センスを誇るプロ注目の司令塔。" },
                { name: "前園", year: 2, position: "一塁手／外野手", desc: "高い打撃技術と強肩を持つ大型野手。" },
                { name: "小湊", year: 3, position: "二塁手", desc: "堅実な守備と巧みなバットコントロールが光る。" },
                { name: "金丸", year: 3, position: "三塁手", desc: "打球反応が速く、強肩が武器。中距離ヒッター。" },
                { name: "倉持", year: 2, position: "ショート", desc: "俊敏な動きと華麗な守備が魅力の内野の要。" },
                { name: "結城", year: 3, position: "レフト", desc: "長打力を武器に快音を響かせる強打者。" },
                { name: "東条", year: 3, position: "センター", desc: "強肩と確実な捕球で外野を統率する守備職人。" },
                { name: "白州", year: 3, position: "ライト", desc: "打撃センスが光る左打者。冷静な状況判断が持ち味。" }
            ]
        },
        "三島北": {
            summary: "雪辱を期す知性派軍団。絶対的エース榛名を擁し、データを駆使した緻密な野球で昨夏の悔しさを晴らす。チームスローガンは『知は力なり』。",
            players: [
                { name: "榛名", year: 3, position: "ピッチャー", desc: "最速140km後半の直球と高速スライダーで三振の山を築く絶対的エース。" },
                { name: "秋丸", year: 3, position: "キャッチャー", desc: "冷静沈着なリードでエース榛名を支える扇の要。" },
                { name: "大川", year: 3, position: "ファースト", desc: "チーム不動の4番。一振りで試合の流れを変えるパワーが魅力。" },
                { name: "福原", year: 3, position: "ショート", desc: "卓越したバットコントロールと選球眼を持つ1番打者。守備も堅実。" },
                { name: "町田", year: 3, position: "センター", desc: "走攻守三拍子揃ったアベレージヒッター。3番を担う。" }
            ]
        },
        "静岡商業": {
            summary: "王座奪還へ、揺るぎなき『王国』のプライド。昨年の雪辱に燃える絶対王者。投打にタレントを揃え、最強左腕・成宮を軸に再び全国の頂点を目指す。スローガンは『常勝』。",
            players: [
                { name: "成宮", year: 3, position: "ピッチャー", desc: "「キング」の異名を持つ世代最強左腕。MAX150km/hの直球と魔球チェンジアップを操る。" },
                { name: "神谷", year: 3, position: "センター", desc: "50m5秒台の俊足を誇る「チーター」。攻守に規格外の身体能力を見せる。" },
                { name: "白河", year: 3, position: "ショート", desc: "卓越した野球センスと華麗な守備が光る内野の司令塔。" },
                { name: "多田野", year: 2, position: "キャッチャー", desc: "「キング」成宮の女房役を射止めた2年生捕手。冷静なリードが持ち味。" },
                { name: "山岡", year: 3, position: "サード", desc: "稲実の新たな4番打者。勝負強いクラッチヒッター。高校通算61本。" }
            ]
        },
        "藤枝明誠": {
            summary: "史上最強の『黄金世代』。投打の柱・猪狩兄弟を擁し、個の力で世代の頂点を証明する。雑草軍団が狙うは完全優勝。スローガンは『実力主義』。",
            players: [
                { name: "猪狩 守", year: 3, position: "ピッチャー", desc: "「黄金世代」を率いるキャプテンにして絶対的エース。「ライジングキャノン」と呼ばれる剛速球が武器。" },
                { name: "猪狩 進", year: 2, position: "キャッチャー", desc: "兄・守とバッテリーを組む天才捕手。「球界の頭脳」と称されるリードと俊足が武器。" },
                { name: "三本松 一", year: 3, position: "ファースト", desc: "不動の4番。高校生離れしたパワーを誇る規格外の長距離砲。" },
                { name: "七井将暉", year: 3, position: "レフト", desc: "三本松と双璧をなす長距離砲。広角に打ち分ける技術と「バズーカ」強肩も。" },
                { name: "矢部 翔雄", year: 3, position: "センター", desc: "俊足が武器の外野手。意外な勝負強さも見せる。" }
            ]
        }
    };
    const INITIAL_TEAM_POOL = Object.keys(TEAM_DATA);

    // --- Utility & State Functions ---
   

 function shuffleArray(array) {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
    }
    
    function saveState() {
        try {
            localStorage.setItem('tournamentState', JSON.stringify(tournamentState));
        } catch (e) {
            console.error("進行状況の保存に失敗しました:", e);
            showAlert("進行状況の保存に失敗しました。ブラウザのストレージ容量が不足している可能性があります。");
        }
    }
    
    function uint8ArrayToBase64(bytes) {
        let binary = '';
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    function getRankFromHistoryString(historyString) {
        if (historyString.includes('優勝')) return 1;
        if (historyString.includes('準優勝')) return 2;
        if (historyString.includes('ベスト4')) return 4;
        if (historyString.includes('ベスト8')) return 8;
        if (historyString.includes('ベスト16')) return 16;
        if (historyString.includes('3回戦')) return 16;
        if (historyString.includes('2回戦')) return 32;
        if (historyString.includes('初戦敗退')) return 64;
        return 64;
    }

    function getRankString(rank) {
 // ★★★ このifブロックを関数の先頭に追加 ★★★
    if (rank <= -1) {
        for (const key in KOSHIEN_RESULTS) {
            if (KOSHIEN_RESULTS[key].rank === rank) {
                return KOSHIEN_RESULTS[key].label;
            }
        }
    }
    // ★★★ ここまで追加 ★★★
        if (rank === 1) return "優勝";
        if (rank === 2) return "準優勝";
        if (rank <= 4) return "ベスト4";
        if (rank <= 8) return "ベスト8";
        if (rank <= 16) return "ベスト16";
        if (rank <= 32) return "3回戦敗退";
        if (rank <= 64) return "2回戦敗退";
        return "初戦敗退";
    }
// --- Utility & State Functions --- などに追加

/**
 * Creates a subtle, realistic dust particle animation.
 */
function createDustEffect() {
    const container = document.getElementById('dust-container');
    if (!container) return;
    
    const particleCount = 20; // The number of dust particles

    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'dust-particle';
        
        const size = Math.random() * 3 + 1; // Particle size between 1px and 4px
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // Use CSS variables to randomize the start and end points of the animation
        particle.style.setProperty('--x-start', `${Math.random() * 100}vw`);
        particle.style.setProperty('--x-end', `${Math.random() * 100}vw`);
        
        particle.style.animationDuration = `${Math.random() * 20 + 10}s`; // Duration between 10s and 30s
        particle.style.animationDelay = `${Math.random() * 10}s`; // Stagger the start time
        
        container.appendChild(particle);
    }
}
/**
 * スコアボードの合計点を更新する
 */
/**
/**
 * スコアボードの合計点を更新する
 */
function updateTotalScores() {
    const table = document.getElementById('inning-score-table');
    if(!table) return;

    table.querySelectorAll('tbody tr').forEach(row => {
        const total = Array.from(row.querySelectorAll('input')).reduce((sum, input) => {
            const value = parseInt(input.value);
            return isNaN(value) ? sum : sum + value;
        }, 0);
        
        const totalCell = row.querySelector('.total-score');
        if (totalCell) {
            totalCell.textContent = total;
        }
    });
}
/**
 * 戦績レコードを読みやすい文字列に変換する
 */
function formatRecordToString(record) {
    if (!record) return "データなし";
    const year = record.year.toString().slice(-2);
    const tournamentNameMap = { summer: '夏', autumn: '秋', spring: '春' };
    const tournament = tournamentNameMap[record.tournament] || '';
    const rank = getRankString(record.rank);
    // ★★★ 以下の行を変更 ★★★
    const prefix = record.rank < 0 ? '' : '県大会'; // 甲子園成績の場合は「県大会」をつけない
    return `'${year} ${tournament}: ${prefix}${rank}`;
    // ★★★ ここまで変更 ★★★
}

// AI Content Generation & Helpers のセクションに追加

/**
 * チームの今大会の軌跡を要約する
 * (★試合ごとの記録を参照して、正確に猛打賞を判断する最終版)
 */
function getCurrentTournamentPerformance(teamName, currentMatchId) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) return "今大会初戦。";

    const path = [];
    const keyPerformances = new Set();
    const currentTournamentMatchIds = Object.keys(tournamentState.matches);

    for (const matchId of currentTournamentMatchIds) {
        if (matchId === currentMatchId) continue;
        const match = tournamentState.matches[matchId];
        
        if (match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            const opponent = match.team1 === teamName ? match.team2 : match.team1;
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 1;
            
            if (match.winner === teamName) {
                path.push(`${roundNum}回戦 vs ${opponent}`);
            }

            if (match.details) {
                const teamKey = match.team1 === teamName ? 'team1' : 'team2';
                
                // 投手の好投
                const pitchers = match.details.pitching?.[teamKey] || [];
                pitchers.forEach(p => {
                    if (p.name && p.result === 'W' && parseFloat(p.innings) >= 6) {
                        keyPerformances.add(`${p.name}が${roundNum}回戦で好投`);
                    }
                });

                // 保存された「試合ごとの成績」を参照して猛打賞を判断
                if (match.details.playerGameStats) {
                    const gameStats = match.details.playerGameStats[teamKey];
                    for (const playerName in gameStats) {
                        // この試合で3安打以上打っていたかをチェック
                        if (gameStats[playerName].h >= 3) {
                            keyPerformances.add(`${playerName}が${roundNum}回戦で猛打賞を記録`);
                        }
                    }
                }
            }
        }
    }
    
    let summary = "";
    if (path.length === 0) {
        return "今大会初戦。";
    } else {
        summary += `ここまでの勝ち上がり: ${path.join(' → ')}。`;
    }
    
    // 大会通算打率の分析
    const playerBattingStats = teamRecord.playerStats?.batting || {};
    for (const playerName in playerBattingStats) {
        const stats = playerBattingStats[playerName];
        if (stats.ab >= 5) { // 5打数以上の選手を対象
            const battingAverage = stats.h / stats.ab;
            if (battingAverage >= 0.4) {
                keyPerformances.add(`${playerName}が打率4割超えと絶好調`);
            } else if (battingAverage <= 0.2) {
                keyPerformances.add(`${playerName}が打率2割以下と不振`);
            }
        }
    }
    
    if (keyPerformances.size > 0) {
        summary += `今大会の主な活躍: ${Array.from(keyPerformances).join('、')}。`;
    }

    return summary;
}

// ▼▼▼ このブロックをまるごと追加 ▼▼▼

// ▼▼▼ この関数をまるごと追加 ▼▼▼
/**
 * 本格的なまとめサイトのHTMLを、現実と架空のニュースを融合させて生成する（エラー修正・ダミーデータ強化版）
 * @returns {Promise<string>} 生成されたHTML文字列
 */
/**
 * 本格的なまとめサイトのHTMLを、サーバーと通信して生成する（複数カテゴリ対応・最終版）
 * @returns {Promise<string>} 生成されたHTML文字列
 */
async function generateMatomeSiteHtml() {
    let articles = [];
    
    // --- 1. 強化されたサーバー機能に、現実のニュースをまとめてリクエスト ---
    try {
        const response = await fetch('/.netlify/functions/get-news');
        if (!response.ok) {
            throw new Error(`サーバーエラー: ${response.status}`);
        }
        const realNewsArticles = await response.json();
        articles.push(...realNewsArticles);

    } catch (e) {
        console.error("サーバーからのニュース取得に失敗しました:", e);
        articles.push({ headline: "【速報】ニュースサーバー、ダウン中", type: 'real', timestamp: Date.now(), category: 'システム' });
    }

    // --- 2. ゲーム内のニュースを取得 ---
    const gameNewsList = tournamentState.news || [];
    gameNewsList.filter(n => n.context && n.context.dbMatch).slice(-5).forEach(gameNews => {
        const { winnerName, loserName, dbMatch } = gameNews.context;
        const winnerRank = calculateRank(winnerName, tournamentState);
        const loserRank = calculateRank(loserName, tournamentState);
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        let gameTitle = `【高校野球】${winnerName}が${loserName}に勝利！`;

        if (rankValues[winnerRank] < rankValues[loserRank]) {
            gameTitle = `【超絶悲報】${loserName}(${loserRank}ランク)、格下の${winnerName}(${winnerRank}ランク)に負けるｗｗｗｗ`;
        } else if ((parseInt(dbMatch.score1) + parseInt(dbMatch.score2)) > 15) {
            gameTitle = `【乱打戦】${winnerName}vs${loserName}、とんでもない試合になる`;
        }
        
        articles.push({
            headline: gameTitle,
            type: 'game',
            matchId: dbMatch.id,
            timestamp: gameNews.timestamp,
            category: '高校野球'
        });
    });

    // --- 3. 全記事をタイムスタンプでソートしてHTMLを生成 ---
    articles.sort((a, b) => b.timestamp - a.timestamp);

    if (articles.length === 0) {
        return '<p class="text-center text-gray-500">まだ表示できるニュースがありません。</p>';
    }

    const categoryColors = {
        "高校野球": "bg-green-100 text-green-800",
        "スポーツ": "bg-blue-100 text-blue-800",
        "エンタメ": "bg-pink-100 text-pink-800",
        "国内": "bg-indigo-100 text-indigo-800",
        "国際": "bg-teal-100 text-teal-800",
        "経済": "bg-yellow-100 text-yellow-800",
        "IT": "bg-purple-100 text-purple-800",
        "科学": "bg-gray-200 text-gray-800",
        "主要": "bg-red-100 text-red-800",
    };

    return articles.map(article => {
        const time = new Date(article.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
        const commentCount = Math.floor(Math.random() * 800) + 50;
        const color = categoryColors[article.category] || "bg-gray-100 text-gray-800";

        // ▼▼▼ aタグのhref属性などを修正 ▼▼▼
        // ▼▼▼ このブロックが修正の核心です ▼▼▼
         // ▼▼▼ このブロックが修正の核心です ▼▼▼
        const linkHref = article.type === 'real' ? `href="${article.url}" target="_blank" rel="noopener noreferrer"` : 'href="javascript:void(0)"';
        const dataAttributes = `data-headline="${article.headline}" data-type="${article.type}" data-category="${article.category}" data-match-id="${article.matchId || ''}"`;

        return `
            <a ${linkHref} class="matome-article-link block p-3 rounded-lg hover:bg-gray-100 transition-colors" ${dataAttributes}>
                <div class="flex items-center text-xs text-gray-500">
                    <span class="font-bold py-0.5 px-2 rounded-full ${color}">${article.category}</span>
                    <span class="ml-auto">${time}</span>
                </div>
                <p class="font-bold text-gray-800 mt-2 text-base">${article.headline}</p>
                <div class="text-right text-xs text-gray-500 mt-1">コメント: ${commentCount} 💬</div>
            </a>
        `;
        // ▲▲▲
    }).join('');
}


/**
 * ゲーム内の試合結果に対する、なんJまとめサイト風のスレッドをAIに生成させる（★軽量化版・背番号情報あり★）
 */
async function generateGameMatchBbsComments(matchContext) {
    // contextから必要な基本情報を取り出す
    // rawBattingResults は受け取らない
    const { winnerName, loserName, dbMatch, matchId, playerStatsText, /* rawBattingResults, */ winnerJourney, loserJourney, nextOpponent, nextOpponentJourney, winnerLineupChanges, loserLineupChanges, highlights } = matchContext;

    // スコア、チーム情報、ランクなどを準備 (変更なし)
    const score = `${dbMatch.score1}-${dbMatch.score2}`;
    const winnerData = TEAM_DATA[winnerName];
    const loserData = TEAM_DATA[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, tournamentState.teamRecords[winnerName]);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, tournamentState.teamRecords[loserName]);
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);

    // 次戦相手情報を準備 (変更なし)
    let nextOpponentText = '次の相手は未定やな。';
    if (nextOpponent) {
        if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            nextOpponentText = `次の${nextOpponent.roundName}の相手は${nextOpponent.opponentName}(ランク:${nextOpponent.opponentRank})か。`;
        } else if (nextOpponent.decidingMatch) {
            const dm = nextOpponent.decidingMatch;
            nextOpponentText = `次の${nextOpponent.roundName}の相手は、${dm.team1}(${dm.rank1}ランク)と${dm.team2}(${dm.rank2}ランク)の勝者やな。`;
        }
    }
    const nextOpponentJourneyText = (nextOpponent && nextOpponentJourney) ? `ちなみに、その${nextOpponent.opponentName}のここまでの軌跡は「${nextOpponentJourney}」。` : '';

    // ハイライト情報をテキスト化 (変更なし)
    let highlightsText = '主な出来事はありませんでした。';
    if (highlights && highlights.length > 0) {
        highlightsText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
    }

    // ラウンド情報を抽出 (変更なし)
    let roundName = "不明なラウンド";
    if (matchId && matchId.includes('-R')) {
        const roundNum = parseInt(matchId.split('-')[1].slice(1));
        const finalRound = tournamentState.is16team ? 4 : 6;
        const roundNameMap = { [finalRound]: '決勝', [finalRound-1]: '準決勝', [finalRound-2]: '準々決勝' };
        if (tournamentState.currentTournament === 'spring' && tournamentState.springPhase === 'main_round2_onwards'){
             const springRoundMap = { 1: '2回戦', 2: '準々決勝', 3: '準決勝', 4: '決勝'};
             roundName = springRoundMap[roundNum] || `${roundNum}回戦`;
        }
        else if (tournamentState.currentTournament === 'autumn' && tournamentState.autumnPhase !== 'main') roundName = "地区予選/順位決定戦";
        else if (tournamentState.currentTournament === 'spring' && tournamentState.springPhase === 'main_round1') roundName = "県大会1回戦";
        else roundName = roundNameMap[roundNum] || `${roundNum}回戦`;
    } else if (matchId === 'bracket') {
        roundName = "組み合わせ決定時";
    }

    // ▼▼▼ プロンプトを修正 ▼▼▼
    const prompt = `あなたは、静岡県の高校野球を観戦している、なんJの野球ファンです。
以下の試合データに基づき、ファンたちのリアルな会話コメントを**25〜30個**生成してください。

### 現在の試合状況
- **大会:** ${tournamentState.tournamentYear}年度 ${tournamentNameMap[tournamentState.currentTournament] || '大会'}
- **ラウンド:** ${roundName}

### 参考情報：高校野球における背番号の意味
- [#1]: チームの絶対的エース投手。
- [#2-9]: 基本的にレギュラーの野手陣（正捕手、内野手、外野手）。
- [#10], [#11]: エースに次ぐ控え投手。
- [#12]以降: 控え選手。時に監督の秘蔵っ子や、期待の1・2年生が含まれる。

### データ1：試合結果
- **勝利:** ${winnerName} (ランク: ${winnerRank})
- **敗北:** ${loserName} (ランク: ${loserRank})
- **スコア:** ${score}
// ▼▼▼ この行を追加 ▼▼▼
${matchContext.calledGame ? `- **特記事項:** ${matchContext.calledInning}回コールドゲーム` : ''}
// ▲▲▲ 追加ここまで ▲▲▲
- **ユーザーによる試合の決め手:** ${dbMatch.summary || '特になし'}

### データ2：チームの背景
- **${winnerName}**: ${winnerDynamicInfo}
- **${loserName}**: ${loserDynamicInfo}

### データ3：この試合の個人成績 (最終結果の要約)
${playerStatsText || '個人成績データはありません。'}

### データ4：試合の主な出来事 (ハイライト)
${highlightsText}

### データ5：トーナメント全体の状況
- **${winnerName}の軌跡(勝ち上がり)**: ${winnerJourney || '今大会初戦'}
- **次の試合**: ${nextOpponentText} ${nextOpponentJourneyText}

### 指示
あなたは今、上記の全データを眺めながら、他のファンと会話しています。**現在の試合が「${roundName}」であること**、**勝者の軌跡**、**次の試合情報**を踏まえつつ、以下の点をコメントに含めてください。

- **【最重要：次戦情報】**: 「データ5」の**\`次の試合:\`** に書かれている情報を**必ず**コメントに含めてください。「次は〇〇か…」のように具体的に言及し、**「未定」という言葉は絶対に使わないでください。**
- **【試合への反応】**:
    - 試合結果（スコア、勝敗）に対する感想。
    - 「データ3（個人成績）」や「データ4（ハイライト）」で目立った選手やプレーへの言及。**特に「データ3」に記載されている選手の背番号にも触れ、その意味合い（エース、レギュラー、控えなど）を考慮したコメントをすること。**
    - もし敗北チームが善戦した場合 (スコア差が小さい、ランク差があるのに接戦など) は、その健闘を称えるコメント。
- **【その他】**:
    - なんJらしい短い煽りや草(w)を適度に含める。
    - 他のコメントへの安価 (>>) をいくつか含める。
    - ランク名を言い換える（A→名門、B→強豪、C→中堅、D→挑戦校、E→無名校）。
** #は背番号と言い換えてください。(例　#1→背番号1)
// ▼▼▼ この指示を追加 ▼▼▼
- **【コールドゲームの場合】**: もし試合がコールドで終了した場合、その圧勝ぶりや大差がついたことについて、キャラクターに応じた反応（称賛、煽り、驚きなど）をコメントに含めてください。
// ▲▲▲ 追加ここまで ▲▲▲

### 出力形式【最重要】
解説や前置きは一切不要です。**必ず以下の JSON 配列形式 (\`[...]\`) のみ**で出力してください。
\`\`\`json
[
  {"personality": "1: 風吹けば名無し", "comment": "（生成したコメント1）"},
  {"personality": "2: 風吹けば名無し", "comment": "（生成したコメント2）"},
  // ... (合計25〜30個のコメント) ...
]
\`\`\`
`; // ← ここでバッククォートを閉じる
    // --- AIへのリクエスト部分は変更なし ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            // AIが指示通り配列を返したかチェック
            if (Array.isArray(commentsJson)) {
                // 成功：コメント配列をそのまま返す
                return commentsJson.map((c, index) => ({
                    id: crypto.randomUUID(),
                    personality: c.personality || `${index + 1}: 風吹けば名無し`,
                    text: c.comment,
                    timestamp: Date.now() + index * 10,
                    replies: []
                }));
            } else {
                // AIがオブジェクト形式 ({title:..., comments:...}) で返してしまった場合のフォールバック
                console.warn("AIが予期しないオブジェクト形式でBBSコメントを返しました。中身を取り出します。");
                if (commentsJson && commentsJson.comments && Array.isArray(commentsJson.comments)) {
                     return commentsJson.comments.map((c, index) => ({
                        id: crypto.randomUUID(),
                        personality: c.personality || `${index + 1}: 風吹けば名無し`,
                        text: c.comment,
                        timestamp: Date.now() + index * 10,
                        replies: []
                    }));
                }
            }
        }
        // AIの応答が期待した形式でなかった場合、エラーを投げる
        throw new Error("AIからの応答が、正しいコメント配列形式ではありません。");
    } catch (error) {
        // エラーが発生した場合の処理
        console.error("AI game match BBS generation failed (lightweight w/ number):", error);
        // エラー情報を含むオブジェクトを返す
        return {
            error: true,
            title: "掲示板コメント生成エラー(軽量版)",
            body: "AIによるコメント生成に失敗しました。",
            timestamp: Date.now(),
            errorId: `error-${matchId}-bbs-lw`,
            context: matchContext
        };
    }
}

/**
 * 現実のニュースヘッドラインに対する、なんJ風の掲示板コメントをAIに生成させる
 * @param {string} headline - 現実のニュースの見出し
 * @param {string} category - ニュースのカテゴリ
 * @returns {Promise<Array|null>} コメントオブジェクトの配列
 */
async function generateRealNewsBbsComments(headline, category) {
    let personaPrompt = `あなたは、日本の匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは少し皮肉屋で、ネットスラングを多用し、あらゆる話題に短いコメントを書き込みます。`;
    let instructions = ``;
    switch (category) {
        case '政治': instructions = `政治ニュースに詳しい住民として、与党や野党を煽ったり、将来を悲観したり、達観したようなコメントをしてください。`; break;
        case '芸能': instructions = `芸能ニュースが大好きな野次馬として、「〇〇ロスだわ」「どうせすぐ別れる」といった、お祝いと嫉妬が入り混じったコメントをしてください。`; break;
        case '学歴': instructions = `学歴コンプレックスを持つ住民として、「F欄のワイ、高みの見物」「結局は学歴よりコミュ力」といった、自虐や持論を展開してください。`; break;
        default: instructions = `一般的な住民として、ニュースに反応してください。`; break;
    }
    
    const prompt = `${personaPrompt}

以下の【${category}】のニュースヘッドラインについて、**リアルタイムでスレッドが進行していくかのように**、自然な流れで**30〜35個**の掲示板の反応を生成してください。

### ニュースヘッドライン
${headline}

### スレッド進行の指示
1.  **序盤 (1〜5レス):** スレ主の投稿に対し、即座に食いつく第一陣の反応。「マジか」「草」「また〇〇か」といった短いコメントが中心。
2.  **中盤 (6〜15レス):** 少し冷静になった住民たちが、ニュースに対して様々な角度からコメントを始める。肯定、否定、煽り、全く関係ない脱線などを織り交ぜる。**「>>1」「>>5」のような安価（アンカー）を使って、他のコメントに返信するやり取りを必ず含めること。**
3.  **終盤 (16レス以降):** ある程度議論が出尽くした後の、まとめのようなコメントや、飽きてきた住民によるおふざけが始まる。
4.　**最終盤 (26レス以降):** スレも混沌としてきて、関係ない話題を持ってくる者や、勝手にコンプレックスを刺激され発狂するもの、ただの荒らしなどが湧き始め、グダグダになり解散する。


### 出力形式（JSON配列）
[
    {"personality": "1: 風吹けば名無し", "comment": "（スレ主のコメント）"},
    {"personality": "2: 風吹けば名無し", "comment": "（住民2のコメント）"},
    {"personality": "3: 風吹けば名無し", "comment": "（住民3のコメント）"},
    ...
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now()
                }));
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI real news BBS generation failed:", error);
        return null;
    }
}
// ▲▲▲ ここまで追加 ▲▲▲

// ▲▲▲ ここまで追加 ▲▲▲

/**
 * 指定されたチームが次に出場する、まだ終わっていない試合を探す
 * @param {string} teamName - 探したいチーム名
 * @param {object} state - 現在のtournamentState
 * @returns {object|null} - 見つかった試合オブジェクト、またはnull
 */
function findCurrentMatchForTeam(teamName, state) {
    const allMatches = { ...state.matches, ...(state.autumnData?.allMatches || {}), ...(state.springData?.allMatches || {}) };
    let earliestMatch = null;
    let minRound = Infinity;

    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (!match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 0;
            if (roundNum < minRound) {
                minRound = roundNum;
                earliestMatch = match;
            }
        }
    }
    return earliestMatch;
}



/**
 * トーナメントの勝者を次のラウンドに進める（processMatchWinから抜粋・改造）
 * @param {object} match - 終了した試合のオブジェクト
 * @param {string} winnerName - 勝者名
 * @param {object} state - 現在のtournamentState
 */
function advanceWinnerToNextRound(match, winnerName, state) {
    const matchId = match.id;
    const idParts = matchId.split('-');
    const side = idParts[0];

    if (side === 'F') return; // 決勝戦なら何もしない

    const roundStr = idParts[1];
    const roundNum = parseInt(roundStr.slice(1));
    
    // このロジックは夏季・春季県大会（16 or 64チーム）を想定
    if (state.teams && state.teams.length > 0) {
        const numTeamsInTournament = state.teams.length;
        const finalRound = Math.log2(numTeamsInTournament);

        if (roundNum < finalRound) {
            const matchNum = parseInt(idParts[2].slice(1));
            const nextRoundNum = roundNum + 1;
            let nextMatchId = (nextRoundNum === finalRound) ? 'F-R1-M1' : `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
            
            if (!state.matches[nextMatchId]) {
                state.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
            }
            let slot = (nextRoundNum === finalRound) ? (side === 'L' ? 1 : 2) : (matchNum % 2 !== 0 ? 1 : 2);
            state.matches[nextMatchId][`team${slot}`] = winnerName;
        }
    }
    // TODO: 秋季大会などの複雑な進行ロジックが必要な場合は、ここに追加する
}

// ▲▲▲ ここまで追加 ▲▲▲


/**
 * 密着ドキュメンタリーを開始し、序章の記事を生成する
 * @param {'underdog' | 'powerhouse'} type - ドキュメンタリーの種類
 * @param {string} teamName - 取材対象のチーム名
 */
async function startDocumentary(type, teamName) {
    tournamentState.documentary = { target: teamName, type: type };
    newsContainer.innerHTML = `<div class="loader">AI記者が「${teamName}」の特別ドキュメンタリー番組の制作を開始しました...</div>`;
    
    renderTournament(tournamentState); 

    const firstMatch = Object.values(tournamentState.matches).find(m => 
        m.id.includes('-R1-') && (m.team1 === teamName || m.team2 === teamName)
    );
    
    let matchDataForArticle = { 
        opponent: '不明', opponentRank: 'E', opponentRecord: '情報なし',
        toughestRival: '不明', toughestRivalRecord: '情報なし'
    };

    if (firstMatch) {
        const opponentName = firstMatch.team1 === teamName ? firstMatch.team2 : firstMatch.team1;
        matchDataForArticle.opponent = opponentName;
        matchDataForArticle.opponentRank = calculateRank(opponentName, tournamentState);
        
        // ▼▼▼ ここからが新しい処理 ▼▼▼
        // 相手の昨年の成績をTEAM_DATAから直接取得
        matchDataForArticle.opponentRecord = TEAM_DATA[opponentName]?.last || '情報なし';

        const teamIndex = tournamentState.teams.indexOf(teamName);
        const blockIndex = Math.floor(teamIndex / 16);
        const blockStart = blockIndex * 16;
        const blockEnd = blockStart + 16;
        const blockTeams = tournamentState.teams.slice(blockStart, blockEnd);
        
        let toughestRivalName = null;
        let highestRankValue = -1;
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };

        blockTeams.forEach(rivalName => {
            if (rivalName === teamName) return;
            const rivalRank = calculateRank(rivalName, tournamentState);
            if (rankValues[rivalRank] > highestRankValue) {
                highestRankValue = rankValues[rivalRank];
                toughestRivalName = rivalName;
            }
        });
        
        if (toughestRivalName) {
            matchDataForArticle.toughestRival = toughestRivalName;
            // 最強ライバルの昨年の成績もTEAM_DATAから直接取得
            matchDataForArticle.toughestRivalRecord = TEAM_DATA[toughestRivalName]?.last || '情報なし';
        }
        // ▲▲▲
    }
    
    const article = await generateDocumentaryArticle('intro', type, teamName, matchDataForArticle);
    
    // ▲▲▲

    if (article) {
        tournamentState.news.push(article);
    } else {
        // 失敗した場合、再生成に必要な情報を「context」として保存する
        tournamentState.news.push({
            title: "ドキュメンタリー記事生成エラー",
            body: `「${teamName}」のドキュメンタリー記事の生成に失敗しました。`,
            timestamp: Date.now(),
            error: true,
            // ★★★ ここからが重要 ★★★
            context: {
                isDocumentary: true, // ドキュメンタリーであるという目印
                type: type,
                teamName: teamName,
                matchData: matchDataForArticle
            }
            // ★★★ ここまで ★★★
        });
    }
    renderNews(tournamentState.news);
    saveState();
}


async function generateDocumentaryArticle(phase, type, teamName, matchData = null, userFeedback = null) {
    const teamMasterData = TEAM_DATA[teamName];
    let prompt = `あなたは、情熱的で人間ドラマを描くのが得意なドキュメンタリー番組の記者です。あなたは今、高校野球チーム「${teamName}」に密着取材しています。`;
    let title = "";

    let charactersPrompt = `### 主な登場人物\n- 監督: ${teamMasterData.coach.name} (${teamMasterData.coach.style})\n`;
    if (DETAILED_TEAM_DATA[teamName]) {
        const detailedData = DETAILED_TEAM_DATA[teamName];
        const keyPlayers = detailedData.players.map(p => `- ${p.name}(${p.year}年, ${p.position}): ${p.desc}`).join('\n');
        charactersPrompt += `### 注目選手\n${keyPlayers}\n`;
    }
    
    let feedbackPrompt = '';
    if (userFeedback) {
        if (userFeedback.include && userFeedback.include.trim() !== '') {
            feedbackPrompt += `\n- **【最重要指示】** 以下の要素を必ず記事の中心に据えて、最もドラマチックに描写してください：\n${userFeedback.include}\n`;
        }
        if (userFeedback.exclude && userFeedback.exclude.trim() !== '') {
            feedbackPrompt += `\n- **【厳禁事項】** 以下の要素や表現は、絶対に記事に含めないでください：\n${userFeedback.exclude}\n`;
        }
    }
    const finalFeedbackPrompt = `\n### ディレクターからの追加指示\n${feedbackPrompt || '特になし'}`;

    // ==================================================================
    // --- 1. 古豪復活チーム (powerhouse_revival) ---
    // ==================================================================
    if (type === 'powerhouse_revival') {
        switch (phase) {
            case 'intro':
                title = `『${teamName}、復活への序曲』`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 1) { // 格上
                        reactionPrompt = `
5.  **【試練の初戦】**
    初戦の相手が格上の「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちが「不足はない相手」「復活をアピールするには最高の相手だ」と闘志を燃やす。
6.  **【監督の『建前』と『本音』】**
    監督は**選手たちの前で**、「挑戦者として、失うものは何もない。全力でぶつかるぞ」という趣旨で語る。
    しかし記者の前では**二人きりで**、「本当の山場は**${matchData.toughestRival}**戦でしょう。彼らは昨年${matchData.toughestRivalRecord}。この初戦は、そこへ向けてチームがどれだけ成長できるかの試金石ですね」という趣旨で、冷静に先を見据える。`;
                    } else { // 同格か格下
                        reactionPrompt = `
5.  **【油断という名の敵】**
    初戦の相手が「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。「勝てる」という安堵の空気が選手たちの間に流れる。
6.  **【監督の『建前』と『本音』】**
    その空気を察した監督が**選手たちの前で**、「油断が一番の敵だ。俺たちはまだ何も成し遂げていない」という趣旨で厳しく一喝する。
    しかし、記者の前では**二人きりで**、「正直、ホッとしました。**${matchData.toughestRival}**（彼らは昨年${matchData.toughestRivalRecord}）と当たるまでに、いくつか試合をこなして練度を上げたかったので」という趣旨で、安堵の理由が戦略的なものであることを明かす。`;
                    }
                }
                prompt += `
### 取材テーマ
かつて黄金時代を築いた古豪「${teamName}」が、失われた栄光を取り戻すべく挑む夏を追う。過去、現在、そして未来が交錯する物語の序章を描いてください。
${charactersPrompt}
### 構成案
1.  **【埃をかぶった優勝旗】**: 部室に眠る色褪せた優勝旗やトロフィーの描写から始める。過去の栄光の重圧と、現在のチームが置かれた状況（${teamMasterData.info}）を対比させる。
2.  **【OBたちの熱き眼差し】**: 練習を厳しい目で見つめるOB会長に「俺たちの時代は…」という昔語りと、現在のチームへの歯がゆさ、そして心の底にある期待を語らせる。
3.  **【重圧を背負う主将】**: 主将に「このユニフォームを着て戦うことの意味」を問う。伝統の重みと、それを力に変えようとする彼の覚悟を描写する。
4.  **【監督の信念と現実】**: 監督に「古豪復活への道筋」をインタビューする。OBからのプレッシャーの中で、彼が信じる今の選手たちの可能性と、現在の課題について語らせる。
${reactionPrompt}
7.  **【新たな歴史へ】**: 主将の「俺たちは俺たちの野球で、新しい歴史を作るだけ」という言葉で、復活をかけた夏の始まりを力強く宣言して締めくくる。
### 描写のポイント
- 時間軸の意識: 「過去の栄光」「現在の葛藤」「未来への挑戦」を意識し、物語に深みを与えること。
- 建前と本音: 監督の二面性を描くことで、キャラクターのリアリティを追求すること。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、復活への第一歩』`;
                prompt += `
### 取材テーマ
古豪「${teamName}」が ${matchData.opponent} との試合に ${matchData.score} で勝利しました。「名門復活への狼煙」となるこの一勝の価値を、感動的に描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」を物語の中心に据え、その場面を最もドラマチックに描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、この勝利の価値をより高める。
3.  監督に「伝統の粘り強さが出せた」という趣旨のコメントをさせる。
4.  主将に、次戦への意気込みと共に「先輩たちが築いた歴史に、新たな1ページを刻みたい」と語らせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、夢、またも届かず』`;
                prompt += `
### 取材テーマ
古豪「${teamName}」の夏が終わりを告げた。復活を願った人々の期待と、それに応えられなかった選手たちの無念さを描いてください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにしてチームの夢を打ち砕いたかを詳細に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、敗北の文脈をより深く描写する。
3.  グラウンドに泣き崩れる選手たちと、彼らにかける言葉が見つからない監督の姿。
4.  「彼らの挑戦は終わった。しかし、〇〇（校名）の野球部の灯が消えることはない」と、未来への希望で締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } 
    // ==================================================================
    // --- 2. 絶対的エースチーム (one_man_team) ---
    // ==================================================================
    else if (type === 'one_man_team') {
        switch (phase) {
            case 'intro':
                title = `『${teamName}のエースと、8人の仲間たち』`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 2) { // 絶望的な格上
                        reactionPrompt = `
5.  **【試される『個』の力】**
    初戦の相手が格上の強豪「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。野手たちが動揺する中、エースだけが「相手が誰であろうと、俺がゼロに抑えるだけです」という趣旨のコメントで闘志を燃やす。
6.  **【監督の『建前』と『本音』】**
    監督は**選手たちの前で**、「最高の相手だ。我々には〇〇（エース名）がいる。彼を信じろ」という趣旨のコメントで、エースへの絶対的な信頼を口にする。
    しかし記者の前では**二人きりで**、「正直、最悪のクジです。彼（エース）の負担を考えれば、勝ち進んだ先の**${matchData.toughestRival}**（昨年${matchData.toughestRivalRecord}）戦まで、他の選手に経験を積ませたかった」という趣旨のコメントで、チーム全体の成長を願う本音を漏らす。`;
                    } else { // 同格か格下
                        reactionPrompt = `
5.  **【エース温存か、否か】**
    初戦の相手が「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちの間に「この相手なら、エース抜きでも勝てるのでは？」という慢心が生まれる。
6.  **【監督の『賭け』】**
    監督が**選手たちの前で**、「初戦、〇〇（エース名）は投げない。お前たちで勝ち上がってこい」という趣旨の、非情とも思える決断を下す。
    記者の前では**二人きりで**、「これは賭けです。でも、**${matchData.toughestRival}**（昨年${matchData.toughestRivalRecord}）と戦うことを見据えれば、ここで他の選手が覚醒しなければ未来はない」という趣旨のコメントで、エースの将来とチームの未来を想う本音を語らせる。`;
                    }
                }
                prompt += `
### 取材テーマ
プロ注目の絶対的エースを擁する「${teamName}」。天才の苦悩と、彼を支える「その他大勢」と呼ばれた仲間たちのプライドを描く。
${charactersPrompt}
### 構成案
1.  **【殺到する報道陣】**: 練習グラウンドに集まる、エースだけを狙う無数のカメラの描写から始める。
2.  **【エースの孤独なマウンド】**: エースにインタビュー。「チームを勝たせるのが自分の仕事」と語る彼の言葉の裏にある、重いプレッシャーを描写する。
3.  **【名もなき脇役たちの意地】**: メディアからは注目されない他の野手たちに焦点を当てる。「俺たちは、あいつの引き立て役じゃない」という、彼らの静かなプライドと葛藤を引き出す。
4.  **【監督の信念】**: 監督に「彼らはワンマンチームですか？」と問う。「世間はそう言うだろう。だが、本当の主役が誰なのかを私だけは知っている」という趣旨の意味深な言葉を語らせる。
${reactionPrompt}
7.  **【一つのチームとして】**: 野手の一人が「俺たちが、あいつを甲子園のマウンドに連れて行く」と力強く宣言し、物語を締めくくる。
### 必ず含めるべき要素
- **チームが抱える状況を描写すること: ${teamMasterData.info}**
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `エース快投！しかし、勝利の影に${teamName}の結束あり`;
                prompt += `
### 取材テーマ
「${teamName}」が勝利。メディアはエースの快投ばかりを報じるだろう。しかし、その裏にあった仲間たちのファインプレーやチームの結束こそが真の勝因だったことを、あなたの視点で深く描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにチームの結束力を象徴するプレーだったかを物語の中心に据える。
2.  エースの投球内容を簡潔に紹介しつつ、「しかし、この日の主役は彼だけではなかった」と続ける。
3.  そのプレーをした選手に「エースを助けるのが俺たちの仕事ですから」と、誇らしげに語らせる。
4.  エースに「今日の勝利は、俺一人の力じゃない。みんなが守ってくれたおかげです」と、初めて仲間に感謝の言葉を述べさせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `英雄、あまりに早すぎる敗退。${teamName}の夏、終わる`;
                prompt += `
### 取材テーマ
絶対的エースを擁しながら、「${teamName}」は敗れた。天才と仲間たちの、残酷で、しかし美しい夏の終わりを描いてください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにして絶対的エースを打ち崩したのか、その一瞬を詳細に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れることで、敗北の衝撃を際立たせる。
3.  マウンドで呆然とするエースと、彼に駆け寄り「お前のせいじゃない」と声をかける仲間たちの姿を描く。
4.  「彼らはワンマンチームではなかった。勝つ時も、負ける時も、彼らは一つのチームだった」と締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } 
    // ==================================================================
    // --- 3. 強豪校 (powerhouse) ---
    // ==================================================================
    else if (type === 'powerhouse') {
        switch (phase) {
            case 'intro':
                title = `『${teamName}、王者の告白』序章`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 0) { // 同格か格上
                        reactionPrompt = `
5.  **【試される王国】**
    初戦の相手がいきなり実力校「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちの間に走る緊張感を「歓迎すべき試練」として描写する。
6.  **【監督の『建前』と『本音』】**
    監督は**選手たちの前で**、「初戦から最高の相手だ。挑戦者を受ける覚悟はできている」という趣旨で、チームのプライドを煽る。
    しかし記者の前では**二人きりで**、「厳しい戦いになる。だが、このブロックの本命は我々と**${matchData.toughestRival}**。彼らは昨年${matchData.toughestRivalRecord}。倒すためには、どこかで通らなければいけない道だ」という趣旨で、厳しい本音を語らせる。`;
                    } else { // 格下
                        reactionPrompt = `
5.  **【王者の静寂】**
    初戦の相手が「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちは表情一つ変えず、淡々と次の練習の準備を始める。
6.  **【監督の『建前』と『本音』】**
    監督が**選手たちの前で**は「油断するな」という趣旨で引き締めつつ、記者の前では**二人きりで**、「初戦は問題ない。本当の勝負は**${matchData.toughestRival}**戦。彼らは昨年${matchData.toughestRivalRecord}の実力校だ。そこが事実上の決勝戦になるだろう」という趣旨で、先を見据えた分析を語らせる。`;
                    }
                }
                prompt += `
### 取材テーマ
絶対的王者「${teamName}」の栄光の裏に隠された苦悩と、常人には理解しがたいプレッシャーを描く。
${charactersPrompt}
### 構成案
1.  **【静寂のトロフィー室】**: 無数に並ぶ優勝トロフィーが放つ輝きと、「勝って当然」という重圧を描写する。
2.  **【Bグラウンドの陽炎】**: ベンチ入りできなかった3年生が、最後の夏にも関わらず、黙々と後輩へのサポートを務める。彼の「チームへの愛」と「諦め」の独白を引き出す。
3.  **【監督の非情な勝負論】**: 監督にインタビュー。「勝つためには、時に非情にならなければならない。それが王者であり続けるということだ」という彼の哲学を語らせる。
4.  **【主将の孤独な背中】**: スター選手揃いのチームを一つにまとめることの難しさと、「負けることが許されない」という王者ならではの孤独な覚悟を主将に語らせる。
${reactionPrompt}
7.  **【王者、出陣】**: 主将が「俺たちの目標は、県大会優勝じゃない。その先にある」と、全国の頂点だけを見据えていることを示唆して締めくくる。
### 必ず含めるべき要素
- **チームが抱える状況を描写すること: ${teamMasterData.info}**
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、王者の告白』第${matchData.round}章`;
                prompt += `
### 取材テーマ
「${teamName}」が勝利。しかし彼らにとってこの勝利は歓喜ではなく、「次へ進むための義務」でしかない。その独特の空気感をリアルに描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」を引用し、それが王者としての力の証明であったことを示す。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、勝利が順当であったことを描写する。
3.  試合後、安堵の表情を浮かべるも、決して喜びを爆発させない選手たちの姿。
4.  監督に「今日のプレーで満足せず、次を見据えている」という趣旨の、冷静なコメントをさせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、王者の告白』最終章`;
                prompt += `
### 取材テーマ
絶対的王者「${teamName}」の夏が終わった。王国の崩壊の瞬間と、選手たちの初めて見せる涙、そして重圧からの解放を感傷的に記録してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにして絶対王者の歯車を狂わせたのか、その瞬間を克明に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、この敗戦が歴史的な番狂わせであることを強調する。
3.  試合終了のサイレンが鳴り響く、球場の信じられないような静寂を描写する。
4.  これまで常に気丈に振る舞ってきた主将が、初めてグラウンドに泣き崩れる姿に焦点を当てる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } 
    // ==================================================================
    // --- 4. 逆境チーム (underdog) ---
    // ==================================================================
    else { 
        switch (phase) {
            case 'intro':
                title = `『${teamName}、魂の記録』序章`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 2) { // 絶望的な格上
                        reactionPrompt = `
3.  **【残酷な現実、そして監督の『建前』】**
    初戦の相手が格上の強豪「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。絶望と沈黙に包まれる選手たち。
    その重い空気の中、監督が**選手たちの前で**「これは試練だ。だが、歴史を創るチャンスでもある」という趣旨の力強い言葉でチームを奮い立たせる。
4.  **【監督室の『本音』】**
    記者が二人きりで監督に心境を聞くと、「いや、正直しんどいですよ…笑っちゃいましたもん、まさか〇〇（相手校名）と当たるなんて…」という趣旨の、人間味あふれる弱音や本音を漏らす。`;
                    } else if (rankDiff >= 1) { // 少し格上
                        reactionPrompt = `
3.  **【挑戦者たち】**
    初戦の相手が、格上の「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちが「不足はない相手」「一泡吹かせてやる」と闘志を燃やす。
4.  **【監督の戦略】**
    監督は**選手たちの前で**「良い顔つきになったな」と彼らの士気を高めつつ、記者の前では**二人きりで**、「正直、勝率は3割もないでしょう。でも、高校野球は何が起こるか分からない」という趣旨で、冷静な分析と本音を語る。`;
                    } else { // 同格か格下
                        reactionPrompt = `
3.  **【運命の初戦】**
    初戦の相手が実力の近い「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。「勝てる！」と少し浮足立つ選手たち。
4.  **【監督の『建前』と『本音』】**
    監督が**選手たちの前で**「油断が一番の敵だ」と厳しく一喝する一方、記者の前では**二人きりで**、「最高のクジを引きました。ここを勝てば、間違いなくチームは波に乗れる」という趣旨で、安堵とプレッシャーが入り混じった本音を語る。`;
                    }
                }
                prompt += `
### 取材テーマ
「${teamName}」が抱える困難な状況と、それでも夢を諦めない彼らの姿を描く。
${charactersPrompt}
### 構成案
1.  **【チームの現在地】**: 記者がチームの元を訪れる場面から始める。監督や選手にインタビューし、チームが抱える具体的なハンデ（例：${teamMasterData.info}）と、それに対する彼らの想いを明らかにする。
2.  **【地域との絆】**: チームを支える地元の人々（例：商店街の店主、OBなど）にも話を聞き、地域にとってこのチームがどのような存在であるかを描写する。
${reactionPrompt}
5.  **【決意表明】**: 最後に、主将が大会へ向かう決意を語り、締めくくる。
### 必ず含めるべき要素
- **チームが抱える状況を描写すること: ${teamMasterData.info}**
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、魂の記録』第${matchData.round}章`;
                prompt += `
### 取材テーマ
「${teamName}」が、奇跡的な勝利を収めた。この一勝が彼らにとってどれほど大きな意味を持つのか、感動的に描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」を、この試合で起きた奇跡の象徴として、最も感動的に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、この勝利がどれほどの金星であったかを伝える。
3.  勝利の瞬間、子供のように抱き合って泣く選手たちの姿を描写する。
4.  この勝利を見届けた地元の人々の、我が事のような喜びの声を加える。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、魂の記録』最終章`;
                prompt += `
### 取材テーマ
「${teamName}」の夏が終わった。夢破れた彼らの姿と、それでも確かに残ったものを描くドキュメンタリー最終章。
### 対戦相手「${teamName}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」に触れ、あと一歩及ばなかった彼らの奮闘を称える。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、「よくやった」「悔しい」といった感情を増幅させる。
3.  試合終了の瞬間、泣き崩れるも、やがて顔を上げ、相手にエールを送る選手たちの姿を描写する。
4.  3年生の引退と、彼らの想いが後輩たちへと受け継がれていくことを示唆して、物語を締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    }
    
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) return { ...article, timestamp: Date.now() };
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI documentary article generation failed:", error);
        return null;
    }
}

/**
 * Sets the weather effect for the background.
 * @param {'none' | 'rain' | 'sun'} weatherType - The type of weather to display.
 */
function setWeather(weatherType) {
    const rainContainer = document.getElementById('rain-container');
    const sunContainer = document.getElementById('sun-container');

    // Hide all weather effects first
    rainContainer.classList.add('hidden');
    sunContainer.classList.add('hidden');
    rainContainer.innerHTML = ''; // Clear old raindrops

    if (weatherType === 'rain') {
        rainContainer.classList.remove('hidden');
        // Create 100 raindrops
        for (let i = 0; i < 100; i++) {
            const drop = document.createElement('div');
            drop.className = 'drop';
            drop.style.left = Math.random() * 100 + 'vw';
            drop.style.animationDelay = Math.random() * 0.5 + 's';
            drop.style.animationDuration = Math.random() * 0.2 + 0.3 + 's';
            rainContainer.appendChild(drop);
        }
    } else if (weatherType === 'sun') {
        sunContainer.classList.remove('hidden');
    }
}

/**
 * 詳細入力モーダル内のチームデータ、またはチーム名自体を入れ替える
 * @param {string} matchId - 対象の試合ID
 */
function swapTeamDetails(matchId) {
    const match = findMatchById(matchId);
    if (!match) return;

    // 1. チーム名と、トーナメント表に表示されているスコアを入れ替える
    const tempTeam = match.team1;
    match.team1 = match.team2;
    match.team2 = tempTeam;

    const tempScore = match.score1;
    match.score1 = match.score2;
    match.score2 = tempScore;

    // 2. もし詳細データが入力済みなら、その中身も入れ替える
    if (match.details) {
        // 打撃データを入れ替え
        const tempBatting = match.details.batting.team1;
        match.details.batting.team1 = match.details.batting.team2;
        match.details.batting.team2 = tempBatting;

        // 投手データを入れ替え
        const tempPitching = match.details.pitching.team1;
        match.details.pitching.team1 = match.details.pitching.team2;
        match.details.pitching.team2 = tempPitching;
        
        // イニングスコアを入れ替え
        if (match.details.inningScore) {
            const tempInningScore = match.details.inningScore.team1;
            match.details.inningScore.team1 = match.details.inningScore.team2;
            match.details.inningScore.team2 = tempInningScore;
        }
    }

    // 3. 変更を保存し、画面を更新する
    saveState();
    renderTournament(tournamentState); // トーナメント表も更新
    openDetailsModal(matchId); // モーダルを再描画して変更を反映
}
/**
 * チームステータスモーダルを表示する
 */
function showTeamStatusModal(teamName) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) return;

    // モーダルの要素を取得
    const modal = document.getElementById('team-status-modal');
    const bestEl = document.getElementById('status-modal-best');
    const historyEl = document.getElementById('status-modal-history');
    const traitsEl = document.getElementById('status-modal-traits');
    // ↓↓↓ おそらく抜けていたのがこの一行です ↓↓↓
    const coachEl = document.getElementById('status-modal-coach'); 

    // チーム名を設定
    document.getElementById('status-modal-team-name').textContent = teamName;
    
    // 最高戦績を設定
    bestEl.textContent = teamRecord.best ? formatRecordToString(teamRecord.best) : 'まだありません';

    // 直近の成績を設定
    historyEl.innerHTML = '';
    if (teamRecord.history && teamRecord.history.length > 0) {
        teamRecord.history.slice(0, 2).forEach(rec => {
            const p = document.createElement('p');
            p.textContent = formatRecordToString(rec);
            historyEl.appendChild(p);
        });
    } else {
        historyEl.innerHTML = '<p>まだありません</p>';
    }

    // 称号を設定
    traitsEl.innerHTML = '';
    if (teamRecord.teamTraits && teamRecord.teamTraits.length > 0) {
        teamRecord.teamTraits.forEach(traitId => {
            const trait = TITLES[traitId];
            if (trait) {
                const span = document.createElement('span');
                span.className = 'bg-blue-100 text-blue-800 text-xs font-semibold px-2.5 py-0.5 rounded-full';
                span.textContent = trait.name;
                traitsEl.appendChild(span);
            }
        });
    } else {
        traitsEl.innerHTML = '<p class="text-gray-500 text-sm">なし</p>';
    }
    
    // 監督情報を設定
    const teamMasterData = TEAM_DATA[teamName];
    if (teamMasterData && teamMasterData.coach) {
        const coach = teamMasterData.coach;
        coachEl.textContent = `${coach.name} (${coach.experience} / ${coach.style})`;
    } else {
        coachEl.textContent = '情報なし';
    }
    
    // モーダルを表示
    modal.classList.remove('hidden');
}
    // --- Custom Alert/Confirm ---
    function showAlert(message) {
        alert(message);
    }

    function showConfirm(message) {
        return new Promise((resolve) => {
            const confirmOk = document.getElementById('confirm-ok');
            const confirmCancel = document.getElementById('confirm-cancel');
            document.getElementById('confirm-modal-text').textContent = message;
            confirmModal.classList.remove('hidden');

            const onOk = () => {
                confirmModal.classList.add('hidden');
                cleanup();
                resolve(true);
            };

            const onCancel = () => {
                confirmModal.classList.add('hidden');
                cleanup();
                resolve(false);
            };
            
            const cleanup = () => {
                confirmOk.removeEventListener('click', onOk);
                confirmCancel.removeEventListener('click', onCancel);
            };

            confirmOk.addEventListener('click', onOk);
            confirmCancel.addEventListener('click', onCancel);
        });
    }

// --- Utility & State Functions --- などに追加

// 甲子園での成績を定義（数字が小さいほど上位）
const KOSHIEN_RESULTS = {
    CHAMPION:       { rank: -1, label: '全国優勝' },
    RUNNER_UP:    { rank: -2, label: '全国準優勝' },
    BEST_4:         { rank: -4, label: '甲子園ベスト4' },
    BEST_8:         { rank: -8, label: '甲子園ベスト8' },
    BEST_16:        { rank: -16, label: '甲子園3回戦敗退' }, // ベスト16
    ROUND_2:        { rank: -32, label: '甲子園2回戦敗退' },
    ROUND_1:        { rank: -64, label: '甲子園初戦敗退' },
};

// チームのA～Eランクごとの、甲子園での成績確率（ウェイト方式）
const KOSHIEN_PROBABILITIES = {
    'A': [
        { result: 'CHAMPION', weight: 20 }, { result: 'RUNNER_UP', weight: 25 },
        { result: 'BEST_4', weight: 25 },   { result: 'BEST_8', weight: 15 },
        { result: 'BEST_16', weight: 10 },  { result: 'ROUND_2', weight: 4 },
        { result: 'ROUND_1', weight: 1 }
    ],
    'B': [
        { result: 'CHAMPION', weight: 5 },  { result: 'RUNNER_UP', weight: 10 },
        { result: 'BEST_4', weight: 20 },   { result: 'BEST_8', weight: 30 },
        { result: 'BEST_16', weight: 20 },  { result: 'ROUND_2', weight: 10 },
        { result: 'ROUND_1', weight: 5 }
    ],
    'C': [
        { result: 'CHAMPION', weight: 1 },  { result: 'RUNNER_UP', weight: 3 },
        { result: 'BEST_4', weight: 8 },    { result: 'BEST_8', weight: 20 },
        { result: 'BEST_16', weight: 30 },  { result: 'ROUND_2', weight: 28 },
        { result: 'ROUND_1', weight: 10 }
    ],
    'D': [
        { result: 'BEST_8', weight: 5 },    { result: 'BEST_16', weight: 15 },
        { result: 'ROUND_2', weight: 40 },  { result: 'ROUND_1', weight: 40 }
    ],
    'E': [
        { result: 'BEST_16', weight: 5 },   { result: 'ROUND_2', weight: 25 },
        { result: 'ROUND_1', weight: 70 }
    ],
};

/**
 * チームランクに基づき、甲子園での成績を確率で決定する
 * @param {string} teamRank - 'A'から'E'までのチームランク
 * @returns {string} - KOSHIEN_RESULTSのキー ('CHAMPION', 'BEST_8'など)
 */
function simulateKoshien(teamRank) {
    const probabilities = KOSHIEN_PROBABILITIES[teamRank] || KOSHIEN_PROBABILITIES['E'];
    const totalWeight = probabilities.reduce((sum, p) => sum + p.weight, 0);
    let random = Math.random() * totalWeight;

    for (const prob of probabilities) {
        if (random < prob.weight) {
            return prob.result;
        }
        random -= prob.weight;
    }
    return 'ROUND_1'; // フォールバック
}
    /**
     * 試合IDを元に、stateオブジェクトの深い階層から試合オブジェクトを検索して返す
     */
    function findMatchById(matchId) {
    // 通常のトーナメント表を検索
    if (tournamentState.matches && tournamentState.matches[matchId]) {
        return tournamentState.matches[matchId];
    }

    // 秋季大会の地区予選・順位決定戦を検索
    if (tournamentState.autumnData) {
        for (const region of ['東部', '中部', '西部', '伊豆']) { // 伊豆を追加
            const regionData = tournamentState.autumnData.regions[region];
            if (!regionData) continue;
            // ▼▼▼ このブロックが修正箇所 ▼▼▼
            if (regionData.blocks) { // 東部・中部・西部
                for (const block of regionData.blocks) {
                    if (block.matches[matchId]) return block.matches[matchId];
                }
            }
            if (regionData.izuBracket && regionData.izuBracket.matches[matchId]) { // 伊豆
                return regionData.izuBracket.matches[matchId];
            }
            // ▲▲▲
            if (regionData.champBracket && regionData.champBracket.matches[matchId]) {
                return regionData.champBracket.matches[matchId];
            }
            if (regionData.repechageBracket && regionData.repechageBracket.matches[matchId]) {
                return regionData.repechageBracket.matches[matchId];
            }
        }
    }
        
        // 春季大会の地区予選を検索
         if (tournamentState.springData) {
        for (const region of ['東部', '中部', '西部', '伊豆']) {
            const regionData = tournamentState.springData.regions[region];
            if (!regionData) continue;

            // ブロック代表決定戦を検索
            if (regionData.blocks) {
                for (const block of regionData.blocks) {
                    if (block.matches[matchId]) return block.matches[matchId];
                }
            }
            // 第5代表決定戦（敗者復活）を検索
            if (regionData.repechageBracket && regionData.repechageBracket.matches[matchId]) {
                return regionData.repechageBracket.matches[matchId];
            }
            // 伊豆地区予選を検索
            if (regionData.izuBracket && regionData.izuBracket.matches[matchId]) {
                return regionData.izuBracket.matches[matchId];
            }
        }
    }
    // ▲▲▲ ここまで修正 ▲▲▲
        return null; // どこにも見つからなかった場合
    }
// --- Team Rank Calculation (Reality-Adjusted Version) ---
    /**
     * チームランクを計算する（現実の勢力図に合わせて調整版）
     */
    function calculateRank(teamName, state) {
        if (!teamName) return '';

        const teamData = TEAM_DATA[teamName];
        if (!teamData) {
            console.error(`TEAM_DATAにチーム「${teamName}」が見つかりません。`);
            return 'E';
        }

        let score = 0;
        
        // 1. 偏差値の影響を半分に (重すぎたため)
        score += teamData.deviation * 0.5;

        // 2. 過去の最高成績ボーナス (変更なし)
        if (teamData.best.includes('優勝')) score += 25;
        else if (teamData.best.includes('準優勝')) score += 20;
        else if (teamData.best.includes('ベスト4')) score += 15;
        else if (teamData.best.includes('出場')) score += 10; // 甲子園出場
        else if (teamData.best.includes('ベスト8')) score += 10;
        else if (teamData.best.includes('ベスト16')) score += 5;

        // 3. 直近の成績ボーナス (倍率を 3.0 → 1.0 に大幅ダウン)
        const rankMultiplier = 1.0; // ★倍率を 1.0 に変更
        if (state.teamRecords && state.teamRecords[teamName]) {
            const lastFinish = state.teamRecords[teamName].lastFinish;
            
            // ★甲子園成績のボーナスを追加
            if (lastFinish <= -1) score += 35 * rankMultiplier; // 全国優勝
            else if (lastFinish <= -2) score += 30 * rankMultiplier; // 全国準優勝
            else if (lastFinish <= -8) score += 25 * rankMultiplier; // 甲子園ベスト8以上
            // ▼県大会の成績
            else if (lastFinish === 1) score += 30 * rankMultiplier; // 県優勝
            else if (lastFinish === 2) score += 25 * rankMultiplier;
            else if (lastFinish <= 4) score += 20 * rankMultiplier;
            else if (lastFinish <= 8) score += 15 * rankMultiplier;
            else if (lastFinish <= 16) score += 5 * rankMultiplier;
            else if (lastFinish >= 64) score -= 5 * rankMultiplier;
        }

        // 4. 人気ボーナス (変更なし)
        if (teamData.popularity) score += 5;

        // 5. ランクの境界線（ボーダーライン）を調整
        if (score >= 60) return 'A'; // Aランク (旧 85+)
        if (score >= 50) return 'B'; // Bランク (旧 70+)
        if (score >= 40) return 'C'; // Cランク (旧 55+)
        if (score >= 30) return 'D'; // Dランク (旧 40+)
        return 'E'; // Eランク (旧 < 40)
    }



// ▼▼▼ この関数をまるごと追加してください ▼▼▼
/**
 * 指定されたブロックのアニメーションを再生する（トーナメント表示版）
 */
/**
 * 指定されたブロックのアニメーションを再生する（トーナメント表示版）
 */
async function playBlockAnimation(blockId) {
    // タブのアクティブ表示を更新
    document.querySelectorAll('.analysis-block-tab-btn').forEach(btn => {
        const isActive = btn.dataset.block === blockId;
        btn.classList.toggle('bg-cyan-500', isActive);
        btn.classList.toggle('text-white', isActive);
        btn.classList.toggle('bg-gray-700', !isActive);
        btn.classList.toggle('text-gray-400', !isActive);
    });

    const stage = document.getElementById('analysis-stage');
    const narrationTextEl = document.getElementById('analysis-narration-text');
    const analysisData = tournamentState.blockAnalysisData;

    if (!analysisData || !analysisData[blockId]) {
        stage.innerHTML = `<p class="text-center text-gray-500">分析データを読み込めませんでした。</p>`;
        narrationTextEl.textContent = '';
        return;
    }
    const narration = analysisData[blockId];
    
    // ... (以降のコードは変更ありません) ...
    const blockTeams = tournamentState.teams.slice(
        (blockId.charCodeAt(0) - 65) * 16, 
        (blockId.charCodeAt(0) - 64) * 16
    );

    stage.innerHTML = '';
    narrationTextEl.textContent = '';
    
    stage.innerHTML = `
        <div id="r1-col" class="round-column"></div>
        <div id="r2-col" class="round-column"></div>
        <div id="r3-col" class="round-column"></div>
        <div id="r4-col" class="round-column"></div>
    `;

    for(let i = 0; i < 8; i++) {
        const matchupEl = document.createElement('div');
        matchupEl.className = 'analysis-matchup';
        matchupEl.innerHTML = `
            <div class="analysis-team" data-team-name="${blockTeams[i*2]}">${blockTeams[i*2]}</div>
            <div class="analysis-team" data-team-name="${blockTeams[i*2+1]}">${blockTeams[i*2+1]}</div>
            <div class="matchup-connector"></div>
        `;
        stage.querySelector('#r1-col').appendChild(matchupEl);
    }
    
    for(let i = 0; i < 4; i++) { stage.querySelector('#r2-col').innerHTML += '<div class="analysis-matchup"><div class="analysis-team">???</div><div class="analysis-team">???</div><div class="matchup-connector"></div><div class="round-connector"></div></div>'; }
    for(let i = 0; i < 2; i++) { stage.querySelector('#r3-col').innerHTML += '<div class="analysis-matchup"><div class="analysis-team">???</div><div class="analysis-team">???</div><div class="matchup-connector"></div><div class="round-connector"></div></div>'; }
    stage.querySelector('#r4-col').innerHTML += '<div class="analysis-matchup"><div class="analysis-team">???</div></div>';

    await new Promise(r => setTimeout(r, 100));
    document.querySelectorAll('.analysis-team').forEach((el, i) => {
        setTimeout(() => el.classList.add('show'), i * 50);
    });

    for (let i = 0; i < narration.length; i++) {
        narrationTextEl.textContent += narration[i];
        await new Promise(r => setTimeout(r, 50));
    }
    
    blockTeams.forEach(team => {
        if (narration.includes(team)) {
            document.querySelectorAll(`.analysis-team[data-team-name="${team}"]`).forEach(el => {
                el.classList.add('highlight');
            });
        }
    });
}
// ▼▼▼ この関数をまるごと追加してください ▼▼▼
/**
 * AIに各ブロックの勢力図を分析させ、ナレーション原稿を生成させる（データ分析強化版）
 * @param {object} state - tournamentState
 * @returns {Promise<object|null>}
 */
/**
 * AIに各ブロックの勢力図を分析させ、ナレーション原稿を生成させる（ハイブリッド版・APIエラー対策済み）
 * @param {object} state - tournamentState
 * @returns {Promise<object|null>}
 */
async function generateBlockAnalysisArticle(state) {
    const { teams, seeds } = state;
    const blocks = { A: [], B: [], C: [], D: [] };
    teams.forEach((team, i) => {
        if (i < 16) blocks.A.push(team);
        else if (i < 32) blocks.B.push(team);
        else if (i < 48) blocks.C.push(team);
        else blocks.D.push(team);
    });

    const blockAnalysisData = {};
    for (const blockId in blocks) {
        const blockTeams = blocks[blockId];
        // ▼▼▼ このブロックを置き換えてください ▼▼▼
        const teamDetails = blockTeams.map(teamName => {
            const rank = calculateRank(teamName, state);
            const isSeed = seeds.includes(teamName);
            const teamData = TEAM_DATA[teamName];
            const tags = teamData?.tags || [];

            // 物語性のあるタグを持っているか
            const hasStoryTag = tags.includes('逆境') || tags.includes('ワンマンチーム') || tags.includes('最後の夏') || tags.includes('古豪');
            
            // A/Bランク、シード校、または「物語タグ」を持つチームは、詳細情報を渡す
            if (isSeed || ['A', 'B'].includes(rank) || hasStoryTag) {
                const info = teamData?.info || '';
                // タグと、短縮した背景情報を渡す
                return `${teamName}(${rank}${isSeed ? 'S' : ''}) [タグ: ${tags.join(',')}, 背景: ${info.substring(0, 40)}...]`;
            } 
            // Cランクはタグのみ渡す
            else if (['C'].includes(rank)) {
                 return `${teamName}(${rank}) [タグ: ${tags.join(',')}]`;
            } 
            // D/Eランクはランクのみ
            else {
                return `${teamName}(${rank})`;
            }
        }).join(', ');
        // ▲▲▲ 置き換えここまで ▲▲▲        blockAnalysisData[blockId] = teamDetails;
    }

    const prompt = `あなたは高校野球の解説者です。以下の各ブロックのチームリストを分析し、それぞれの見どころを**150字程度**のナレーション原稿にまとめてください。

### 分析対象ブロック (チーム名とランク、Sはシード校、[]内は注目校の背景情報)
- **Aブロック:** ${blockAnalysisData.A}
- **Bブロック:** ${blockAnalysisData.B}
- **Cブロック:** ${blockAnalysisData.C}
- **Dブロック:** ${blockAnalysisData.D}

### 指示
- **物語を重視:** [背景]情報が提供されている注目校を中心に、そのチームが持つ物語や背景（例：古豪の復活、王者の苦悩）に触れながら解説してください。
- **簡潔に:** 全体のナレーションは150字程度に収めてください。
- 最も激戦区だと思われる「死のブロック」を特定してください。
- 4ブロック分、必ず全てのナレーションを生成してください。

### 出力形式 (JSON)
{
  "A": "（Aブロックのナレーション）",
  "B": "（Bブロックのナレーション）",
  "C": "（Cブロックのナレーション）",
  "D": "（Dブロックのナレーション）"
}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        return parseJsonFromText(result.candidates[0].content.parts[0].text);
    } catch (error) {
        console.error("AIブロック分析記事の生成に失敗:", error);
        return null;
    }
}
   /**
 * 新しいトーナ-メントを開始するメイン関数（大会移行バグ修正・最終完全版）
 */
async function createNewTournament(isNext = false, nextTournamentType = 'summer', predeterminedTeams = null) {
    setupEl.classList.add('hidden');
    tournamentDisplayEl.classList.remove('hidden');
    
    // 大会移行時に、前の大会のコントロールボタンを確実に非表示にする
    autumnControls.classList.add('hidden');
    startMainTournamentBtn.classList.add('hidden');
    startRankingPlayoffsBtn.classList.add('hidden');

    // --- 世代交代処理 ---
    if (isNext && tournamentState.teamRecords) {
        for (const teamName in tournamentState.teamRecords) {
            if (tournamentState.teamRecords.hasOwnProperty(teamName)) {
                const record = tournamentState.teamRecords[teamName];
                record.previousRank = record.lastFinish;
                record.wins = 0;
                record.losses = 0;
            }
        }
    }

    // --- 秋季大会の開始 ---
    if (nextTournamentType === 'autumn') {
        tournamentState.currentTournament = 'autumn';
        tournamentState.autumnPhase = 'regional_blocks';
        if (!isNext) {
            tournamentState.tournamentYear = 2025;
            tournamentState.settings = { enableArticleGeneration: true, enableBbsGeneration: true };
        }
        tournamentState.autumnData = {
            regions: {
                '東部': { blocks: [], blockWinners: [], blockRunnersUp: [], ranking: [], finalReps: [] },
                '中部': { blocks: [], blockWinners: [], blockRunnersUp: [], ranking: [], finalReps: [] },
                '西部': { blocks: [], blockWinners: [], blockRunnersUp: [], ranking: [], finalReps: [] },
                '伊豆': { izuBracket: null, finalReps: [] }
            }
        };
        Object.assign(tournamentState, {
            teams: [], matches: {}, news: [], seeds: [], bbsComments: [], daiyaBbsComments: [],
            tickerHeadlines: [], namcoNews: null, is16team: false, documentary: { target: null, type: null }
        });
        await setupAutumnRegionalBlocks();
        return;
    }
    // --- 春季大会の開始 ---
    else if (nextTournamentType === 'spring') {
        tournamentState.currentTournament = 'spring';
        tournamentState.autumnPhase = null;
        
        const allRankedTeams = Object.keys(tournamentState.teamRecords)
            .map(name => ({ name, rank: tournamentState.teamRecords[name].lastFinish }))
            .sort((a, b) => a.rank - b.rank);

        const seedTeams = allRankedTeams.slice(0, 8).map(t => t.name);
        const qualifierTeams = allRankedTeams.slice(8).map(t => t.name);

        tournamentState.springPhase = 'regional_qualifiers';
        tournamentState.springData = {
            seedTeams,
            qualifierTeams,
            regions: {
                '東部': { blocks: [], repechageBracket: null, finalReps: [] },
                '中部': { blocks: [], repechageBracket: null, finalReps: [] },
                '西部': { blocks: [], repechageBracket: null, finalReps: [] },
                '伊豆': { izuBracket: null, finalReps: [] }
            },
            allMatches: {}
        };
        await setupSpringRegionalQualifiers();

         if (tournamentState.senbatsuTeams && tournamentState.senbatsuTeams.length > 0) {
        for (const teamName of tournamentState.senbatsuTeams) {
            // チームの実力（ランク）を取得
            const teamRank = calculateRank(teamName, tournamentState);
            // ランクに基づき、甲子園での成績を確率的に決定
            const koshienResultKey = simulateKoshien(teamRank);
            const koshienResult = KOSHIEN_RESULTS[koshienResultKey];
            
            // チームの公式記録を更新
            const teamRecord = tournamentState.teamRecords[teamName];
            if (teamRecord) {
                teamRecord.lastFinish = koshienResult.rank; // 最終成績を甲子園のものに更新
                const newHistoryRecord = { 
                    year: tournamentState.tournamentYear, 
                    tournament: 'spring_koshien', // 春の甲子園という特別な記録
                    rank: koshienResult.rank 
                };
                teamRecord.history.unshift(newHistoryRecord);
                // これまでの最高成績より良ければ更新
                if (!teamRecord.best || newHistoryRecord.rank < teamRecord.best.rank) {
                    teamRecord.best = newHistoryRecord;
                }
            }
            
            // 結果を元にニュース記事をAIに生成させる
            const article = await generateKoshienSummaryArticle(teamName, koshienResult.label, 'spring');
            if (article) {
                tournamentState.news.push(article);
            }
        }
    }
    // ▲▲▲

    tournamentState.senbatsuTeams = [];
    return;
}    
    // --- 夏季大会の開始 ---
    mainBracketWrapper.classList.remove('hidden');
    tournamentState.is16team = false;
    tournamentState.currentTournament = 'summer';

    if (isNext) { // 春から夏への移行時
        tournamentState.tournamentYear++;
    }
    
    // 年度とチーム記録の初期化 (全くの初回プレイ時)
    if (!isNext) { 
        tournamentState.tournamentYear = 2025;
        tournamentState.teamRecords = {};
        const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
        historicalRanks.sort((a, b) => a.rank - b.rank);
        
        // 初回のみsettingsを初期化
        tournamentState.settings = {
            enableArticleGeneration: true,
            enableBbsGeneration: true
        };

        INITIAL_TEAM_POOL.forEach(t => {
            const historicalRank = historicalRanks.find(hr => hr.name === t);
            tournamentState.teamRecords[t] = { 
                wins: 0, losses: 0, best: null, history: [],
                lastFinish: historicalRank ? historicalRank.rank : 64, 
                previousRank: null,
                teamTraits: [], 
                previousStarters: null,
                roster: null,
            };
        });
    }
    
    let teams;
    let seeds = [];
    if (predeterminedTeams) {
        teams = predeterminedTeams;
        const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
        historicalRanks.sort((a, b) => a.rank - b.rank);
        seeds = historicalRanks.slice(0, 8).map(t => t.name);
    } else {
        if (isNext) {
            const lastTournamentTeams = Object.keys(tournamentState.teamRecords)
                .map(teamName => ({ name: teamName, ...tournamentState.teamRecords[teamName] }))
                .sort((a, b) => a.lastFinish - b.lastFinish);
            seeds = lastTournamentTeams.slice(0, 8).map(t => t.name);
        } else {
            const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
            historicalRanks.sort((a, b) => a.rank - b.rank);
            seeds = historicalRanks.slice(0, 8).map(t => t.name);
        }

        const nonSeeds = INITIAL_TEAM_POOL.filter(t => !seeds.includes(t));
        const shuffledNonSeeds = shuffleArray(nonSeeds);
        teams = Array(64).fill(null);
        const seedPositionsTemplate = [0, 32, 16, 48, 8, 40, 24, 56];
        const seedPlacements = {};
        seeds.forEach((seed, i) => { seedPlacements[seedPositionsTemplate[i]] = seed; });
        let nonSeedIndex = 0;
        for (let i = 0; i < 64; i++) {
            teams[i] = seedPlacements[i] ? seedPlacements[i] : shuffledNonSeeds[nonSeedIndex++];
        }
    }
    
    // トーナメントデータの作成
    tournamentState.teams = teams;
    tournamentState.matches = {};
    tournamentState.news = [];
    tournamentState.documentary = { target: null, type: null };
    tournamentState.activeScandal = null;
    tournamentState.seeds = seeds;
    tournamentState.bbsComments = [];
    tournamentState.daiyaBbsComments = [];
    tournamentState.tickerHeadlines = []; 
    tournamentState.rivalries = RIVALRIES;
    tournamentState.feuds = tournamentState.feuds || [];
    tournamentState.namcoNews = null;

    const round1Setup = teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    round1Setup.forEach((match, index) => {
        const side = index < 16 ? 'L' : 'R';
        const matchNum = index < 16 ? index + 1 : index - 15;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

    saveState(); // 組み合わせ決定時点の状態を保存
    renderTournament(tournamentState); // 組み合わせを描画

    const currentTournamentName = tournamentNameMap[tournamentState.currentTournament];
    newsContainer.innerHTML = `<div class="loader">AI記者が${currentTournamentName}の組み合わせと展望を分析中...</div>`;
    bbsCommentsContainer.innerHTML = `<div class="loader">AIが組み合わせを分析中...</div>`;
    namcoNewsSection.classList.remove('hidden');
    namcoNewsContent.innerHTML = `<div class="loader">ナムコグループからのお知らせを確認中...</div>`;

    let analysisArticlePromise = Promise.resolve(null);
    let bracketBbsPromise = Promise.resolve(null); // ★BBS生成Promiseの初期化★

    if (tournamentState.currentTournament === 'summer') {
        analysisArticlePromise = generateBracketAnalysisNewsArticle(tournamentState);
        bracketBbsPromise = generateBracketBbsThread(tournamentState); // ★新しい関数を呼び出す★

    } else { // 秋季・春季大会の展望記事 (変更なし)
        const previewContext = { matchId: 'preview' };
        analysisArticlePromise = generateNewsArticle(previewContext);
        // 秋季・春季は簡易的な反応コメントにする場合 ( generateBracketReactionComments を使う)
        // bracketBbsPromise = generateBracketReactionComments(tournamentState);
        // もし秋季・春季でも詳細なスレッドが欲しければ generateBracketBbsThread を呼んでも良い
    }

   // ▼▼▼ Promise.all の中身を修正 ▼▼▼
    const [namcoNews, analysisArticle, bracketBbsResult] = await Promise.all([
        generateNamcoNews(tournamentState, 'bracket'),
        analysisArticlePromise,
        bracketBbsPromise
    ]);
    // ▲▲▲ 修正ここまで ▲▲▲

    // --- 生成されたコンテンツの処理 ---
    // 記事の処理 (変更なし)
    if (analysisArticle && !analysisArticle.error) {
         tournamentState.news.unshift(analysisArticle);
    } else if (analysisArticle && analysisArticle.error) {
        tournamentState.news.unshift(analysisArticle);
    }

   // ▼▼▼ BBSスレッドのエラーハンドリングを修正 ▼▼▼
    if (bracketBbsResult && !bracketBbsResult.error) {
        tournamentState.bbsComments.push(bracketBbsResult); // 成功スレッドをBBSに追加
    } else if (bracketBbsResult && bracketBbsResult.error) {
        // ★★★ 変更点: newsではなくbbsCommentsにエラーを追加 ★★★
        tournamentState.bbsComments.push({
            title: bracketBbsResult.title || "組み合わせスレッド生成エラー",
            body: bracketBbsResult.body || "AIによるスレッド生成に失敗しました。",
            timestamp: Date.now(),
            error: true,
            errorId: bracketBbsResult.errorId || `bracket-thread-error-${Date.now()}`,
            // ★★★ contextを追加して再生成可能にする ★★★
            context: { isBracketThread: true } // 再生成時に使う目印
        });
    }
    // ▲▲▲ 修正ここまで ▲▲▲

    if (namcoNews) tournamentState.namcoNews = namcoNews;

    renderNews(tournamentState.news);
    renderBbsComments(tournamentState.bbsComments); // BBSを描画
    renderNamcoNews(tournamentState.namcoNews);
    saveState();
}

/**
 * AIに組み合わせ抽選結果の詳細分析に基づいた展望ニュース記事を生成させる
 * (generateBracketReactionCommentsの分析ロジックを流用)
 */
async function generateBracketAnalysisNewsArticle(state) {
    const { teams, seeds } = state;
    if (teams.length < 8) return null; // チーム数が少なすぎる場合は生成しない

    // --- トーナメント表の詳細分析ロジック (generateBracketReactionCommentsから流用) ---
    const numBlocks = Math.max(1, Math.ceil(teams.length / 16));
    const blockSize = Math.floor(teams.length / numBlocks);
    const blockData = [];
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    const getTeamRank = (teamName) => calculateRank(teamName, state);

    for (let i = 0; i < numBlocks; i++) {
        const blockName = String.fromCharCode(65 + i);
        const startIdx = i * blockSize;
        const endIdx = (i + 1) * blockSize;
        const blockTeams = teams.slice(startIdx, endIdx);
        if (blockTeams.length === 0) continue;

        const strongTeamsInBlock = blockTeams.filter(team => {
            const rank = getTeamRank(team);
            return seeds.includes(team) || ['A', 'B'].includes(rank);
        });

        const matchupsR1 = [];
        const potentialR2 = [];
        const potentialR3 = [];

        for (let j = 0; j < blockTeams.length; j += 2) {
            const team1 = blockTeams[j];
            const team2 = blockTeams[j + 1];
            if (!team1 || !team2) continue;
            const rank1 = getTeamRank(team1);
            const rank2 = getTeamRank(team2);
            const matchup = { team1, rank1, team2, rank2 };
            matchupsR1.push(matchup);
            if ((seeds.includes(team1) || ['A', 'B'].includes(rank1)) && (seeds.includes(team2) || ['A', 'B'].includes(rank2))) {
                matchup.isCrush = true;
            }
        }

        if (blockTeams.length >= 4) {
            for (let j = 0; j < matchupsR1.length; j += 2) {
                 const winner1Match = matchupsR1[j];
                 const winner2Match = matchupsR1[j + 1];
                 if (!winner1Match || !winner2Match) continue;
                 const potentialWinner1 = rankValues[winner1Match.rank1] >= rankValues[winner1Match.rank2] ? winner1Match.team1 : winner1Match.team2;
                 const potentialWinner2 = rankValues[winner2Match.rank1] >= rankValues[winner2Match.rank2] ? winner2Match.team1 : winner2Match.team2;
                 if (strongTeamsInBlock.includes(potentialWinner1) && strongTeamsInBlock.includes(potentialWinner2)) {
                     potentialR2.push(`${potentialWinner1} vs ${potentialWinner2}`);
                 }
            }
        }
        if (teams.length === 64 && blockTeams.length >= 8) {
             const blockSeeds = strongTeamsInBlock.filter(t => seeds.includes(t));
             if (blockSeeds.length >= 2) {
                 potentialR3.push(`${blockSeeds[0]} vs ${blockSeeds[1]} (予想)`);
             }
        }

        blockData.push({
            name: blockName, teams: blockTeams, strongTeams: strongTeamsInBlock,
            matchupsR1: matchupsR1, potentialR2: potentialR2, potentialR3: potentialR3
        });
    }

    let blockSummary = '';
    let crushR1 = [];
    let goodCardsR2 = [];
    let goodCardsR3 = [];
    blockData.forEach(block => {
        blockSummary += `- ${block.name}ブロック: 有力校 ${block.strongTeams.length} (${block.strongTeams.join(', ') || 'なし'})\n`;
        block.matchupsR1.forEach(m => {
            if (m.isCrush) crushR1.push(`${block.name}: ${m.team1}(${m.rank1}) vs ${m.team2}(${m.rank2})`);
        });
        goodCardsR2.push(...block.potentialR2.map(card => `${block.name}: ${card}`));
        goodCardsR3.push(...block.potentialR3.map(card => `${block.name}: ${card}`));
    });

    blockData.sort((a, b) => b.strongTeams.length - a.strongTeams.length);
    const deathBlock = blockData[0];
    const blessedBlock = blockData[blockData.length - 1];

    let analysisText = `各ブロックの有力校:\n${blockSummary}`;
    analysisText += `死のブロック: ${deathBlock.name} (${deathBlock.strongTeams.length}校)\n`;
    analysisText += `恵まれたブロック: ${blessedBlock.name} (${blessedBlock.strongTeams.length}校)\n`;
    if (crushR1.length > 0) analysisText += `1回戦での有力校潰し合い:\n  - ${crushR1.join('\n  - ')}\n`;
    if (goodCardsR2.length > 0) analysisText += `2回戦での注目カード(予想):\n  - ${goodCardsR2.join('\n  - ')}\n`;
    if (goodCardsR3.length > 0) analysisText += `3回戦での注目カード(予想):\n  - ${goodCardsR3.join('\n  - ')}\n`;
    // --- 分析ロジックここまで ---

    // --- 記事生成用プロンプト ---
    const prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。
${state.tournamentYear}年度 夏季大会の組み合わせ抽選会が終了しました。
以下の詳細な分析結果に基づき、読者の期待感を高めるような展望記事を作成してください。

### 組み合わせ分析結果 (チーム名(ランクS=シード), [タグ], [背景])
${analysisText}

### 執筆指示
- **タイトル:** 「夏の組み合わせ決定！${deathBlock.name}ブロックは激戦区か？」のように、抽選結果のポイントと大会への期待が伝わるものにしてください。
- **本文構成:**
    1. 組み合わせが決定したことを伝える導入。
    2. 各ブロックの有力校（A/Bランク）に触れつつ、特に「死のブロック (${deathBlock.name})」と「恵まれたブロック (${blessedBlock.name})」について詳しく解説してください。
    3. Cランクの実力校がどのブロックでシード校を脅かす存在（ダークホース）になりそうか、**具体的な校名を挙げて**分析してください。
    4. 勝ち上がりを予想し、2回戦や3回戦で実現しそうな好カード（分析結果の${goodCardsR2.length > 0 ? '2回戦' : ''}${goodCardsR3.length > 0 ? 'や3回戦' : ''}の注目カード）についても触れてください。
    
    5. **【AI記者の注目株】**: 上記の分析結果（特に[タグ]や[背景]情報）を踏まえ、あなたが**「今大会の一押しチーム（推し）」**を1校選び、そのチームが持つドラマ性（例：「逆境」「最後の夏」「古豪復活」など）を熱く語るコラム欄を設けてください。
       (例：『記者の視点：今大会、私が注目するのは〇〇高校だ。彼らは...』)

    6. 最後に、3年生最後の夏としてのドラマ性や、甲子園への切符をかけた熱い戦いへの期待を述べて締めくくってください。
- **文体:** 熱意が伝わる、ややドラマチックなスポーツ記事の文体で記述してください。

### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
    // --- AIへのリクエストと結果の処理 ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article && article.title && article.body) {
                // 記事オブジェクトにタイムスタンプを追加して返す
                return { ...article, timestamp: Date.now() };
            }
        }
        throw new Error("AIからの応答が、正しい記事形式ではありません。");
    } catch (error) {
        console.error("AI組み合わせ分析記事の生成に失敗しました:", error);
        // エラー記事オブジェクトを返す
        return {
            title: "組み合わせ分析記事 生成エラー",
            body: "AI記者との通信に失敗し、記事を生成できませんでした。",
            timestamp: Date.now(),
            error: true,
            errorId: `bracket-analysis-${Date.now()}` // エラー識別用ID
        };
    }
}   


// --- Tournament Animation Logic ---

let currentAnimation = null; // 再生中のアニメーションの種類 (null, 'autumn', 'spring')
let currentStep = -1;       // 現在のステップ番号
let animationSteps = [];    // 現在のアニメーションの全ステップ関数

const stage = document.getElementById('animation-stage');
const narrationEl = document.getElementById('animation-narration');
const prevBtn = document.getElementById('prev-step-btn');
const nextBtn = document.getElementById('next-step-btn');
const animPlaceholder = document.getElementById('anim-placeholder');
const showAutumnBtn = document.getElementById('show-autumn-anim-btn');
const showSpringBtn = document.getElementById('show-spring-anim-btn');

/**
 * アニメーション要素を作成するヘルパー
 */
function createAnimElement(type, text, options = {}) {
    const el = document.createElement('div');
    el.className = `anim-${type}`;
    el.textContent = text;
    if (options.id) el.id = options.id;
    if (options.children) options.children.forEach(child => el.appendChild(child));
    if (options.style) Object.assign(el.style, options.style);
    return el;
}

/**
 * 要素を表示（フェードイン）させるヘルパー
 */
async function showElement(element, delay = 50) {
    if (!element) return;
    await sleep(delay);
    element.classList.add('show');
}

/**
 * 要素を非表示（フェードアウト）させるヘルパー
 */
async function hideElement(element, delay = 0) {
    if (!element) return;
    await sleep(delay);
    element.classList.remove('show', 'anim-highlight');
    await sleep(500); // Wait for fade out
}

/**
 * 要素をハイライトするヘルパー
 */
function highlightElement(element, clearOthers = true) {
    if (clearOthers) {
        stage.querySelectorAll('.anim-highlight').forEach(el => el.classList.remove('anim-highlight'));
    }
    if (element) {
        element.classList.add('anim-highlight');
    }
}

/**
 * ナレーションを設定し、タイプライター風に表示するヘルパー
 */
async function setNarration(text) {
    narrationEl.textContent = '';
    for (const char of text) {
        narrationEl.textContent += char;
        await sleep(30); // 文字間のウェイト
    }
}

/**
 * ステップ実行とボタン制御
 */
async function runStep(stepIndex) {
    if (stepIndex < 0 || stepIndex >= animationSteps.length) return;
    currentStep = stepIndex;
    stage.innerHTML = ''; // ステージをクリア
    animPlaceholder.classList.add('hidden'); // プレースホルダー非表示
    await animationSteps[currentStep](); // 現在のステップ関数を実行
    updateButtons();
}

function updateButtons() {
    prevBtn.disabled = currentStep <= 0;
    nextBtn.disabled = currentStep >= animationSteps.length - 1;
}

// --- 秋季大会アニメーションステップ ---
const autumnAnimation = [
    // Step 0: Introduction
    async () => {
        await setNarration("🍂 秋季大会は新チーム最初の公式戦！センバツ甲子園出場に繋がります。");
        const title = createAnimElement('bracket', '秋季大会システム', { style: { fontSize: '1.2rem', fontWeight: 'bold' } });
        stage.appendChild(title);
        await showElement(title);
    },
    // Step 1: Regional Qualifiers Overview
    async () => {
        await setNarration("まず、県内を4地区（東部・中部・西部・伊豆）に分けて地区予選を行います。");
        const regions = ['東部(20)', '中部(20)', '西部(20)', '伊豆(4)'].map(r => createAnimElement('region', r));
        const container = createAnimElement('bracket', '', { children: regions, style: { display: 'flex', justifyContent: 'center' } });
        stage.appendChild(container);
        for (const region of regions) await showElement(region);
    },
    // Step 2: Main 3 Regions - Blocks
    async () => {
        await setNarration("東・中・西地区では、20チームが4ブロックに分かれ、各ブロック優勝を目指します。");
        const region = createAnimElement('region', '東部地区 (20チーム)', { id: 'main-region', style: { width: '80%' } });
        const blocks = ['A (5)', 'B (5)', 'C (5)', 'D (5)'].map(b => createAnimElement('block', `ブロック ${b}`));
        region.append(...blocks);
        stage.appendChild(region);
        await showElement(region);
        for (const block of blocks) await showElement(block, 100);
        highlightElement(region);
    },
    // Step 3: Block Winner
    async () => {
        await setNarration("各ブロックの優勝チーム (計4チーム) は県大会へ進出決定！🏆");
        const region = document.getElementById('main-region');
        if (!region) { // 要素がなければ再生成 (Prevボタン対策)
            await autumnAnimation[2](); // 前のステップを再実行
            await sleep(500);
        }
        const blockA = stage.querySelector('.anim-block'); // 例としてAブロック
        const winner = createAnimElement('team', 'A優勝', { classList: ['winner'] });
        blockA.appendChild(winner);
        await showElement(winner, 200);
        highlightElement(winner);
        // TODO: 矢印で「県大会へ」を示す
    },
    // Step 4: Block Runner-up & Repechage
    async () => {
        await setNarration("各ブロックの準優勝チーム (計4チーム) は、最後の1枠を賭けた敗者復活戦へ。");
        await autumnAnimation[3](); // 前のステップの表示をベースにする
        const blocks = stage.querySelectorAll('.anim-block');
        const runnersUp = [];
        blocks.forEach((block, i) => {
            const runnerUp = createAnimElement('team', `${String.fromCharCode(65 + i)}準優勝`, { classList: ['loser'] });
            block.appendChild(runnerUp);
            runnersUp.push(runnerUp);
        });
        for (const ru of runnersUp) await showElement(ru, 100);

        const repechage = createAnimElement('bracket', '第5代表決定戦 (敗者復活)', { id: 'repechage', style: { marginTop: '15px' } });
        stage.appendChild(repechage);
        await showElement(repechage);
        highlightElement(repechage);
        // TODO: 準優勝チームから敗者復活戦への矢印
    },
    // Step 5: Repechage Winner
    async () => {
        await setNarration("敗者復活戦の勝者 (1チーム) も県大会へ進出！これで各地区5チーム。");
        await autumnAnimation[4]();
        const repechage = document.getElementById('repechage');
        const repWinner = createAnimElement('team', '復活優勝', { classList: ['winner'] });
        repechage.appendChild(repWinner);
        await showElement(repWinner, 200);
        highlightElement(repWinner);
        // TODO: 矢印で「県大会へ」を示す
    },
    // Step 6: Izu Region
    async () => {
        await setNarration("伊豆地区は4チームのトーナメント。優勝した1チームのみ県大会へ。");
        const region = createAnimElement('region', '伊豆地区 (4チーム)', { id: 'izu-region' });
        const winner = createAnimElement('team', '伊豆優勝', { classList: ['winner'] });
        region.appendChild(winner);
        stage.appendChild(region);
        await showElement(region);
        await showElement(winner, 200);
        highlightElement(region);
    },
    // Step 7: Prefectural Tournament
    async () => {
        await setNarration("全代表16チーム (東5+中5+西5+伊豆1) が集結し、県大会本戦 (トーナメント)！");
        const bracket = createAnimElement('bracket', '県大会本戦 (16チーム)', { id: 'main-bracket' });
        const teams = ['東1', '中1', '西1', '伊1', '東2', '中2', '...', '西5(敗復)'].map(t => createAnimElement('team', t));
        bracket.append(...teams);
        stage.appendChild(bracket);
        await showElement(bracket);
        for (const team of teams) await showElement(team, 30);
        highlightElement(bracket);
    },
    // Step 8: Rewards
    async () => {
        await setNarration("県大会の優勝・準優勝はセンバツ有力！ベスト8以上で春季大会のシード権獲得！✨");
        await autumnAnimation[7]();
        const bracket = document.getElementById('main-bracket');
        const rewards = createAnimElement('bracket', '🏆優勝/準優勝 → センバツへ<br>🏅ベスト8 → 春シード権', { style: { marginTop: '15px', borderColor: 'gold' } });
        stage.appendChild(rewards);
        await showElement(rewards, 200);
        highlightElement(rewards);
    }
];

// --- 春季大会アニメーションステップ ---
const springAnimation = [
    // Step 0: Introduction
    async () => {
        await setNarration("🌸 春季大会は夏の大会の前哨戦！夏のシード権獲得を目指します。");
        const title = createAnimElement('bracket', '春季大会システム', { style: { fontSize: '1.2rem', fontWeight: 'bold' } });
        stage.appendChild(title);
        await showElement(title);
    },
    // Step 1: Seed Teams
    async () => {
        await setNarration("秋季大会ベスト8のチームはシード校となり、県大会2回戦から登場します。");
        const seeds = Array.from({ length: 8 }).map((_, i) => createAnimElement('team', `秋Best8-${i+1}`, { classList: ['seed'] }));
        const container = createAnimElement('bracket', 'シード校 (8チーム)', { children: seeds, id: 'seeds', style: { borderColor: 'orange' } });
        stage.appendChild(container);
        await showElement(container);
        for (const seed of seeds) await showElement(seed, 50);
        highlightElement(container);
    },
    // Step 2: Regional Qualifiers (Non-seeds)
    async () => {
        await setNarration("シード校以外のチームは、再び地区予選へ。秋と同様に代表枠を争います。");
        const others = createAnimElement('region', 'シード以外の全チーム (56チーム)', { id: 'others' });
        const qualifiers = createAnimElement('bracket', '地区予選 (秋と同じ形式)', { id: 'qualifiers' });
        stage.appendChild(others);
        stage.appendChild(qualifiers);
        await showElement(others);
        await showElement(qualifiers, 200);
        highlightElement(qualifiers);
        // TODO: othersからqualifiersへの矢印
    },
    // Step 3: Qualifier Winners
    async () => {
        await setNarration("地区予選を突破した16チームが県大会1回戦へ進出します。");
        await springAnimation[2](); // 前のステップ表示
        const qualifiers = document.getElementById('qualifiers');
        const winners = Array.from({ length: 16 }).map((_, i) => createAnimElement('team', `予選突破-${i+1}`, { classList: ['winner'] }));
        const winnerContainer = createAnimElement('bracket', '予選突破 (16チーム)', { children: winners, id: 'q-winners' });
        qualifiers.appendChild(winnerContainer);
        await showElement(winnerContainer, 200);
        highlightElement(winnerContainer);
    },
    // Step 4: Prefectural Round 1
    async () => {
        await setNarration("県大会1回戦は、予選突破校同士の対決です。");
        await springAnimation[3]();
        const qWinners = document.getElementById('q-winners');
        const r1Bracket = createAnimElement('bracket', '県大会1回戦 (8試合)', { id: 'r1-bracket', style: { marginTop: '15px' } });
        // 代表として4チーム表示
        const teamsR1 = ['予選A', '予選B', '予選C', '予選D'].map(t => createAnimElement('team', t));
        r1Bracket.append(...teamsR1);
        stage.appendChild(r1Bracket);
        await showElement(r1Bracket, 200);
        highlightElement(r1Bracket);
        // TODO: q-winnersからr1-bracketへの矢印
    },
    // Step 5: Prefectural Round 2 (Seeds Join)
    async () => {
        await setNarration("1回戦の勝者8チームが、シード校8チームと2回戦で激突！ここから本戦！");
        const seeds = Array.from({ length: 8 }).map((_, i) => createAnimElement('team', `秋Best8-${i+1}`, { classList: ['seed'] }));
        const seedContainer = createAnimElement('bracket', 'シード校 (8チーム)', { children: seeds, id: 'seeds', style: { borderColor: 'orange' } });

        const r1Winners = Array.from({ length: 8 }).map((_, i) => createAnimElement('team', `1回戦勝者-${i+1}`, { classList: ['winner'] }));
        const r1WinnerContainer = createAnimElement('bracket', '1回戦勝者 (8チーム)', { children: r1Winners, id: 'r1-winners' });

        const r2Bracket = createAnimElement('bracket', '県大会2回戦 (16チーム)', { id: 'r2-bracket', style: { borderColor: 'red' } });

        stage.append(seedContainer, r1WinnerContainer, r2Bracket);
        await showElement(seedContainer);
        await showElement(r1WinnerContainer);
        await showElement(r2Bracket, 200);
        highlightElement(r2Bracket);
        // TODO: seedContainerとr1WinnerContainerからr2Bracketへの矢印
    },
    // Step 6: Reward (Summer Seed)
    async () => {
        await setNarration("この大会でベスト8以上に入ると、夏の選手権大会のシード権獲得！🔥");
        await springAnimation[5]();
        const r2Bracket = document.getElementById('r2-bracket');
        const reward = createAnimElement('bracket', '🏅ベスト8 → 夏のシード権', { style: { marginTop: '15px', borderColor: 'gold' } });
        stage.appendChild(reward);
        await showElement(reward, 200);
        highlightElement(reward);
    }
];

// --- Event Listeners for Animation Control ---

showAutumnBtn.addEventListener('click', () => {
    currentAnimation = 'autumn';
    animationSteps = autumnAnimation;
    runStep(0);
});

showSpringBtn.addEventListener('click', () => {
    currentAnimation = 'spring';
    animationSteps = springAnimation;
    runStep(0);
});

prevBtn.addEventListener('click', () => {
    if (currentStep > 0) {
        runStep(currentStep - 1);
    }
});

nextBtn.addEventListener('click', () => {
    if (currentStep < animationSteps.length - 1) {
        runStep(currentStep + 1);
    }
});

// Helper for delays
// function sleep(ms) { // 既存のsleep関数があれば不要
//     return new Promise(resolve => setTimeout(resolve, ms));
// }

/**
 * AIに組み合わせ抽選結果に基づいた、なんJ風の掲示板スレッド（タイトル＋コメント群）を生成させる
 * (★マニアックな分析とコメント指示を追加した最終版★)
 */
async function generateBracketBbsThread(state) {
    const { teams, seeds } = state;
    // チーム数が少なすぎる場合 (例: 8未満) は掲示板コメントを生成しない
    if (!teams || teams.length < 8) {
        console.log("チーム数が少ないため、組み合わせBBSスレッドは生成しません。");
        return null; // 何も生成しない場合は null を返す
    }

    // --- トーナメント表の詳細分析ロジック ---
    const numBlocks = Math.max(1, Math.ceil(teams.length / 16)); // 64チームなら4ブロック、16チームなら1ブロック
    const blockSize = Math.floor(teams.length / numBlocks);
    const blockData = []; // 各ブロックの情報を格納
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 }; // ランクの強さ
    const getTeamRank = (teamName) => calculateRank(teamName, state); // チームランク取得関数
    const getTeamRegion = (teamName) => TEAM_DATA[teamName]?.region || '不明'; // 地域取得ヘルパー

    let nicheMatchups = []; // マニアックな注目カードを格納する配列

    // 各ブロックを分析
    for (let i = 0; i < numBlocks; i++) {
        const blockName = String.fromCharCode(65 + i);
        const startIdx = i * blockSize;
        const endIdx = (i + 1) * blockSize;
        const blockTeams = teams.slice(startIdx, endIdx);
        // ブロックにチームが存在しない場合はスキップ
        if (blockTeams.length === 0) continue;

        // ブロック内の有力校 (シード or A/Bランク) を特定
        const strongTeamsInBlock = blockTeams.filter(team => {
            const rank = getTeamRank(team);
            return seeds.includes(team) || ['A', 'B'].includes(rank);
        });

        const matchupsR1 = []; // 1回戦のカード情報
        const potentialR2 = []; // 2回戦で当たりそうなカード
        const potentialR3 = []; // 3回戦で当たりそうなカード (64チーム時)

        // 1回戦の各カードを分析
        for (let j = 0; j < blockTeams.length; j += 2) {
            const team1 = blockTeams[j];
            const team2 = blockTeams[j + 1];
            // 対戦相手がいない場合はスキップ (チーム数が奇数の場合など)
            if (!team1 || !team2) continue;

            const rank1 = getTeamRank(team1);
            const rank2 = getTeamRank(team2);
            const region1 = getTeamRegion(team1);
            const region2 = getTeamRegion(team2);
            const matchup = { team1, rank1, region1, team2, rank2, region2 }; // カード情報に地域も追加
            matchupsR1.push(matchup);

            // 1回戦での有力校潰し合いチェック
            if ((seeds.includes(team1) || ['A', 'B'].includes(rank1)) && (seeds.includes(team2) || ['A', 'B'].includes(rank2))) {
                matchup.isCrush = true; // 潰し合いフラグ
            }

            // ▼▼▼ このブロック全体を、既存のマニアックな注目カードのロジックと置き換えてください ▼▼▼

            // マニアックな注目カードの抽出ロジック
            const rankDiff = Math.abs(rankValues[rank1] - rankValues[rank2]);
            
            // ★★★ おそらく、以下の4行の定義が抜けているか、順番が間違っています ★★★
            const isStrong1 = rankValues[rank1] >= 4; // A or B
            const isStrong2 = rankValues[rank2] >= 4; // A or B
            const isMid1 = rankValues[rank1] === 3; // C
            const isMid2 = rankValues[rank2] === 3; // C

            // 1. 同地区の下位〜中堅対決 (C vs C, C vs D in same region)
            if (region1 === region2 && !matchup.isCrush && rankValues[rank1] <= 3 && rankValues[rank2] <= 3) {
                 if (nicheMatchups.length < 3) {
                    nicheMatchups.push({ block: blockName, match: `${team1}(${rank1}) vs ${team2}(${rank2})`, reason: `${region1}地区対決` });
                 }
            }
            // 2. Cランク vs 強豪 (A/B) の「波乱期待カード」
            else if (nicheMatchups.length < 3 && !matchup.isCrush && ((isStrong1 && isMid2) || (isMid1 && isStrong2))) {
                nicheMatchups.push({ 
                    block: blockName, 
                    match: `${team1}(${rank1}) vs ${team2}(${rank2})`, 
                    reason: `Cランクが強豪に挑む注目カード` 
                });
            }
            // 3. ランクが近く、勝機がありそうな下位対決 (D vs D, D vs E, E vs E)
            else if (rankDiff <= 1 && rankValues[rank1] <= 2 && rankValues[rank2] <= 2) {
                 // 既にリストにあるチームとの重複を避ける
                 if (nicheMatchups.length < 3 && !nicheMatchups.some(nm => nm.match.includes(team1) || nm.match.includes(team2))) {
                    nicheMatchups.push({ block: blockName, match: `${team1}(${rank1}) vs ${team2}(${rank2})`, reason: `実力伯仲の下位対決` });
                 }
            }
                    } // End of 1回戦カード分析ループ

        // 2回戦以降の有力カード予測 (簡易版)
        if (blockTeams.length >= 4) { // 2回戦が存在する場合
            for (let j = 0; j < matchupsR1.length; j += 2) {
                const winner1Match = matchupsR1[j];
                const winner2Match = matchupsR1[j + 1];
                if (!winner1Match || !winner2Match) continue; // ペアになる試合がない場合

                // 各1回戦でランクが高い方が勝ち上がると仮定
                const potentialWinner1 = rankValues[winner1Match.rank1] >= rankValues[winner1Match.rank2] ? winner1Match.team1 : winner1Match.team2;
                const potentialWinner2 = rankValues[winner2Match.rank1] >= rankValues[winner2Match.rank2] ? winner2Match.team1 : winner2Match.team2;

                // 両方とも有力校なら2回戦の注目カード候補
                if (strongTeamsInBlock.includes(potentialWinner1) && strongTeamsInBlock.includes(potentialWinner2)) {
                    potentialR2.push(`${potentialWinner1} vs ${potentialWinner2}`);
                }
            }
        }
        // 3回戦 (64チームトーナメントの場合のみ)
        if (teams.length === 64 && blockTeams.length >= 8) { // 3回戦が存在する場合
             // ブロック内のシード校同士が当たる可能性などをリストアップ
             const blockSeeds = strongTeamsInBlock.filter(t => seeds.includes(t));
             if (blockSeeds.length >= 2) {
                 // 例: ブロック内のシード校 上位2校が当たると予想
                 potentialR3.push(`${blockSeeds[0]} vs ${blockSeeds[1]} (予想)`);
             }
             // 他にも有力校がいれば、シード vs 有力ノーシードなどの組み合わせも予測可能
             if (blockSeeds.length >= 1 && strongTeamsInBlock.length > blockSeeds.length) {
                 const topNonSeed = strongTeamsInBlock.find(t => !seeds.includes(t));
                 if (topNonSeed) {
                     potentialR3.push(`${blockSeeds[0]} vs ${topNonSeed} (予想)`);
                 }
             }
        }

        // ブロックの分析結果を格納
        blockData.push({
            name: blockName,
            teams: blockTeams,
            strongTeams: strongTeamsInBlock,
            matchupsR1: matchupsR1,
            potentialR2: potentialR2,
            potentialR3: potentialR3
        });
    } // End of ブロック分析ループ

    // --- 分析結果をテキストにまとめる ---
    let blockSummary = '';
    let crushR1 = []; // 1回戦潰し合いリスト
    let goodCardsR2 = []; // 2回戦好カードリスト
    let goodCardsR3 = []; // 3回戦好カードリスト

    blockData.forEach(block => {
        blockSummary += `- ${block.name}ブロック: 有力校 ${block.strongTeams.length} (${block.strongTeams.join(', ') || 'なし'})\n`;
        block.matchupsR1.forEach(m => {
            if (m.isCrush) { // 潰し合いフラグが立っているカードを追加
                crushR1.push(`${block.name}: ${m.team1}(${m.rank1}) vs ${m.team2}(${m.rank2})`);
            }
        });
        // 2回戦、3回戦の注目カードをブロック名付きで追加
        goodCardsR2.push(...block.potentialR2.map(card => `${block.name}: ${card}`));
        goodCardsR3.push(...block.potentialR3.map(card => `${block.name}: ${card}`));
    });

    // 死のブロックと恵まれたブロックを判定 (有力校数でソート)
    blockData.sort((a, b) => b.strongTeams.length - a.strongTeams.length);
    const deathBlock = blockData[0]; // 最も有力校が多いブロック
    const blessedBlock = blockData[blockData.length - 1]; // 最も有力校が少ないブロック

    // AIに渡すための最終的な分析テキストを生成
    let analysisText = `各ブロックの有力校:\n${blockSummary}`;
    analysisText += `死のブロック: ${deathBlock.name} (${deathBlock.strongTeams.length}校)\n`;
    analysisText += `恵まれたブロック: ${blessedBlock.name} (${blessedBlock.strongTeams.length}校)\n`;
    if (crushR1.length > 0) {
        analysisText += `1回戦での有力校潰し合い:\n  - ${crushR1.join('\n  - ')}\n`;
    } else {
        analysisText += `1回戦での有力校同士の直接対決はなし。\n`;
    }
    if (goodCardsR2.length > 0) {
        analysisText += `2回戦での注目カード(予想):\n  - ${goodCardsR2.join('\n  - ')}\n`;
    }
     if (goodCardsR3.length > 0) {
        analysisText += `3回戦での注目カード(予想):\n  - ${goodCardsR3.join('\n  - ')}\n`;
    }
    // マニアックな注目カードを分析結果に追加
    if (nicheMatchups.length > 0) {
        analysisText += `その他の注目1回戦カード:\n${nicheMatchups.map(nm => `  - ${nm.block}ブロック: ${nm.match} (${nm.reason})`).join('\n')}\n`;
    }
    // --- 分析ロジックここまで ---

    // --- スレッド生成用プロンプト ---
    const prompt = `あなたは、匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは高校野球に詳しく、煽りやユーモアを交えながら会話を盛り上げます。
夏の高校野球大会の組み合わせ抽選会が終わりました。以下の詳細な分析結果を基に、**なんJらしいスレッドタイトル**と、そのスレッド内での**リアルタイムな反応コメントを30〜40個**生成してください。

### 組み合わせ分析結果サマリー
${analysisText}

### あなたが生成するコメントの方向性
- **分析結果への反応:**
    - 「死のブロック (${deathBlock.name})」に入ったチームへの同情や煽り。「〇〇終わったなw」「ここ勝ち上がるのマジでキツイやろ」
    - 「恵まれたブロック (${blessedBlock.name})」への反応。「△△はクジ運良すぎ」「決勝まで余裕やん」
    - 1回戦での有力校潰し合い (${crushR1.length}件) について。「初戦からこれとか勿体ねえ」「いきなり事実上の決勝かよ」
    - 2, 3回戦で実現しそうな好カード予想について。「□□ vs ◇◇は絶対見たい」「もし実現したら熱いな」
- **★マニアックな視点 (超重要)★:**
    - **特定の無名校・中堅校のファンになりきること。**具体的な学校名を挙げて**当事者目線のコメントを**必ず複数**生成してください。
    - 分析結果にある「その他の注目1回戦カード」に挙げられているような、**下位・中堅校同士の対決**について、「〇〇と△△どっち勝つかな」「ここは潰し合いだな」「正直どうでもいいw」といったコメントも生成してください。
- **個人的な視点:**
    - 自分の応援するチーム (架空で良い) の組み合わせに対する一喜一憂。「ワイの母校、初戦から強豪で草」「よっしゃ！いけるやん！」
    - シード校や注目校に対するコメント。「王者〇〇のブロック楽すぎ」「△△はノーシードだけど怖いぞ」
- **なんJらしさ:**
    - 短い煽りレス。「は？」「雑魚w」「ファーwww」
    - 他のコメントへの安価 (>>) 付きの返信やツッコミ。
    - 全く関係ない野球ネタや時事ネタへの脱線 (少しだけ)。
    - 草 (w) や顔文字 (^^;) などを適度に使う。
- **スレッドの流れ:** 序盤は組み合わせへの驚き、中盤で各ブロック分析や有力校・マニアックなカードへの言及、終盤は少し脱線しつつ盛り上がる、という自然な流れを意識してください。

### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{
  "threadTitle": "（例：【速報】夏の高校野球組み合わせ決定www 死のブロックは〇〇！今年の組み合わせはヤバすぎるｗｗｗ）",
  "comments": [
    {"personality": "1: 風吹けば名無し", "comment": "（スレ主のコメント）"},
    {"personality": "2: 風吹けば名無し", "comment": "（>>1 うおおおお）"},
    {"personality": "3: 熱海高校応援民", "comment": "（下田か…！勝てるやろ！）"}
    // ... (合計35〜45個のコメント) ...
  ]
}`;

    // --- AIへのリクエストと結果の処理 ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        // AIからの応答があるかチェック
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            // 応答テキストからJSONを抽出
            const bbsJson = parseJsonFromText(rawText);
            // JSONが期待する形式 (タイトルとコメント配列を持つオブジェクト) かチェック
            if (bbsJson && bbsJson.threadTitle && Array.isArray(bbsJson.comments)) {
                // 成功：スレッドオブジェクトを生成して返す
                return {
                    id: `bracket-thread-${Date.now()}`, // スレッド固有ID
                    title: bbsJson.threadTitle,
                    matchId: 'bracket', // 試合IDの代わりに'bracket'などを設定
                    comments: bbsJson.comments.map((c, index) => ({ // 個々のコメントにIDなどを付与
                        id: crypto.randomUUID(),
                        personality: c.personality || `${index + 1}: 風吹けば名無し`, // personalityがなければデフォルト値
                        text: c.comment,
                        timestamp: Date.now() + index * 10, // タイムスタンプを少しずらす
                        replies: [] // 返信用の空配列
                    })),
                    timestamp: Date.now() // スレッド作成日時
                };
            }
        }
        // AIの応答が期待した形式でなかった場合、エラーを投げる
        throw new Error("AIからの応答が、正しいスレッド形式ではありません。");
    } catch (error) {
        // エラーが発生した場合の処理
        console.error("AI組み合わせ反応スレッドの生成に失敗しました:", error);
        // エラー情報を含むオブジェクトを返す
        return {
            error: true,
            title: "組み合わせスレッド生成エラー",
            body: "AIによるスレッド生成に失敗しました。", // エラーメッセージ
            timestamp: Date.now(),
            errorId: `bracket-thread-error-${Date.now()}` // エラー識別用ID
        };
    }
}

/**
 * 大会終了時に、全チームの最終順位をteamRecordsに記録し、履歴を更新する
 */
function updateTournamentFinishRecords() {
    const { matches, teams } = tournamentState;
    if (!teams || teams.length === 0) return;

    const numTeams = teams.length;
    const finalRound = Math.log2(numTeams);

    // 最終順位を決定する
    const getRoundLosers = (round, side) => {
        const losers = [];
        const numMatches = (numTeams / 2) / Math.pow(2, round - 1);
        for (let m = 1; m <= numMatches; m++) {
            const match = matches[`${side}-R${round}-M${m}`];
            if (match && match.winner) {
                const loser = match.winner === match.team1 ? match.team2 : match.team1;
                if (loser) losers.push(loser);
            }
        }
        return losers;
    };

    const finalMatch = matches['F-R1-M1'];
    if (finalMatch && finalMatch.winner) {
        const winner = finalMatch.winner;
        const runnerUp = finalMatch.winner === finalMatch.team1 ? finalMatch.team2 : finalMatch.team1;
        if (tournamentState.teamRecords[winner]) tournamentState.teamRecords[winner].lastFinish = 1;
        if (tournamentState.teamRecords[runnerUp]) tournamentState.teamRecords[runnerUp].lastFinish = 2;
    }

    // 準決勝以前の敗退順位を記録
    for (let r = finalRound - 1; r >= 1; r--) {
        const finishRank = Math.pow(2, finalRound - r + 1);
        getRoundLosers(r, 'L').concat(getRoundLosers(r, 'R')).forEach(t => {
            if (t && tournamentState.teamRecords[t]) tournamentState.teamRecords[t].lastFinish = finishRank;
        });
    }

    // ★★★ ここからが戦績履歴と最高成績の更新処理 ★★★
    Object.keys(tournamentState.teamRecords).forEach(team => {
        const record = tournamentState.teamRecords[team];
        if(!record.lastFinish) return; // 試合に参加していない場合はスキップ

        // 今回の大会結果オブジェクトを作成
        const newHistoryRecord = {
            year: tournamentState.tournamentYear,
            tournament: tournamentState.currentTournament,
            rank: record.lastFinish
        };

        // 履歴の先頭に追加 (新しいものが常に一番上に来るように)
        if (!record.history) record.history = [];
        record.history.unshift(newHistoryRecord);

        // 最高成績を更新
        // (bestが未設定か、今回の成績の方が良い(rankの数字が小さい)場合に更新)
        if (!record.best || newHistoryRecord.rank < record.best.rank) {
            record.best = newHistoryRecord;
        }
    });
    // ★★★ ここまで ★★★
}

 /**
     * 現在のトーナメント状態に基づいてUI全体を再描画する
     * @param {object} data - 現在のtournamentState
     */
// 【修正対象1】
function renderTournament(data) {
        let tournamentNameString = tournamentNameMap[data.currentTournament] || '大会';

    // UI要素を一度すべて非表示に初期化
    mainBracketWrapper.classList.add('hidden');
    autumnRegionalContainer.classList.add('hidden');
    autumnRankingContainer.classList.add('hidden');
    autumnControls.classList.add('hidden');
    // 全ての秋季・春季スキップボタンを隠す
    [skipAutumnBlocksBtn, skipAutumnRankingBtn, skipAutumnMainBtn, skipSpringQualifiersBtn, skipSpringRound1Btn, skipSpringMainBtn, startRankingPlayoffsBtn, startMainTournamentBtn].forEach(btn => btn?.classList.add('hidden'));
    
    // --- 大会種別に応じて表示を切り替え ---
    if (data.currentTournament === 'spring') {
        autumnControls.classList.remove('hidden'); // 春季大会中もコントロール用の親コンテナは表示

        switch(data.springPhase) {
            case 'regional_qualifiers':
                tournamentNameString = '春季大会 地区予選';
                autumnRegionalContainer.classList.remove('hidden');
                renderSpringRegionalQualifiers();
                skipSpringQualifiersBtn.classList.remove('hidden'); // ★地区予選スキップボタンを表示
                checkSpringQualifiersComplete();
                break;
            case 'main_round1':
                tournamentNameString = '春季大会 県大会1回戦';
                mainBracketWrapper.classList.remove('hidden');
                renderMainBracket(data);
                skipSpringRound1Btn.classList.remove('hidden'); // ★県大会1回戦スキップボタンを表示
                break;
            case 'main_round2_onwards':
                tournamentNameString = '春季大会 県大会';
                mainBracketWrapper.classList.remove('hidden');
                renderMainBracket(data);
                skipSpringMainBtn.classList.remove('hidden'); // ★県大会2回戦以降スキップボタンを表示
                break;
        }
    } else if (data.currentTournament === 'autumn') {
        // ▼▼▼ ここからが修正箇所 ▼▼▼
        autumnControls.classList.remove('hidden'); // ★秋季大会中は、親コンテナを常に表示する

        switch(data.autumnPhase) {
            case 'regional_blocks':
                tournamentNameString = '秋季大会 地区ブロック予選';
                autumnRegionalContainer.classList.remove('hidden');
                renderAutumnRegionalBlocks();
                skipAutumnBlocksBtn.classList.remove('hidden'); // ★ブロック予選スキップボタンを表示
                checkAutumnRegionalBlocksComplete(); // 完了していれば進行ボタンも表示
                break;
            case 'regional_ranking':
                tournamentNameString = '秋季大会 地区 第5代表決定トーナメント';
                autumnRankingContainer.classList.remove('hidden');
                renderAutumnRankingTournaments();
                skipAutumnRankingBtn.classList.remove('hidden'); // ★順位決定戦スキップボタンを表示
                checkAutumnRankingTournamentsComplete(); // 完了していれば進行ボタンも表示
                break;
            case 'main':
                tournamentNameString = '秋季大会 県大会本戦';
                mainBracketWrapper.classList.remove('hidden');
                renderMainBracket(data);
                skipAutumnMainBtn.classList.remove('hidden'); // ★県大会本戦スキップボタンを表示
                break;
        }
        // ▲▲▲ 修正箇所ここまで ▲▲▲
    } else { // Summer
        mainBracketWrapper.classList.remove('hidden');
        renderMainBracket(data);
    }

    // --- 共通の描画処理 ---
    tournamentYearDisplay.textContent = `${data.tournamentYear}年度 ${tournamentNameString}`;
    renderRegionMap(data);
    renderNews(data.news || []);
    renderBbsComments(data.bbsComments || []);
    renderDaiyaBbsComments(data.daiyaBbsComments || []);
    renderNamcoNews(data.namcoNews);
    checkTournamentProgress(); // 夏大会のスキップボタン表示制御
    updateTicker();
}
/**
 * [秋季大会] 地区ブロック予選をスキップする
 */
async function skipAutumnRegionalBlocks() {
    skipAutumnBlocksBtn.disabled = true;
    skipAutumnBlocksBtn.textContent = '進行中...';

    // 全ての地区の全ブロックの試合を処理
    for (const region of ['東部', '中部', '西部', '伊豆']) {
        const regionData = tournamentState.autumnData.regions[region];
        
        const blocks = regionData.izuBracket ? [regionData.izuBracket] : regionData.blocks;

        for (const block of blocks) {
            // ブロック内の全試合IDを取得
            const matchIds = Object.keys(block.matches);
            for (const matchId of matchIds) {
                const match = block.matches[matchId];
                // チームがセットされていて、まだ勝者が決まっていない試合を処理
                if (match.team1 && match.team2 && !match.winner) {
                    const { team1, team2 } = match;
                    const rank1 = calculateRank(team1, tournamentState);
                    const rank2 = calculateRank(team2, tournamentState);
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    
                    const winnerName = (rankValues[rank1] >= rankValues[rank2]) ? team1 : team2;
                    const loserName = winnerName === team1 ? team2 : team1;

                    const [winnerScore, loserScore] = generateAutoScore(rank1, rank2);
                    match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
                    match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;
                    
                    // processMatchWinを呼び出して勝者を次に進める
                    await processMatchWin(matchId, winnerName);
                }
            }
        }
    }
    
    // 全て終わったら、自動で次のステージへ
    await setupAutumnRankingTournaments();
    skipAutumnBlocksBtn.disabled = false;
    skipAutumnBlocksBtn.textContent = '地区ブロック予選をスキップ';
}

/**
 * [秋季大会] 地区順位決定戦（敗者復活戦）をスキップする
 */
async function skipAutumnRankingTournaments() {
    skipAutumnRankingBtn.disabled = true;
    skipAutumnRankingBtn.textContent = '進行中...';

    for (const region of ['東部', '中部', '西部']) {
        const repBracket = tournamentState.autumnData.regions[region].repechageBracket;
        if (!repBracket) continue;
        
        const matchIds = Object.keys(repBracket.matches);
        for (const matchId of matchIds) {
            const match = repBracket.matches[matchId];
            if (match.team1 && match.team2 && !match.winner) {
                const { team1, team2 } = match;
                const rank1 = calculateRank(team1, tournamentState);
                const rank2 = calculateRank(team2, tournamentState);
                const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                
                const winnerName = (rankValues[rank1] >= rankValues[rank2]) ? team1 : team2;
                
                const [winnerScore, loserScore] = generateAutoScore(rank1, rank2);
                match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
                match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;

                await processMatchWin(matchId, winnerName);
            }
        }
    }

    // 自動で県大会本戦へ
    await setupAutumnMainTournament();
    skipAutumnRankingBtn.disabled = false;
    skipAutumnRankingBtn.textContent = '地区順位決定戦をスキップ';
}

/**
 * [秋季大会] 県大会本戦をスキップする
 */
async function skipAutumnMainTournament() {
    skipAutumnMainBtn.disabled = true;
    skipAutumnMainBtn.textContent = '進行中...';

    // 秋季県大会は16チームトーナメント（4ラウンド）
    await skipRound(1); // 1回戦 (ベスト8決定)
    await skipRound(2); // 準々決勝 (ベスト4決定)
    await skipRound(3); // 準決勝 (決勝進出決定)
    await skipFinal();  // 決勝

    skipAutumnMainBtn.disabled = false;
    skipAutumnMainBtn.textContent = '県大会本戦をスキップ';
}

/**
 * [春季大会] 地区予選をスキップする
 */
async function skipSpringQualifiers() {
    skipSpringQualifiersBtn.disabled = true;
    skipSpringQualifiersBtn.textContent = '進行中...';

    const allQualifierMatches = Object.values(tournamentState.springData.allMatches);

    // 予選の全試合をループ処理
    for (const match of allQualifierMatches) {
        // チームがまだセットされていない試合はスキップ
        if (!match.team1 || !match.team2 || match.winner) continue;
        
        const { team1, team2 } = match;
        const rank1 = calculateRank(team1, tournamentState);
        const rank2 = calculateRank(team2, tournamentState);
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        
        const winnerName = (rankValues[rank1] >= rankValues[rank2]) ? team1 : team2;
        
        const [winnerScore, loserScore] = generateAutoScore(rank1, rank2);
        match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
        match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;

        await processMatchWin(match.id, winnerName);
    }

    // 自動で県大会1回戦へ
    await setupSpringMainTournament_Round1();
    skipSpringQualifiersBtn.disabled = false;
    skipSpringQualifiersBtn.textContent = '春季地区予選をスキップ';
}

/**
 * [春季大会] 県大会1回戦をスキップする
 */
async function skipSpringMainRound1() {
    skipSpringRound1Btn.disabled = true;
    skipSpringRound1Btn.textContent = '進行中...';

    // 1回戦は8試合
    await skipRound(1); 
    
    // 自動で県大会2回戦へ
    await setupSpringMainTournament_Round2();
    skipSpringRound1Btn.disabled = false;
    skipSpringRound1Btn.textContent = '春季県大会1回戦をスキップ';
}

/**
 * [春季大会] 県大会2回戦以降をスキップする
 */
async function skipSpringMainTournament() {
    skipSpringMainBtn.disabled = true;
    skipSpringMainBtn.textContent = '進行中...';

    // 2回戦以降はベスト16トーナメントと同じ
    await skipRound(1); // 2回戦 (ベスト8決定)
    await skipRound(2); // 準々決勝 (ベスト4決定)
    await skipRound(3); // 準決勝 (決勝進出決定)
    await skipFinal();  // 決勝

    skipSpringMainBtn.disabled = false;
    skipSpringMainBtn.textContent = '春季県大会2回戦以降をスキップ';
}

    /**
     * メインのトーナメント表（64チームまたは16チーム）を描画する
     */
    function renderMainBracket(data) {
        if (!data.teams || data.teams.length === 0) {
             mainBracketContainer.innerHTML = '';
             return;
        };

        const { matches, teams, seeds } = data;
        const numTeams = teams.length;

        const bracketContentWrapper = document.createElement('div');
        bracketContentWrapper.className = 'flex flex-row';

        const leftBracketEl = document.createElement('div');
        leftBracketEl.className = 'bracket-half left';

        const rightBracketEl = document.createElement('div');
        rightBracketEl.className = 'bracket-half right';
        
        const finalRound = Math.log2(numTeams);
        const semiFinalRound = finalRound - 1;
        
        const leftChampion = data.matches[`L-R${semiFinalRound}-M1`]?.winner ?? null;
        const rightChampion = data.matches[`R-R${semiFinalRound}-M1`]?.winner ?? null;
        
        const finalMatch = data.matches['F-R1-M1'] || {};
        const finalTeam1 = finalMatch.team1 ?? leftChampion;
        const finalTeam2 = finalMatch.team2 ?? rightChampion;

        const finalEl = document.createElement('div');
        finalEl.className = 'bracket-final';
        finalEl.innerHTML = `<div class="final-title">決勝</div><div class="final-matchup" data-match-id="F-R1-M1">${createMatchHTML('F-R1-M1', finalTeam1, finalTeam2, finalMatch, seeds)}</div><div class="winner-box" id="tournament-winner">${finalMatch.winner ? `🏆 ${finalMatch.winner} 🏆` : '🏆'}</div>`;

        const round1Setup = teams.reduce((acc, team, i) => {
            if (i % 2 === 0) acc.push({ team1: team, team2: null });
            else acc[acc.length - 1].team2 = team;
            return acc;
        }, []);
        
        const leftHalfSetup = round1Setup.slice(0, round1Setup.length / 2);
        const rightHalfSetup = round1Setup.slice(round1Setup.length / 2);

        generateHalf(leftBracketEl, leftHalfSetup, 'L', matches, seeds);
        generateHalf(rightBracketEl, rightHalfSetup, 'R', matches, seeds);

        mainBracketContainer.innerHTML = '';
        bracketContentWrapper.append(leftBracketEl, finalEl, rightBracketEl);
        mainBracketContainer.appendChild(bracketContentWrapper);

        if (finalMatch.winner) {
            nextTournamentBtn.classList.remove('hidden');
        } else {
            nextTournamentBtn.classList.add('hidden');
        }
    }

    /**
     * トーナメント表の片側（レフトまたはライト）を描画するヘルパー関数
     */
    function generateHalf(containerEl, setup, side, allMatches, seeds) {
        containerEl.innerHTML = '';
        const numMatchesInFirstRound = setup.length;
        const numTeamsOnSide = numMatchesInFirstRound * 2;
        const numRounds = Math.log2(numTeamsOnSide);

        const roundNameMap = tournamentState.is16team
            ? { 1: "1回戦", 2: "準々決勝", 3: "準決勝" }
            : { 1: "1回戦", 2: "2回戦", 3: "3回戦", 4: "準々決勝", 5: "準決勝" };

        const roundElements = [];
        for (let i = 0; i < numRounds; i++) {
            const roundEl = document.createElement('div');
            roundEl.className = 'round';
            if (i > 0) roundEl.classList.add('subsequent-round');

            const roundTitle = document.createElement('h3');
            roundTitle.className = 'text-center font-bold mb-2';
            roundTitle.textContent = roundNameMap[i + 1] || `${i + 1}回戦`;
            roundEl.appendChild(roundTitle);

            containerEl.appendChild(roundEl);
            roundElements.push(roundEl);
        }

        // ▼▼▼ このループをまるごと置き換える ▼▼▼
        setup.forEach((matchSetup, index) => {
            const matchId = `${side}-R1-M${index + 1}`;
            let dbMatch = allMatches[matchId] || {}; // 既存の match データを取得

            // ★修正点：
            // 抽選時の setup (matchSetup) ではなく、
            // 現在の試合データ (dbMatch) の team1 と team2 を優先して使用する。
            // これにより、swapTeamDetails で入れ替えた結果が反映される。
            const team1 = dbMatch.team1 || matchSetup.team1;
            const team2 = dbMatch.team2 || matchSetup.team2;
            
            // createMatchHTML には dbMatch の team1, team2 を渡す
            roundElements[0].insertAdjacentHTML('beforeend', createMatchHTML(matchId, team1, team2, dbMatch, seeds));
        });
        // ▲▲▲ 置き換えここまで ▲▲▲

        for (let r = 2; r <= numRounds; r++) {
            const numMatchesInRound = numMatchesInFirstRound / Math.pow(2, r - 1);
            for (let m = 1; m <= numMatchesInRound; m++) {
                const matchId = `${side}-R${r}-M${m}`;
                const prevMatch1Id = `${side}-R${r - 1}-M${(m * 2) - 1}`;
                const prevMatch2Id = `${side}-R${r - 1}-M${m * 2}`;
                const team1 = allMatches[prevMatch1Id]?.winner || null;
                const team2 = allMatches[prevMatch2Id]?.winner || null;
                const dbMatch = allMatches[matchId] || {};
                roundElements[r - 1].insertAdjacentHTML('beforeend', createMatchHTML(matchId, team1, team2, dbMatch, seeds));
            }
        }
    }

    /**
     * 1試合分のHTMLを生成する
     */
    /**
 * 1試合分のHTMLを生成する（ドキュメンタリーボタン対応・エラー修正版）
 */
function createMatchHTML(matchId, team1, team2, dbMatch, seeds = []) {
    // ▼▼▼ 先に関数の定義をここ（関数の冒頭）に移動します ▼▼▼
    const createSpecialButtons = (teamName) => {
    if (!teamName || (tournamentState.documentary && tournamentState.documentary.target)) return '';
    
    let buttonHTML = '';
    // 逆境チーム用
    if (UNDERDOG_TEAMS.includes(teamName)) {
        buttonHTML += `<button class="underdog-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の逆境に密着取材する">📹</button>`;
    }
    // 通常の強豪校用
    if (POWERHOUSE_TEAMS.includes(teamName)) {
        buttonHTML += `<button class="powerhouse-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の王者の苦悩に密着取材する">👑</button>`;
    }
    // ▼▼▼ ここから追加 ▼▼▼
    // 古豪復活チーム用
    if (POWERHOUSE_REVIVAL_TEAMS.includes(teamName)) {
        buttonHTML += `<button class="powerhouse-revival-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の古豪復活に密着取材する">🏰</button>`;
    }
if (ONE_MAN_TEAMS.includes(teamName)) {
        buttonHTML += `<button class="one-man-team-doc-btn text-lg ml-2" data-team-name="${teamName}" title="絶対的エースとその仲間たちに密着取材する">🌟</button>`;
    }


        return buttonHTML;
    };
    // ▲▲▲ 関数の定義はここまで ▲▲▲

    const t1Empty = !team1;
    const t2Empty = !team2;

    let specialMatchClass = '';
    if (!t1Empty && !t2Empty) {
        const feud = tournamentState.feuds?.find(f => f.teams.includes(team1) && f.teams.includes(team2));
        if (feud) {
            specialMatchClass = 'feud-match';
        } else {
            const rivalry = tournamentState.rivalries?.find(r => r.teams.includes(team1) && r.teams.includes(team2));
            if (rivalry) {
                specialMatchClass = 'rivalry-match';
            }
        }
    }

    const rank1 = calculateRank(team1, tournamentState);
    const rank2 = calculateRank(team2, tournamentState);
    const rankColor = (rank) => {
        switch (rank) {
            case 'A': return 'rank-A';
            case 'B': return 'rank-B';
            case 'C': return 'rank-C';
            case 'D': return 'rank-D';
            case 'E': return 'rank-E';
            default: return '';
        }
    };

    const isMainBracketMatch = matchId.includes('-R');
    const roundStr = isMainBracketMatch ? matchId.split('-')[1] : '';
    const showDetailsButton = !t1Empty && !t2Empty;
    const isSeed1 = seeds.includes(team1);
    const isSeed2 = seeds.includes(team2);

    // HTMLテンプレート内の関数呼び出し名を修正
    const content = `
        <div class="team-slot ${t1Empty ? 'empty' : ''} ${dbMatch.winner === team1 && !t1Empty ? 'winner' : ''} ${dbMatch.winner && dbMatch.winner !== team1 && dbMatch.winner !== null ? 'loser' : ''}" data-team-name="${team1 || ''}">
            <span class="team-name clickable-team-name ${isSeed1 ? 'seed' : ''}" title="${team1 || ''}" data-team-name="${team1 || ''}">
                ${team1 ? `<span class="rank ${rankColor(rank1)}">[${rank1}]</span>` : ''}
                ${isSeed1 ? 'S ' : ''}${team1 || '---'}
            </span>
            ${createSpecialButtons(team1)} 
            <input type="text" class="score-input" value="${dbMatch.score1 ?? ''}" data-team-pos="1">
            <button class="win-btn">▶</button>
        </div>
        <div class="team-slot ${t2Empty ? 'empty' : ''} ${dbMatch.winner === team2 && !t2Empty ? 'winner' : ''} ${dbMatch.winner && dbMatch.winner !== team2 && dbMatch.winner !== null ? 'loser' : ''}" data-team-name="${team2 || ''}">
            <span class="team-name clickable-team-name ${isSeed2 ? 'seed' : ''}" title="${team2 || ''}" data-team-name="${team2 || ''}">
                ${team2 ? `<span class="rank ${rankColor(rank2)}">[${rank2}]</span>` : ''}
                ${isSeed2 ? 'S ' : ''}${team2 || '---'}
            </span>
            ${createSpecialButtons(team2)}
            <input type="text" class="score-input" value="${dbMatch.score2 ?? ''}" data-team-pos="2">
            <button class="win-btn">▶</button>
        </div>
        <div class="match-summary-container ${!t1Empty && !t2Empty ? '' : 'hidden'}">
            <textarea class="match-summary-input w-full text-xs p-1 mt-1 border rounded" data-match-id="${matchId}" placeholder="試合の決め手（任意）">${dbMatch.summary || ''}</textarea>
        </div>
    `;

// ▼▼▼ ここからコールド表示を追加 ▼▼▼
    let calledGameInfo = '';
    if (dbMatch.calledGame) {
        calledGameInfo = `<div class="text-center text-xs text-red-600 font-bold mt-1">(${dbMatch.calledInning}回コールド)</div>`;
    }
    // ▲▲▲ コールド表示ここまで ▲▲▲

    const footer = showDetailsButton ?
        `<div class="matchup-footer">
            <button class="details-btn" data-match-id="${matchId}">詳細入力</button>
            <button class="quick-sim-btn text-lg" data-match-id="${matchId}" title="このスコアでおまかせ入力">🎲</button>
        </div>` :
        '';

return `<div class="matchup ${specialMatchClass}" data-match-id="${matchId}">
                ${content}
                ${calledGameInfo} 
                ${footer}
            </div>`;
}    
    
/**
 * UIの各種コンテンツエリア（ニュース）を描画する（全機能対応・最終版）
 */
function renderNews(news) {
    if (!news || news.length === 0) {
        newsContainer.innerHTML = `<p class="text-gray-500 text-center">まだニュースはありません。</p>`;
        return;
    }
    newsContainer.innerHTML = '';
    
    news.slice().reverse().forEach((article, reversedIndex) => {
        const articleEl = document.createElement('div');
        const originalIndex = news.length - 1 - reversedIndex;

        if (article.isScandalRumor) {
            articleEl.className = 'bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg shadow';
            articleEl.innerHTML = `
                <h3 class="font-bold">${article.title}</h3>
                <p class="text-sm mt-2">${article.body}</p>
                <div class="mt-4 border-t pt-3 text-center">
                    <p class="text-sm font-bold mb-2">あなたはこの疑惑をどうしますか？</p>
                    <button class="report-scandal-btn bg-red-600 text-white px-4 py-1 rounded text-sm hover:bg-red-700">大会運営に報告する</button>
                    <button class="ignore-scandal-btn bg-gray-500 text-white px-4 py-1 rounded text-sm hover:bg-gray-600 ml-2">見て見ぬふりをする</button>
                </div>
            `;
        } else if (article.error) {
            articleEl.className = 'article-error';
            const regenerateButtonHTML = article.context ? `<button class="regenerate-btn" data-index="${originalIndex}">再生成</button>` : '';
            articleEl.innerHTML = `<span>${article.title}</span>${regenerateButtonHTML}`;
        } else {
            articleEl.className = 'bg-white p-4 rounded-lg shadow';
            let buttonsHTML = '';

            if (article.isAnalysisArticle) {
                buttonsHTML = `<button class="text-sm bg-cyan-500 text-white font-bold px-4 py-2 rounded hover:bg-cyan-600 view-analysis-btn">勢力図をアニメーションで見る</button>`;
            } else {
                const regenerateButtonHTML = article.context ? `<button class="text-sm bg-yellow-100 text-yellow-800 px-3 py-1 rounded hover:bg-yellow-200 ml-2 regenerate-btn" data-index="${originalIndex}">再生成</button>` : '';
                const newspaperButtonHTML = article.isNewspaper ? `<button class="text-sm bg-red-100 text-red-700 px-3 py-1 rounded hover:bg-red-200 ml-2 newspaper-view-btn" data-index="${originalIndex}">新聞を読む</button>` : '';
                buttonsHTML = `
                    <button class="text-sm bg-gray-200 px-3 py-1 rounded hover:bg-gray-300 news-article-btn" data-index="${originalIndex}">本文</button>
                    ${newspaperButtonHTML}
                    ${regenerateButtonHTML}
                `;
            }

            articleEl.innerHTML = `
                <div class="flex justify-between items-center">
                    <div>
                        <h3 class="font-bold text-lg text-blue-600">${article.title}</h3>
                        <p class="text-xs text-gray-400 mt-1">${new Date(article.timestamp).toLocaleDateString('ja-JP')}</p>
                    </div>
                    <div class="flex items-center space-x-2">
                        ${buttonsHTML}
                    </div>
                </div>
            `;
        }
        newsContainer.appendChild(articleEl);
    });
}
    



/**
 * 掲示板のコメント（スレッド形式と個別コメント形式の両方に対応）を描画する
 */
function renderBbsComments(items) { // 引数名を items に変更
    if (!items || items.length === 0) {
        bbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">まだ反応はありません。</p>`;
        return;
    }
    bbsCommentsContainer.innerHTML = ''; // コンテナをクリア

    // 新しいアイテムが上に来るように逆順で処理
    items.slice().reverse().forEach((item, reversedIndex) => {
        const originalIndex = items.length - 1 - reversedIndex;

        // A. エラーオブジェクトの場合
        if (item.error && item.title) {
            const errorEl = document.createElement('div');
            errorEl.className = 'article-error mb-4'; // マージン追加, ニュース記事のエラースタイルを流用
            // ★★★ 再生成ボタンのdata属性を修正 ★★★
            const regenerateButtonHTML = item.context ? `<button class="retry-bbs-btn bg-red-600 text-white px-3 py-1 rounded text-sm hover:bg-red-700" data-index="${originalIndex}" data-type="${item.context.isBracketThread ? 'bracket-thread' : 'match-comments'}">再生成</button>` : '';
            errorEl.innerHTML = `<span>${item.title}</span>${regenerateButtonHTML}`;
            bbsCommentsContainer.appendChild(errorEl);
        }
        // B. スレッドオブジェクトの場合 (組み合わせ決定スレなど title と comments を持つ)
        else if (item.comments && Array.isArray(item.comments) && item.title) {
            const threadWrapper = document.createElement('div');
            threadWrapper.className = 'mb-6 p-4 border rounded-lg bg-white shadow';

            const titleEl = document.createElement('h3');
            titleEl.className = 'text-lg font-bold text-gray-800 mb-3 border-b pb-2';
            titleEl.textContent = `【${item.matchId === 'bracket' ? '組み合わせ決定' : '試合結果'}】${item.title}`;
            threadWrapper.appendChild(titleEl);

            const commentsContainer = document.createElement('div');
            commentsContainer.className = 'space-y-3';

            // スレッド内のコメントを描画
            item.comments.forEach(comment => {
                renderCommentThread(comment, commentsContainer, 'general');
            });

            threadWrapper.appendChild(commentsContainer);
            bbsCommentsContainer.appendChild(threadWrapper);
        }
        // C. 個別のコメントオブジェクトの場合 (試合後の反応など personality と text を持つ)
        else if (item.personality && item.text) {
            // 個別コメントはスレッド枠なしで直接描画
            renderCommentThread(item, bbsCommentsContainer, 'general');
            // 個別コメント間に区切り線などを入れても良いかも
            const hr = document.createElement('hr');
            hr.className = 'my-3 border-gray-200';
            bbsCommentsContainer.appendChild(hr);
        }
        // D. その他の予期せぬデータ
        else {
             console.warn("Unknown item type in bbsComments:", item);
             const unknownEl = document.createElement('div');
             unknownEl.className = 'text-red-500 text-sm my-2';
             unknownEl.textContent = '[不明な掲示板データ]';
             bbsCommentsContainer.appendChild(unknownEl);
        }
    });

     // 最後の区切り線を削除 (個別コメントが最後だった場合)
     const lastElement = bbsCommentsContainer.lastElementChild;
     if (lastElement && lastElement.tagName === 'HR') {
         bbsCommentsContainer.removeChild(lastElement);
     }
}

// renderCommentThread 関数は個別のコメントを描画するため、基本変更不要
// function renderCommentThread(comment, container, bbsType) { ... }

    function renderDaiyaBbsComments(comments) {
        if (!comments || comments.length === 0) {
            daiyaBbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">まだ反応はありません。</p>`;
            return;
        }
        daiyaBbsCommentsContainer.innerHTML = '';
        comments.slice().reverse().forEach(comment => {
            renderCommentThread(comment, daiyaBbsCommentsContainer, 'daiya');
        });
    }

    function renderNamcoNews(news) {
        if (!news) {
            namcoNewsSection.classList.add('hidden');
            return;
        }
        namcoNewsSection.classList.remove('hidden');
        namcoNewsContent.innerHTML = '';
        const newsItem = document.createElement('div');
        newsItem.className = 'namco-news-item p-2 hover:bg-orange-50 rounded';
        newsItem.innerHTML = `<p class="font-semibold text-gray-700">${news.title}<span class="namco-news-tag">野球部</span></p>`;
        newsItem.addEventListener('click', () => {
            document.getElementById('modal-title').textContent = news.title;
            document.getElementById('modal-body').textContent = news.body;
            document.getElementById('modal-meta').innerHTML = `<p>${new Date(news.timestamp).toLocaleDateString('ja-JP')}</p><p class="font-bold text-gray-500">野球部</p>`;
            newsModal.classList.remove('hidden');
            newsModal.classList.add('flex');
        });
        namcoNewsContent.appendChild(newsItem);
    }

    function renderCommentThread(comment, container, bbsType) {
        const threadContainer = document.createElement('div');
        if (container.id === `replies-to-${comment.id}` || (container.id.includes('bbs-comments') && container.children.length > 0)) {
            threadContainer.className = 'ml-4 border-l-2 pl-4 mt-2';
        } else {
            threadContainer.className = 'mt-2';
        }

        const personalityClass = comment.personality === 'あなた' ? 'text-blue-600 font-bold' : 'text-gray-600';
        const commentEl = document.createElement('div');
        commentEl.className = 'bbs-comment';
        commentEl.innerHTML = `
            <div class="flex justify-between items-center">
                <p class="font-semibold ${personalityClass} text-sm">${comment.personality || '名無しさん'}</p>
                <button class="reply-btn text-xs text-blue-500 hover:underline" data-comment-id="${comment.id}" data-bbs-type="${bbsType}">返信する</button>
            </div>
            <p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>
            <p class="text-xs text-gray-400 text-right">${new Date(comment.timestamp).toLocaleString('ja-JP')}</p>
            <div id="reply-form-container-${comment.id}" class="hidden mt-2">
                <form class="reply-form" data-comment-id="${comment.id}" data-bbs-type="${bbsType}">
                    <textarea class="w-full p-2 border rounded text-sm" placeholder="返信を入力..." required></textarea>
                    <button type="submit" class="mt-1 bg-blue-500 text-white px-3 py-1 text-xs rounded hover:bg-blue-600">送信</button>
                </form>
            </div>
        `;
        threadContainer.appendChild(commentEl);

        const repliesContainer = document.createElement('div');
        repliesContainer.id = `replies-to-${comment.id}`;
        threadContainer.appendChild(repliesContainer);

        container.appendChild(threadContainer);

        if (comment.replies && comment.replies.length > 0) {
            comment.replies.slice().reverse().forEach(reply => {
                renderCommentThread(reply, repliesContainer, bbsType);
            });
        }
    }

    /**
 * Renders the regional survival status with a new card-based, scrollable layout.
 */
function renderRegionMap(data) {
    const regionMapSection = document.getElementById('region-map-section');
    const finalMatch = data.matches['F-R1-M1'];
    if ((!data.matches || Object.keys(data.matches).length === 0) && !finalMatch) {
        regionMapSection.classList.add('hidden');
        return;
    }
    regionMapSection.classList.remove('hidden');

    const container = document.getElementById('region-map-container');
    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    INITIAL_TEAM_POOL.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region && teamsByRegion[region]) {
            teamsByRegion[region].push(teamName);
        }
    });

    const eliminatedTeams = new Set();
    const allMatches = { ...data.matches, ...(data.autumnData?.allMatches || {}) };

    Object.values(allMatches).filter(match => match.winner).forEach(match => {
        const loser = match.team1 === match.winner ? match.team2 : match.team1;
        if (loser) eliminatedTeams.add(loser);
    });

    if (finalMatch?.winner) {
        const tournamentWinner = finalMatch.winner;
        eliminatedTeams.forEach(team => {
            if (team === tournamentWinner) eliminatedTeams.delete(team);
        });
    }
    
    let html = '<div class="region-map-scroll-container">'; // New scroll container
    for (const region in teamsByRegion) {
        const teams = teamsByRegion[region];
        if (teams.length === 0) continue;
        
        const survivingCount = teams.filter(team => !eliminatedTeams.has(team)).length;

        html += `
        <div class="region-column">
            <div class="region-header">
                <h3 class="region-title">${region}地区</h3>
                <p class="region-stats">${survivingCount} / ${teams.length} チーム生存</p>
            </div>
            <ul class="region-team-list">
                ${teams.sort((a, b) => { // Sort teams to put survivors at the top
                    const aElim = eliminatedTeams.has(a);
                    const bElim = eliminatedTeams.has(b);
                    if (aElim === bElim) return a.localeCompare(b, 'ja');
                    return aElim ? 1 : -1;
                }).map(team => `
                    <li class="region-team ${eliminatedTeams.has(team) ? 'team-eliminated' : 'team-surviving'}">
                        ${team}
                    </li>
                `).join('')}
            </ul>
        </div>
        `;
    }
    html += '</div>';
    container.innerHTML = html;
}
    
    /**
     * スキップボタンの表示・非表示を制御する
     */
    function checkTournamentProgress() {
    // ボタン要素の取得
    const skipR1Btn = document.getElementById('skip-r1-btn');
    const skipR2Btn = document.getElementById('skip-r2-btn');
    const skipR3Btn = document.getElementById('skip-r3-btn');
    const skipR4Btn = document.getElementById('skip-r4-btn');
    const skipR5Btn = document.getElementById('skip-r5-btn');
    const skipFinalBtn = document.getElementById('skip-final-btn');
    const generateSummaryBtn = document.getElementById('generate-summary-btn');

    // 夏の大会以外では、全てのスキップボタンを非表示にする
    if (tournamentState.is16team || !tournamentState.matches || Object.keys(tournamentState.matches).length === 0 || tournamentState.currentTournament !== 'summer') {
        [skipR1Btn, skipR2Btn, skipR3Btn, skipR4Btn, skipR5Btn, skipFinalBtn, generateSummaryBtn].forEach(btn => btn?.classList.add('hidden'));
        return;
    }

    const matchIds = Object.keys(tournamentState.matches);

    // ▼▼▼ ここが修正されたヘルパー関数 ▼▼▼
    const getRoundStatus = (roundNumber) => {
        // 現在の試合データから、そのラウンドでプレイ済みの試合数を数える
        const played = matchIds.filter(id => id.includes(`-R${roundNumber}-M`) && tournamentState.matches[id]?.winner).length;
        
        // ★変更点：総試合数は、常に64チームトーナメントとして計算する
        const total = 64 / Math.pow(2, roundNumber);
        
        return { total, played };
    };
    // ▲▲▲ 修正ここまで ▲▲▲

    const r1 = getRoundStatus(1);
    const r2 = getRoundStatus(2);
    const r3 = getRoundStatus(3);
    const r4 = getRoundStatus(4); // 準々決勝
    const r5 = getRoundStatus(5); // 準決勝
    const finalMatch = tournamentState.matches['F-R1-M1'];

    // この表示/非表示の切り替えロジックは、getRoundStatusが修正されたことで正常に動作するようになります
    skipR1Btn.classList.toggle('hidden', r1.played > 0);
    skipR2Btn.classList.toggle('hidden', !(r1.played === r1.total && r2.played === 0));
    skipR3Btn.classList.toggle('hidden', !(r2.played === r2.total && r3.played === 0));
    skipR4Btn.classList.toggle('hidden', !(r3.played === r3.total && r4.played === 0));
    skipR5Btn.classList.toggle('hidden', !(r4.played === r4.total && r5.played === 0));
    skipFinalBtn.classList.toggle('hidden', !(r5.played === r5.total && (!finalMatch || !finalMatch.winner)));

    const summaryGenerated = tournamentState.news.some(n => n.summaryType === 'best8');
    generateSummaryBtn.classList.toggle('hidden', !(r3.played === r3.total && r4.played === 0 && !summaryGenerated));
}
/**
 * 決勝戦を自動でスキップする
 */
async function skipFinal() {
    const finalMatch = tournamentState.matches['F-R1-M1'];
    if (!finalMatch || !finalMatch.team1 || !finalMatch.team2 || finalMatch.winner) return;

    const btn = document.getElementById('skip-final-btn');
    if(btn) btn.disabled = true;
    
    const { team1, team2 } = finalMatch;
    const rank1 = calculateRank(team1, tournamentState);
    const rank2 = calculateRank(team2, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    
    let winnerName, loserName;
    // ランク差が2以上ある場合、95%の確率でランク上位が勝利
    const upsetChance = Math.abs(rankValues[rank1] - rankValues[rank2]) >= 2 ? 0.05 : 0.45;

    if (Math.random() < upsetChance) { // 番狂わせ
        winnerName = rankValues[rank1] < rankValues[rank2] ? team1 : team2;
    } else { // 順当
        winnerName = rankValues[rank1] >= rankValues[rank2] ? team1 : team2;
    }
    loserName = winnerName === team1 ? team2 : team1;

    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const [winnerScore, loserScore] = generateAutoScore(winnerRank, loserRank);

    finalMatch.score1 = (finalMatch.team1 === winnerName) ? winnerScore : loserScore;
    finalMatch.score2 = (finalMatch.team2 === winnerName) ? winnerScore : loserScore;

    await processMatchWin('F-R1-M1', winnerName);

    if(btn) btn.classList.add('hidden');
}

    function checkBest8Decided(){} // checkTournamentProgressに統合
// --- 試合詳細モーダル関連の関数（高機能版） ---

   /**
     * 【修正版】新しい試合詳細モーダルを開き、各種テーブルを生成する
     */
    /**
     * イニングスコアのテーブルHTMLを生成する
     */
    /**
 * イニングスコアのテーブルHTMLを生成する（★列幅クラスを適用した最終版）
 */
/**
/**
 * イニングスコアのテーブルHTMLを生成する（0点表示バグ修正版）
 * @param {string} team1Name - チーム1の名前
 * @param {string} team2Name - チーム2の名前
 * @param {object} details - 試合の詳細データ
 * @returns {string} - 生成されたHTML
 */
function createInningScoreTable(team1Name, team2Name, details) {
    const inningData = details.inningScore || { team1: [], team2: [] };
    const numInnings = (inningData.team1 && inningData.team1.length > 0) ? inningData.team1.length : 9;
    
    let header = '';
    for (let i = 1; i <= numInnings; i++) {
        header += `<th class="col-inning-score">${i}</th>`;
    }

    const createRow = (teamKey, teamName) => {
        let cells = '';
        for (let i = 0; i < numInnings; i++) {
            // ▼▼▼【重要修正】ここがバグの原因でした▼▼▼
            // 保存された値が0の場合でも、''（空文字）ではなく0と表示されるように修正
            const scoreValue = inningData[teamKey]?.[i] ?? ''; // nullかundefinedの場合のみ''にする
            cells += `<td class="col-inning-score"><input type="number" value="${scoreValue}"></td>`;
            // ▲▲▲
        }
        return `<tr>
                    <th class="col-team text-left font-semibold pl-2">${teamName}</th>
                    ${cells}
                    <td class="total-score col-total"></td>
                </tr>`;
    };

    return `
        <div class="mb-6 overflow-x-auto">
            <h4 class="font-bold mb-2">イニングスコア</h4>
            <table class="details-table" id="inning-score-table">
                <thead>
                    <tr>
                        <th class="col-team">チーム</th>${header}<th class="col-total">計</th><th class="col-add-inning"><button id="add-inning-score-btn" class="text-xs font-bold">+</button></th>
                    </tr>
                </thead>
                <tbody>${createRow('team1', team1Name)}${createRow('team2', team2Name)}</tbody>
            </table>
        </div>`;
}
/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する（全ての機能を含む最終版）
 */
/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する（★常時縦並びレイアウト対応版）
 */
// 【完成版】openDetailsModal
/**
 * Opens the detailed input modal with the corrected vertical layout.
 */
/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する（★レイアウト問題を完全修正した最終版）
 */
/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する（★データ初期化の欠陥を修正した最終版）
 */
function openDetailsModal(matchId) {
    currentMatchIdForDetails = matchId;
    const match = findMatchById(matchId);
    if (!match) {
        console.error(`[openDetailsModal] エラー: ID ${matchId} の試合が見つかりません。`);
        return;
    }

    console.log("--- [モーダル表示 開始] ---", { matchId: matchId, 既存データ: match.details });

    let details = JSON.parse(JSON.stringify(match.details || {}));
    
    const numInnings = Math.max(9, ...Object.values(tournamentState.matches)
        .filter(m => m.details?.inningScore?.team1)
        .map(m => m.details.inningScore.team1.length));

    console.log(`[モーダル表示] 現在の最大イニング数を ${numInnings} と判断しました。`);

    // データ構造の初期化
    details.inningScore = details.inningScore || { team1: [], team2: [] };
    details.batting = details.batting || { team1: [], team2: [] };
    details.pitching = details.pitching || { team1: [], team2: [] };
    details.fielding = details.fielding || { team1: [], team2: [] }; // ★追加
    details.inningEvents = details.inningEvents || { team1: [], team2: [] };
    details.positionChanges = details.positionChanges || [];
    
    // 配列の長さを現在のイニング数に合わせる
    for(const teamKey of ['team1', 'team2']) {
        if (!details.inningEvents[teamKey]) details.inningEvents[teamKey] = [];
        while (details.inningScore[teamKey].length < numInnings) details.inningScore[teamKey].push('');
        while (details.inningEvents[teamKey].length < numInnings) details.inningEvents[teamKey].push('');
        if (details.batting[teamKey]) {
            details.batting[teamKey].forEach(player => {
                if (!player.results) player.results = [];
                while (player.results.length < numInnings) player.results.push('');
            });
        }
    }
    console.log("[モーダル表示] 表示用に準備したデータ:", JSON.parse(JSON.stringify(details)));


    // もし試合データが空で、かつチームの選手名簿(roster)が存在すれば、それを読み込む
    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (details.batting[teamKey].length === 0 && teamRecord && teamRecord.roster) {
            details.batting[teamKey] = teamRecord.roster.map(p => ({ ...p, results: Array(numInnings).fill('') }));
        }
    }
    
// ★ 選手リストをここで取得 ★
    const playersTeam1 = details.batting.team1.filter(p => p.name).map(p => ({name: p.name}));
    const playersTeam2 = details.batting.team2.filter(p => p.name).map(p => ({name: p.name}));

    const detailsBody = document.getElementById('details-modal-body');
    detailsBody.innerHTML = `
        <div class="space-y-4">
            ${createInningScoreTable(match.team1, match.team2, details)}
            <div class="text-center py-2 border-t border-b">
                <button id="swap-teams-btn" data-match-id="${matchId}" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded">先攻・後攻を入れ替え</button>
            </div>
            
<div class="space-y-4">
                <h4 class="font-bold text-lg">${match.team1} 打撃成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPlayerBattingTable(match.team1, 'team1', details)}</div>
                <h4 class="font-bold text-lg mt-4">${match.team2} 打撃成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPlayerBattingTable(match.team2, 'team2', details)}</div>
            </div>
            
            <div class="space-y-4 mt-4">
                <h4 class="font-bold text-lg">${match.team1} 投手成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPitchingStatsTable('team1', details)}</div>
                 <h4 class="font-bold text-lg mt-4">${match.team2} 投手成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPitchingStatsTable('team2', details)}</div>
            </div>

            <div class="space-y-4 mt-4">
                <h4 class="font-bold text-lg">${match.team1} 守備ハイライト</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">
                    ${createFieldingTable('team1', details, playersTeam1)}
                </div>
                 <h4 class="font-bold text-lg mt-4">${match.team2} 守備ハイライト</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">
                    ${createFieldingTable('team2', details, playersTeam2)}
                </div>
            </div>
            </div>
    `;

    detailsModal.classList.remove('hidden');
    updateTotalScores();
}
 

/**
 * 投手成績のテーブルHTMLを生成する
 * @param {string} teamKey - 'team1' または 'team2'
 * @param {object} details - 試合の詳細データ
 * @returns {string} - 生成されたHTML
 */
function createPitchingStatsTable(teamKey, details) {
    const pitchingData = details.pitching[teamKey] || [];
    let bodyRows = pitchingData.map((player, index) => `
        <tr data-pitcher-index="${index}">
            <td>
                <select>
                    <option value="" ${!player.result ? 'selected' : ''}>-</option>
                    <option value="W" ${player.result === 'W' ? 'selected' : ''}>○</option>
                    <option value="L" ${player.result === 'L' ? 'selected' : ''}>●</option>
                    <option value="S" ${player.result === 'S' ? 'selected' : ''}>S</option>
                    <option value="H" ${player.result === 'H' ? 'selected' : ''}>H</option>
                </select>
            </td>
            <td><input type="text" value="${player.name || ''}"></td>
            <td><input type="text" value="${player.innings || ''}"></td>
            <td><input type="number" value="${player.battersFaced || ''}"></td>
            <td><input type="number" value="${player.pitches || ''}"></td>
            <td><input type="number" value="${player.hits || ''}"></td>
            <td><input type="number" value="${player.strikeouts || ''}"></td>
            <td><input type="number" value="${player.walks || ''}"></td>
            <td><input type="number" value="${player.runs || ''}"></td>
            <td><input type="number" value="${player.earnedRuns || ''}"></td>
        </tr>
    `).join('');

    // もし投手が一人もいなければ、空の行を1つ追加しておく
    if (pitchingData.length === 0) {
        bodyRows = `
            <tr data-pitcher-index="0">
                <td><select><option value="" selected>-</option><option value="W">○</option><option value="L">●</option><option value="S">S</option><option value="H">H</option></select></td>
                <td><input type="text" value=""></td><td><input type="text" value=""></td><td><input type="number" value=""></td>
                <td><input type="number" value=""></td><td><input type="number" value=""></td><td><input type="number" value=""></td>
                <td><input type="number" value=""></td><td><input type="number" value=""></td><td><input type="number" value=""></td>
            </tr>
        `;
    }

    return `
        <div class="overflow-x-auto">
            <table class="details-table" id="pitching-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="w-12">勝敗</th><th class="col-player">選手名</th><th class="col-stat">回数</th>
                        <th class="col-stat">打者</th><th class="col-stat">球数</th><th class="col-stat">被安打</th>
                        <th class="col-stat">奪三振</th><th class="col-stat">与四球</th><th class="col-stat">失点</th>
                        <th class="col-stat">自責点</th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            <button class="add-row-btn text-xs mt-2" data-table-id="pitching-table-${teamKey}">+ 投手を追加</button>
        </div>
    `;
}

/**
 * 守備ハイライトのテーブルHTMLを生成する
 * @param {string} teamKey - 'team1' または 'team2'
 * @param {object} details - 試合の詳細データ
 * @param {Array} playersOnField - チームの選手リスト
 * @returns {string} - 生成されたHTML
 */
function createFieldingTable(teamKey, details, playersOnField) {
    const fieldingData = details.fielding?.[teamKey] || [];
    
    // 選手名を選択するための <option> タグを生成
    const playerOptions = playersOnField.map(p => `<option value="${p.name}">${p.name}</option>`).join('');

    let bodyRows = fieldingData.map((play, index) => `
        <tr data-fielding-index="${index}">
            <td class="w-16"><input type="number" class="fielding-inning" value="${play.inning || ''}" min="1"></td>
            <td>
                <select class="player-name w-full">
                    <option value="">- 選手 -</option>
                    ${playersOnField.map(p => `<option value="${p.name}" ${p.name === play.player ? 'selected' : ''}>${p.name}</option>`).join('')}
                </select>
            </td>
            <td><input type="text" class="fielding-play" value="${play.play || ''}" placeholder="例: ダイビングキャッチ、レーザービームで補殺"></td>
            <td class="w-12 text-center">
                <button class="remove-fielding-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </td>
        </tr>
    `).join('');
    
    // データが空の場合のデフォルト行は不要（ボタンで追加させる）

    return `
        <div class="overflow-x-auto">
            <table class="details-table" id="fielding-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="w-16">イニング</th>
                        <th>選手名</th>
                        <th>ファインプレーの内容</th>
                        <th class="w-12">削除</th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            <button class="add-fielding-play-btn add-row-btn text-xs mt-2" data-team-key="${teamKey}">+ ファインプレーを追加</button>
        </div>
    `;
}

// ★★★ この関数を丸ごと置き換えてください ★★★
/**
 * 個人別打席結果のテーブルHTMLを生成する（交代選手表示バグ修正・最終版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（スタメン・交代選手の分離を修正した最終版）
 */
/**
 * Creates the batting stats table, with all dropdowns correctly implemented.
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（★列幅クラスを適用した最終版）
 */
// 【完成版】createPlayerBattingTable
/**
 * 個人別打席結果のテーブルHTMLを生成する（複数走者入力UI対応の最終版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（打者・走者入力分離の最終完成版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（複数打席ロジック統合版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（複数打席ロジック統合・最終版）
 */
/**
 * 個人別打席結果のテーブルHTMLを生成する（司令塔として再設計した最終版）
 */
function createPlayerBattingTable(teamName, teamKey, details) {
    const battingData = details.batting[teamKey] || [];
    const numInnings = details.inningScore?.[teamKey]?.length || 9;
    const playersOnField = battingData.filter(p => p.name);

    let numberOptions = '<option value=""></option>';
    for (let i = 1; i <= 20; i++) { numberOptions += `<option value="${i}">${i}</option>`; }
    const posOptions = ['投', '捕', '一', '二', '三', '遊', '左', '中', '右'].map(p => `<option value="${p}">${p}</option>`).join('');
    
    let inningsHeader = '';
    for (let i = 1; i <= numInnings; i++) {
        inningsHeader += `<th class="col-inning">${i}</th>`;
    }

    let bodyRows = '';

    for (let i = 1; i <= 9; i++) {
        let starterData = battingData.find(p => p.order && parseInt(p.order) === i) || { order: i, results: Array(numInnings).fill('') };
        if (!starterData.results) starterData.results = Array(numInnings).fill('');

        const starterNumberSelect = `<select class="player-number w-full bg-transparent">${numberOptions.replace(`value="${starterData.number}"`, `value="${starterData.number}" selected`)}</select>`;
        const starterPosSelect = `<select class="player-pos w-full bg-transparent"><option value=""></option>${posOptions.replace(`value="${starterData.pos}"`, `value="${starterData.pos}" selected`)}</select>`;
        
        let resultInputs = '';
        for (let j = 0; j < numInnings; j++) {
            const resultString = starterData.results[j] || '';
            const atBats = (resultString && resultString.split('、').length > 0) ? resultString.split('、') : [''];
            
            const atBatBlocksHTML = atBats.map(atBatString => 
                createBattingResultDropdowns(playersOnField, atBatString)
            ).join('');

            resultInputs += `
                <td class="col-inning batting-result-cell align-top p-1">
                    ${atBatBlocksHTML}
                    <button class="add-at-bat-btn text-xs mt-2 bg-blue-100 px-2 py-1 rounded hover:bg-blue-200 w-full font-semibold">＋ 2打席目を追加</button>
                </td>
            `;
        }
        bodyRows += `
            <tr data-order="${starterData.order}">
                <td class="col-order">${i}</td><td class="col-number">${starterNumberSelect}</td>
                <td class="col-player"><input type="text" class="player-name" value="${starterData.name || ''}"></td>
                <td class="col-pos flex items-center justify-between">${starterPosSelect}<button class="text-xs bg-gray-200 px-1 ml-1 rounded pos-change-btn" data-player-name="${starterData.name || ''}" data-team-key="${teamKey}">変更</button></td>
                <td class="col-sub-type"></td>${resultInputs}
            </tr>
        `;
        
        const substitutes = battingData.filter(p => p.order && p.order.toString().startsWith(`${i}-sub`));
        substitutes.forEach(subData => {
            if (!subData.results) subData.results = Array(numInnings).fill('');
            const subNumberSelect = `<select class="player-number w-full bg-transparent">${numberOptions.replace(`value="${subData.number}"`, `value="${subData.number}" selected`)}</select>`;
            const subPosSelect = `<select class="player-pos w-full bg-transparent"><option value=""></option>${posOptions.replace(`value="${subData.pos}"`, `value="${subData.pos}" selected`)}</select>`;
            
            let subResultInputs = '';
            for (let j = 0; j < numInnings; j++) {
                const resultString = subData.results[j] || '';
                const atBats = (resultString && resultString.split('、').length > 0) ? resultString.split('、') : [''];
                const atBatBlocksHTML = atBats.map(atBatString => 
                    createBattingResultDropdowns(playersOnField, atBatString)
                ).join('');
                subResultInputs += `
                    <td class="col-inning batting-result-cell align-top p-1">
                        ${atBatBlocksHTML}
                        <button class="add-at-bat-btn text-xs mt-2 bg-blue-100 px-2 py-1 rounded hover:bg-blue-200 w-full font-semibold">＋ 2打席目を追加</button>
                    </td>
                `;
            }
            
            bodyRows += `
                <tr data-order="${subData.order}">
                    <td class="col-order"></td><td class="col-number">${subNumberSelect}</td>
                    <td class="col-player pl-4"><input type="text" class="player-name" value="${subData.name || ''}"></td>
                    <td class="col-pos flex items-center justify-between">${subPosSelect}<button class="text-xs bg-gray-200 px-1 ml-1 rounded pos-change-btn" data-player-name="${subData.name || ''}" data-team-key="${teamKey}">変更</button></td>
                    <td class="col-sub-type">
                        <select class="sub-type-select w-full bg-transparent">
                            <option value="" ${!subData.sub_type ? 'selected' : ''}>-</option>
                            <option value="PH" ${subData.sub_type === 'PH' ? 'selected' : ''}>代打</option>
                            <option value="PR" ${subData.sub_type === 'PR' ? 'selected' : ''}>代走</option>
                            <option value="DEF" ${subData.sub_type === 'DEF' ? 'selected' : ''}>守備</option>
                            <option value="PITCHER" ${subData.sub_type === 'PITCHER' ? 'selected' : ''}>投手</option>
                        </select>
                    </td>
                    ${subResultInputs}
                </tr>
            `;
        });
    }

    return `
        <div class="overflow-x-auto">
            <table class="details-table batting-table" id="batting-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="col-order">打順</th><th class="col-number">#</th><th class="col-player">選手名</th>
                        <th class="col-pos">守備</th><th class="col-sub-type">出場</th>${inningsHeader}
                        <th class="w-10"><button class="add-inning-btn text-xs" data-team-key="${teamKey}">+ 回</button></th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            <button class="add-substitute-btn text-xs mt-2" data-team-key="${teamKey}">+ 交代選手を追加</button>
        </div>
    `;
}
    /**
 * 詳細データを保存し、通算成績を更新する
 * (★先攻後攻を入れ替えた場合にも対応した最終版)
 */
/**
 * 詳細データを保存し、通算成績を更新する（全ての機能を網羅した最終完成版）
 */
/**
 * 詳細データを保存し、通算成績を更新する（省略箇所を全て復元した最終完成版）
 */
/**
 * 詳細データを保存し、通算成績を更新する（データ構造の矛盾を解消した最終完成版）
 */
/**
 * 詳細データを保存し、通算成績を更新する（データ構造の矛盾を解消した最終完成版）
 */
function saveDetailedStats() {
    if (!currentMatchIdForDetails) return;
    const match = findMatchById(currentMatchIdForDetails);
    if (!match) return;

    // --- 1. 古い成績を一度リセット ---
    if (match.details && match.details.playerGameStats) {
        for (const teamKey of ['team1', 'team2']) {
            const teamName = match[teamKey];
            const teamRecord = tournamentState.teamRecords[teamName];
            if (!teamRecord || !teamRecord.playerStats) continue;

            const previousBattingStats = match.details.playerGameStats[teamKey];
            if (previousBattingStats) {
                for (const playerName in previousBattingStats) {
                    const careerStats = teamRecord.playerStats.batting[playerName];
                    const prevGameStats = previousBattingStats[playerName];
                    if (careerStats && prevGameStats) {
                        if(prevGameStats.played) careerStats.games = (careerStats.games || 1) - 1;
                        careerStats.pa -= prevGameStats.pa || 0;
                        careerStats.ab -= prevGameStats.ab || 0;
                        careerStats.h -= prevGameStats.h || 0;
                        careerStats.hr -= prevGameStats.hr || 0;
                        careerStats.rbi -= prevGameStats.rbi || 0;
                    }
                }
            }
            const previousPitchingStats = match.details.pitching?.[teamKey];
            if (previousPitchingStats) {
                previousPitchingStats.forEach(prevGameStats => {
                    const playerName = prevGameStats.name;
                    const careerStats = teamRecord.playerStats.pitching[playerName];
                    if (careerStats && prevGameStats && parseFloat(prevGameStats.innings) > 0) {
                        careerStats.games = (careerStats.games || 1) - 1;
                        if (prevGameStats.result === 'W') careerStats.w--;
                        if (prevGameStats.result === 'L') careerStats.l--;
                        careerStats.ip -= parseFloat(prevGameStats.innings || 0);
                        careerStats.so -= parseInt(prevGameStats.strikeouts || 0);
                        careerStats.er -= parseInt(prevGameStats.earnedRuns || 0);
                    }
                });
            }
        }
    }

    // --- 2. 新しい詳細データオブジェクトを作成 ---
    const details = { 
        inningScore: { team1: [], team2: [] }, 
        batting: { team1: [], team2: [] }, 
        pitching: { team1: [], team2: [] }, 
        fielding: { team1: [], team2: [] }, // ★ fielding を初期化
        playerGameStats: { team1: {}, team2: {} },
        positionChanges: match.details?.positionChanges || []
    };

    
    // --- 3. 画面から入力された値を読み取り、成績を再計算・加算 ---
    const scoreTable = document.getElementById('inning-score-table');
    if (scoreTable) {
        const rows = scoreTable.querySelectorAll('tbody tr');
        const team1Row = Array.from(rows).find(row => row.querySelector('th')?.textContent.trim() === match.team1);
        const team2Row = Array.from(rows).find(row => row.querySelector('th')?.textContent.trim() === match.team2);
        if (team1Row) details.inningScore.team1 = Array.from(team1Row.querySelectorAll('input')).map(input => parseInt(input.value) || 0);
        if (team2Row) details.inningScore.team2 = Array.from(team2Row.querySelectorAll('input')).map(input => parseInt(input.value) || 0);
    }
    match.score1 = details.inningScore.team1.reduce((sum, score) => sum + score, 0);
    match.score2 = details.inningScore.team2.reduce((sum, score) => sum + score, 0);

    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord) continue;
        if (!teamRecord.playerStats) teamRecord.playerStats = { batting: {}, pitching: {} };

        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (battingTable) {
            battingTable.querySelectorAll('tbody tr').forEach(row => {
                const nameInput = row.querySelector('.player-name');
                if (nameInput && nameInput.value.trim() !== '') {
                    
                    const resultCells = Array.from(row.querySelectorAll('td.col-inning'));
                    const results = resultCells.map(cell => {
                        const atBatBlocks = Array.from(cell.querySelectorAll('.at-bat-block'));
                        
                        const atBatsString = atBatBlocks.map(block => {
                            const container = block.querySelector('.batting-result-container');
                            if (!container) return ''; 

                            const resultType = container.querySelector('.result-type').value;
                            const direction = container.querySelector('.result-direction').value;
                            const rbi = container.querySelector('.result-rbi').value;
                            const runnerPlay = container.querySelector('.result-runner-play').value;
                            const batterPlay = [direction, resultType, rbi, runnerPlay].filter(Boolean).join('');
                            
                            // ▼▼▼【重要修正】区切り文字を「、」から「,」に変更▼▼▼
                            const runnerPlays = Array.from(block.querySelectorAll('.runner-play-input')).map(rpContainer => {
                                const name = rpContainer.querySelector('.runner-name').value;
                                const play = rpContainer.querySelector('.runner-play').value;
                                const base = rpContainer.querySelector('.runner-base').value;
                                if (!name || !play) return '';
                                return [name, play, base].filter(Boolean).join(' ');
                            }).filter(Boolean).join(',');
                            // ▲▲▲
                            
                            return [batterPlay, runnerPlays].filter(Boolean).join(';');
                        }).join('、');

                        return atBatsString;
                    });
                    
                    const playerData = {
                        order: row.dataset.order, name: nameInput.value.trim(),
                        number: row.querySelector('.player-number').value,
                        pos: row.querySelector('.player-pos').value,
                        sub_type: row.querySelector('.sub-type-select') ? row.querySelector('.sub-type-select').value : null,
                        results: results
                    };
                    details.batting[teamKey].push(playerData);
                    
                    const playerName = playerData.name;
                    if (!teamRecord.playerStats.batting[playerName]) {
                        teamRecord.playerStats.batting[playerName] = { games: 0, pa: 0, ab: 0, h: 0, hr: 0, rbi: 0 };
                    }
                    const careerStats = teamRecord.playerStats.batting[playerName];
                    const gameStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, played: false };

                    playerData.results.forEach(inningResultString => {
                        if (!inningResultString) return;
                        inningResultString.split('、').forEach(atBatString => {
                            if (!atBatString) return;
                            const [batterPlay] = atBatString.split(';');
                            if (!batterPlay) return;
                            
                            gameStats.played = true;
                            gameStats.pa++;
                            if (!batterPlay.includes('四球') && !batterPlay.includes('死球') && !batterPlay.includes('犠')) gameStats.ab++;
                            
                            const isHitWord = ['安', '二塁打', '三塁打', '本塁打'].some(w => batterPlay.includes(w));
                            if (isHitWord) gameStats.h++;
                            if (batterPlay.includes('本')) gameStats.hr++;
                            if (batterPlay.includes('点')) {
                                const rbiMatch = batterPlay.match(/(\d+)点/);
                                gameStats.rbi += rbiMatch ? parseInt(rbiMatch[1]) : 1;
                            }
                        });
                    });

                    if(gameStats.played) careerStats.games++;
                    careerStats.pa += gameStats.pa;
                    careerStats.ab += gameStats.ab;
                    careerStats.h += gameStats.h;
                    careerStats.hr += gameStats.hr;
                    careerStats.rbi += gameStats.rbi;
                    
                    details.playerGameStats[teamKey][playerName] = gameStats;
                }
            });
        }
        const pitchingTable = document.getElementById(`pitching-table-${teamKey}`);
        if (pitchingTable) {
            pitchingTable.querySelectorAll('tbody tr').forEach(row => {
                const inputs = row.querySelectorAll('input');
                const select = row.querySelector('select');
                if (inputs[0] && inputs[0].value.trim() !== '') {
                    const pitcherData = {
                        result: select.value, name: inputs[0].value.trim(), innings: inputs[1].value,
                        battersFaced: inputs[2].value, pitches: inputs[3].value, hits: inputs[4].value,
                        strikeouts: inputs[5].value, walks: inputs[6].value, runs: inputs[7].value,
                        earnedRuns: inputs[8].value,
                    };
                    details.pitching[teamKey].push(pitcherData);

                    const pitcherName = pitcherData.name;
                    if (!teamRecord.playerStats.pitching[pitcherName]) {
                        teamRecord.playerStats.pitching[pitcherName] = { games: 0, w: 0, l: 0, ip: 0, so: 0, er: 0 };
                    }
                    const careerStats = teamRecord.playerStats.pitching[pitcherName];
                    if (parseFloat(pitcherData.innings) > 0) {
                        careerStats.games = (careerStats.games || 0) + 1;
                        if (pitcherData.result === 'W') careerStats.w++;
                        if (pitcherData.result === 'L') careerStats.l--;
                        careerStats.ip += parseFloat(pitcherData.innings) || 0;
                        careerStats.so += parseInt(pitcherData.strikeouts) || 0;
                        careerStats.er += parseInt(pitcherData.earnedRuns) || 0;
                    }
                }
            });
        }
    }

// ▼▼▼ この for ループをここに追加 ▼▼▼
    for (const teamKey of ['team1', 'team2']) {
        const fieldingTable = document.getElementById(`fielding-table-${teamKey}`);
        if (fieldingTable) {
            fieldingTable.querySelectorAll('tbody tr').forEach(row => {
                const inning = row.querySelector('.fielding-inning')?.value;
                const player = row.querySelector('.player-name')?.value;
                const play = row.querySelector('.fielding-play')?.value;
                
                if (player && play) { // 選手名とプレー内容が入力されている場合のみ保存
                    details.fielding[teamKey].push({
                        inning: inning ? parseInt(inning) : null,
                        player: player,
                        play: play
                    });
                }
            });
        }
    }
    // ▲▲▲ 追加はここまで ▲▲

    match.details = details;
    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord) continue;
        const battingData = details.batting[teamKey];
        if (battingData && battingData.length > 0) {
            teamRecord.roster = battingData
                .filter(p => p.order && !p.order.toString().includes('sub'))
                .map(p => ({ order: p.order, number: p.number, name: p.name, pos: p.pos }));
        }
    }

    saveState();
    detailsModal.classList.add('hidden');
    renderTournament(tournamentState);
    alert('詳細を保存しました。');
}
/**
     * 【修正版】スキップ機能関連
     */
    function generateAutoScore(rankWinner, rankLoser) {
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        const diff = rankValues[rankWinner] - rankValues[rankLoser];
        let winnerScore, loserScore;

        if (diff >= 3) { // 大差
            winnerScore = 7 + Math.floor(Math.random() * 4);
            loserScore = Math.floor(Math.random() * 3);
        } else if (diff >= 2) { // 中差
            winnerScore = 5 + Math.floor(Math.random() * 3);
            loserScore = Math.max(0, winnerScore - (3 + Math.floor(Math.random() * 2)));
        } else if (diff >= 1) { // 小差
            winnerScore = 3 + Math.floor(Math.random() * 4);
            loserScore = Math.max(0, winnerScore - (1 + Math.floor(Math.random() * 2)));
        } else { // 同ランク
            winnerScore = 2 + Math.floor(Math.random() * 5);
            loserScore = winnerScore - 1;
        }
        return [winnerScore, loserScore];
    }

    /**
     * 【修正版】ラウンドを自動でスキップする
     */
    async function skipRound(roundNumber) {
        const btnId = `skip-r${roundNumber}-btn`;
        const btn = document.getElementById(btnId);
        if (btn) btn.disabled = true;

        const matchIds = [];
        const numMatchesInRoundSide = (tournamentState.teams.length / 2) / Math.pow(2, roundNumber - 1);

        ['L', 'R'].forEach(side => {
            for (let i = 1; i <= numMatchesInRoundSide; i++) {
                matchIds.push(`${side}-R${roundNumber}-M${i}`);
            }
        });

        const results = []; // このラウンドの結果を格納する配列

        // ステップ1：ラウンドの全試合の勝敗を決定
        for (const matchId of matchIds) {
            const match = tournamentState.matches[matchId];
            if (!match || match.winner || !match.team1 || !match.team2) continue;

            const { team1, team2 } = match;
            const rank1 = calculateRank(team1, tournamentState);
            const rank2 = calculateRank(team2, tournamentState);
            const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
            let winnerName, loserName;
            
            const upsetChance = 0.15 - (Math.abs(rankValues[rank1] - rankValues[rank2]) * 0.03);

            if (Math.random() < upsetChance) { // 番狂わせ
                winnerName = rankValues[rank1] < rankValues[rank2] ? team1 : team2;
            } else { // 順当
                winnerName = rankValues[rank1] >= rankValues[rank2] ? team1 : team2;
            }
            loserName = winnerName === team1 ? team2 : team1;
            
            const winnerRank = calculateRank(winnerName, tournamentState);
            const loserRank = calculateRank(loserName, tournamentState);

            const [winnerScore, loserScore] = generateAutoScore(winnerRank, loserRank);
            match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
            match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;
            match.winner = winnerName;
            
            if (tournamentState.teamRecords[winnerName]) tournamentState.teamRecords[winnerName].wins++;
            if (tournamentState.teamRecords[loserName]) tournamentState.teamRecords[loserName].losses++;
            
            // ダイジェスト記事用に結果を保存
            results.push({ winnerName, loserName, winnerScore, loserScore, rankDiff: Math.abs(rankValues[rank1] - rankValues[rank2]) });
        }
        
        // ステップ2：勝者を次のラウンドに進める
        const nextRoundNum = roundNumber + 1;
        const numTeams = tournamentState.teams.length;
        const finalRound = Math.log2(numTeams);

        if (nextRoundNum <= finalRound) {
            const numMatchesInNextRoundSide = numTeams / 2 / Math.pow(2, nextRoundNum - 1);
            for (const side of ['L', 'R']) {
                if (nextRoundNum < finalRound) {
                    for (let m = 1; m <= numMatchesInNextRoundSide; m++) {
                        const prevMatch1Id = `${side}-R${roundNumber}-M${(m * 2) - 1}`;
                        const prevMatch2Id = `${side}-R${roundNumber}-M${m * 2}`;
                        const winner1 = tournamentState.matches[prevMatch1Id]?.winner;
                        const winner2 = tournamentState.matches[prevMatch2Id]?.winner;
                        const nextMatchId = `${side}-R${nextRoundNum}-M${m}`;
                        
                        if (!tournamentState.matches[nextMatchId]) {
                            tournamentState.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
                        }
                        tournamentState.matches[nextMatchId].team1 = winner1;
                        tournamentState.matches[nextMatchId].team2 = winner2;
                    }
                } else { // 決勝戦への進出処理
                    const finalMatchId = 'F-R1-M1';
                    if (!tournamentState.matches[finalMatchId]) {
                         tournamentState.matches[finalMatchId] = { id: finalMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
                    }
                    const semiFinalWinner = tournamentState.matches[`${side}-R${roundNumber}-M1`]?.winner;
                    if (side === 'L') tournamentState.matches[finalMatchId].team1 = semiFinalWinner;
                    if (side === 'R') tournamentState.matches[finalMatchId].team2 = semiFinalWinner;
                }
            }
        }
        
        // ステップ3：UIの更新とダイジェスト記事の生成
        renderTournament(tournamentState);
        newsContainer.innerHTML = `<div class="loader">AI記者が${roundNumber}回戦のダイジェスト記事を執筆中...</div>`;

        const summaryArticle = await generateSkipRoundSummaryArticle(roundNumber, results);
        if (summaryArticle) {
            tournamentState.news.push(summaryArticle);
        }
        
        renderNews(tournamentState.news);
        saveState();
        if (btn) btn.classList.add('hidden');
    }
// --- NEW Autumn Tournament System ---

    /**
 * [秋季大会 ステージ1] 地区ブロック予選を開始する（伊豆地区追加・最終版）
 */
/**
 * [秋季大会 ステージ1] 地区ブロック予選を開始する（伊豆地区追加・最終版）
 */
async function setupAutumnRegionalBlocks() {
    tournamentState.autumnPhase = 'regional_blocks';
    
    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    INITIAL_TEAM_POOL.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region) teamsByRegion[region].push(teamName);
    });

    // 主要3地区のブロック分け
    ['東部', '中部', '西部'].forEach(region => {
        let regionalTeams = shuffleArray(teamsByRegion[region]);
        const blocks = [];
        for (let i = 0; i < 4; i++) { // 4ブロック作成
            const blockTeams = regionalTeams.splice(0, 5); // 5チームずつ
            if (blockTeams.length === 0) continue;

            const blockId = `${region}-B${i+1}`;
            
            const playInMatchId = `${blockId}-R0-M1`;
            const semi1Id = `${blockId}-R1-M1`;
            const semi2Id = `${blockId}-R1-M2`;
            const finalId = `${blockId}-R2-M1`;

            const matches = {
                [playInMatchId]: { id: playInMatchId, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '', summary: '' },
                [semi1Id]: { id: semi1Id, team1: null, team2: blockTeams[2], winner: null, score1: '', score2: '', summary: '' },
                [semi2Id]: { id: semi2Id, team1: blockTeams[3], team2: blockTeams[4], winner: null, score1: '', score2: '', summary: '' },
                [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '', summary: '' }
            };
            blocks.push({ id: blockId, teams: blockTeams, matches });
        }
        tournamentState.autumnData.regions[region].blocks = blocks;
    });

    // 伊豆地区の4チームトーナメントを作成
    const izuTeams = shuffleArray(teamsByRegion['伊豆']);
    const izuBracketId = '伊豆-AUTUMN';
    const izuMatches = {
        [`${izuBracketId}-R1-M1`]: { id: `${izuBracketId}-R1-M1`, team1: izuTeams[0], team2: izuTeams[1], winner: null, score1: '', score2: '' },
        [`${izuBracketId}-R1-M2`]: { id: `${izuBracketId}-R1-M2`, team1: izuTeams[2], team2: izuTeams[3], winner: null, score1: '', score2: '' },
        [`${izuBracketId}-R2-M1`]: { id: `${izuBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' } // 決勝
    };
    tournamentState.autumnData.regions['伊豆'].izuBracket = {
        id: izuBracketId,
        teams: izuTeams,
        matches: izuMatches
    };

    renderTournament(tournamentState);
    saveState();
}
   
/**
 * [秋季大会 ステージ1 UI] 地区ブロック予選を描画する（伊豆地区追加・最終版）
 */
function renderAutumnRegionalBlocks() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">秋季大会 地区予選</h2>`;
    html += '<div class="space-y-8">';

    // 東部・中部・西部の描画
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.blocks) continue;

        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">${region}地区 (5枠)</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    ${regionData.blocks.map(block => `
                        <div class="p-3 border rounded-lg bg-gray-50">
                            <h4 class="font-bold text-center mb-2">ブロック ${block.id.split('-')[1]}</h4>
                            ${create5TeamBlockHTML(block)}
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }

    // 伊豆地区の描画
    const izuData = tournamentState.autumnData.regions['伊豆'];
    if (izuData && izuData.izuBracket) {
        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">伊豆地区 (1枠)</h3>
                <div class="flex justify-center">
                    ${create4TeamBlockHTML(izuData.izuBracket)}
                </div>
            </div>
        `;
    }

    html += '</div>';
    autumnRegionalContainer.innerHTML = html;
    checkAutumnRegionalBlocksComplete();
}

    /**
     * 5チーム構成のブロックトーナメントHTMLを生成する
     * @param {object} blockData - 対象ブロックのデータ
     */
    // 【修正対象2】
function create5TeamBlockHTML(blockData) {
    const { id, matches } = blockData;
    const playIn = matches[`${id}-R0-M1`];
    const semi1 = matches[`${id}-R1-M1`];
    const semi2 = matches[`${id}-R1-M2`];
    const final = matches[`${id}-R2-M1`];

    // 試合の進行状況を更新
    semi1.team1 = playIn.winner;
    final.team1 = semi1.winner;
    final.team2 = semi2.winner;

    return `
        <div class="flex items-center justify-center space-x-2 text-xs">
            <div class="flex flex-col justify-around h-full space-y-4">
                <div class="w-40">${createMatchHTML(playIn.id, playIn.team1, playIn.team2, playIn, [])}</div>
                <div class="w-40">${createMatchHTML(semi2.id, semi2.team1, semi2.team2, semi2, [])}</div>
            </div>
            <div class="flex flex-col justify-center h-full w-40">
                ${createMatchHTML(semi1.id, semi1.team1, semi1.team2, semi1, [])}
            </div>
            <div class="flex flex-col justify-center h-full w-40">
                ${createMatchHTML(final.id, final.team1, final.team2, final, [])}
            </div>
        </div>
    `;
}

    /**
     * [秋季大会 ステージ2] 地区内順位決定戦を開始する
     */
    async function setupAutumnRankingTournaments() {
    tournamentState.autumnPhase = 'regional_ranking';

    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        
        // 重要な変更：上位校トーナメントは廃止し、敗者復活戦のみを行う
        regionData.champBracket = null; // 不要になったのでクリア

        // ブロック準優勝したチームで、第5代表決定トーナメントを組む
        const repechageBracketId = `${region}-REP`;
        const repTeams = shuffleArray(regionData.blockRunnersUp);
        regionData.repechageBracket = {
            id: repechageBracketId,
            teams: repTeams,
            matches: {
                [`${repechageBracketId}-R1-M1`]: { id: `${repechageBracketId}-R1-M1`, team1: repTeams[0], team2: repTeams[1], winner: null, score1: '', score2: '', summary: '' },
                [`${repechageBracketId}-R1-M2`]: { id: `${repechageBracketId}-R1-M2`, team1: repTeams[2], team2: repTeams[3], winner: null, score1: '', score2: '', summary: '' },
                [`${repechageBracketId}-R2-M1`]: { id: `${repechageBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '', summary: '' } // 5位決定戦
            }
        };
    }
    
    renderTournament(tournamentState);
    saveState();
}
    /**
     * [秋季大会 ステージ2 UI] 地区内順位決定戦を描画する
     */
   // 【修正対象3】
function renderAutumnRankingTournaments() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">秋季大会 地区 第5代表決定トーナメント</h2>`;
    html += '<div class="space-y-8">';
    
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.repechageBracket) continue;

        const rep = regionData.repechageBracket;
        
        const repSemi1 = rep.matches[`${rep.id}-R1-M1`];
        const repSemi2 = rep.matches[`${rep.id}-R1-M2`];
        rep.matches[`${rep.id}-R2-M1`].team1 = repSemi1.winner;
        rep.matches[`${rep.id}-R2-M1`].team2 = repSemi2.winner;
        
        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">${region}地区</h3>
                <div class="flex items-center justify-center space-x-4">
                    <div class="space-y-4">
                        ${createMatchHTML(repSemi1.id, repSemi1.team1, repSemi1.team2, repSemi1, [])}
                        
                        ${createMatchHTML(repSemi2.id, repSemi2.team1, repSemi2.team2, repSemi2, [])}
                        </div>
                    <div>
                        <p class="text-center font-semibold">代表決定戦</p>
                        ${createMatchHTML(rep.matches[`${rep.id}-R2-M1`].id, rep.matches[`${rep.id}-R2-M1`].team1, rep.matches[`${rep.id}-R2-M1`].team2, rep.matches[`${rep.id}-R2-M1`], [])}
                    </div>
                </div>
            </div>
        `;
    }
    html += '</div>';
    autumnRankingContainer.innerHTML = html;
    checkAutumnRankingTournamentsComplete();
}
    /**
     * [秋季大会 ステージ3] 県大会本戦を開始する
     */
   // 【修正対象4】
/**
 * [秋季大会 ステージ3] 県大会本戦を開始する（組み合わせロジックを修正した完全版）
 */
async function setupAutumnMainTournament() {
    tournamentState.autumnPhase = 'main';
    tournamentState.is16team = true;

    // --- 代表チームのリストを作成 ---
    const finalReps = [];
    // 1. 伊豆地区の代表
    const izuWinner = tournamentState.autumnData.regions['伊豆'].finalReps[0];
    if (izuWinner) finalReps.push(izuWinner.team);

    // 2. 主要3地区の代表
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        // 2-1. ブロック優勝した4チーム
        finalReps.push(...regionData.blockWinners);
        // 2-2. 敗者復活戦を勝ち上がった1チーム
        const repFinal = regionData.repechageBracket.matches[`${region}-REP-R2-M1`];
        if (repFinal.winner) {
            finalReps.push(repFinal.winner);
        }
    }

    // --- トーナメントデータを作成 ---
    tournamentState.teams = shuffleArray(finalReps); // 16チームをシャッフル
    tournamentState.matches = {};
    tournamentState.seeds = []; //秋季県大会はシードなし

    const round1Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    round1Setup.forEach((match, index) => {
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

    renderTournament(tournamentState);
    saveState();

    // --- 記事生成などの後続処理 (変更なし) ---
    const currentTournamentName = "秋季県大会本戦";
    newsContainer.innerHTML = `<div class="loader">AI記者が${currentTournamentName}の展望記事を執筆中...</div>`;
    bbsCommentsContainer.innerHTML = `<div class="loader">AIが組み合わせを分析中...</div>`;

    const [previewArticle, bracketComments] = await Promise.all([
        generateNewsArticle({ matchId: 'preview' }), // ★簡易contextを渡す
    generateBracketReactionComments(tournamentState)
]);
    if (previewArticle) tournamentState.news.unshift(previewArticle);
    if (bracketComments && bracketComments.length > 0) tournamentState.bbsComments.push(...bracketComments);
    
    renderNews(tournamentState.news);
    renderBbsComments(tournamentState.bbsComments);
    saveState();
}
    /**
     * 秋季地区ブロック予選がすべて終了したかチェックする
     */
    function checkAutumnRegionalBlocksComplete() {
    let allBlocksFinished = true;
    // 東部・中部・西部のチェック
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.blocks || regionData.blocks.length === 0) {
            allBlocksFinished = false; break;
        }
        for (const block of regionData.blocks) {
            const finalMatch = block.matches[`${block.id}-R2-M1`];
            if (!finalMatch.winner) {
                allBlocksFinished = false; break;
            }
        }
        if (!allBlocksFinished) break;
    }

    // ▼▼▼ このブロックが修正箇所 ▼▼▼
    // 伊豆地区のチェック
    if (allBlocksFinished) {
        const izuData = tournamentState.autumnData.regions['伊豆'];
        if (!izuData.izuBracket || !izuData.izuBracket.matches[`伊豆-AUTUMN-R2-M1`].winner) {
            allBlocksFinished = false;
        }
    }
    // ▲▲▲

    if (allBlocksFinished) {
        autumnControls.classList.remove('hidden');
        startRankingPlayoffsBtn.classList.remove('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startRankingPlayoffsBtn.classList.add('hidden');
    }
}

    /**
     * 秋季地区内順位決定戦がすべて終了したかチェックする
     */
    /**
     * 【修正版】秋季地区内順位決定戦がすべて終了したかチェックする
     */
    function checkAutumnRankingTournamentsComplete() {
    let allRankingsFinished = true;
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.repechageBracket) {
            allRankingsFinished = false;
            break;
        }

        const repechageFinal = regionData.repechageBracket.matches[`${region}-REP-R2-M1`]; // 5位決定戦

        // 敗者復活戦の決勝がすべて終わっているかチェック
        if (!repechageFinal.winner) {
            allRankingsFinished = false;
            break;
        }
    }
    
    if (allRankingsFinished) {
        autumnControls.classList.remove('hidden');
        startRankingPlayoffsBtn.classList.add('hidden');
        startMainTournamentBtn.classList.remove('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startMainTournamentBtn.classList.add('hidden');
    }
}
// --- NEW Spring Tournament System ---

/**
 * [春季大会 ステージ1] 地区予選を開始する（3校トーナメント対応・最終版）
 */
async function setupSpringRegionalQualifiers() {
    tournamentState.springPhase = 'regional_qualifiers';
    const { qualifierTeams } = tournamentState.springData;

    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    qualifierTeams.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region && teamsByRegion[region]) {
            teamsByRegion[region].push(teamName);
        }
    });
    
    // 東部・中部・西部地区の予選設定
    for (const region of ['東部', '中部', '西部']) {
        let regionalTeams = shuffleArray(teamsByRegion[region]);
        const blockCount = 4;
        const regionBlocks = [];
        
        for (let i = 0; i < blockCount; i++) {
            const blockTeams = regionalTeams.splice(0, Math.ceil(regionalTeams.length / (blockCount - i)));
            if(blockTeams.length === 0) continue;
            
            const blockId = `${region}-SB${i+1}`; // Spring Block
            const blockMatches = {};
            
            // チーム数に応じてトーナメント形式を決定
            if (blockTeams.length <= 4) { // 4チーム以下
                const semi1Id = `${blockId}-R1-M1`;
                const semi2Id = `${blockId}-R1-M2`;
                const finalId = `${blockId}-R2-M1`;
                Object.assign(blockMatches, {
                    [semi1Id]: { id: semi1Id, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '' },
                    [semi2Id]: { id: semi2Id, team1: blockTeams[2] || null, team2: blockTeams[3] || null, winner: null, score1: '', score2: '' },
                    [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '' }
                });
            } else { // 5チーム
                 const playInMatchId = `${blockId}-R0-M1`;
                 const semi1Id = `${blockId}-R1-M1`;
                 const semi2Id = `${blockId}-R1-M2`;
                 const finalId = `${blockId}-R2-M1`;
                 Object.assign(blockMatches, {
                    [playInMatchId]: { id: playInMatchId, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '' },
                    [semi1Id]: { id: semi1Id, team1: null, team2: blockTeams[2], winner: null, score1: '', score2: '' },
                    [semi2Id]: { id: semi2Id, team1: blockTeams[3], team2: blockTeams[4], winner: null, score1: '', score2: '' },
                    [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '' }
                 });
            }
            regionBlocks.push({ id: blockId, teams: blockTeams, matches: blockMatches });
            Object.assign(tournamentState.springData.allMatches, blockMatches);
        }
        tournamentState.springData.regions[region].blocks = regionBlocks;

        // 第5代表決定トーナメントの器を準備
        const repBracketId = `${region}-SREP`;
        tournamentState.springData.regions[region].repechageBracket = {
            id: repBracketId,
            teams: [], // ブロック準優勝校がここに入る
            matches: {
                [`${repBracketId}-R1-M1`]: { id: `${repBracketId}-R1-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' },
                [`${repBracketId}-R1-M2`]: { id: `${repBracketId}-R1-M2`, team1: null, team2: null, winner: null, score1: '', score2: '' },
                [`${repBracketId}-R2-M1`]: { id: `${repBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' }
            }
        };
        Object.assign(tournamentState.springData.allMatches, tournamentState.springData.regions[region].repechageBracket.matches);
    }
    
    // 伊豆地区の予選設定
    const izuTeams = shuffleArray(teamsByRegion['伊豆']);
    const izuBracketId = '伊豆-SIZU'; // IDを'SIZU'に変更
    const izuBracket = { id: izuBracketId, teams: izuTeams, matches: {} };

    if (izuTeams.length === 3) {
        // --- 3校トーナメントの場合 ---
        const semiId = `${izuBracketId}-R1-M1`;
        const finalId = `${izuBracketId}-R2-M1`;
        // 1チームが不戦勝（bye）で決勝へ
        Object.assign(izuBracket.matches, {
            [semiId]: { id: semiId, team1: izuTeams[0], team2: izuTeams[1], winner: null, score1: '', score2: '' },
            [finalId]: { id: finalId, team1: null, team2: izuTeams[2], winner: null, score1: '', score2: '' }
        });
    } else if (izuTeams.length >= 2) {
        // --- 4校（または2校）トーナメントの場合 ---
        const semi1Id = `${izuBracketId}-R1-M1`;
        const semi2Id = `${izuBracketId}-R1-M2`;
        const finalId = `${izuBracketId}-R2-M1`;
        Object.assign(izuBracket.matches, {
            [semi1Id]: { id: semi1Id, team1: izuTeams[0], team2: izuTeams[1], winner: null, score1: '', score2: '' },
            [semi2Id]: { id: semi2Id, team1: izuTeams[2] || null, team2: izuTeams[3] || null, winner: null, score1: '', score2: '' },
            [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '' }
        });
    }
    tournamentState.springData.regions['伊豆'].izuBracket = izuBracket;
    Object.assign(tournamentState.springData.allMatches, izuBracket.matches);

    renderTournament(tournamentState);
    saveState();
}

/**
 * [春季大会 ステージ1 UI] 地区予選を描画する
 */
function renderSpringRegionalQualifiers() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">春季大会 地区予選</h2>`;
    html += '<div class="space-y-8">';

    // 東部・中部・西部
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.springData.regions[region];
        if (!regionData.blocks) continue;

        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-green-700">${region}地区 (5枠)</h3>
                <h4 class="font-bold text-center text-lg mb-2">代表決定ブロック</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    ${regionData.blocks.map(block => `
                        <div class="p-3 border rounded-lg bg-gray-50">
                            <h4 class="font-bold text-center mb-2">ブロック ${block.id.split('-')[1].slice(1)}</h4>
                            ${block.teams.length <= 4 ? create4TeamBlockHTML(block) : create5TeamBlockHTML(block)}
                        </div>
                    `).join('')}
                </div>
                <h4 class="font-bold text-center text-lg mb-2">第5代表決定トーナメント</h4>
                <div class="flex justify-center">
                   ${create4TeamBlockHTML(regionData.repechageBracket, true)}
                </div>
            </div>
        `;
    }

    // 伊豆
    const izuData = tournamentState.springData.regions['伊豆'];
    if (izuData.izuBracket) {
        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-green-700">伊豆地区 (1枠)</h3>
                <div class="flex justify-center">
                    ${create4TeamBlockHTML(izuData.izuBracket)}
                </div>
            </div>
        `;
    }
    
    html += '</div>';
    autumnRegionalContainer.innerHTML = html; // 秋のコンテナを流用
    checkSpringQualifiersComplete();
}

/**
 * 4チーム構成のブロックトーナメントHTMLを生成する
 */
function create4TeamBlockHTML(blockData, isRepechage = false) {
    if (!blockData || !blockData.matches) return '<div></div>';
    const { id, matches } = blockData;
    const semi1 = matches[`${id}-R1-M1`];
    const semi2 = matches[`${id}-R1-M2`];
    const final = matches[`${id}-R2-M1`];
    if (!semi1 || !semi2 || !final) return '<div></div>';

    // 試合の進行状況を更新
    final.team1 = semi1.winner;
    final.team2 = semi2.winner;

    const placeholder = isRepechage ? 'ブロック準優勝校' : '---';

    return `
        <div class="flex items-center justify-center space-x-2 text-xs">
            <div class="space-y-4 w-40">
                ${createMatchHTML(semi1.id, semi1.team1 || placeholder, semi1.team2 || placeholder, semi1, [])}
                ${createMatchHTML(semi2.id, semi2.team1 || placeholder, semi2.team2 || placeholder, semi2, [])}
            </div>
            <div class="w-40">
                ${createMatchHTML(final.id, final.team1, final.team2, final, [])}
            </div>
        </div>
    `;
}

/**
 * 春季地区予選がすべて終了したかチェックする
 */
function checkSpringQualifiersComplete() {
    let allFinished = true;
    for (const match of Object.values(tournamentState.springData.allMatches)) {
        // チームがセットされていて、まだ勝者が決まっていない試合があるか
        if (match.team1 && match.team2 && !match.winner) {
            allFinished = false;
            break;
        }
    }

    if (allFinished) {
        autumnControls.classList.remove('hidden');
        startMainTournamentBtn.classList.remove('hidden'); // 県大会へ進むボタン
        startRankingPlayoffsBtn.classList.add('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startMainTournamentBtn.classList.add('hidden');
    }
}/**
 * [春季大会 ステージ2-1] 県大会本戦1回戦を開始する
 */
async function setupSpringMainTournament_Round1() {
    tournamentState.springPhase = 'main_round1';
    
    // 各地区の代表校をfinalRepsから集計
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.springData.regions[region];
        // ブロック優勝校
        regionData.blocks.forEach(block => {
            const finalMatch = block.matches[`${block.id}-R2-M1`] || block.matches[`${block.id}-R1-M1`]; // 2,3チームブロック対応
            if(finalMatch && finalMatch.winner) regionData.finalReps.push(finalMatch.winner);
        });
        // 第5代表
        const repFinal = regionData.repechageBracket.matches[`${regionData.repechageBracket.id}-R2-M1`];
        if (repFinal.winner) regionData.finalReps.push(repFinal.winner);
    }
    const izuFinal = tournamentState.springData.regions['伊豆'].izuBracket.matches[`伊豆-SIZU-R2-M1`];
    if (izuFinal.winner) tournamentState.springData.regions['伊豆'].finalReps.push(izuFinal.winner);

    const qualifiedTeams = Object.values(tournamentState.springData.regions).flatMap(r => r.finalReps);
    
    // 予選敗退チームの成績を記録
    tournamentState.springData.qualifierTeams.forEach(team => {
        if (!qualifiedTeams.includes(team)) {
            tournamentState.teamRecords[team].lastFinish = 64; // 予選敗退
        }
    });

    tournamentState.teams = shuffleArray(qualifiedTeams); // 予選突破16校で1回戦
    tournamentState.matches = {};
    tournamentState.is16team = true; // 16チームトーナメントとして描画
    tournamentState.seeds = []; // 1回戦はシードなし

    const round1Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    round1Setup.forEach((match, index) => {
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

    renderTournament(tournamentState);
    saveState();
    
    // 展望記事などを生成...
    newsContainer.innerHTML = `<div class="loader">AI記者が県大会1回戦の展望記事を執筆中...</div>`;
    // ★展望記事用の簡易contextを作成して渡す
    const previewContext = { matchId: 'preview' };
    const previewArticle = await generateNewsArticle(previewContext);
    if (previewArticle) tournamentState.news.unshift(previewArticle);

    renderNews(tournamentState.news);
    saveState();
}

/**
 * [春季大会 ステージ2-2] 県大会本戦2回戦を開始する
 */
async function setupSpringMainTournament_Round2() {
    tournamentState.springPhase = 'main_round2_onwards';
    
    const round1Winners = [];
    Object.values(tournamentState.matches).forEach(match => {
        if(match.id.includes('-R1-') && match.winner) {
            round1Winners.push(match.winner);
        }
    });

    const seedTeams = tournamentState.springData.seedTeams;
    const shuffledSeeds = shuffleArray(seedTeams);
    const shuffledWinners = shuffleArray(round1Winners);

    // 2回戦の組み合わせを作成 (シード vs 1回戦勝者)
    let newTeamsForRound2 = [];
    for (let i = 0; i < 8; i++) {
        newTeamsForRound2.push(shuffledSeeds[i]);
        newTeamsForRound2.push(shuffledWinners[i]);
    }
    newTeamsForRound2 = shuffleArray(newTeamsForRound2); // 組み合わせをシャッフル

    tournamentState.teams = newTeamsForRound2;
    tournamentState.matches = {};
    tournamentState.is16team = true;
    tournamentState.seeds = seedTeams; // 2回戦からシード校として表示

    const round2Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    // R1として試合IDを生成するが、これは大会の「2回戦」にあたる
    round2Setup.forEach((match, index) => {
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });
    
    // 敗退チームの成績を記録
    Object.values(tournamentState.teamRecords).forEach(record => {
        if (record.lastFinish > 16 && record.lastFinish <=32) record.lastFinish = 32; // 1回戦敗退はベスト32扱い
    });
    
    renderTournament(tournamentState);
    saveState();

    // 2回戦の展望記事を生成
    newsContainer.innerHTML = `<div class="loader">AI記者が県大会2回戦の展望記事を執筆中...</div>`;
    // ★展望記事用の簡易contextを作成して渡す
    const previewContext = { matchId: 'preview' };
    const previewArticle = await generateNewsArticle(previewContext);
    if (previewArticle) tournamentState.news.unshift(previewArticle);
    if(previewArticle) 
        tournamentState.news.unshift(previewArticle);
    

    renderNews(tournamentState.news);
    saveState();
}


// --- AI Content Generation & Helpers (Part A: Main Generators) ---

/**
 * 試合の全情報を集約した「matchContext」オブジェクトを生成する司令塔（★生の打席結果を渡すように修正）
 * @param {string} matchId - 対象の試合ID
 * @param {string} winnerName - 勝者名
 * @returns {object} - AIに渡すための全ての情報が詰まったオブジェクト
 */
function createMatchContext(matchId, winnerName) {
    const dbMatch = findMatchById(matchId);
    if (!dbMatch) return null;

    const loserName = dbMatch.team1 === winnerName ? dbMatch.team2 : dbMatch.team1;
    const nextOpponentInfo = findNextOpponent(winnerName, matchId);
    let nextOpponentJourney = null;
    if (nextOpponentInfo && nextOpponentInfo.opponentName && !['（未定）', '優勝'].includes(nextOpponentInfo.opponentName)) {
        nextOpponentJourney = getCurrentTournamentPerformance(nextOpponentInfo.opponentName, matchId);
    }

    const { highlights, keyPlayerNames } = createHighlightsText(dbMatch, winnerName);

    // ★★★ ここからが変更点 ★★★
    // generatePlayByPlayTextの呼び出しを削除
    // const playByPlayText = dbMatch.details ? generatePlayByPlayText(dbMatch) : null;

    // 生の打席結果データを抽出
    let rawBattingResults = null;
    if (dbMatch.details && dbMatch.details.batting) {
        rawBattingResults = {
            team1: dbMatch.details.batting.team1?.map(p => ({ name: p.name, order: p.order, results: p.results })),
            team2: dbMatch.details.batting.team2?.map(p => ({ name: p.name, order: p.order, results: p.results }))
        };
    }
    // ★★★ 変更点はここまで ★★★

    const context = {
        winnerName,
        loserName,
        dbMatch,
        matchId,
        winnerData: TEAM_DATA[winnerName],
        loserData: TEAM_DATA[loserName],
        winnerDetailedData: DETAILED_TEAM_DATA[winnerName],
        loserDetailedData: DETAILED_TEAM_DATA[loserName],
        playerStatsText: dbMatch.details ? formatPlayerStatsForPrompt(dbMatch) : null,
                rawBattingResults: rawBattingResults, // ← 新しく追加
        winnerJourney: getCurrentTournamentPerformance(winnerName, matchId),
        loserJourney: getCurrentTournamentPerformance(loserName, matchId),
        winnerLineupChanges: dbMatch.details ? analyzeLineupChanges(winnerName, dbMatch) : "比較データなし",
        loserLineupChanges: dbMatch.details ? analyzeLineupChanges(loserName, dbMatch) : "比較データなし",
        nextOpponent: nextOpponentInfo,
        nextOpponentJourney: nextOpponentJourney,
        highlights: highlights,
        keyPlayerNames: keyPlayerNames,
        calledGame: dbMatch.calledGame,
        calledInning: dbMatch.calledInning
    };
    return context;
}

/**
 * 前試合と今試合のスタメンを比較し、変更点を要約する
 * @param {string} teamName - 分析対象のチーム名
 * @param {object} dbMatch - 現在の試合オブジェクト
 * @returns {string} - 変更点をまとめた短いテキスト
 */
function analyzeLineupChanges(teamName, dbMatch) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord || !teamRecord.previousStarters) {
        return "今大会初戦のため、比較なし。";
    }

    const teamKey = dbMatch.team1 === teamName ? 'team1' : 'team2';
    const previousStarters = teamRecord.previousStarters;
    const currentStarters = dbMatch.details.batting[teamKey].filter(p => p.order && !p.order.toString().includes('sub'));

    if (previousStarters.length === 0 || currentStarters.length === 0) return "比較データなし。";
    
    let changes = [];
    const prevPlayerMap = new Map(previousStarters.map(p => [p.name, p]));
    const currentPlayerMap = new Map(currentStarters.map(p => [p.name, p]));

    // 1. スタメンから外れた選手を検出
    for (const prevPlayer of previousStarters) {
        if (!currentPlayerMap.has(prevPlayer.name)) {
            changes.push(`${prevPlayer.order}番の${prevPlayer.name}がスタメン落ち`);
        }
    }

    // 2. 新しくスタメンに入った選手や、打順が変わった選手を検出
    for (const currPlayer of currentStarters) {
        const prevPlayer = prevPlayerMap.get(currPlayer.name);
        if (!prevPlayer) {
            changes.push(`${currPlayer.order}番に${currPlayer.name}が新しくスタメン入り`);
        } else {
            if (currPlayer.order !== prevPlayer.order) {
                changes.push(`${currPlayer.name}が${prevPlayer.order}番から${currPlayer.order}番に打順変更`);
            }
        }
    }
    
    if (changes.length === 0) {
        return "前試合からスタメン変更なし。";
    }
    
    // AIに渡す情報が多すぎないよう、主な変更点に絞る
    return `主な変更点: ${changes.slice(0, 3).join('、')}。`;
}

/**
 * 打席結果の文字列を、シミュレーションで使える日本語とデータに変換する
 */
function translatePlay(atBatString) {
    if (!atBatString) return { description: "記録なし", type: "none", out: false, base: 0 };
    
    const s = atBatString;
    if (s.includes('本塁打')) return { description: `ホームラン`, type: "hr", out: false, base: 4 };
    if (s.includes('三塁打')) return { description: `三塁打`, type: "triple", out: false, base: 3 };
    if (s.includes('二塁打')) return { description: `二塁打`, type: "double", out: false, base: 2 };
    if (s.includes('安')) return { description: `ヒット`, type: "single", out: false, base: 1 };
    
    if (s.includes('四球') || s.includes('死球')) return { description: `四死球`, type: "walk", out: false, base: 1 };
    if (s.includes('エラー') || s.includes('野選') || s.includes('犠失')) return { description: `エラー/野選`, type: "error", out: false, base: 1 };

    if (s.includes('犠飛')) return { description: `犠牲フライ`, type: "sac_fly", out: true, base: 0 };
    if (s.includes('犠打')) return { description: `犠牲バント`, type: "sac_bunt", out: true, base: 0 };
    if (s.includes('併殺')) return { description: `併殺打`, type: "dp", out: true, base: 0 }; // 2アウトは別途処理

    if (s.includes('三振')) return { description: `三振`, type: "so", out: true, base: 0 };
    if (s.includes('ゴロ')) return { description: `ゴロ`, type: "go", out: true, base: 0 };
    if (s.includes('飛')) return { description: `フライ`, type: "fo", out: true, base: 0 };
    if (s.includes('直')) return { description: `ライナー`, type: "lo", out: true, base: 0 };
    
    return { description: `その他`, type: "other", out: false, base: 0 };
}

/**
 * 1イニング分の試合経過をシミュレートし、テキストを生成する
 */
function processHalfInning(dbMatch, teamKey, inningIndex, batterIndices) {
    let halfInningText = "";
    let outs = 0;
    let bases = [null, null, null]; // [1B, 2B, 3B]
    
    const battingOrder = dbMatch.details.batting[teamKey].filter(p => p.name).sort((a,b) => a.order - b.order);
    if (battingOrder.length === 0) return "";
    
    let batterIndex = batterIndices[teamKey];
    let atBatsInInning = 0;

    while (outs < 3) {
        const batter = battingOrder[batterIndex];
        const resultString = batter.results[inningIndex] || "";
        const atBatsForPlayer = resultString.split('、');

        // このイニングでこの打者がまだ打席に立っていない場合はループを抜ける
        if (atBatsForPlayer.length <= atBatsInInning) break; 
        
        const currentAtBatString = atBatsForPlayer[atBatsInInning];
        if(!currentAtBatString) break;

        const play = translatePlay(currentAtBatString);
        
        // 1. 打席結果をテキストに追加
        halfInningText += `${batter.order}番 ${batter.name} (${batter.pos}): ${play.description}\n`;

        // 2. アウトカウントを更新
        if(play.out) outs++;
        if(play.type === 'dp') outs++; // 併殺打

        if (outs >= 3) {
            halfInningText += `  → ${outs}アウト\n`;
            batterIndex = (batterIndex + 1) % battingOrder.length;
            break;
        }
        
        // 3. ランナーを進塁させる（簡易ロジック）
        const newBases = [null, null, null];
        let batterOnBase = false;

        // まずランナーを進める (3塁から)
        if (bases[2]) { // 3塁ランナー
            if (play.base >= 1 || play.type === 'sac_fly' || play.type === 'walk') newBases[2] = null; // 生還
            else newBases[2] = bases[2];
        }
        if (bases[1]) { // 2塁ランナー
            if (play.base >= 2) newBases[1] = null; // 生還
            else if (play.base === 1 || play.type === 'sac_bunt') newBases[2] = bases[1];
            else newBases[1] = bases[1];
        }
        if (bases[0]) { // 1塁ランナー
            if (play.base >= 3) newBases[0] = null; // 生還
            else if (play.base === 2) newBases[2] = bases[0];
            else if (play.base === 1 || play.type === 'sac_bunt' || play.type === 'walk') newBases[1] = bases[0];
            else newBases[0] = bases[0];
        }
        
        // 打者走者を塁に出す
        if (!play.out && play.base > 0) {
            newBases[play.base - 1] = batter.name;
        }

        bases = newBases;
        
        // 4. 現在の状況をテキストに追加
        const runners = [];
        if(bases[0]) runners.push("1塁");
        if(bases[1]) runners.push("2塁");
        if(bases[2]) runners.push("3塁");
        const runnerText = runners.length > 0 ? `ランナー${runners.join(', ')}` : "ランナーなし";
        halfInningText += `  → ${outs}アウト, ${runnerText}\n`;
        
        batterIndex = (batterIndex + 1) % battingOrder.length;
        atBatsInInning++;
    }

    batterIndices[teamKey] = batterIndex; // 次のイニングの先頭打者を記憶
    
    if (outs < 3) {
      halfInningText += `(${outs}アウトでイニング終了)\n`;
    }
    
    halfInningText += "チェンジ\n";
    return halfInningText;
}

/**
 * 全イニングの試合経過テキストを生成するマスター関数
 */
function generatePlayByPlayText(dbMatch) {
    if (!dbMatch || !dbMatch.details) return "詳細な試合データがありません。";

    let playByPlay = "";
    const numInnings = dbMatch.details.inningScore?.team1?.length || 9;
    // 各チームの次の先頭打者を記録するオブジェクト
    let batterIndices = { team1: 0, team2: 0 };

    for (let i = 0; i < numInnings; i++) {
        // 表の攻撃
        playByPlay += `\n【${i + 1}回表】${dbMatch.team1}の攻撃\n`;
        playByPlay += processHalfInning(dbMatch, 'team1', i, batterIndices);
        
        // サヨナラゲームの判定
        if (i >= 8) { // 9回表以降
            const score1 = (dbMatch.details.inningScore.team1 || []).slice(0, i + 1).reduce((a, b) => a + (b || 0), 0);
            const score2 = (dbMatch.details.inningScore.team2 || []).slice(0, i + 1).reduce((a, b) => a + (b || 0), 0);
            if (dbMatch.team2 === dbMatch.winner && score2 > score1) {
                 break;
            }
        }

        // 裏の攻撃
        playByPlay += `\n【${i + 1}回裏】${dbMatch.team2}の攻撃\n`;
        playByPlay += processHalfInning(dbMatch, 'team2', i, batterIndices);
    }

    playByPlay += "\n--- 試合終了 ---\n";
    return playByPlay;
}

/**
 * Finds a specific team's final result in the tournament.
 */
function getTeamFateSummary(teamName) {
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            if (match.winner !== teamName) {
                const opponent = match.winner;
                const score1 = match.team1 === teamName ? match.score1 : match.score2;
                const score2 = match.team1 === teamName ? match.score2 : match.score1;
                const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 1;
                return `${roundNum}回戦で${opponent}に${score1}-${score2}で敗退した。`;
            }
        }
    }
    
    // Check if the team is still in the tournament
    const isStillIn = Object.values(allMatches).some(match => !match.winner && (match.team1 === teamName || match.team2 === teamName));
    if(isStillIn) {
        return "まだ勝ち残っている。";
    }

    return "（今大会には出場していないか、情報がありません）";
}
   



/**
 * チームの紹介文を動的に生成する最終進化版。
 * TEAM_DATAの固定情報に、最新の成績情報を付け加える。
 * @param {string} teamName - チーム名
 * @param {object} teamData - TEAM_DATAから取得したそのチームの基本情報
 * @param {object} teamRecord - tournamentState.teamRecordsから取得したそのチームの成績記録
 * @returns {string} - 生成された最新の紹介文
 */
function generateDynamicTeamInfo(teamName, teamData, teamRecord) {
// ▼▼▼ この安全装置が、今後のあなたを助けます ▼▼▼
    if (!teamData) {
        // コンソールに、どのチーム名で失敗したかを出力
        console.error(`TEAM_DATAにチーム「${teamName}」が見つかりません。名前のタイプミスがないか確認してください。`);
        // 記事にはエラーメッセージを表示
        return `${teamName}のチーム情報が見つかりませんでした。`;
    }
    // ▲▲▲ ▲▲▲    
// teamData.info が基本の紹介文となる
    const baseInfo = teamData.info || `${teamName}の情報は不明です。`;

    // チームの成績記録がまだない（＝1年目の途中など）場合は、基本情報だけを返す
    if (!teamRecord || !teamRecord.history || teamRecord.history.length === 0) {
        return baseInfo;
    }

    const history = teamRecord.history;

    // --- ここからが追加情報の生成 ---
    let additionalNarrative = []; // 追加情報を入れる配列

    // 創部年数を計算 (2年目以降に意味を持つ情報)
    if (history.length > 0) {
        const establishedYear = history[history.length - 1].year;
        const yearsPassed = tournamentState.tournamentYear - establishedYear + 1;
        // 1年目の最初の大会では表示しないように、2年目以降の情報として扱う
        if (yearsPassed > 1) {
            additionalNarrative.push(`創部${yearsPassed}年目。`);
        }
    }
    
    // 昨年の成績を追加
    const lastFinishLabel = teamRecord.last?.label;
    if (lastFinishLabel && lastFinishLabel !== 'なし') {
        additionalNarrative.push(`昨年は${lastFinishLabel}。`);
    }

    // 過去最高成績を追加
    const bestFinishLabel = teamRecord.best?.label;
    if (bestFinishLabel && bestFinishLabel !== 'なし') {
        additionalNarrative.push(`過去最高は${bestFinishLabel}。`);
    }

    // 称号（Traits）を追加
    const traitDescriptions = {
        'GIANT_KILLER': '「ジャイアントキラー」の異名を持つ。',
        'REPECHAGE_KING': '「敗者復活の王」として知られる。',
    };
    if (teamRecord.teamTraits && teamRecord.teamTraits.length > 0) {
        teamRecord.teamTraits.forEach(traitId => {
            if (traitDescriptions[traitId]) {
                additionalNarrative.push(traitDescriptions[traitId]);
            }
        });
    }

    // --- 最終的な紹介文の組み立て ---
    // もし追加情報が何か一つでもあれば、基本情報に付け加える
    if (additionalNarrative.length > 0) {
        // 例：「（基本情報）。加えて、創部2年目。昨年は県大会2回戦。」のようになる
        return `${baseInfo} ${additionalNarrative.join(' ')}`;
    } 
    // 追加情報がなければ、基本情報だけを返す
    else {
        return baseInfo;
    }
}

 
/**
 * 選手の出場形式コードを、記事で使える自然な日本語に変換する（翻訳機）
 * @param {object} player - 選手のデータオブジェクト
 * @returns {string} - 出場形式を説明する文章
 */
function getSubstitutionDescription(player) {
    // 交代選手でない（スタメン）場合は "スタメン出場" とする
    if (!player.sub_type) {
        return 'スタメン出場';
    }

    // sub_typeの値に応じて、返す文章を切り替える
    switch (player.sub_type) {
        case 'PH':
            return '代打で出場';
        case 'PR':
            return '代走で出場';
        case 'DEF':
            return '守備固めで出場';
        // ▼▼▼ ADD THIS CASE ▼▼▼
        case 'PITCHER': return 'リリーフとして登板';
        // ▲▲▲ END OF ADDITION ▲▲▲
        default:
            return '途中出場'; // 何らかの理由でsub_typeが上記以外の場合
    }
}

/**
 * 試合の個人成績をAIプロンプト用のテキスト形式（★背番号付きボックススコア）にフォーマットする
 * @param {object} dbMatch - 試合オブジェクト
 * @returns {string} - フォーマットされたテキスト
 */
function formatPlayerStatsForPrompt(dbMatch) {
    if (!dbMatch || !dbMatch.details || !dbMatch.details.playerGameStats) {
        return '詳細な個人成績データはありません。';
    }

    const { details, winner } = dbMatch;

    const formatTeamStats = (teamKey) => {
        const teamName = dbMatch[teamKey];
        const isWinner = teamName === winner;
        const battingOrder = details.batting?.[teamKey] || [];
        const gameStats = details.playerGameStats?.[teamKey] || {};
        const pitchingData = details.pitching?.[teamKey] || [];

        let output = `\n**${teamName} (${isWinner ? '勝者' : '敗者'})**\n`;

        const sortedBatters = battingOrder.sort((a, b) => {
            const orderA = parseFloat(a.order.replace('-sub', '.'));
            const orderB = parseFloat(b.order.replace('-sub', '.'));
            return orderA - orderB;
        });

        sortedBatters.forEach(player => {
            if (!player.name) return;
            const stats = gameStats[player.name];
            if (!stats || !stats.played) return; 

            const orderDisplay = player.order.includes('sub') ? `  - ${player.sub_type || '代'}` : `${player.order}.`;
            // ★ここを変更: 選手名の前に背番号を追加
            const playerIdentifier = `[#${player.number}] ${player.name}`; 
            const statsLine = `${stats.ab}打数${stats.h}安打 ${stats.rbi}打点` + (stats.hr > 0 ? ` ${stats.hr}本塁打` : '');
            
            output += `${orderDisplay} ${playerIdentifier} (${player.pos}): ${statsLine}\n`;
        });
        
        pitchingData.forEach(pitcher => {
            if (!pitcher.name || !pitcher.innings) return;
            // ★ここも変更: 投手名の前に背番号を追加 (打撃データから背番号を検索)
            const pitcherData = sortedBatters.find(b => b.name === pitcher.name);
            const pitcherIdentifier = pitcherData ? `[#${pitcherData.number}] ${pitcher.name}` : pitcher.name;
            output += `- 投手: ${pitcherIdentifier} (${pitcher.innings}回 ${pitcher.runs}失点 ${pitcher.strikeouts}奪三振 ${pitcher.walks}四死球)\n`;
        });

        return output;
    };

    return formatTeamStats('team1') + formatTeamStats('team2');
}
/**
 * 試合の詳細データから、AIプロンプト用の個人成績ハイライトを生成する（★投手分析強化版）
 * @param {object} dbMatch - 試合オブジェクト
 * @returns {string} - "勝者・〇〇: 鈴木(4安打), 投手・田中(9回1失点, HQS達成). // 敗者・△△: ..."
 */
function extractKeyPerformances(dbMatch) {
    if (!dbMatch || !dbMatch.details || !dbMatch.details.playerGameStats) {
        return '詳細な個人成績データはありません。';
    }

    const { details, winner } = dbMatch;
    const winnerName = winner;
    const loserName = dbMatch.team1 === winner ? dbMatch.team2 : dbMatch.team1;

    const winnerKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
    const loserKey = dbMatch.team1 === loserName ? 'team1' : 'team2';

    const formatTeamPerformances = (teamKey) => {
        const teamName = dbMatch[teamKey];
        const performances = [];
        
        // 打撃成績の分析 (変更なし)
        const battingStats = details.playerGameStats?.[teamKey] || {};
        for (const playerName in battingStats) {
            const stats = battingStats[playerName];
            const playerHighlights = [];
            if (stats.h >= 3) playerHighlights.push(`${stats.h}安打`);
            if (stats.hr > 0) playerHighlights.push(`${stats.hr}本塁打`);
            if (stats.rbi >= 3) playerHighlights.push(`${stats.rbi}打点`);

            if (playerHighlights.length > 0) {
                const battingData = details.batting[teamKey].find(p => p.name === playerName);
                const order = battingData ? `${battingData.order}番` : '';
                performances.push(`${order}${playerName}(${playerHighlights.join(', ')})`);
            }
        }

        // ★★★ ここからが強化された投手分析ロジック ★★★
        const pitchingData = details.pitching?.[teamKey] || [];
        const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
        const opponentBattingData = details.batting?.[opponentTeamKey] || [];

        pitchingData.forEach(pitcher => {
            if (!pitcher.name) return;
            const pitcherHighlights = [];

            // 1. 基本的な投球結果を分析
            const innings = parseFloat(pitcher.innings || 0);
            const runs = parseInt(pitcher.runs || 0);
            const earnedRuns = parseInt(pitcher.earnedRuns || 0);
            const strikeouts = parseInt(pitcher.strikeouts || 0);
            const walks = parseInt(pitcher.walks || 0);
            const pitches = parseInt(pitcher.pitches || 0);

            // 従来の分析
            if (pitcher.result === 'W') {
                 if (innings >= 9 && earnedRuns === 0) pitcherHighlights.push('完封勝利');
                 else if (innings >= 9) pitcherHighlights.push('完投勝利');
            }
            if (strikeouts >= 10) pitcherHighlights.push(`${strikeouts}奪三振`);
            if (pitcher.result === 'L' && runs >= 5) pitcherHighlights.push(`${runs}失点炎上`);

            // 2. 新しい詳細分析
            if (pitches > 120) pitcherHighlights.push(`${pitches}球の熱投`);
            if (walks >= 5) pitcherHighlights.push(`与四球${walks}と制球難`);

            // 3. イニングごとの内容分析（主に先発投手を対象）
            if (innings >= 6 && opponentBattingData.length > 0) {
                let walksByInning = Array(9).fill(0);
                for (let i = 0; i < 9; i++) {
                    opponentBattingData.forEach(batter => {
                        const result = batter.results[i] || '';
                        if (result.includes('四球') || result.includes('死球')) {
                            walksByInning[i]++;
                        }
                    });
                }

                const earlyInningWalks = walksByInning.slice(0, 5).reduce((a, b) => a + b, 0);
                const lateInningWalks = walksByInning.slice(5, 9).reduce((a, b) => a + b, 0);

                if (lateInningWalks > earlyInningWalks && lateInningWalks >= 3) {
                    pitcherHighlights.push('終盤に制球を乱した');
                } else if (innings >= 7 && earnedRuns <= 2 && pitcher.result !== 'L') {
                    // 良い内容だった場合の評価
                    pitcherHighlights.push('試合を作った'); 
                }
            }
            
            if (pitcherHighlights.length > 0) {
                performances.push(`投手・${pitcher.name}(${pitcherHighlights.join(', ')})`);
            }
        });
        // ★★★ 投手分析ロジックはここまで ★★★

        return performances.length > 0 ? `${teamName}: ${performances.join(', ')}` : '';
    };

    const winnerPerf = formatTeamPerformances(winnerKey);
    const loserPerf = formatTeamPerformances(loserKey);

    return [winnerPerf, loserPerf].filter(Boolean).join(' // ');
}
/**
 * AI記者にニュース記事を執筆させるメイン関数（フィードバック機能付き・最終完全版）
 * @param {string|null} winnerName - 勝者名
 * @param {string|null} loserName - 敗者名
 * @param {object} dbMatch - 試合データ
 * @param {string} matchId - 試合ID
 * @param {object} winnerData - 勝者チームのマスターデータ
 * @param {object} loserData - 敗者チームのマスターデータ
 * @param {object} winnerDetailedData - 勝者チームの詳細選手データ
 * @param {object} loserDetailedData - 敗者チームの詳細選手データ
 * @param {Array} highlightsText - 試合のハイライト
 * @param {Array} keyPlayerNames - 注目選手名
 * @param {object|null} userFeedback - ユーザーからの追加指示
 * @returns {Promise<object|null>}
 */
async function generateNewsArticle(matchContext, userFeedback = null) {
    // --- 1. contextから必要な情報を取り出す ---
    const {
        winnerName, loserName, dbMatch, matchId,
        winnerData, loserData, winnerDetailedData, loserDetailedData,
        winnerLineupChanges, loserLineupChanges,
        winnerJourney, loserJourney,
        nextOpponent // 次の対戦相手の情報
    } = matchContext || {};
    
 let prompt = '';
    // --- 1. 大会展望記事の生成ロジック ---
    if (matchId === 'preview') {
        let prompt;
        const { tournamentYear, seeds, teams, matches, currentTournament, is16team, autumnData } = tournamentState;
        const tournamentName = tournamentNameMap[currentTournament] || '大会';

        // --- 1A. 秋季大会の展望 ---
        if (is16team) { 
            const reps = autumnData;
            const repText = Object.entries(reps.regions).map(([region, data]) => {
                if (!data.finalReps || data.finalReps.length === 0) return null;
                if (region === '伊豆') return `- ${region} (1校): ${data.finalReps[0].team}`;
                const repNames = data.finalReps.sort((a,b) => a.rank - b.rank).map(r => `${r.team}(${r.rank}位)`);
                return `- ${region} (${data.finalReps.length}校): ${repNames.join(', ')}`;
            }).filter(Boolean).join('\n');
            
            const matchups = [];
            for(let i=0; i<teams.length; i+=2) {
                matchups.push(`- ${teams[i]} vs ${teams[i+1]}`);
            }

            prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。野球以外の話題(プログラミング等)には一切触れないでください。
間もなく開幕する「${tournamentYear}年度 秋季大会 県大会本戦」の展望記事を作成してください。
### 大会のポイント
- 秋季大会は新チームで挑む最初の県大会であり、来春のセンバツ出場を占う重要な大会です。
- 地区予選を勝ち上がった順位に応じてポット分けされ、1回戦は同地区対決が避けられるなど、独特の組み合わせが特徴です。
### 県大会出場校一覧 (地区順位順)
${repText}
### 県大会1回戦の組み合わせ
${matchups.join('\n')}
### 執筆指示
- 最も厳しいブロック、いわゆる「死のブロック」はどこか指摘してください。
- 地区1位校と下位ポットの強豪校が当たる、注目の1回戦カードをいくつか挙げてください。
- 地区間のレベル差や、新チームの仕上がりについて分析的な視点で記述してください。
### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
        } 
        // --- 1B. 春季大会の展望 ---
        else if (currentTournament === 'spring') {
            const qualifierWinners = teams.filter(team => !seeds.includes(team));
            const round1Matchups = Object.values(matches)
                .filter(match => match.id.includes('-R1-'))
                .map(match => `- ${match.team1} vs ${match.team2}`);

            const allPromisingSchools = [...seeds, ...qualifierWinners];
            let notablePlayersText = '';
            const notablePlayers = allPromisingSchools.filter(team => DETAILED_TEAM_DATA[team]);
            if (notablePlayers.length > 0) {
                notablePlayersText += '### 今大会の注目選手\n';
                notablePlayers.forEach(team => {
                    const players = DETAILED_TEAM_DATA[team].players.slice(0, 2);
                    notablePlayersText += `- **${team}**: ${players.map(p => `${p.name}(${p.year}年)`).join(', ')}\n`;
                });
            }

            prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。野球以外の話題(プログラミング等)には一切触れないでください。
間もなく開幕する「${tournamentYear}年度 ${tournamentName}」の展望記事を作成してください。
### 大会の見どころ
- 今大会は、秋季大会ベスト8の強豪【シード校】と、厳しい地区予選を勝ち抜いた【予選突破校】が覇を競います。
- 1回戦は予選突破校同士が対戦し、勝ち上がったチームが2回戦でシード校に挑むという、下剋上も期待される注目の形式です。
### シード校 (2回戦から登場)
${seeds.join(', ')}
### 地区予選突破校 (1回戦から登場)
${qualifierWinners.join(', ')}
### 1回戦の注目カード
${round1Matchups.slice(0, 4).join('\n')}
${notablePlayersText}
### 執筆指示
- 予選突破校の中から、シード校を脅かす存在となりそうな「ダークホース」を2～3校挙げてください。
- どのシード校が最も厳しいブロックに入ったか、逆に最も楽なブロックはどこかを分析してください。
- 記事の本文で「注目選手」に言及し、彼らの活躍が大会の鍵を握ることを示唆してください。
- 夏の大会を占う重要な大会として、各チームの仕上がり具合を分析する視点で記述してください。
### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
        } 
        // --- 1C. 夏季大会の展望 ---
        else { 
            const isPromising = (teamName) => {
                const rank = calculateRank(teamName, tournamentState);
                return ['A', 'B'].includes(rank) || seeds.includes(teamName) || TEAM_DATA[teamName].popularity;
            };

            const blockAnalyses = [];
            const numBlocks = 4;
            const blockSize = 16;
            for (let i = 0; i < numBlocks; i++) {
                const blockName = String.fromCharCode(65 + i);
                const start = i * blockSize;
                const end = (i + 1) * blockSize;
                const blockTeams = teams.slice(start, end);
                if (blockTeams.length === 0) continue;
                const promisingInBlock = blockTeams.filter(isPromising);
                blockAnalyses.push(`- ${blockName}ブロック (${blockTeams.length}校): ${promisingInBlock.join(', ')}`);
            }
            const blockAnalysis = blockAnalyses.join('\n');
            
            let notablePlayersText = '';
            const promisingSchools = teams.filter(isPromising);
            const notablePlayers = promisingSchools.filter(team => DETAILED_TEAM_DATA[team]);
            if (notablePlayers.length > 0) {
                notablePlayersText += '### 今大会の注目選手\n';
                notablePlayers.forEach(team => {
                    const players = DETAILED_TEAM_DATA[team].players.slice(0, 2);
                    notablePlayersText += `- **${team}**: ${players.map(p => `${p.name}(${p.year}年)`).join(', ')}\n`;
                });
            }

            prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。野球以外の話題(プログラミング等)には一切触れないでください。
間もなく開幕する「${tournamentYear}年度 ${tournamentName}」の展望記事を作成してください。
### 大会の見どころ
- 3年生にとっては最後の夏であり、甲子園出場をかけた最も熱い戦いです。
- 春の大会の結果などからシード校が決定されていますが、ノーシードの実力校も多く、波乱が予想されます。
### シード校
${seeds.join(', ')}
### 各ブロックの有力校
${blockAnalysis}
${notablePlayersText}
### 執筆指示
- 最も厳しいブロック、いわゆる「死のブロック」はどこか指摘し、その理由を分析してください。
- 有力校が少ない「恵まれたブロック」に入ったチームにも言及してください。
- 「注目選手」を記事に登場させ、彼らが大会の鍵を握る存在であることを示唆してください。
- ノーシードの実力校の中から、大会の「ダークホース」となりそうなチームを挙げてみてください。
### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
        }

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
                if (article) return { ...article, timestamp: Date.now() };
            }
            throw new Error("AI preview response format error.");
        } catch (error) {
            console.error("AI preview article generation failed:", error);
            return { title: "展望記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true, errorId: `preview-${Date.now()}` };
        }
}


    // --- 2. 試合後記事の生成ロジック ---

    // --- 準備フェーズ ---
    const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
    const loserRankDesc = getRankDescription(calculateRank(loserName, tournamentState));
    const winnerRecord = tournamentState.teamRecords[winnerName];
    const loserRecord = tournamentState.teamRecords[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, winnerRecord);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, loserRecord);
　　
    const winnerCoach = winnerData.coach;
    const loserCoach = loserData.coach;
    const battingFirstTeam = dbMatch.team1;
    const battingSecondTeam = dbMatch.team2;
    const winnerPrevRankStr = winnerRecord?.previousRank ? ` (前大会: ${getRankString(winnerRecord.previousRank)})` : '';
    const loserPrevRankStr = loserRecord?.previousRank ? ` (前大会: ${getRankString(loserRecord.previousRank)})` : '';
    const winnerTitles = winnerRecord?.teamTraits?.map(tId => Object.values(TITLES).find(t => t.id === tId)?.name).join(', ') || '';
    const loserTitles = loserRecord?.teamTraits?.map(tId => Object.values(TITLES).find(t => t.id === tId)?.name).join(', ') || '';
    let currentTournamentName = tournamentNameMap[tournamentState.currentTournament] || '大会';

    let roundAchievement = '';
    let seedingImplication = '';
    let specialNarrativeContext = '';
    if (tournamentState.currentTournament === 'autumn') {
        const phase = tournamentState.autumnPhase;
        if (matchId.includes('-')) {
            const [region, bracketType, roundStr] = matchId.split('-');
            const roundNum = parseInt(roundStr?.slice(1));
            if (phase === 'regional_blocks') {
                currentTournamentName = `秋季大会 ${region}地区ブロック予選`;
                if (roundNum === 2) roundAchievement = 'ブロック優勝';
            } else if (phase === 'regional_ranking') {
                currentTournamentName = `秋季大会 ${region}地区内順位決定戦`;
                if (bracketType === 'CHAMP' && roundNum === 2) {
                    roundAchievement = dbMatch.type === 'final' ? '地区1位通過' : '地区3位通過';
                } else if (bracketType === 'REP' && roundNum === 2) {
                    roundAchievement = '第5代表（敗者復活）';
                }
            } else if (phase === 'main') {
                currentTournamentName = '秋季大会 県大会本戦';
                const roundNumMain = parseInt(matchId.split('-')[1].slice(1));
                if (roundNumMain === 1) {
                    roundAchievement = '県大会初戦突破（ベスト8進出）';
                    seedingImplication = 'この勝利で、来季の春季大会のシード権獲得を確実なものとした。';
                    const winnerRank = calculateRank(winnerName, tournamentState);
                    if (winnerData.type === '公立' && (winnerRank === 'D' || winnerRank === 'E')) {
                        specialNarrativeContext = `### 【物語のハイライト】\n県大会出場だけでも快挙だった公立校「${winnerName}」が、初戦を突破し【来春のシード権】まで獲得しました！これは二重の奇跡です。この「シンデレラ・ストーリーの最高潮」をテーマに、歴史的快挙として記事を執筆してください。`;
                    }
                } else if (roundNumMain === 2) roundAchievement = '準々決勝突破(ベスト4進出)';
                else if (roundNumMain === 3) roundAchievement = '準決勝突破(決勝進出)';
            }
        }
    } else if (matchId.includes('-R')) {
        const roundNum = parseInt(matchId.split('-')[1].slice(1));
        const finalRound = tournamentState.is16team ? 4 : 6;
        if (roundNum === finalRound) roundAchievement = (tournamentState.currentTournament === 'summer') ? '甲子園出場決定！' : '優勝！';
        else if (roundNum === finalRound - 1) roundAchievement = '準決勝突破(決勝進出)';
        else if (roundNum === finalRound - 2) roundAchievement = '準々決勝突破(ベスト4進出)';
        else if (roundNum === finalRound - 3) {
            roundAchievement = '3回戦突破(ベスト8進出)';
            if (tournamentState.currentTournament === 'spring') {
                seedingImplication = 'この勝利で、夏の選手権大会のシード権獲得を確実なものとした。';
            }
        } else if (roundNum === 2) roundAchievement = '2回戦突破';
        else if (roundNum === 1) roundAchievement = '初戦突破';
    }
    
    

    // --- 詳細データがある場合 (Aルート) ---
    
 let nextOpponentText = '次の対戦相手は未定。'; // デフォルト
        if (nextOpponent) {
            // パターン1: 対戦相手が決まっている場合
            if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
                nextOpponentText = `次の${nextOpponent.roundName}では、${nextOpponent.opponentName}(${nextOpponent.opponentRank}ランク)と対戦する。`;
            } 
            // パターン2: 対戦相手は未定だが、どの試合の勝者と当たるか分かっている場合
            else if (nextOpponent.decidingMatch) {
                const dm = nextOpponent.decidingMatch;
                nextOpponentText = `次の${nextOpponent.roundName}では、${dm.team1}(${dm.rank1}ランク)と${dm.team2}(${dm.rank2}ランク)の勝者と対戦する。`;
            }
            // パターン3: それ以外の未定の場合 (この場合はデフォルトのまま)
        }
    // --- 詳細データがある場合 (Aルート) ---
    if (dbMatch.details) {
        // --- 準備フェーズ ---
        const { highlights, keyPlayerNames } = createHighlightsText(dbMatch, winnerName);
        const factListText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
        
        const winnerKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
        const winnerPlayersInGame = new Set(
            (dbMatch.details.batting?.[winnerKey] || []).map(p => p.name)
            .concat((dbMatch.details.pitching?.[winnerKey] || []).map(p => p.name))
        );
        const winnerKeyPlayers = keyPlayerNames.filter(name => winnerPlayersInGame.has(name));
        const loserKeyPlayers = keyPlayerNames.filter(name => !winnerPlayersInGame.has(name));

        const formatPlayerList = (playerNames, teamName, detailedTeamData) => {
            if (playerNames.length === 0) return '特になし';
            return playerNames.map(playerName => {
                const detailedInfo = detailedTeamData?.players.find(p => p.name === playerName);
                return detailedInfo ? `- **${detailedInfo.name} (${detailedInfo.year}年・${detailedInfo.position})**: ${detailedInfo.desc}` : `- **${playerName}**`;
            }).join('\n');
        };
        const winnerPlayersPrompt = formatPlayerList(winnerKeyPlayers, winnerName, winnerDetailedData);
        const loserPlayersPrompt = formatPlayerList(loserKeyPlayers, loserName, loserDetailedData);
        
        // ★★★ ここが重要：関数内部での分析は不要になり、渡された情報をそのまま使う ★★★
        const lineupChangesText = `- ${winnerName}: ${winnerLineupChanges}\n- ${loserName}: ${loserLineupChanges}`;
        
        const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, tournamentState.teamRecords[winnerName]);
        const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, tournamentState.teamRecords[loserName]);
        const winnerCoach = winnerData.coach;
        const loserCoach = loserData.coach;

// ▼▼▼ ここから追加 ▼▼▼
        const calledGameText = matchContext.calledGame
            ? `\n- **【重要】** この試合は ${matchContext.calledInning}回コールド (${winnerScore}-${loserScore}) で ${winnerName} が勝利しました。`
            : '';
        // ▲▲▲ 追加ここまで ▲▲▲

        // 1. 次の対戦相手に関するテキストを、3つのパターンに応じて準備する
       
        // ★★★ 修正箇所はここまで ★★★

        prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。
あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。
---
### **参考情報：高校野球における背番号の意味**
- **[#1]**: チームの絶対的エース投手。その投球がチームの運命を左右する。
- **[#2-9]**: 基本的にレギュラーの野手陣。一桁番号はチームの中心選手である証。
- **[#10], [#11]**: エースに次ぐ控え投手。
- **[#12]以降**: ベンチ入りした控え選手。時に監督の秘蔵っ子や、期待の1・2年生が含まれるサプライズ枠。
---
---
// ▼▼▼ この行を追加 ▼▼▼
${matchContext.calledGame ? `- **特記事項:** ${matchContext.calledInning}回コールドゲーム` : ''}
// ▲▲▲ 追加ここまで ▲▲▲
### **【最重要】この記事の唯一の事実情報源 (★背番号付きボックススコア)**
${matchContext.playerStatsText} {/* ← ここで背番号情報が渡されている */}
---
### **【最重要】この記事の唯一の事実情報源**
${factListText}
---
### **参考情報：補足**
- **前試合からのスタメン変更**:
${lineupChangesText}
- **ユーザーによる試合の決め手**: ${dbMatch.summary || 'なし'}
---
### **参考情報：チームと選手のプロフィール**
- **${winnerName}**: ${winnerDynamicInfo}
- **今大会の軌跡**: ${winnerJourney}
  - **監督**: ${winnerCoach ? `${winnerCoach.name} (${winnerCoach.style})` : '情報なし'}
  - **主な選手プロフィール**:\n${winnerPlayersPrompt}
- **${loserName}**: ${loserDynamicInfo}
  - **今大会の軌跡**: ${loserJourney}
  - **監督**: ${loserCoach ? `${loserCoach.name} (${loserCoach.style})` : '情報なし'}
  - **主な選手プロフィール**:\n${loserPlayersPrompt}
---
### **執筆指示**
1.  「事実リスト」を厳密に基に、試合の物語を再構築してください。
2.  **【監督の采配】**: 「スタメン変更」があった場合、その采配が試合にどう影響したかに触れること。
3.  **【物語の連続性】**: 「今大会の軌跡」情報を参考に、これまでの戦いと繋がりのある物語を描写すること。
4.  試合後の両チーム監督のコメントを、試合内容やチームの背景を反映させて生成すること。
5.  **【次戦への展望】**: 記事の最後に、次の対戦相手（${nextOpponentText}）に簡潔に触れ、今後の戦いへの展望を記述して締めくくること。
6.  **【背番号の意味を反映】**: 記事中で選手に言及する際、その選手の背番号が持つ意味を考慮し、物語に深みを与えてください。#は背番号と言い換えてください。(例　#1→背番号1)
7. **【コールドゲームの場合】**: もし試合がコールドで終了した場合、その旨を記事の冒頭やタイトルで明確に記述し、大差がついた理由（一方的な攻撃、相手のミスなど）にも触れること。
---
### 編集長からの追加指示
${(userFeedback && userFeedback.include) ? `- **【最重要指示】** ${userFeedback.include}\n` : ''}
${(userFeedback && userFeedback.exclude) ? `- **【厳禁事項】** ${userFeedback.exclude}\n` : '特になし'}
---
### 出力形式
【最重要】必ず以下のJSON形式"のみ"で出力すること。
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;

    } 
    // --- 詳細データがない場合 (Bルート) ---
    else {
        // (こちらのルートは元々シンプルなので、大きな変更はありません)
        const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
        const loserRankDesc = getRankDescription(calculateRank(loserName, tournamentState));
        const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
        const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);

// ▼▼▼ ここから追加 ▼▼▼
        const calledGameText = matchContext.calledGame
            ? `\n- **【重要】** この試合は ${matchContext.calledInning}回コールド (${winnerScore}-${loserScore}) で ${winnerName} が勝利しました。`
            : '';
        // ▲▲▲ 追加ここまで ▲▲▲



        prompt = `あなたは、高校野球専門のAI記者です。
以下の試合結果に基づき、簡潔で分かりやすいニュース記事を作成してください。
---
// ▼▼▼ この行を追加 ▼▼▼
${matchContext.calledGame ? `- **特記事項:** ${matchContext.calledInning}回コールドゲーム` : ''}
// ▲▲▲ 追加ここまで ▲▲▲
---
### 試合情報
- **勝利チーム**: ${winnerName} (${winnerRankDesc})
- **敗北チーム**: ${loserName} (${loserRankDesc})
- **スコア**: ${winnerScore} - ${loserScore}
- **ユーザーによる試合の決め手**: ${dbMatch.summary || 'なし'}
### 執筆指示
 **【コールドゲームの場合】**: もし試合がコールドで終了した場合、その旨を記事の冒頭やタイトルで明確に記述し、大差がついた理由（一方的な攻撃、相手のミスなど）にも触れること。
- もし「ユーザーによる試合の決め手」に記述があれば、それを中心に記事を構成してください。
- 試合結果を客観的に伝えてください。
- **記事の最後に、次の対戦相手（${nextOpponentText}）に簡潔に触れて締めくくってください。** // ← ★★★ この指示を追加 ★★★
- 記事のタイトルと本文をJSON形式で出力してください。`;
        }

    // --- AIへのリクエスト ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                const isNewspaperWorthy = (dbMatch.details && (tournamentState.currentTournament !== 'autumn' || tournamentState.autumnPhase === 'main'));
                const newspaperHtml = isNewspaperWorthy ? createNewspaperHtml(article, { winnerName, loserName, dbMatch, matchId }) : null;
                return { ...article, isNewspaper: isNewspaperWorthy, timestamp: Date.now(), newspaperHtml };
            }
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI記事の生成に失敗しました:", error);
        return { 
            title: "記事生成エラー", body: "AI記者との通信に失敗しました。", 
            timestamp: Date.now(), error: true, errorId: matchId,
            context: matchContext // ★再生成のためにcontext全体を保存
        };
    }
}
/**
     * AIにスキップしたラウンドのダイジェスト記事を生成させる
     */
    async function generateSkipRoundSummaryArticle(roundNumber, results) {
        // 最も番狂わせが大きかった試合を1つ選出
        const biggestUpset = results.filter(r => r.rankDiff >= 2).sort((a,b) => b.rankDiff - a.rankDiff)[0];
        
        let highlightText = "シード校や有力校が順当に勝ち進みました。";
        if (biggestUpset) {
            highlightText = `最大の波乱は${biggestUpset.winnerName}が強豪${biggestUpset.loserName}を${biggestUpset.winnerScore}-${biggestUpset.loserScore}で破った一戦でした。`;
        }

        const prompt = `あなたは高校野球専門のAI記者です。
現在、${tournamentState.tournamentYear}年度${tournamentNameMap[tournamentState.currentTournament]}が進行中です。
${roundNumber}回戦の全試合が終了しました。以下のハイライトを元に、簡潔なダイジェスト記事を生成してください。

### ${roundNumber}回戦ハイライト
- ${highlightText}
- 次のラウンドでは、勝ち上がった猛者たちによる更なる激戦が期待されます。

### 執筆指示
- 上記のハイライトを自然な文章にまとめてください。
- タイトルは「${roundNumber}回戦が終了！波乱は起きるか？」のように、次への期待感を煽るものにしてください。

### 出力形式
JSON形式で出力してください: {"title": "記事のタイトル", "body": "記事の本文"}`;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
                if (article) return { ...article, timestamp: Date.now() };
            }
            throw new Error("AI summary response format error.");
        } catch (error) {
            console.error("AI summary article generation failed:", error);
            return { title: "ダイジェスト記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true, errorId: `skip-summary-${roundNumber}` };
        }
    }

/**
 * AIに掲示板のコメントを生成させるメイン関数（★context共有方式に統一した最終版）
 * @param {object} matchContext - 試合の全コンテキストデータ
 * @returns {Promise<Array|null>} 生成されたコメントオブジェクトの配列
 */
async function generateBbsComments(matchContext) {
    // --- 1. 受け取った「取材ファイル(matchContext)」から必要な情報を取り出す ---
    const { 
        winnerName, loserName, dbMatch, matchId, 
        winnerData, loserData
    } = matchContext;
    
    // --- 2. AIへの指示を作成するために必要な情報を準備する ---
    const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
    const loserRankDesc = getRankDescription(calculateRank(loserName, tournamentState));
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, tournamentState.teamRecords[winnerName]);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, tournamentState.teamRecords[loserName]);
    let specialNarrativeContext = '';
    
    if (tournamentState.currentTournament === 'autumn' && tournamentState.autumnPhase === 'main' && matchId.includes('-R1-')) {
        const winnerRank = calculateRank(winnerName, tournamentState);
        if (winnerData.type === '公立' && (winnerRank === 'D' || winnerRank === 'E')) {
            specialNarrativeContext = `### 【掲示板の話題】\n衝撃！無名の公立「${winnerName}」が県大会初戦を勝ち、【来春のシード権獲得】だ！この快進撃に驚きと嫉妬のコメントを生成せよ。`;
        }
    }

    let prompt = '';

    // --- 3. 記事の方向性を決定し、AIへの指示書(プロンプト)を作成する ---
    if (dbMatch.details) {
        // 詳細データがある場合 (Aルート)
        const { highlights } = createHighlightsText(dbMatch, winnerName);
        const highlightsText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
        
        prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下の試合結果と詳細なハイライトに基づき、各キャラクターになりきって、辛辣でリアルな短いコメントを5つ生成してください。
### 試合情報
- 勝利チーム: ${winnerName} (${winnerRankDesc})
- 敗北チーム: ${loserName} (${loserRankDesc})
- スコア: ${winnerScore} - ${loserScore}
// ▼▼▼ この行を追加 ▼▼▼
${matchContext.calledGame ? `- **特記事項:** ${matchContext.calledInning}回コールドゲーム` : ''}
// ▲▲▲ 追加ここまで ▲▲▲
- ユーザーが語る試合の決め手: ${dbMatch.summary || '特になし'}
### 試合の主なハイライト
${highlightsText}
### チームの背景
- **${winnerName}**: ${winnerDynamicInfo}
- **${loserName}**: ${loserDynamicInfo}
${specialNarrativeContext}
### あなたがなりきるべきキャラクターと指示
- **熱狂的な勝者チームのOB**: 「試合のハイライト」で活躍した自チームの選手を熱烈に称賛してください。
- **上から目線の野球解説者**: 「試合のハイライト」のプレーを玄人っぽく分析してください。
- **アンチ**: 「試合のハイライト」で活躍した相手選手を「まぐれだ」と貶してください。
- **ライバル校のファン**: 「試合のハイライト」の選手を自チームの選手と比較してください。
- **単なる野球好き**: 「試合のハイライト」で最も印象的だったプレーの感想を述べてください。
// ▼▼▼ この指示を追加 ▼▼▼
- **【コールドゲームの場合】**: もし試合がコールドで終了した場合、その圧勝ぶりや大差がついたことについて、キャラクターに応じた反応（称賛、煽り、驚きなど）をコメントに含めてください。
// ▲▲▲ 追加ここまで ▲▲▲
### 出力形式
【最重要】必ず以下のJSON配列形式"のみ"で出力してください。
[ {"personality": "（キャラクター名）", "comment": "（生成したコメント）"} ]`;
    } else {
        // 詳細データがない場合 (Bルート)
        prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下の試合結果について、それぞれのキャラクターになりきって、辛辣でリアルな短いコメントを5つ生成してください。
### 試合情報
- 勝利チーム: ${winnerName} (${winnerRankDesc})
- 敗北チーム: ${loserName} (${loserRankDesc})
- スコア: ${winnerScore} - ${loserScore}
// ▼▼▼ この行を追加 ▼▼▼
${matchContext.calledGame ? `- **特記事項:** ${matchContext.calledInning}回コールドゲーム` : ''}
// ▲▲▲ 追加ここまで ▲▲▲
- ユーザーが語る試合の決め手: ${dbMatch.summary || '特になし'}
### チームの背景
- **${winnerName}**: ${winnerDynamicInfo}
- **${loserName}**: ${loserDynamicInfo}
${specialNarrativeContext}
### あなたがなりきるべきキャラクターと指示
- **熱狂的な勝者チームのOB**: 勝利を喜び、チームの伝統や背景に触れてコメントしてください。
- **上から目線の野球解説者**: 順当な結果か、意外な結果かを分析してください。
- **アンチ**: 負けたチームや、スコアが僅差だったチームを批判してください。
- **ライバル校のファン**: 試合結果を見て、自チームとの力関係を測るようなコメントをしてください。
- **単なる野球好き**: スコアを見て、接戦だったか、一方的だったかなどの感想を述べてください。
// ▼▼▼ この指示を追加 ▼▼▼
- **【コールドゲームの場合】**: もし試合がコールドで終了した場合、その圧勝ぶりや大差がついたことについて、キャラクターに応じた反応（称賛、煽り、驚きなど）をコメントに含めてください。
// ▲▲▲ 追加ここまで ▲▲▲
### 出力形式
【最重要】必ず以下のJSON配列形式"のみ"で出力してください。
[ {"personality": "（キャラクター名）", "comment": "（生成したコメント）"} ]`;
    }

    // --- 4. AIへリクエストを送信し、結果を整形して返す ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AIからの応答が、正しい配列形式ではありません。");
    } catch (error) {
        console.error("AI掲示板コメントの生成に失敗しました:", error);
        return [{
            id: `error-${matchId}-bbs`,
            error: true,
            title: `掲示板コメント生成エラー`,
            context: matchContext // ★エラー時に再生成できるよう、context全体を保存
        }];
    }
}
/**
     * AIに代矢東応援掲示板のコメントを生成させる
     */
    async function generateDaiyaBbsComments(winnerName, loserName, dbMatch, nextOpponentInfo) {
        const isDaiyaWinner = winnerName === '静岡';
        const opponentName = isDaiyaWinner ? loserName : winnerName;
        const opponentRank = calculateRank(opponentName, tournamentState);
        const resultContext = isDaiyaWinner ? '勝利' : '敗北';
        const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
        const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;
        const score = `${winnerScore} - ${loserScore}`;
        
        const prompt = `あなたは、静岡の古豪「静岡」高校野球部の熱狂的なファンです。あなたは野球に非常に詳しく、常に冷静に試合を分析し、どうすればチームが甲子園に行けるかを考えています。
以下の試合結果について、あなたらしいコメントを5つ生成してください。

### 試合情報
- 試合結果: 静岡の${resultContext}
- 対戦相手: ${opponentName} (${getRankDescription(opponentRank)})
- スコア: ${score}

### あなたのキャラクターと指示
- あなたは生粋の野球好きで、静岡のファンが集う特設掲示板の常連です。
- **もし代矢東が勝利した場合:**
  - 喜びつつも、冷静に勝因を分析してください（例：「今日の勝因は継投のタイミングだな」「あの場面のスクイズは見事だった」）。
  - すぐに次の対戦相手に目を向け、どうすれば勝てるかの戦略を語ってください（例：「次は〇〇か…キーマンは相手の3番打者だ。徹底的にインコースを攻めるべき」）。
  - 決して浮かれず、常に甲子園への道を冷静に見据えてください。
- **もし代矢東が敗北した場合:**
  - 非常に落胆し、性格の悪さを露呈してください。
  - 敗因を厳しく追及してください（例：「なぜあの場面でピッチャーを変えなかったんだ」「監督の采配ミスだろ」）。
  - 「【悲報】静岡、今年も甲子園いけず…」のような、絶望的なスレッドタイトルを必ず一つ生成してください。
  - 来年に向けての不安や、チームの課題を辛辣に指摘してください。

### 出力形式
必ず以下のJSON配列形式で出力してください。
[
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"}
]`;
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const commentsJson = parseJsonFromText(rawText);
                if (Array.isArray(commentsJson)) {
                    return commentsJson.map(c => ({
                        id: crypto.randomUUID(),
                        personality: c.personality,
                        text: c.comment,
                        timestamp: Date.now(),
                        replies: []
                    }));
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("代矢東 掲示板コメントの生成に失敗しました:", error);
            return [];
        }
    }

   /**
 * AIに組み合わせ決定時の掲示板の反応を生成させる
 * ★★★ 詳細な組み合わせ分析を追加した完成版 ★★★
 */
async function generateBracketReactionComments(state) {
    const { teams, seeds } = state;
    // チーム数が少ない場合はコメントを生成しない
    if (teams.length < 8) return [];

    let analysis = ''; // 組み合わせ分析を入れる変数
    let commentDirections = ''; // AIへの指示を入れる変数

    // --- トーナメント表の詳細分析ロジック ---
    const numBlocks = Math.max(1, Math.ceil(teams.length / 16)); // 64チームなら4ブロック、16チームなら1ブロック
    const blockSize = Math.floor(teams.length / numBlocks);
    const blockData = []; // 各ブロックの情報を格納 [{ name: 'A', teams: [...], strongTeams: [...], matchupsR1: [...], potentialR2: [], potentialR3: [] }, ...]
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 }; // ランクの強さ

    const getTeamRank = (teamName) => calculateRank(teamName, state); // チームランク取得関数

    for (let i = 0; i < numBlocks; i++) {
        const blockName = String.fromCharCode(65 + i);
        const startIdx = i * blockSize;
        const endIdx = (i + 1) * blockSize;
        const blockTeams = teams.slice(startIdx, endIdx);
        if (blockTeams.length === 0) continue;

        const strongTeamsInBlock = blockTeams.filter(team => {
            const rank = getTeamRank(team);
            return seeds.includes(team) || ['A', 'B'].includes(rank);
        });

        const matchupsR1 = []; // 1回戦のカード
        const potentialR2 = []; // 2回戦で当たりそうなカード
        const potentialR3 = []; // 3回戦で当たりそうなカード (64チーム時)

        // 1回戦の分析
        for (let j = 0; j < blockTeams.length; j += 2) {
            const team1 = blockTeams[j];
            const team2 = blockTeams[j + 1];
            if (!team1 || !team2) continue;
            const rank1 = getTeamRank(team1);
            const rank2 = getTeamRank(team2);
            const matchup = { team1, rank1, team2, rank2 };
            matchupsR1.push(matchup);
            // 1回戦での有力校潰し合いチェック
            if ((seeds.includes(team1) || ['A', 'B'].includes(rank1)) && (seeds.includes(team2) || ['A', 'B'].includes(rank2))) {
                matchup.isCrush = true; // 潰し合いフラグ
            }
        }

        // 2回戦以降の有力カード予測 (簡易版)
        if (blockTeams.length >= 4) {
            for (let j = 0; j < matchupsR1.length; j += 2) {
                const winner1Match = matchupsR1[j];
                const winner2Match = matchupsR1[j + 1];
                if (!winner1Match || !winner2Match) continue;
                // 各1回戦で有力な方が勝ち上がると仮定
                const potentialWinner1 = rankValues[winner1Match.rank1] >= rankValues[winner1Match.rank2] ? winner1Match.team1 : winner1Match.team2;
                const potentialWinner2 = rankValues[winner2Match.rank1] >= rankValues[winner2Match.rank2] ? winner2Match.team1 : winner2Match.team2;
                // 両方とも有力校なら2回戦の注目カード候補
                if (strongTeamsInBlock.includes(potentialWinner1) && strongTeamsInBlock.includes(potentialWinner2)) {
                    potentialR2.push(`${potentialWinner1} vs ${potentialWinner2}`);
                }
            }
        }
        // 3回戦 (64チームトーナメントの場合のみ)
        if (teams.length === 64 && blockTeams.length >= 8) {
             // 簡易的にブロック内のシード校同士が当たる可能性などをリストアップ (より詳細な予測も可能)
             const blockSeeds = strongTeamsInBlock.filter(t => seeds.includes(t));
             if (blockSeeds.length >= 2) {
                 potentialR3.push(`${blockSeeds[0]} vs ${blockSeeds[1]} (予想)`); // 例: ブロック内のシード上位2校
             }
        }


        blockData.push({
            name: blockName,
            teams: blockTeams,
            strongTeams: strongTeamsInBlock,
            matchupsR1: matchupsR1,
            potentialR2: potentialR2,
            potentialR3: potentialR3
        });
    }

    // 分析結果をテキストにまとめる
    let blockSummary = '';
    let crushR1 = []; // 1回戦潰し合いリスト
    let goodCardsR2 = []; // 2回戦好カードリスト
    let goodCardsR3 = []; // 3回戦好カードリスト

    blockData.forEach(block => {
        blockSummary += `- ${block.name}ブロック: 有力校 ${block.strongTeams.length}チーム (${block.strongTeams.join(', ') || 'なし'})\n`;
        block.matchupsR1.forEach(m => {
            if (m.isCrush) {
                crushR1.push(`${block.name}ブロック: ${m.team1}(${m.rank1}) vs ${m.team2}(${m.rank2})`);
            }
        });
        if (block.potentialR2.length > 0) {
            goodCardsR2.push(...block.potentialR2.map(card => `${block.name}ブロック: ${card}`));
        }
         if (block.potentialR3.length > 0) {
            goodCardsR3.push(...block.potentialR3.map(card => `${block.name}ブロック: ${card}`));
        }
    });

    // 死のブロックと恵まれたブロックを判定
    blockData.sort((a, b) => b.strongTeams.length - a.strongTeams.length);
    const deathBlock = blockData[0];
    const blessedBlock = blockData[blockData.length - 1];

    analysis = `夏の選手権、組み合わせ決定！ 各ブロックの有力校:\n${blockSummary}`;
    analysis += `\n--- 詳細分析 ---\n`;
    analysis += `◆ 死のブロック: ${deathBlock.name}ブロック (有力校 ${deathBlock.strongTeams.length}チーム)\n`;
    analysis += `◆ 恵まれたブロック: ${blessedBlock.name}ブロック (有力校 ${blessedBlock.strongTeams.length}チーム)\n`;
    if (crushR1.length > 0) {
        analysis += `◆ 1回戦での有力校潰し合い:\n${crushR1.map(c => `  - ${c}`).join('\n')}\n`;
    } else {
        analysis += `◆ 1回戦での有力校同士の直接対決はなし。\n`;
    }
    if (goodCardsR2.length > 0) {
        analysis += `◆ 勝ち上がれば2回戦で実現しそうな好カード:\n${goodCardsR2.map(c => `  - ${c}`).join('\n')}\n`;
    }
     if (goodCardsR3.length > 0) {
        analysis += `◆ 勝ち上がれば3回戦で実現しそうな好カード:\n${goodCardsR3.map(c => `  - ${c}`).join('\n')}\n`;
    }

    commentDirections = `
- 分析結果に基づき、「死のブロック」に入ったチームへの同情や、「恵まれたブロック」への羨望コメント。
- 「1回戦の潰し合い」カードについて、「もったいない」「初戦から熱い」などの反応。
- 「2回戦・3回戦の好カード」予想について、「〇〇ブロックは3回戦が事実上の決勝だな」「△△ vs □□が見たい！」などの期待コメント。
- 自分の応援するチームがどのブロックに入り、勝ち上がりはどうなりそうか、という個人的な視点でのコメント。
- シード校が順当に勝ち上がるのか、ノーシードのダークホースが波乱を起こすのか、といった大会全体の展望。`;
    // --- ここまでが分析ロジック ---

    // --- プロンプトの組み立て (分析結果を反映) ---
    const prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下のトーナメントの組み合わせ分析を読んで、ファンらしいリアルな短いコメントを**7～10個**生成してください。

### 組み合わせ分析結果
${analysis}

### コメントの方向性 (上記の分析結果を踏まえて)
${commentDirections}

### 出力形式
必ず以下のJSON配列形式で出力してください。
[
  {"personality": "匿名ファンA", "comment": "（コメント本文）"},
  {"personality": "野球通B", "comment": "（コメント本文）"},
  {"personality": "悲観的なファンC", "comment": "（コメント本文）"}
]`; // personalityは適当に変えてOK

    // --- AIへのリクエストと結果の処理 (変更なし) ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                // 順序を保持しつつ、personalityを少しランダムにする
                const personalities = ["風吹けば名無し", "＠実況は実況板で", "甲子園大好き芸人", "データ厨", "OBのおっちゃん"];
                return commentsJson.map((c, index) => ({
                    id: crypto.randomUUID(),
                    // 元の personality を使いつつ、少しバリエーションを加える
                    personality: `${index + 1}: ${c.personality || personalities[Math.floor(Math.random() * personalities.length)]}`,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI組み合わせ反応コメントの生成に失敗しました:", error);
        return []; // エラー時は空配列を返す
    }
}
    
/**
 * Takes a user's comment and generates multiple AI fan replies to it.
 */
/**
 * Generates multiple AI fan replies to a user's top-level comment,
 * using the same advanced logic as the in-thread reply function.
 */
/**
 * ユーザーのコメント一つに対して、複数のAIファンからの返信を一度に生成する
 * (★チームの敗退状況も認識する最終版)
 */
async function generateMultipleReplies(userCommentText) {
    const conversationHistory = `あなた: 「${userCommentText}」`;

    // --- AIに与える「知識」の部分を作成（完全版） ---
    const mentionedTeams = new Set();
    const mentionedPlayers = new Set(); // ★言及された選手名を保存するSet

    INITIAL_TEAM_POOL.forEach(team => {
        if (userCommentText.includes(team)) {
            mentionedTeams.add(team);
            // チーム名が言及されたら、そのチームの全選手を潜在的な調査対象とする
            const detailedData = DETAILED_TEAM_DATA[team];
            if (detailedData) {
                detailedData.players.forEach(p => mentionedPlayers.add({name: p.name, team: team}));
            }
        } else {
            // チーム名がなくても、選手名単体で言及されている場合
            const detailedData = DETAILED_TEAM_DATA[team];
            if(detailedData) {
                detailedData.players.forEach(p => {
                    if (userCommentText.includes(p.name)) {
                        mentionedPlayers.add({name: p.name, team: team});
                    }
                });
            }
        }
    });

    let teamInfoPromptPart = '### 参考情報：関連チームと選手の状況\n';
    
    // チーム全体の状況
    mentionedTeams.forEach(teamName => {
        const teamData = TEAM_DATA[teamName];
        const teamRecord = tournamentState.teamRecords[teamName];
        const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord);
        const fate = getTeamFateSummary(teamName);
        teamInfoPromptPart += `- **${teamName}**: ${dynamicInfo} (今大会の状況: ${fate})\n`;
    });

    // 言及された全選手の個人成績
    if (mentionedPlayers.size > 0) {
        teamInfoPromptPart += `\n- **主な選手の今大会成績**:\n`;
        mentionedPlayers.forEach(playerInfo => {
            const statsSummary = getPlayerTournamentStatsSummary(playerInfo.name, playerInfo.team);
            if (statsSummary) {
                teamInfoPromptPart += `  - ${statsSummary}\n`;
            }
        });
    }

    // --- プロンプト作成 ---
    const prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
ユーザー「あなた」の投稿した以下のコメントに対し、4人の異なるキャラクターとして返信してください。
### **ユーザーのコメント**: 「${userCommentText}」
### **現在の大会状況**: ${getTournamentStatusSummary()}
${teamInfoPromptPart}
### **指示**:
- 各キャラクターの返信は、必ずユーザーのコメント内容に直接関連していること。
- **【重要】**: あなたの知識である「参考情報」を最大限に活用し、具体的なチーム状況や選手成績に触れながら、的確な返信をすること。
- **【注意】**: まだ大会序盤である（例：2試合しか終わっていない）ことを考慮し、「本塁打が少ない」といった早計な批判は避けること。
---
---### **ステップ4：出力形式**
【最重要】必ず以下のJSON配列形式"のみ"で出力すること。
[
    {"personality": "熱狂的なファン", "comment": "（コメント本文）"},
    {"personality": "上から目線の解説者", "comment": "（コメント本文）"},
    {"personality": "アンチ", "comment": "（コメント本文）"},
    {"personality": "ライバル校のファン", "comment": "（コメント本文）"}
]`;
    
    // --- 4. Call AI and Process Response ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI multi-reply generation failed:", error);
        return [];
    }
}

/**
     * AIにナムコグループからのお知らせを生成させる
     */
    async function generateNamcoNews(state, type, matchData = null) {
        const namcoSchools = ["初星学園", "765総合高校", "283学園", "美城学園", "283学園B"];
        let prompt = '';

        if (type === 'bracket') {
            const participatingSchools = state.teams.filter(t => namcoSchools.includes(t));
            if(participatingSchools.length === 0) return null;

            const matchups = participatingSchools.map(school => {
                const schoolIndex = state.teams.indexOf(school);
                if (schoolIndex === -1) return null;
                const opponentIndex = schoolIndex % 2 === 0 ? schoolIndex + 1 : schoolIndex - 1;
                const opponentName = state.teams[opponentIndex];
                return `- ${school} の初戦は ${opponentName} と対戦します。`;
            }).filter(item => item !== null).join('\n');

            prompt = `あなたはナムコグループの広報担当者です。
夏の高校野球選手権大会の組み合わせが決定しました。
以下の情報に基づき、グループの公式サイトに掲載する、プロフェッショナルで丁寧な「お知らせ」記事を生成してください。

### 各校の初戦の組み合わせ
${matchups}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）組み合わせ決定のお知らせ」とする。
- 本文では、抽選会が行われたことと、上記の組み合わせが決定したことを報告してください。
- 最後に、系列校野球部への応援をお願いする言葉で締めくくる。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}`;
        } else if (type === 'matchResult') {
            const { winnerName, loserName, dbMatch } = matchData;
            const isCivilWar = (winnerName === '283学園' && loserName === '283学園B') || (winnerName === '283学園B' && loserName === '283学園');

            if (isCivilWar) {
                // ... (省略)
            } else {
                const namcoTeam = namcoSchools.includes(winnerName) ? winnerName : loserName;
                const opponent = namcoSchools.includes(winnerName) ? loserName : winnerName;
                const result = namcoSchools.includes(winnerName) ? '勝利' : '敗北';
                const score = namcoSchools.includes(winnerName) ? `${dbMatch.score1}-${dbMatch.score2}` : `${dbMatch.score2}-${dbMatch.score1}`;

                prompt = `あなたはナムコグループの広報担当者です。
本日行われた、夏の高校野球選手権大会の試合結果について、公式サイトに掲載する「お知らせ」記事を生成してください。

### 試合情報
- 系列校: ${namcoTeam}
- 対戦相手: ${opponent}
- 結果: ${namcoTeam}の${result}
- スコア: ${score}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）試合結果のお知らせ」とする。
- 本文では、まず試合が行われたことと、結果を簡潔に報告する。
- **もし勝利した場合:**
  - 応援への感謝を述べ、次の試合への意気込みを語る（例：「次戦もチーム一丸となって勝利を目指します」）。
- **もし敗北した場合:**
  - 選手たちの健闘を称え、応援への感謝を深く述べる（例：「皆様の熱い声援が、選手の力となりました。心より感謝申し上げます」）。
  - 新チームでの再起を誓う言葉で締めくくる。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}`;
            }
        }

        if (!prompt) return null;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const newsJson = parseJsonFromText(rawText);
                if (newsJson) {
                    return { ...newsJson, timestamp: Date.now() };
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("ナムコニュースの生成に失敗しました:", error);
            return null;
        }
    }
/**
     * AIにスポーツ新聞の一面を生成させる
     */
    /**
     * AIが生成した新聞データからHTMLを生成する
     */
    function createNewspaperHtml(articleData, matchData) {
        const { winnerName, loserName, dbMatch, matchId } = matchData;
        const idParts = matchId.split('-');
        const roundNum = idParts[0] === 'F' ? Math.log2(tournamentState.teams.length) : parseInt(idParts[1].slice(1));

        const isLateRound = roundNum >= 4;
        const containerClass = isLateRound ? 'newspaper-late' : 'newspaper-early';
        const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
        const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;

        return `
            <div class="newspaper-container ${containerClass}">
                <div class="newspaper-header">
                    <h2 class="newspaper-title">熱闘高校野球</h2>
                    <p class="newspaper-date">${new Date(articleData.timestamp).toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                </div>
                <div class="newspaper-content">
                    <h1 class="newspaper-main-headline">${winnerName.slice(0, 4)}</h1>
                    <div class="newspaper-body-content">
                        <h2 class="newspaper-sub-headline">${articleData.title}</h2>
                        ${isLateRound ? '<div class="newspaper-image-placeholder">[試合の様子の写真]</div>' : ''}
                        <p class="newspaper-text">${articleData.body.replace(/\\n/g, '\n')}</p>
                        <div class="newspaper-score-box">
                            <h3>最終スコア</h3>
                            <p class="score">${winnerName} ${winnerScore} - ${loserScore} ${loserName}</p>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
async function generateSportsNewspaper(roundNumber) {
        const numTeams = tournamentState.is16team ? 16 : 64;
        const finalRound = Math.log2(numTeams);

        const roundNameMap = {
            [finalRound]: '決勝',
            [finalRound-1]: '準決勝',
            [finalRound-2]: '準々決勝',
            [finalRound-3]: '3回戦'
        };

        const roundName = roundNameMap[roundNumber];
        if (!roundName) return null;

        const matchIdsInRound = Object.keys(tournamentState.matches).filter(id => 
            (id.includes(`-R${roundNumber}-`)) || (roundNumber === finalRound && id.includes('F-R1-'))
        );
        const results = matchIdsInRound.map(id => tournamentState.matches[id]);

        const resultsText = results.map(match => {
            const winnerRank = getRankDescription(calculateRank(match.winner, tournamentState));
            const loser = match.team1 === match.winner ? match.team2 : match.team1;
            const loserRank = getRankDescription(calculateRank(loser, tournamentState));
            const winnerScore = match.team1 === match.winner ? match.score1 : match.score2;
            const loserScore = match.team1 === match.winner ? match.score2 : match.score1;
            return `${winnerRank}・${match.winner}が${loserRank}・${loser}に ${winnerScore}-${loserScore} で勝利。`;
        }).join('\n');

        const prompt = `あなたは、読者の購買意欲を掻き立てるのが得意な、日本のスポーツ新聞の編集長です。
現在、高校野球の${tournamentState.tournamentYear}年度大会が進行中です。${roundName}の全試合が終了しました。
以下の試合結果を基に、最も衝撃的でドラマチックな出来事を一つ選び出し、それに対応する新聞の一面を飾るテキストを生成してください。

### ${roundName} 全試合結果
${resultsText}

### あなたが作成するテキスト
以下の4つの要素を、JSON形式で出力してください。
1.  **mainHeadline**: 最も重要な結果を伝える、短く、衝撃的で、扇情的な大見出し。（例：「怪物散る！」「王者、盤石の決勝へ」）
2.  **subHeadline**: mainHeadlineを補足する、少し詳しい小見出し。
3.  **photoCaption**: その日のハイライトシーンを切り取った架空の写真に対する、情景が目に浮かぶようなキャプション。（例：「あと一歩及ばず、マウンドに崩れ落ちる〇〇高校のエース△△」）
4.  **otherResults**: その他の注目すべき結果を2つ、簡潔にまとめたもの。

### 出力形式
{"mainHeadline": "...", "subHeadline": "...", "photoCaption": "...", "otherResults": ["...", "..."]}`;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const newspaperData = parseJsonFromText(rawText);
                if (newspaperData) return newspaperData;
            }
            throw new Error("AI newspaper response format error.");
        } catch (error) {
            console.error("AI newspaper generation failed:", error);
            return null;
        }
    }

    /**
     * ラウンド終了時に新聞発行などのイベントを処理する
     */
    async function handleRoundCompletion(roundNumber) {
        const numTeams = tournamentState.is16team ? 16 : 64;
        const finalRound = Math.log2(numTeams);
        const significantRounds = [finalRound, finalRound - 1, finalRound - 2, finalRound - 3].filter(r => r > 0);
        if (!significantRounds.includes(roundNumber)) return;

        const alreadyExists = tournamentState.news.some(n => n.roundNumber === roundNumber && n.isNewspaper);
        if (alreadyExists) return;

        const newspaperData = await generateSportsNewspaper(roundNumber);
        if (newspaperData) {
            const roundNameMap = { 3: '3回戦', 4: '準々決勝', 5: '準決勝', 6: '決勝' };
            const roundName = tournamentState.is16team ? {1: '1回戦', 2: '準々決勝', 3: '準決勝', 4: '決勝'}[roundNumber] : roundNameMap[roundNumber];

            tournamentState.news.push({
                title: `【熱闘新聞】${roundName}特集号が発行されました！`,
                body: newspaperData.subHeadline,
                timestamp: Date.now(),
                isNewspaper: true,
                roundNumber: roundNumber,
                newspaperData: newspaperData
            });
            renderNews(tournamentState.news);
            saveState();
        }
    }

    /**
     * 新聞モーダルを描画する
     */
    function renderNewspaperModal(newspaperData) {
        const { mainHeadline, subHeadline, photoCaption, otherResults, imageUrl } = newspaperData;
        
        const imageHtml = imageUrl 
            ? `<img src="${imageUrl}" alt="${photoCaption}" class="w-full h-auto my-4 border">` 
            : `<div class="newspaper-image-placeholder my-4"><p class="text-sm p-4">${photoCaption}</p></div>`;

        newspaperModalBody.innerHTML = `
            <div class="newspaper-container newspaper-late">
                <div class="newspaper-header">
                    <h2 class="newspaper-title">熱闘スポーツ</h2>
                    <p class="newspaper-date">${new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                </div>
                <div class="newspaper-content">
                    <h1 class="newspaper-main-headline">${mainHeadline}</h1>
                    <div class="newspaper-body-content">
                        <h2 class="newspaper-sub-headline">${subHeadline}</h2>
                        ${imageHtml}
                        <div class="newspaper-score-box">
                            <h3>その他の主な結果</h3>
                            ${otherResults.map(r => `<p>${r}</p>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
 * AIに掲示板の返信を生成させる（最終版）
 * 最新のデータ構造と、脱線防止を強化したプロンプトを使用する
 */
/**
 * AIに掲示板の返信を生成させる（最新の環境に適合した最終版）
 */
async function generateBbsReply(parentCommentId, userReplyText, bbsType, aiPersona, context) {
    const commentSource = bbsType === 'general' ? tournamentState.bbsComments : tournamentState.daiyaBbsComments;
    const parentComment = findCommentById(commentSource, parentCommentId);
    if (!parentComment) return null;

    // --- 1. AIに渡すための「文脈」を収集する ---
    const userReplyObject = { id: 'temp_user_reply', personality: 'あなた', text: userReplyText, replies: [] };
    parentComment.replies.push(userReplyObject);
    const conversationHistory = formatConversationHistory(commentSource, 'temp_user_reply');
    parentComment.replies.pop();

    const mentionedTeams = new Set();
    conversationHistory.split('\n').forEach(line => {
        INITIAL_TEAM_POOL.forEach(team => {
            if (line.includes(team)) {
                mentionedTeams.add(team);
            }
        });
    });

    // --- 2. AIに与える「知識」の部分を作成する ---
    let teamInfoPromptPart = '';
    if (mentionedTeams.size > 0) {
        teamInfoPromptPart = '### 関連チームの背景情報\n';
        mentionedTeams.forEach(teamName => {
            const teamData = TEAM_DATA[teamName];
            const teamRecord = tournamentState.teamRecords[teamName];
            // ★最新のアナウンサー関数を活用
            const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord);
            teamInfoPromptPart += `- **${teamName}**: ${dynamicInfo}\n`;
        });
    }

    // --- 3. 最終的なプロンプトを組み立てる（★脱線防止策を適用） ---
    const prompt = `あなたは、匿名掲示板のキャラクター「${aiPersona}」です。あなたは今、他のユーザーと日本の高校野球について会話しています。
あなたの唯一の仕事は、会話の流れとあなたの知識に基づき、キャラクターになりきって自然な返信をすることです。野球以外の話題には絶対に触れないでください。
---
### **ステップ1：現在の会話状況を理解する**
- **これまでの会話の流れ**:
${conversationHistory}
- **あなたのキャラクター**: ${aiPersona}
- **現在の大会状況**: ${context.tournamentSummary}
---
### **ステップ2：関連情報を思い出す**
${teamInfoPromptPart}
---
### **ステップ3：返信する**
上記のステップ1と2の情報を元に、会話の最後の発言「${userReplyText}」に対して、あなたのキャラクターとして最も自然で的を射た返信を生成してください。
- **指示**:
  - 必ず相手の発言に直接応答することから始めること。
  - 応答の根拠として、ステップ2の「関連情報」を自然な形で会話に含めること。
  - 相手が話していない無関係なチームや試合の情報を一方的に解説しないこと。
---
### **ステップ4：出力形式**
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"comment": "（あなたの返信本文）"}`;
    
    // --- 4. AIを呼び出し、結果を処理する ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const replyJson = parseJsonFromText(rawText);
            if (replyJson && replyJson.comment) {
                return {
                    id: crypto.randomUUID(),
                    personality: aiPersona,
                    text: replyJson.comment,
                    timestamp: Date.now(),
                    replies: []
                };
            }
        }
        throw new Error("AIの応答形式が不正です。");
    } catch (error) {
        console.error("AI返信コメントの生成に失敗しました:", error);
        return null;
    }
}
/**
     * AIからの応答テキストからJSONオブジェクトを安全に抽出する
     */
    function parseJsonFromText(text) {
        try {
            const cleanedText = text.replace(/```json/g, '').replace(/```/g, '').trim();
            const jsonMatch = cleanedText.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch (e) {
            console.error("Failed to parse JSON from text:", text, e);
        }
        return null;
    }

    /**
     * リトライ機能付きでバックエンドAPI(Netlify Function)を呼び出す
     */
    async function fetchWithRetry(payload, maxRetries = 3) {
        const functionUrl = '/.netlify/functions/generateApiContent'; // Netlify Functionのエンドポイント
        let lastError;

        for (let i = 0; i < maxRetries; i++) {
            try {
                const response = await fetch(functionUrl, {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    return response;
                }
                
                if (response.status >= 400 && response.status < 500 && response.status !== 429) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error}`);
                }

                lastError = new Error(`API Error: ${response.status}`);
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));

            } catch (error) {
                lastError = error;
                const delay = Math.pow(2, i) * 1000;
                if (i < maxRetries - 1) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        throw lastError;
    }

    /**
     * チームランク（A～E）から説明的な文字列を取得する
     */
    function getRankDescription(rank) {
        switch(rank) {
            case 'A': return '名門校';
            case 'B': return '強豪校';
            case 'C': return '中堅校';
            case 'D': return '発展途上のチーム';
            case 'E': return '挑戦者';
            default: return '実力不明';
        }
    }
    
    /**
 * Generates a team's tournament path history, compatible with all tournament types.
 */
function getTournamentPath(teamName, startingMatchId) {
    if (!teamName) return "（不明）";
    const path = [];
    
    // Combine all matches from all tournaments into one list
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    // Determine the current round number to analyze up to that point
    const idParts = startingMatchId.split('-');
    if (idParts.length < 3) return '（地区予選突破）'; // Not a main tournament match
    let currentRoundNum = parseInt(idParts[1].slice(1));

    // Loop from the first round up to the current round
    for (let r = 1; r < currentRoundNum; r++) {
        // Find the match the team won in that round
        const matchInRound = Object.values(allMatches).find(match =>
            match.id && 
            match.id.includes(`-R${r}-`) && // Belongs to the correct round
            match.winner === teamName
        );

        if (matchInRound) {
            const opponent = matchInRound.team1 === teamName ? matchInRound.team2 : matchInRound.team1;
            const winnerScore = matchInRound.team1 === teamName ? matchInRound.score1 : matchInRound.score2;
            const loserScore = matchInRound.team1 === teamName ? matchInRound.score2 : matchInRound.score1;
            path.push(`${r}回戦 vs ${opponent} (${winnerScore}-${loserScore})`);
        }
    }

    return path.length > 0 ? path.join(' → ') : '（今大会初戦）';
}
    /**
     * AIプロンプト用に、チームの次の対戦相手情報を生成する
     */
    /**
 * Generates the next opponent info, compatible with all tournament structures.
 */
function getNextOpponentInfoForPrompt(teamName) {
    // Combine all matches from all tournaments into one list
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    let latestMatch = null;
    let maxRound = -1;

    // Find the most recent game this team played in
    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (match.team1 === teamName || match.team2 === teamName) {
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 0;
            if (roundNum > maxRound) {
                maxRound = roundNum;
                latestMatch = match;
            }
        }
    }

    if (!latestMatch) return "（まだ試合なし）";
    if (latestMatch.winner !== teamName) return "（この試合で敗退）";
    
    // Find the next game this team is in
    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        
        // Look for a future game where this team is slotted but the opponent is not yet decided
        if ((match.team1 === teamName && !match.team2) || (match.team2 === teamName && !match.tran1)) {
             return "（次の対戦相手は未定）";
        }
        
        // Look for a future game where the opponent is known
        if (match.team1 === teamName && match.team2 && !match.winner) {
             return `次の対戦相手は${match.team2}です。`;
        }
        if (match.team2 === teamName && match.team1 && !match.winner) {
            return `次の対戦相手は${match.team1}です。`;
        }
    }

    return "（優勝、または次のステージへ）";
}
    /**
     * AIプロンプト用に、掲示板の会話履歴をフォーマットする
     */
    function formatConversationHistory(comments, targetId) {
        let history = [];
        function findPath(currentComments, currentPath) {
            for(const comment of currentComments) {
                const newPath = [...currentPath, comment];
                if(comment.id === targetId) {
                    history = newPath;
                    return true;
                }
                if(comment.replies && findPath(comment.replies, newPath)) {
                    return true;
                }
            }
            return false;
        }
        findPath(comments, []);
        return history.map(c => `${c.personality}:「${c.text}」`).join('\n');
    }

    /**
     * AIプロンプト用に、現在の大会状況の要約を生成する
     */
    function getTournamentStatusSummary() {
        if (tournamentState.currentTournament === 'autumn') {
            return `現在、${tournamentState.tournamentYear}年度 秋季大会が進行中です。フェーズ: ${tournamentState.autumnPhase}`;
        }
        
        const finalMatch = tournamentState.matches['F-R1-M1'];
        if (finalMatch?.winner) return `${finalMatch.winner}が優勝しました。`;
        if (finalMatch?.team1 && finalMatch.team2) return `決勝戦の組み合わせは ${finalMatch.team1} vs ${finalMatch.team2} です。`;
        
        const numRounds = Math.log2(tournamentState.teams.length);
        for (let r = numRounds - 1; r >= 1; r--) {
            const roundIds = Object.keys(tournamentState.matches).filter(id => id.includes(`-R${r}-`));
            if (roundIds.some(id => tournamentState.matches[id]?.team1 && tournamentState.matches[id]?.team2)) {
                 const roundNameMap = { 5: "準決勝", 4: "準々決勝", 3: "3回戦", 2: "2回戦", 1: "1回戦"};
                 return `現在、${roundNameMap[r] || r + '回戦'}が進行中です。`;
            }
        }
        return '大会はまもなく開始されます。';
    }

    /**
     * IDを元に、入れ子構造のコメントデータから特定のコメントを見つけ出す
     */
    function findCommentById(comments, id) {
        for (const comment of comments) {
            if (comment.id === id) return comment;
            if (comment.replies && comment.replies.length > 0) {
                const found = findCommentById(comment.replies, id);
                if (found) return found;
            }
        }
        return null;
    }
/**
 * AIに甲子園（または東海大会）の結果を総括する記事を生成させる
 */
async function generateKoshienSummaryArticle(teamName, resultLabel, type) {
    let context, titleInstruction;

    if (type === 'summer') {
        context = `夏の甲子園、全国の頂点を目指した${teamName}の戦いが終わりました。`;
        titleInstruction = `「${teamName}、聖地での戦いの軌跡」のような、夏の終わりを感じさせる感動的なタイトルにしてください。`;
    } else if (type === 'spring') {
        context = `選抜高校野球大会に出場した${teamName}の最終結果が確定しました。`;
        titleInstruction = `「${teamName}、春の聖地に爪痕」のように、来たる夏への期待を感じさせるタイトルにしてください。`;
    } else { // tokai
        context = `秋季東海大会で、静岡県代表の${teamName}が見事な戦いを見せました。`;
        titleInstruction = `「${teamName}、センバツ当確！」のように、速報らしく、喜びが伝わるタイトルにしてください。`;
    }

    const prompt = `あなたは、情熱的な高校野球専門のAI記者です。
以下の情報に基づき、読者の心を打つような総括記事を生成してください。

### 大会結果
- チーム: ${teamName}
- 最終成績: ${resultLabel}
- 文脈: ${context}

### 執筆指示
- ${titleInstruction}
- チームのこれまでの努力や、県大会での戦いぶりを称え、今回の結果が持つ意味をドラマチックに描写してください。
- 最後に、選手たちへの賛辞や、今後のチームへの期待を述べて締めくくってください。

### 出力形式
JSON形式で出力してください: {"title": "記事のタイトル", "body": "記事の本文"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) return { ...article, timestamp: Date.now() };
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI甲子園記事の生成に失敗しました:", error);
        return { title: "記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true };
    }
}
// --- Match Processing & Event Listeners ---

/**
 * 延長イニングを全ての関連テーブルに追加する
 */
function addExtraInning() {
    // --- 1. イニングスコアのテーブルを更新 ---
    const scoreTable = document.getElementById('inning-score-table');
    if (scoreTable) {
        const headerRow = scoreTable.querySelector('thead tr');
        // 現在の最終イニング番号を取得し、1を足す
        const lastInningHeader = headerRow.children[headerRow.children.length - 3];
        const newInningNum = parseInt(lastInningHeader.textContent) + 1;

        // 新しいヘッダーを追加
        const newTh = document.createElement('th');
        newTh.className = 'w-10';
        newTh.textContent = newInningNum;
        headerRow.insertBefore(newTh, headerRow.children[headerRow.children.length - 2]);

        // 各チームの行に新しい入力欄を追加
        scoreTable.querySelectorAll('tbody tr').forEach(row => {
            const newTd = document.createElement('td');
            newTd.innerHTML = `<input type="text" value="">`;
            row.insertBefore(newTd, row.children[row.children.length - 1]);
        });
    }

    // --- 2. 両チームの打撃成績テーブルを更新 ---
    for (const teamKey of ['team1', 'team2']) {
        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (!battingTable) continue;

        // ヘッダーを更新
        const headerRow = battingTable.querySelector('thead tr');
        const lastInningHeader = headerRow.lastElementChild.previousElementSibling;
        const newInningNum = parseInt(lastInningHeader.textContent) + 1;
        const newTh = document.createElement('th');
        newTh.className = 'col-inning';
        newTh.textContent = newInningNum;
        headerRow.insertBefore(newTh, headerRow.lastElementChild);

        // 全ての選手行（スタメン・交代）に新しい入力欄を追加
        battingTable.querySelectorAll('tbody tr').forEach(row => {
            const newTd = document.createElement('td');
            newTd.innerHTML = `<input type="text" placeholder="-">`;
            row.appendChild(newTd);
        });

        // イニング出来事入力欄のcolspanを更新し、新しい入力欄を追加
        const tfoot = battingTable.querySelector('tfoot');
        if (tfoot) {
            const targetCell = tfoot.querySelector('td[colspan]');
            const currentNumInnings = parseInt(targetCell.getAttribute('colspan')) - 1;
            targetCell.setAttribute('colspan', currentNumInnings + 2);

            const newEventTd = document.createElement('td');
            newEventTd.className = 'border-t-2';
            newEventTd.innerHTML = `<input type="text" class="inning-events-input w-full text-left px-1 text-xs" data-team-key="${teamKey}" data-inning-index="${newInningNum - 1}" placeholder="例: 鈴木 盗塁">`;
            
            const eventRow = tfoot.querySelector('tr');
            eventRow.insertBefore(newEventTd, eventRow.lastElementChild);
        }
    }
}

/**
 * ニュースティッカーの表示を更新する
 */
function updateTicker() {
    const tickerContainer = document.querySelector('.ticker-content');
    const oldTickerText = document.getElementById('ticker-text');
    if (!tickerContainer || !oldTickerText) return;

    let headlines = tournamentState.tickerHeadlines || [];
    
    // 表示するヘッドラインがなければ、デフォルトのものを表示
    if (headlines.length === 0) {
        const defaultHeadlines = [
            "昨年度王者・283学園、県内連覇と「全国での一勝」へ視界良好か",
            "『公立最後の砦』静岡、名門復活へ『今年こそ』",
            "プロ注目158km右腕・斎藤擁する富士宮北、ワンマンチームの汚名返上なるか",
            "創部一年目・浜松特支、初めての夏。「まずは1点」を合言葉に挑む",
            "離島のハンデを覆せ！虎府島総合、逆境スピリッツで本土勢に挑む",
            "765総合高校、2年前の栄光再び。ノーシードからの逆襲なるか",
            "最後の夏・川根、閉校する母校の名を刻めるか",
            "『ベスト8の壁』は越えられるか。堅守の聖隷クリストファー、打線の仕上がりは"
        ];
        headlines = new Array(5).fill(defaultHeadlines).flat().sort(() => Math.random() - 0.5);
    }

    const newTextContent = headlines.join('　／／　');
    
    // アニメーションをリセットするために要素を再生成
    const newTickerText = oldTickerText.cloneNode(false);
    newTickerText.textContent = newTextContent;
    oldTickerText.remove();
    tickerContainer.appendChild(newTickerText);
}

/**
 * 試合結果からニュースティッカー用の短いヘッドラインを生成する
 * @param {object} matchData - 試合のデータオブジェクト
 * @returns {string | null} - 生成されたヘッドラインの文字列、またはnull
 */
function generateTickerHeadline(matchData) {
    const { winnerName, loserName, score1, score2 } = matchData;
    const winnerScore = Math.max(parseInt(score1), parseInt(score2));
    const loserScore = Math.min(parseInt(score1), parseInt(score2));
    const scoreDiff = winnerScore - loserScore;

    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    const rankDiff = rankValues[winnerRank] - rankValues[loserRank];

    // パターン1：大番狂わせ（ジャイアントキリング）
    if (rankDiff <= -2) {
        return `【波乱】${getRankDescription(loserRank)}・${loserName}が初戦で散る！ ${winnerName}が金星挙げる`;
    }
    // パターン2：接戦
    if (scoreDiff <= 2 && rankDiff <= 1 && rankDiff >= -1) {
        return `手に汗握る接戦！ ${winnerName}が${loserName}を${winnerScore}-${loserScore}で振り切る`;
    }
    // パターン3：圧勝
    if (scoreDiff >= 8 && rankDiff >= 2) {
        return `王者・${winnerName}、盤石の試合運びで${loserName}を圧倒。${winnerScore}対${loserScore}でコールド勝ち級の快勝`;
    }
    // パターン4：ライバル対決
    const rivalry = RIVALRIES.find(r => r.teams.includes(winnerName) && r.teams.includes(loserName));
    if (rivalry) {
        return `因縁の${rivalry.type}は${winnerName}に軍配！ ${loserName}を下す`;
    }
    // デフォルト
    return `${winnerName}が${loserName}を下し、次のラウンドへ駒を進める`;
}

/**
 * 試合の詳細データから「事実オブジェクトの配列」と活躍選手リストを返す
 * (★精密版α：打順追跡、方向、交代詳細、走塁アウト詳細、交代状況分析 すべて込み★)
 */
function createHighlightsText(dbMatch, winnerName) {
    // 詳細データがない場合は空を返す
    if (!dbMatch || !dbMatch.details) {
        return { highlights: [], keyPlayerNames: [] };
    }

    // --- 内部ヘルパー関数：打席結果を日本語に翻訳 (方向・打点対応版) ---
    const translateResult = (res, playerInfo, eventType = '') => {
        if (!res) return null; // 結果文字列がなければnull
        let tempRes = res.trim(); // 元の文字列をコピー
        let direction = ''; // 打球方向
        // 方向と表示名のマッピング
        const directionMap = {'投': 'ピッチャー', '捕': 'キャッチャー', '一': 'ファースト', '二': 'セカンド', '三': 'サード', '遊': 'ショート', '左': 'レフト', '中': 'センター', '右': 'ライト'};
        const directionKeys = Object.keys(directionMap);

        // 文字列の先頭から方向を特定・抽出
        for (const key of directionKeys) {
            if (tempRes.startsWith(key)) {
                direction = directionMap[key] + 'へ'; // 例: 'センターへ'
                // ゴロ、フライ、ライナーの場合は方向名をそのまま使う
                if (tempRes.includes('ゴロ') || tempRes.includes('飛') || tempRes.includes('直')) {
                    direction = directionMap[key]; // 例: 'ショート'
                }
                tempRes = tempRes.substring(key.length).trim(); // 方向部分を削除
                break;
            }
        }

        let description = `${playerInfo}が`; // 基本の主語
        const rbiMatch = tempRes.match(/(\d+)点/); // 打点を抽出
        // 打点テキスト: 1点=タイムリー, 2点以上=X点タイムリー, なし=''
        const rbiText = rbiMatch ? (parseInt(rbiMatch[1]) > 1 ? `${rbiMatch[1]}点タイムリー` : 'タイムリー') : '';
        const eventText = eventType ? `${eventType}となる` : ''; // イベントタイプ (先制、逆転など)

        // 結果の種類に応じて説明文を生成 (方向 direction を追加)
        if (tempRes.includes('本塁打')) description = `${playerInfo}が${direction ? direction + 'への' : ''}${eventText}${rbiText || 'ソロ'}ホームランを放った`; // 方向は「への」を追加
        else if (tempRes.includes('三塁打')) description = `${playerInfo}が${direction ? direction + 'への' : ''}${eventText}${rbiText}三塁打を放った`;
        else if (tempRes.includes('二塁打')) description = `${playerInfo}が${direction ? direction + 'への' : ''}${eventText}${rbiText}二塁打を放った`;
        else if (tempRes.includes('安')) description = `${playerInfo}が${direction ? direction + 'への' : ''}${eventText}${rbiText}ヒットを放った`;
        else if (tempRes.includes('犠飛')) description = `${playerInfo}が${direction || '外野'}への${eventText}犠牲フライ${rbiMatch ? `で${rbiMatch[1]}点` : 'で1点'}を挙げた`; // 方向がない場合は外野と仮定
        else if (tempRes.includes('犠打')) description = `${playerInfo}が${direction ? direction + 'へ' : ''}送りバントを決めた`;
        // --- エラーや野選での打点 ---
        else if (tempRes.includes('ゴロ') && rbiMatch) description = `${playerInfo}の${direction || '内野'}ゴロの間に${eventText}${rbiMatch[1]}点を挙げた`;
        else if ((tempRes.includes('エラー') || tempRes.includes('失')) && rbiMatch) description = `相手${direction ? direction + 'の' : ''}エラーの間に${eventText}${rbiMatch[1]}点を記録した`;
        // --- アウト系 ---
        else if (tempRes.includes('三振')) description = `${playerInfo}が三振に倒れた`; // 方向なし
        else if (tempRes.includes('併殺')) description = `${playerInfo}が${direction || '内野'}ゴロで併殺打に倒れた`;
        else if (tempRes.includes('ゴロ')) description = `${playerInfo}が${direction || '内野'}ゴロに倒れた`;
        else if (tempRes.includes('飛')) description = `${playerInfo}が${direction || '外野'}フライに倒れた`;
        else if (tempRes.includes('直')) description = `${playerInfo}が${direction || ''}ライナーに倒れた`;
        // --- 出塁系 (打点なし) ---
        else if (tempRes.includes('四球')) description = `${playerInfo}が四球を選んだ`; // 方向なし
        else if (tempRes.includes('死球')) description = `${playerInfo}が死球で出塁した`; // 方向なし
        else if (tempRes.includes('エラー') || tempRes.includes('犠失')) description = `${playerInfo}が相手${direction ? direction + 'の' : ''}エラーで出塁した`; // 犠失もエラー扱い
        else if (tempRes.includes('野選')) description = `${playerInfo}が${direction ? direction + 'への' : ''}野選で出塁した`;
        else return null; // どれにも当てはまらない場合は null

        // 不要な表現を整理
        return description.replace(/タイムリー1点/g, 'タイムリー').replace(/1点を挙げた/g, '点を挙げた');
    };
    // --- ヘルパー関数ここまで ---

    // --- 初期化 ---
    const highlights = []; // ハイライトリスト
    const keyPlayerNames = new Set(); // 活躍選手名
    const winningTeamKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
    const losingTeamKey = winningTeamKey === 'team1' ? 'team2' : 'team1';
    const numInnings = dbMatch.details.inningScore?.team1?.length || 9;
    const inningScores = dbMatch.details.inningScore || { team1: Array(numInnings).fill(0), team2: Array(numInnings).fill(0) }; // スコア取得、なければ0埋め

    let hasScored = false;
    let isReversed = false;
    let cumulativeScores = { team1: 0, team2: 0 };
    // ▼▼▼ batterIndices: イニング開始時の先頭打者インデックス ▼▼▼
    let batterIndices = { team1: 0, team2: 0 };

    // --- 1. イニングごとのプレーを、精密な打順で解析 ---
    for (let i = 0; i < numInnings; i++) {
        const currentInning = i + 1;
        const scoreBeforeInning = { ...cumulativeScores };

        for (const teamKey of ['team1', 'team2']) {
            const teamName = dbMatch[teamKey];
            const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
            const allBattingData = dbMatch.details.batting?.[teamKey] || [];
            if (allBattingData.length === 0) continue;

            // 打順でソート (スタメン/交代含む)
            const sortedBattingOrder = allBattingData
                .filter(p => p.name) // 名前がある選手のみ
                .sort((a,b) => parseFloat(a.order.replace('-sub','.')) - parseFloat(b.order.replace('-sub','.')));
            if (sortedBattingOrder.length === 0) continue;

            // A. このイニングの全プレーを収集 (変更なし)
            let playsInHalfInning = [];
            sortedBattingOrder.forEach(player => {
                const resultString = player.results?.[i];
                if (resultString) {
                    resultString.split('、').forEach(atBatString => {
                        if(atBatString) {
                            playsInHalfInning.push({ player, atBatString });
                        }
                    });
                }
            });
            if (playsInHalfInning.length === 0) continue;

            // B. 打順インデックスに基づき、プレーを時系列順に並べ替える (改善版)
            const startingBatterIndex = batterIndices[teamKey]; // このイニングの先頭打者
            const orderedPlays = []; // 並べ替えた結果を入れる配列
            let currentBatterIndex = startingBatterIndex; // 現在処理中の打者のインデックス
            let playsFoundCount = 0; // 見つかったプレー数 (無限ループ防止)
            const atBatsCountPerPlayer = {}; // 各選手のこのイニングでの打席数をカウント { "1": 0, "2": 1, ... }

            // playsInHalfInning のすべてのプレーが orderedPlays に入るまでループ
            while (orderedPlays.length < playsInHalfInning.length && playsFoundCount < playsInHalfInning.length * 2) {
                 const currentPlayer = sortedBattingOrder[currentBatterIndex]; // 現在注目している打者
                 const playerOrderKey = currentPlayer.order; // "1", "1-sub-1" など
                 const currentAtBatOrdinal = atBatsCountPerPlayer[playerOrderKey] || 0; // この打者の何打席目か (0始まり)

                 // playsInHalfInning から、現在の打者(currentPlayer)の、まだ処理していない(currentAtBatOrdinal番目の)打席結果を探す
                 let foundPlayIndex = -1;
                 let searchCount = 0;
                 for(let k=0; k < playsInHalfInning.length; k++){
                     if(playsInHalfInning[k].player.order === playerOrderKey) {
                         if(searchCount === currentAtBatOrdinal) {
                             // まだ orderedPlays に追加されていないか確認
                             if (!orderedPlays.includes(playsInHalfInning[k])) {
                                 foundPlayIndex = k;
                                 break;
                             }
                         }
                         searchCount++;
                     }
                 }


                 if (foundPlayIndex !== -1) {
                     const foundPlay = playsInHalfInning[foundPlayIndex];
                     orderedPlays.push(foundPlay); // 順番通りに追加
                     atBatsCountPerPlayer[playerOrderKey] = currentAtBatOrdinal + 1; // この打者の打席数を+1
                     // 次の打者へ (打順が一巡する場合も考慮)
                     currentBatterIndex = (currentBatterIndex + 1) % sortedBattingOrder.length;
                 } else {
                     // 現在の打者の次の打席が見つからない場合、次の打順の選手へ移る
                     // (例: 1番打者が1打席しかなかった場合など)
                     currentBatterIndex = (currentBatterIndex + 1) % sortedBattingOrder.length;
                 }
                 playsFoundCount++; // 無限ループ防止カウンター
            }
            // 並び替えに失敗した場合のフォールバック (元の順で処理) - 念のため残す
            const finalOrderedPlays = orderedPlays.length === playsInHalfInning.length ? orderedPlays : playsInHalfInning;


            // C. 並べ替えた正しい順序で、ハイライトを生成する (変更なし)            // C. 並べ替えた正しい順序で、ハイライトを生成する
            finalOrderedPlays.forEach(play => {
                const { player, atBatString } = play;
                const [batterPlay, runnerPlaysString] = atBatString.split(';'); // 打撃結果と走塁結果を分離

                // 交代選手情報をplayerInfoに付与
                let playerRole = '';
                if (player.order.includes('sub')) {
                    switch(player.sub_type) {
                        case 'PH': playerRole = '代打の'; break;
                        case 'PR': playerRole = '代走の'; break; // 代走は通常打席に立たないが念のため
                        case 'DEF': playerRole = '守備から途中出場の'; break; // 守備交代選手が打席に立った場合
                        case 'PITCHER': playerRole = 'リリーフの'; break; // 投手が打席に立った場合
                        default: playerRole = '途中出場の';
                    }
                } else {
                     playerRole = `${player.order}番`; // スタメン
                }
                const playerInfo = `${playerRole}${player.name}`;

                // 打撃結果の処理
                if (batterPlay && batterPlay.trim() !== '') {
                    let eventType = ''; // イベントタイプ (先制、逆転など)
                    const isScorePlay = batterPlay.includes('点') || batterPlay.toLowerCase().includes('hr') || batterPlay.includes('本');

                    // 得点プレーの場合、イベントタイプを判定
                    if (isScorePlay) {
                        const prevScoreSelf = scoreBeforeInning[teamKey];
                        const prevScoreOpp = scoreBeforeInning[opponentTeamKey];
                        const rbiMatch = batterPlay.match(/(\d+)点/);
                        let addedScore = rbiMatch ? parseInt(rbiMatch[1]) : (batterPlay.includes('点') ? 1 : 0);
                        if (batterPlay.includes('本')) addedScore = Math.max(1, addedScore);

                        if (prevScoreSelf === 0 && prevScoreOpp === 0) {
                            eventType = '先制'; // 両者0点からの初得点
                            hasScored = true;
                        } else if (prevScoreSelf <= prevScoreOpp && (prevScoreSelf + addedScore) > prevScoreOpp && !isReversed) {
                            // ビハインド/同点からリードした場合 (逆転フラグは一度だけ)
                            eventType = '逆転';
                            isReversed = true;
                        } else if (prevScoreSelf < prevScoreOpp && (prevScoreSelf + addedScore) === prevScoreOpp) {
                             eventType = '同点'; // 追いついた場合
                        } else if (prevScoreSelf >= prevScoreOpp) {
                             eventType = '追加点'; // リードを広げる場合
                        } else {
                             eventType = '反撃'; // ビハインドで点を返した場合
                        }
                    }

                    // ヘルパー関数で説明文生成
                    const description = translateResult(batterPlay, playerInfo, eventType);
                    if (description) {
                        highlights.push({ inning: currentInning, team: teamName, player: player.name, description });
                        keyPlayerNames.add(player.name);
                    }
                }

                // 走塁結果の処理 (詳細なアウト種類対応)
                if (runnerPlaysString) {
                    runnerPlaysString.split(',').forEach(runnerPlay => {
                        if (!runnerPlay) return;
                        const runnerPlayParts = runnerPlay.trim().split(' ');
                        if (runnerPlayParts.length < 2) return;
                        const runnerName = runnerPlayParts[0];
                        const play = runnerPlayParts[1]; // 例: "盗塁", "盗塁死", "進塁"
                        const detail = runnerPlayParts.slice(2).join(' ') || ''; // 例: "二塁へ", "生還"
                        let description = `${runnerName}が`;

                        if (play === '盗塁') description += `盗塁成功（${detail}）`;
                        else if (play === 'タッチアップ') description += `タッチアップから${detail}`;
                        else if (play === '生還' || (play === '進塁' && detail.includes('生還'))) description += `ホームイン`;
                        else if (play === '盗塁死') description += `盗塁失敗`;
                        else if (play === '牽制死') description += `牽制アウト`;
                        else if (play === '走塁死') description += `走塁死`;
                        else if (play === '挟殺プレーでアウト') description += `挟殺アウト`;
                        else if (play.includes('アウト')) description += `走塁中にアウト`;
                        else if (play === '進塁') description += `進塁して${detail}`;
                        else description += `${play} ${detail}`.trim();

                        highlights.push({ type: 'baserunning', inning: currentInning, team: teamName, player: runnerName, description: description });
                        keyPlayerNames.add(runnerName);
                    });
                }
            }); // finalOrderedPlays.forEach の終わり

           // ▼▼▼ D. 次のイニングの先頭打者を正確に更新 ▼▼▼
            if (finalOrderedPlays.length > 0) {
                 // このイニングで最後に打席に立った選手を取得
                 const lastPlayer = finalOrderedPlays[finalOrderedPlays.length - 1].player;
                 // sortedBattingOrder で lastPlayer のインデックスを探す
                 const lastBatterIndexInLineup = sortedBattingOrder.findIndex(p => p.order === lastPlayer.order);
                 if (lastBatterIndexInLineup !== -1) {
                      // その次の打者のインデックスを batterIndices に保存
                      batterIndices[teamKey] = (lastBatterIndexInLineup + 1) % sortedBattingOrder.length;
                 } else {
                      // 見つからない場合 (エラーケース) - 簡易更新
                      console.warn(`Could not find index for last batter in inning ${currentInning}: ${lastPlayer.name}`);
                      batterIndices[teamKey] = (startingBatterIndex + finalOrderedPlays.length) % sortedBattingOrder.length;
                 }
            }
            // ▲▲▲ 先頭打者更新ここまで ▲▲▲
        } // teamKey loop の終わり

        // イニング終了時に累計スコアを更新
        cumulativeScores.team1 += parseInt(inningScores.team1?.[i] || 0);
        cumulativeScores.team2 += parseInt(inningScores.team2?.[i] || 0);

    } // inning loop の終わり

    // --- 2. 試合全体の個別要素を分析 ---
    // 惜敗投手 (変更なし)
    const loserName = dbMatch[losingTeamKey];
    const losingPitchers = dbMatch.details.pitching?.[losingTeamKey] || [];
    if (losingPitchers.length === 1) {
        const ace = losingPitchers[0];
        if (ace.result === 'L' && parseFloat(ace.innings || 0) >= 8 && parseInt(ace.earnedRuns || 0) <= 2) {
             highlights.push({ type: 'tough_loss', team: loserName, player: ace.name, description: `${ace.name}投手は${ace.innings}回を${ace.earnedRuns}失点と好投したが、打線の援護に恵まれなかった` });
             keyPlayerNames.add(ace.name);
        }
    }

    // 交代選手の活躍 (代打ヒット - 変更なし)
    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const teamBatting = dbMatch.details.batting?.[teamKey] || [];
        const substitutes = teamBatting.filter(p => p.sub_type && p.sub_type === 'PH'); // 代打のみ抽出
        substitutes.forEach(subPlayer => {
            for (let i = 0; i < numInnings; i++) {
                const resultInInning = subPlayer.results?.[i];
                if (resultInInning) {
                    // ヒット系の結果かチェック
                    if (resultInInning.includes('安') || resultInInning.includes('本') || resultInInning.includes('二') || resultInInning.includes('三')) {
                         let playerRole = '代打の';
                         const playerInfo = `${playerRole}${subPlayer.name}`;
                         const description = translateResult(resultInInning, playerInfo, ''); // イベントタイプなし
                         if(description){
                              highlights.push({ type: 'substitute_hit', inning: i + 1, team: teamName, player: subPlayer.name, description: `${description}。見事起用に応えた` });
                              keyPlayerNames.add(subPlayer.name);
                         }
                    }
                    break; // その選手の最初の打席結果のみ記録
                }
            }
        });
    }

    // ▼▼▼ 投手成績のハイライト生成方法を変更 ▼▼▼
    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const pitchingData = dbMatch.details.pitching?.[teamKey] || [];
        if (!pitchingData) continue;

        let pitchingRelayTextParts = []; // 継投表示用

        pitchingData.forEach((pitcher, pIdx) => {
            if (!pitcher.name || !pitcher.innings) return;

            // 全ての成績を取得 (未入力は 0 や '-' とする)
            const resultMark = {'W': '○', 'L': '●', 'S': 'Ｓ', 'H': 'Ｈ'}[pitcher.result] || ''; // 勝敗ＳＨ
            const innings = pitcher.innings || '不明';
            const batters = pitcher.battersFaced || '-';
            const pitches = pitcher.pitches || '-';
            const hits = pitcher.hits || '0';
            const strikeouts = pitcher.strikeouts || '0';
            const walks = pitcher.walks || '0';
            const runs = pitcher.runs || '0';
            const earnedRuns = pitcher.earnedRuns || '0';

            // 詳細な成績文字列を生成
            const statsDetail = `(${innings}回 打${batters} 球${pitches} 被${hits} 奪${strikeouts} 与${walks} 失${runs} 自${earnedRuns})`;

            // ハイライトの説明文を作成
            let description = `${resultMark}${pitcher.name} ${statsDetail}`;

            // 交代タイミングの情報を取得 (精密版αのロジックを流用)
            let inningWhenChanged = '?'; // 登板イニング
            let isMidInningChange = false;
            let outsWhenChanged = 0;
            let situation = ''; // 交代時の状況

            if (pIdx > 0) { // 2番手以降の場合、前の投手と比較
                const prevPitcher = pitchingData[pIdx - 1];
                if (prevPitcher.innings) {
                    const prevInningsStr = prevPitcher.innings.toString();
                    if (prevInningsStr.includes('.')) {
                        isMidInningChange = true;
                        const parts = prevInningsStr.split('.');
                        inningWhenChanged = parseInt(parts[0]) + 1;
                        outsWhenChanged = parseInt(parts[1] || 0);
                    } else {
                        isMidInningChange = false;
                        inningWhenChanged = Math.floor(parseFloat(prevInningsStr)) + 1;
                        outsWhenChanged = 0;
                    }
                    if (isNaN(inningWhenChanged)) inningWhenChanged = '?';

                    // 交代時の状況分析 (ヘルパー関数呼び出し)
                    if (inningWhenChanged !== '?' && isMidInningChange) {
                        const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
                        const opponentBatting = dbMatch.details.batting?.[opponentTeamKey] || [];
                        if (opponentBatting.length > 0) {
                            const opponentStartingBatterIdx = batterIndices[opponentTeamKey];
                            const simulationResult = simulateHalfInningUntilOuts(opponentBatting, inningWhenChanged - 1, outsWhenChanged, opponentStartingBatterIdx);
                            if (simulationResult) {
                                const runnerCount = simulationResult.runners.filter(r => r !== null).length;
                                if (runnerCount === 3) situation = '満塁のピンチで';
                                else if (runnerCount > 0) situation = `${runnerCount}者を背負い`;
                                // 点差などの情報も追加可能
                            }
                        }
                    }
                }
            } else {
                inningWhenChanged = 1; // 先発投手は1回から
            }

            // 交代情報を説明文に追加
            if (pIdx > 0 && inningWhenChanged !== '?') {
                 if (isMidInningChange) {
                     description = `${inningWhenChanged}回${outsWhenChanged}死${situation}登板した${description}`;
                 } else {
                     description = `${inningWhenChanged}回から登板した${description}`;
                 }
            } else if (pIdx === 0) {
                 description = `先発の${description}`; // 先発投手の記述
            }

            // 特筆すべき成績があれば追記 (完封、奪三振など) - オプション
            if (runs === '0' && parseFloat(innings) >= 7 && pitcher.result === 'W') description += ' 見事な完封勝利';
            else if (parseInt(strikeouts) >= 10) description += ` ${strikeouts}奪三振の快投`;
            else if (pitcher.result === 'L' && parseFloat(innings) >= 8 && parseInt(earnedRuns) <= 2) description += ' 好投も報われず'; // 惜敗

            // ハイライトに追加
            highlights.push({
                type: 'pitching_performance', // タイプ名を変更
                inning: inningWhenChanged !== '?' ? inningWhenChanged : undefined, // 登板イニング
                team: teamName,
                player: pitcher.name,
                description: description
            });
            keyPlayerNames.add(pitcher.name);

            // 継投表示用の情報を記録
            pitchingRelayTextParts.push(`${pitcher.name}(${innings}回)`);

        }); // pitchingData.forEach の終わり

        // 継投全体の情報をハイライトに追加
        if (pitchingRelayTextParts.length > 1) {
             highlights.push({ type: 'pitching_relay', team: teamName, description: `投手リレーは ${pitchingRelayTextParts.join(' → ')} だった` });
        }
    } // teamKey loop の終わり
    // ▲▲▲ 投手成績のハイライト生成ここまで ▲▲▲
  
// ▼▼▼ このブロックを「試合全体の物語性を分析」の手前で置き換え/挿入 ▼▼▼
    // --- 3. 守備ハイライト / エラー の処理 ---
    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const fieldingPlays = dbMatch.details.fielding?.[teamKey] || [];
        
        // エラーを示すキーワード
        const errorKeywords = ['エラー', 'トンネル', '落球', '後逸', '悪送球', 'ファンブル'];

        fieldingPlays.forEach(play => {
            if (play.player && play.play) {
                let description = '';
                // 入力されたテキストにエラーキーワードが含まれているかチェック
                const isError = errorKeywords.some(keyword => play.play.includes(keyword));

                if (isError) {
                    // エラーの場合
                    description = `${play.player}が${play.play}の痛恨のミスを犯した`;
                } else {
                    // ファインプレーの場合
                    description = `${play.player}が${play.play}のファインプレーを見せた`;
                }
                
                highlights.push({
                    type: isError ? 'fielding_error' : 'fielding_fine_play', // タイプを分ける
                    inning: play.inning || null,
                    team: teamName,
                    player: play.player,
                    description: description
                });
                keyPlayerNames.add(play.player);
            }
        });
    }
    // ▲▲▲ 修正ここまで ▲▲▲

  // --- 4. 試合全体の物語性を分析し、総括ハイライトを生成 ---
    let summaryHighlight = null; // 総括ハイライトを入れる変数
    // 勝者と敗者の最終スコアを取得 (parseIntで数値に変換、失敗時は0)
    const winnerScore = parseInt(dbMatch[winningTeamKey === 'team1' ? 'score1' : 'score2'] || 0);
    const loserScore = parseInt(dbMatch[losingTeamKey === 'team1' ? 'score1' : 'score2'] || 0);
    const totalRuns = winnerScore + loserScore; // 合計得点

    // ヒット数を計算するヘルパー関数 (playerGameStatsから取得)
    const countHitsFromStats = (teamKey) => {
        // 試合ごとの成績データ(playerGameStats)を取得、なければ空のオブジェクト
        const gameStats = dbMatch.details.playerGameStats?.[teamKey] || {};
        // gameStatsオブジェクトの各選手の成績(stats)を取り出し、ヒット数(h)を合計する
        return Object.values(gameStats).reduce((sum, stats) => sum + (stats.h || 0), 0);
    };
    const winnerHits = countHitsFromStats(winningTeamKey); // 勝者のヒット数
    const loserHits = countHitsFromStats(losingTeamKey);   // 敗者のヒット数
    const totalHits = winnerHits + loserHits; // 合計ヒット数

    
    let scoreAfter6th = { team1: 0, team2: 0 }; // 6回終了時点のスコア
    // イニングスコアデータが存在するか確認
    if(inningScores?.team1 && inningScores?.team2){
        // 6回終了 (インデックス5) までのスコアを合計
        for(let i = 0; i < Math.min(numInnings, 6); i++) {
             scoreAfter6th.team1 += parseInt(inningScores.team1[i] || 0);
             scoreAfter6th.team2 += parseInt(inningScores.team2[i] || 0);
        }
    }

    const winnerScoreAfter6th = scoreAfter6th[winningTeamKey]; // 勝者の6回終了時スコア
    const loserScoreAfter6th = scoreAfter6th[losingTeamKey];   // 敗者の6回終了時スコア
    const lastInning = numInnings - 1; // 最終イニングのインデックス (0始まり)

    // サヨナラ勝ちの判定
    let isSayonara = false;
    // 9回裏以降 (lastInning >= 8) かつ 勝者が後攻 (winningTeamKey === 'team2') の場合
    if (lastInning >= 8 && winningTeamKey === 'team2') {
        const scoreInLast = parseInt(inningScores?.team2[lastInning] || 0); // 最終回の得点
        const scoreBeforeLast = winnerScore - scoreInLast; // 最終回開始前の勝者のスコア
        // 最終回に得点があり、かつ最終回開始前に勝者が負けていたか同点だった場合
        if (scoreInLast > 0 && scoreBeforeLast <= loserScore) {
            isSayonara = true;
        }
    }

// ▼▼▼ 新しい判定ロジック ▼▼▼
    let mvpPlayer = null; // 活躍した選手名
    let mvpPerformance = ''; // 活躍内容

    // 1. 勝利チームの打者MVP判定
    const winnerBattingStats = dbMatch.details.playerGameStats?.[winningTeamKey] || {};
    for (const playerName in winnerBattingStats) {
        const stats = winnerBattingStats[playerName];
        if (!stats || !stats.played) continue; // 試合に出ていない選手は除く
        if (stats.hr >= 2) { mvpPlayer = playerName; mvpPerformance = `${stats.hr}本塁打`; break; }
        if (stats.rbi >= 4) { mvpPlayer = playerName; mvpPerformance = `${stats.rbi}打点`; break; }
        if (stats.h >= 4) { mvpPlayer = playerName; mvpPerformance = `${stats.h}安打`; break; }
        // 決勝打などの判定はより複雑になるため、ここでは安打数/本塁打/打点で判定
    }

    // 2. 勝利チームの投手MVP判定 (打者MVPがいなければ)
    const winnerPitchingData = dbMatch.details.pitching?.[winningTeamKey] || [];
    if (!mvpPlayer && winnerPitchingData.length > 0) {
        winnerPitchingData.forEach(pitcher => {
            if (!pitcher.name || !pitcher.innings) return;
            const innings = parseFloat(pitcher.innings);
            const earnedRuns = parseInt(pitcher.earnedRuns || 0);
            const strikeouts = parseInt(pitcher.strikeouts || 0);
            const runs = parseInt(pitcher.runs || 0); // 失点も考慮

            if (pitcher.result === 'W') { // 勝利投手のみ
                 if (runs === 0 && innings >= 7) { // 7回以上完封
                     mvpPlayer = pitcher.name; mvpPerformance = `完封勝利`;
                 } else if (strikeouts >= 10 && innings >= 6) { // 6回以上投げ10奪三振以上
                     mvpPlayer = pitcher.name; mvpPerformance = `${strikeouts}奪三振の快投`;
                 } else if (innings >= 6 && earnedRuns <= 1) { // 6回以上自責点1以下 (HQS相当)
                      mvpPlayer = pitcher.name; mvpPerformance = `好投で試合を作る`;
                 }
            }
             // リリーフ投手の好投も判定できる (例: 複数イニング無失点セーブなど)
             else if (pitcher.result === 'S' && innings >= 2 && earnedRuns === 0) {
                  mvpPlayer = pitcher.name; mvpPerformance = `好リリーフで試合を締める`;
             }
        });
    }

    // 3. 継投成功判定 (MVPがいなければ)
    let isRelaySuccess = false;
    if (!mvpPlayer && winnerPitchingData.length > 1) {
        // 合計自責点が少ない (例: 9回投げて3点以下) かつ 勝利
        const totalER = winnerPitchingData.reduce((sum, p) => sum + parseInt(p.earnedRuns || 0), 0);
        const totalIP = winnerPitchingData.reduce((sum, p) => sum + parseFloat(p.innings || 0), 0);
        // 9イニング換算の自責点が3.00未満くらいを目安にするか、単純に合計自責点が2点以下など
        if (totalER <= 2 && totalIP >= (numInnings - 1)) { // ほぼ試合全体を投げて自責点2以下
            isRelaySuccess = true;
        }
        // 他にも、リードを守り切った、ピンチを切り抜けたなどの判定を追加可能
    }
    // ▲▲▲ 新しい判定ロジックここまで ▲▲▲

   // --- 試合内容に応じたサマリーハイライトを決定 (★優先順位変更★) ---
    if (mvpPlayer) {
        // 個人活躍を最優先
        summaryHighlight = { type: 'summary', description: `${mvpPlayer}の${mvpPerformance}の活躍で、${winnerName}が勝利を掴んだ` };
    } else if (isRelaySuccess) {
        // 次に継投成功
        summaryHighlight = { type: 'summary', description: `${winnerName}投手陣が${loserName}打線を${loserScore}失点に抑える見事な継投策で勝利` };
    } else if (isSayonara) {
        // 以下、既存の判定
        summaryHighlight = { type: 'summary', description: `劇的なサヨナラ勝ちで、${winnerName}が熱戦に終止符を打った` };
    } else if (winnerScoreAfter6th < loserScoreAfter6th && winnerScore > loserScore && numInnings >= 7) {
        summaryHighlight = { type: 'summary', description: `${winnerName}が終盤に見事な逆転劇を演じ、勝利を掴んだ` };
    } else if (totalRuns <= 5 && totalHits <= 12) {
        summaryHighlight = { type: 'summary', description: `両チーム合わせて${totalHits}安打${totalRuns}得点に終わる、息詰まる投手戦となった` };
    } else if (totalRuns >= 13 && totalHits >= 20) {
        summaryHighlight = { type: 'summary', description: `両チーム合わせて${totalHits}安打${totalRuns}得点が乱れ飛ぶ、壮絶な打撃戦となった` };
    } else if (winnerScore - loserScore >= 7) {
        summaryHighlight = { type: 'summary', description: `${winnerName}が投打に相手を圧倒し、${winnerScore}-${loserScore}で快勝した` };
    } else if (winnerScore - loserScore <= 2) {
        summaryHighlight = { type: 'summary', description: `${winnerName}が${loserName}の粘り強い追撃を振り切り、${winnerScore}-${loserScore}で接戦を制した` };
    } else {
        summaryHighlight = { type: 'summary', description: `${winnerName}が${loserName}を下し、${winnerScore}-${loserScore}で勝利した` };
    }

    // 決定したサマリーハイライトがあれば、highlights配列の先頭に追加
    if (summaryHighlight) {
        highlights.unshift(summaryHighlight);
    }
    // --- 5. 結果を返す ---
    return { highlights: highlights, keyPlayerNames: Array.from(keyPlayerNames) };
}

// ▼▼▼ ヘルパー関数：交代状況シミュレーション用 (★複数打席対応・先頭打者指定版★) ▼▼▼
/**
 * 指定されたイニングの攻撃を、特定のアウトカウントになるまで簡易的にシミュレートする
 * @param {Array} battingOrder - 相手チームの打順データ (ソート済み)
 * @param {number} inningIndex - シミュレーション対象イニングのインデックス (0始まり)
 * @param {number} targetOuts - シミュレーションを停止するアウトカウント
 * @param {number} startingBatterIdx - このイニングの先頭打者のインデックス
 * @returns {object | null} - { runners: [1B, 2B, 3B], outs: number, scoreSelf: number, scoreOpp: number, nextBatterIdx: number } または null
 */
function simulateHalfInningUntilOuts(battingOrder, inningIndex, targetOuts, startingBatterIdx) {
    if (!battingOrder || battingOrder.length === 0 || targetOuts < 0 || targetOuts > 3) return null;

    let outs = 0;
    let runners = [null, null, null]; // 1B, 2B, 3B
    let scoreSelf = 0; // 仮スコア (守備側)
    let scoreOpp = 0;  // 仮スコア (攻撃側)

    let currentBatterIndex = startingBatterIdx; // 先頭打者から開始
    let playsProcessedCount = 0; // 無限ループ防止 & デバッグ用
    const atBatsCountThisInning = {}; // このイニングでの各打者の打席数 { "1": 0, "2": 1, ... }

    // シミュレーション対象イニングの全プレーを事前に収集・打席順に並べ替える
    const playsForInning = [];
     battingOrder.forEach(player => {
         const resultString = player.results?.[inningIndex];
         if (resultString) {
             resultString.split('、').forEach(atBat => {
                 if(atBat) playsForInning.push({ player, atBat });
             });
         }
     });
     if (playsForInning.length === 0) return { runners, outs, scoreSelf, scoreOpp, nextBatterIdx: startingBatterIdx };

     // 打順並べ替え (createHighlightsText と同じロジック)
     const orderedPlays = [];
     let tempBatterIndex = startingBatterIdx;
     let playsCount = 0;
     const processedFlags = new Array(playsForInning.length).fill(false);
     const atBatsTempCount = {};
     while (orderedPlays.length < playsForInning.length && playsCount < playsForInning.length * 2) {
         const currentPlayer = battingOrder[tempBatterIndex];
         const playerOrderKey = currentPlayer.order;
         const currentAtBatOrdinal = atBatsTempCount[playerOrderKey] || 0;
         let foundPlayIndex = -1;
         let searchCount = 0;
         for(let k=0; k < playsForInning.length; k++){
             if(playsForInning[k].player.order === playerOrderKey && !processedFlags[k]) {
                 if(searchCount === currentAtBatOrdinal) {
                     foundPlayIndex = k;
                     break;
                 }
                 searchCount++;
             }
         }
         if (foundPlayIndex !== -1) {
             orderedPlays.push(playsForInning[foundPlayIndex]);
             processedFlags[foundPlayIndex] = true;
             atBatsTempCount[playerOrderKey] = currentAtBatOrdinal + 1;
             tempBatterIndex = (tempBatterIndex + 1) % battingOrder.length;
         } else {
             tempBatterIndex = (tempBatterIndex + 1) % battingOrder.length;
         }
         playsCount++;
     }
     const finalOrderedPlays = orderedPlays.length === playsForInning.length ? orderedPlays : playsForInning;


    // 並べ替えたプレーを順番に処理し、targetOuts に達するまでシミュレーション
    for (const playData of finalOrderedPlays) {
        if (outs >= targetOuts) break; // 目標アウトカウントに達したら終了

        const { player, atBat } = playData;
        const [batterPlay] = atBat.split(';');

        // 簡易アウト判定
        if (batterPlay.includes('三振') || batterPlay.includes('ゴロ') || batterPlay.includes('飛') || batterPlay.includes('直') || batterPlay.includes('犠')) {
            outs++;
            if (batterPlay.includes('併殺')) outs++;
        }
        if (outs >= targetOuts) break; // アウトが発生して targetOuts に達したら即終了

        // 簡易ランナー状況更新
        if (batterPlay.includes('安') || batterPlay.includes('塁打') || batterPlay.includes('四球') || batterPlay.includes('死球') || batterPlay.includes('エラー')) {
            if (runners[0] && runners[1] && runners[2] && (batterPlay.includes('四球') || batterPlay.includes('死球'))) {
                 scoreOpp++; // 押し出し
            } else {
                if (runners[1]) runners[2] = 'runner'; // 2塁→3塁
                if (runners[0]) runners[1] = runners[0]; // 1塁→2塁
                runners[0] = player.name; // 打者→1塁
            }
        }
        // 簡易得点計算
        if (batterPlay.includes('本塁打')) {
            scoreOpp += runners.filter(r => r !== null).length + 1;
            runners = [null, null, null];
        } else if (batterPlay.includes('点')) {
             const rbiMatch = batterPlay.match(/(\d+)点/);
             scoreOpp += rbiMatch ? parseInt(rbiMatch[1]) : 1;
             // 簡易シミュレーションのため、どの走者が還ったかは無視
        }

        playsProcessedCount++; // 処理済みプレー数
    }

    // 次の打者のインデックスを計算して返す
    const lastSimulatedPlayer = finalOrderedPlays[playsProcessedCount - 1]?.player;
    let nextBatterIdx = startingBatterIdx; // デフォルト
    if(lastSimulatedPlayer){
        const lastSimIdx = battingOrder.findIndex(p => p.order === lastSimulatedPlayer.order);
        if(lastSimIdx !== -1){
            nextBatterIdx = (lastSimIdx + 1) % battingOrder.length;
        }
    }


    return { runners, outs, scoreSelf, scoreOpp, nextBatterIdx }; // シミュレーション結果と次の打者インデックスを返す
}
// ▲▲▲ ヘルパー関数ここまで ▲▲▲

// ▲▲▲ ヘルパー関数ここまで ▲▲▲

/**
 * 3連携の打撃結果プルダウンメニューのHTMLを生成する
 */
/**
 * 3連携の打撃結果プルダウンメニューのHTMLを生成する（保存値の再現機能付き）
 */
/**
 * 3連携の打撃結果プルダウンメニューのHTMLを生成する（★データ属性を追加した最終版）
 */
/**
 * 3連携の打撃結果プルダウンメニューのHTMLを生成する（打者一巡対応版）
 */
/**
 * 3連携の打席結果プルダウンメニューのHTMLを生成する（シンプルな3連バージョン・完全版）
 */
/**
 * 3連携の打席結果プルダウンと、それに付随する走塁入力欄のHTMLを生成する（参照エラー修正版）
/**
 * 1打席分の入力ブロックHTMLを生成する（役割を単機能化した最終版）
 * @param {Array<object>} playersOnField - 現在出場中の選手リスト
 * @param {string} atBatString - 1打席分の保存済み文字列 (例: "中安1点好走塁;田中 進塁 二塁へ")
 * @returns {string} - 生成されたHTML
 */
/**
 * 1打席分の入力ブロックHTMLを生成する（役割を単機能化した最終版）
 */
function createBattingResultDropdowns(playersOnField, atBatString = '') {
    const [batterPlay, runnerPlaysString] = (atBatString || '').split(';');
    
    let selectedResult = '', selectedDirection = '', selectedRbi = '', selectedRunnerPlay = '';
    let tempResult = (batterPlay || '').trim();

    if (tempResult) {
        const rbiMatch = tempResult.match(/(\d+点)/);
        if (rbiMatch) {
            selectedRbi = rbiMatch[0];
            tempResult = tempResult.replace(selectedRbi, '').trim();
        }
        if (tempResult.includes('好走塁')) {
            selectedRunnerPlay = '好走塁';
            tempResult = tempResult.replace('好走塁', '').trim();
        }
        const allResultTypes = [ ...BATTING_RESULTS.hits, ...BATTING_RESULTS.outs, ...BATTING_RESULTS.walks, ...BATTING_RESULTS.sacrifices, ...BATTING_RESULTS.other ];
        for (const type of allResultTypes) {
            if (tempResult.includes(type)) {
                selectedResult = type;
                tempResult = tempResult.replace(type, '').trim();
                break;
            }
        }
        if (tempResult.length > 0 && DIRECTIONS.includes(tempResult)) {
            selectedDirection = tempResult;
        }
    }

    const resultOptions = [ ...BATTING_RESULTS.hits, ...BATTING_RESULTS.outs, ...BATTING_RESULTS.walks, ...BATTING_RESULTS.sacrifices, ...BATTING_RESULTS.other ]
        .map(r => `<option value="${r}" ${selectedResult === r ? 'selected' : ''}>${r}</option>`).join('');
    const directionOptions = DIRECTIONS.map(d => `<option value="${d}" ${selectedDirection === d ? 'selected' : ''}>${d}</option>`).join('');
    const rbiOptions = RBIS.map(r => `<option value="${r}" ${selectedRbi === r ? 'selected' : ''}>${r}</option>`).join('');
    const runnerPlayOptions = ['好走塁'].map(r => `<option value="${r}" ${selectedRunnerPlay === r ? 'selected' : ''}>${r}</option>`).join('');

    return `
        <div class="at-bat-block border-t border-dashed pt-2 mt-2 first:mt-0 first:pt-0 first:border-t-0">
            <div class="flex items-center gap-1 batting-result-container mb-1">
                <div class="flex-grow flex gap-1">
                    <select class="batting-result-part w-[28%] text-xs p-1 border rounded result-type"><option value="">-結果-</option>${resultOptions}</select>
                    <select class="batting-result-part w-[22%] text-xs p-1 border rounded result-direction"><option value="">-方向-</option>${directionOptions}</select>
                    <select class="batting-result-part w-[22%] text-xs p-1 border rounded result-rbi"><option value="">-打点-</option>${rbiOptions}</select>
                    <select class="batting-result-part w-[28%] text-xs p-1 border rounded result-runner-play bg-yellow-50"><option value="">-打者走塁-</option>${runnerPlayOptions}</select>
                </div>
            </div>
            ${createRunnerInputsHTML(playersOnField, runnerPlaysString)}
        </div>
    `;
}

/**
 * トーナメント表をたどり、次の対戦相手の情報を特定する（★タイプミスを修正した最終版）
 * @param {string} teamName - チーム名
 * @param {string} currentMatchId - そのチームが勝利した現在の試合ID
 * @returns {object|null} - 次の対戦相手に関する詳細情報
 */
function findNextOpponent(teamName, currentMatchId) {
    const allMatches = tournamentState.matches;
    // ★★★ ここが修正箇所： allMessages -> allMatches に修正 ★★★
    if (!allMatches || !allMatches[currentMatchId]) return null;

    const idParts = currentMatchId.split('-');
    const side = idParts[0];

    if (side === 'F') {
        return { opponentName: '優勝', roundName: '大会終了' };
    }

    const roundNum = parseInt(idParts[1].slice(1));
    const matchNum = parseInt(idParts[2].slice(1));
    const numTeams = tournamentState.teams.length;
    const finalRound = Math.log2(numTeams);

    let nextMatchId, roundName;
    if (roundNum === finalRound - 1) {
        nextMatchId = 'F-R1-M1';
        roundName = '決勝';
    } else if (roundNum < finalRound - 1) {
        const nextRoundNum = roundNum + 1;
        nextMatchId = `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
        const roundNameMap = { [finalRound - 1]: "準決勝", [finalRound - 2]: "準々決勝" };
        roundName = roundNameMap[nextRoundNum] || `${nextRoundNum}回戦`;
    } else {
        return null;
    }

    const nextMatch = allMatches[nextMatchId];
    if (!nextMatch) return null;

    let opponentName = null;
    if (nextMatch.team1 && nextMatch.team1 !== teamName) opponentName = nextMatch.team1;
    else if (nextMatch.team2 && nextMatch.team2 !== teamName) opponentName = nextMatch.team2;

    if (opponentName) {
        return {
            opponentName: opponentName,
            opponentRank: calculateRank(opponentName, tournamentState),
            roundName: roundName
        };
    } else {
        // 相手が未定の場合、その相手を決める試合を探しに行く
        const feederMatchNumber = matchNum % 2 === 1 ? matchNum + 1 : matchNum - 1;
        const feederMatchId = `${side}-R${roundNum}-M${feederMatchNumber}`;
        const feederMatch = allMatches[feederMatchId];

        if (feederMatch && feederMatch.team1 && feederMatch.team2) {
            return {
                opponentName: '（未定）',
                roundName: roundName,
                decidingMatch: {
                    team1: feederMatch.team1,
                    rank1: calculateRank(feederMatch.team1, tournamentState),
                    team2: feederMatch.team2,
                    rank2: calculateRank(feederMatch.team2, tournamentState)
                }
            };
        }
        
        return { opponentName: '（未定）', opponentRank: '?', roundName: roundName };
    }
}

/**
 * 複数走者に対応した走塁入力欄のHTMLを生成する
 * @param {Array<object>} playersOnField - 現在出場中の選手リスト
 * @param {string} currentResult - 保存済みの打席結果文字列
 * @returns {string} - 生成されたHTML
 */
/**
 * 複数走者に対応した走塁入力欄のHTMLを生成する（区切り文字バグ修正版）
 */
function createRunnerInputsHTML(playersOnField, runnerPlaysString = '') {
    const baserunningPlays = ['盗塁', '盗塁死', 'タッチアップ', '進塁', '生還', '走塁死', '牽制死', '挟殺プレーでアウト'];
    const bases = ['一塁へ', '二塁へ', '三塁へ', '本塁へ(生還)'];
    
    // ▼▼▼【重要修正】区切り文字を「、」から「,」に変更▼▼▼
    const runnerEvents = runnerPlaysString ? runnerPlaysString.split(',') : [];
    // ▲▲▲

    let html = '<div class="runner-plays-container space-y-1 mt-1">';
    
    runnerEvents.forEach(event => {
        const parts = event.trim().split(' ');
        const name = parts[0] || '';
        const play = parts[1] || '';
        const base = parts.slice(2).join(' ') || '';
        
        const nameOptions = playersOnField.map(p => `<option value="${p.name}" ${p.name === name ? 'selected' : ''}>${p.name}</option>`).join('');
        const playOptions = baserunningPlays.map(p => `<option value="${p}" ${p === play ? 'selected' : ''}>${p}</option>`).join('');
        const baseOptions = bases.map(b => `<option value="${b}" ${b === base ? 'selected' : ''}>${b}</option>`).join('');

        html += `
            <div class="runner-play-input flex gap-1 items-center mt-1">
                <select class="runner-name w-1/3 text-xs p-1 border rounded"><option value="">-誰が-</option>${nameOptions}</select>
                <select class="runner-play w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-何をした-</option>${playOptions}</select>
                <select class="runner-base w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-どこへ-</option>${baseOptions}</select>
                <button class="remove-runner-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </div>
        `;
    });

    html += '</div>';
    html += '<button class="add-runner-play-btn text-xs mt-1 bg-gray-200 px-2 py-0.5 rounded hover:bg-gray-300">+ 走者プレーを追加</button>';
    return html;
}

/**
 * 選手の大会通算成績を、AIプロンプト用の短い文章に要約する
 * @param {string} playerName - 選手名
 * @param {string} teamName - チーム名
 * @returns {string | null} - "姫川: 打率.500, 3本塁打, 10打点" のような要約文。成績がなければnull。
 */
function getPlayerTournamentStatsSummary(playerName, teamName) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord || !teamRecord.playerStats) return null;

    const battingStats = teamRecord.playerStats.batting[playerName];
    const pitchingStats = teamRecord.playerStats.pitching[playerName];
    
    let summaries = [];

    if (battingStats && battingStats.ab > 0) {
        const avg = (battingStats.h / battingStats.ab).toFixed(3);
        summaries.push(`打率${avg}, ${battingStats.hr}本塁打, ${battingStats.rbi}打点`);
    }

    if (pitchingStats && pitchingStats.ip > 0) {
        const era = pitchingStats.er > 0 ? ((pitchingStats.er * 9) / pitchingStats.ip).toFixed(2) : "0.00";
        summaries.push(`${pitchingStats.w}勝${pitchingStats.l}敗, 防御率${era}, ${pitchingStats.so}奪三振`);
    }

    if (summaries.length > 0) {
        return `${playerName}: ${summaries.join(' / ')}`;
    }
    
    return null;
}

/**
 * Analyzes the results of a half-inning, counts outs, and updates the UI (colors and disabled state).
 */
function updateInningState(teamKey, inningIndex) {
    const battingTable = document.getElementById(`batting-table-${teamKey}`);
    if (!battingTable) return;

    let outCount = 0;
    
    // --- 1. Analyze Batting Results ---
    battingTable.querySelectorAll('tbody tr').forEach(row => {
        const resultCell = row.children[5 + inningIndex];
        if (!resultCell) return;
        
        const atBatContainers = resultCell.querySelectorAll('.batting-result-container');
        atBatContainers.forEach(container => {
            const resultTypeSelect = container.querySelector('.result-type');
            const resultText = resultTypeSelect.value;
            
            // Count outs
            if (BATTING_RESULTS.outs.includes(resultText)) {
                outCount += (resultText === '併殺') ? 2 : 1;
            }

            // Color-code the dropdowns
            const dropdowns = container.querySelectorAll('select');
            dropdowns.forEach(dd => dd.classList.remove('result-hit', 'result-out', 'result-on-base'));

            if (BATTING_RESULTS.hits.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-hit'));
            } else if (BATTING_RESULTS.walks.includes(resultText) || BATTING_RESULTS.other.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-on-base'));
            } else if (BATTING_RESULTS.outs.includes(resultText) || BATTING_RESULTS.sacrifices.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-out'));
            }
        });
    });

    // --- 2. Count Outs from "Inning Events" (Baserunning) ---
    const eventsInput = document.querySelector(`.inning-events-input[data-team-key="${teamKey}"][data-inning-index="${inningIndex}"]`);
    if (eventsInput && eventsInput.value) {
        const events = eventsInput.value.split('、');
        events.forEach(event => {
            if (event.includes('盗塁死') || event.includes('走塁死')) {
                outCount++;
            }
        });
    }

    // --- 3. Lock the Inning if 3 Outs are Reached ---
    const isLocked = outCount >= 3;
    battingTable.querySelectorAll('tbody tr').forEach(row => {
        const resultCell = row.children[5 + inningIndex];
        if (!resultCell) return;
        
        const dropdowns = resultCell.querySelectorAll('.batting-result-container select');
        const addButtons = resultCell.querySelectorAll('.add-at-bat-btn');
        
        dropdowns.forEach(dd => {
            dd.disabled = isLocked;
            if (isLocked) dd.classList.add('bg-gray-100');
        });
        addButtons.forEach(btn => {
            btn.disabled = isLocked;
            if (isLocked) btn.style.visibility = 'hidden';
        });
    });
     if (eventsInput) {
        eventsInput.disabled = isLocked;
        if (isLocked) eventsInput.classList.add('bg-gray-100');
     }
}


/**
 * 試合の勝者を処理する中心的関数（全機能統合・実行順序修正・事実確認削除の最終版）
 */
async function processMatchWin(matchId, winnerName) {
    // --- 1. 試合データの特定と基本情報の設定 ---
    let dbMatch = findMatchById(matchId);
    if (!dbMatch || !dbMatch.team1 || !dbMatch.team2 || dbMatch.winner) return;

    const loserName = dbMatch.team1 === winnerName ? dbMatch.team2 : dbMatch.team1;
    dbMatch.winner = winnerName;

    // トーナメント表からスコアとsummaryを読み取る
    const matchEl = document.querySelector(`.matchup[data-match-id="${matchId}"]`);
    if (matchEl) {
        const score1El = matchEl.querySelector('[data-team-pos="1"]');
        const score2El = matchEl.querySelector('[data-team-pos="2"]');
        // スコアが入力されている場合のみdbMatchを更新
        if (score1El && score2El && score1El.value !== '' && score2El.value !== '') {
            dbMatch.score1 = score1El.value;
            dbMatch.score2 = score2El.value;
        } else {
            // スコアが空の場合、0-0などを仮で設定するか、エラー処理が必要かもしれません
            // ここでは仮に 0-0 としますが、適切なデフォルト値やバリデーションを検討してください
            dbMatch.score1 = '0';
            dbMatch.score2 = '0';
        }
        dbMatch.summary = matchEl.querySelector('.match-summary-input')?.value || '';
    } else {
        // matchElが見つからない場合もスコアを仮設定 (エラーハンドリング)
        dbMatch.score1 = '0';
        dbMatch.score2 = '0';
    }


// ▼▼▼ ここからコールドゲーム判定（修正版） ▼▼▼
    dbMatch.calledGame = false;
    dbMatch.calledInning = null;
    let earliestCalledInning = null; // コールドが成立した最初のイニングを記録する変数

    // 詳細入力があり、イニングスコアが存在し、最低5イニング以上のデータがある場合のみ判定
    if (dbMatch.details && dbMatch.details.inningScore &&
        dbMatch.details.inningScore.team1 && dbMatch.details.inningScore.team2 &&
        dbMatch.details.inningScore.team1.length >= 5)
    {
        const inningScores1 = dbMatch.details.inningScore.team1;
        const inningScores2 = dbMatch.details.inningScore.team2;
        const actualNumInningsRecorded = inningScores1.length; // 記録されているイニング数

        let cumulativeScore1 = 0;
        let cumulativeScore2 = 0;

        // 1回から記録されている最終イニングまで、各イニング終了時点のスコア差をチェック
        for (let i = 0; i < actualNumInningsRecorded; i++) {
            cumulativeScore1 += parseInt(inningScores1[i] || 0);
            cumulativeScore2 += parseInt(inningScores2[i] || 0);
            const currentInning = i + 1; // 現在チェックしているイニング (1始まり)
            const scoreDiff = Math.abs(cumulativeScore1 - cumulativeScore2);

            // 【重要】チェックはイニング終了時点で行う
            // 5回終了時点で10点差以上か？
            if (currentInning === 5 && scoreDiff >= 10) {
                earliestCalledInning = 5;
                break; // 5回コールド成立なら以降のチェック不要
            }
            // 6回終了時点で10点差以上か？
            if (currentInning === 6 && scoreDiff >= 10) {
                earliestCalledInning = 6;
                break; // 6回コールド成立
            }
            // 7回終了時点で7点差以上か？ (10点差も含む)
            if (currentInning === 7 && scoreDiff >= 7) {
                earliestCalledInning = 7;
                break; // 7回コールド成立
            }
            // 8回終了時点で7点差以上か？ (10点差も含む)
            if (currentInning === 8 && scoreDiff >= 7) {
                earliestCalledInning = 8;
                break; // 8回コールド成立
            }
            // ★★★ 9回以降のコールドはルール上ないので、ここでループは実質終了 ★★★
        }

        // earliestCalledInning が見つかっていれば、コールド成立と記録
        if (earliestCalledInning !== null) {
            dbMatch.calledGame = true;
            dbMatch.calledInning = earliestCalledInning; // ★成立したイニングを記録
        }
    }
    // ▲▲▲ コールドゲーム判定ここまで ▲▲▲


    // ▼▼▼ 修正箇所 ▼▼▼
    // --- ★★★ 勝者を次のラウンドに進める処理を先に実行 ★★★ ---
    // 秋季/春季の地区予選・順位決定戦「以外」の場合（つまり夏大会 or 秋/春の県大会本戦）
    if (!(tournamentState.currentTournament === 'autumn' && tournamentState.autumnPhase !== 'main') &&
        !(tournamentState.currentTournament === 'spring' && tournamentState.springPhase === 'regional_qualifiers'))
    {
        // 勝敗数を記録 (teamRecordsが存在する場合のみ)
        if(tournamentState.teamRecords[winnerName]) tournamentState.teamRecords[winnerName].wins++;
        if(tournamentState.teamRecords[loserName]) tournamentState.teamRecords[loserName].losses++;

        const idParts = matchId.split('-');
        const side = idParts[0];

        // 決勝戦('F')以外の場合、次のラウンドへ進める
        if (side !== 'F') {
            const roundNum = parseInt(idParts[1].slice(1));
            const numTeamsInTournament = tournamentState.teams.length; // 現在の大会のチーム数を取得
            const finalRound = Math.log2(numTeamsInTournament); // 現在の大会の最終ラウンド数を計算

            // 最終ラウンドより前のラウンドの場合のみ進行処理を行う
            if (roundNum < finalRound) {
                const matchNum = parseInt(idParts[2].slice(1));
                const nextRoundNum = roundNum + 1;
                let nextMatchId = (nextRoundNum === finalRound) ? 'F-R1-M1' : `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;

                // 次の試合オブジェクトがなければ作成
                if (!tournamentState.matches[nextMatchId]) {
                    tournamentState.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
                }

                // 勝者を次の試合の正しいスロット (team1 or team2) に書き込む
                let slot;
                if (nextRoundNum === finalRound) { // 次が決勝の場合
                    slot = (side === 'L' ? 1 : 2); // 左ならteam1, 右ならteam2
                } else { // 決勝以外の場合
                    slot = (matchNum % 2 !== 0 ? 1 : 2); // 奇数試合ならteam1, 偶数試合ならteam2
                }
                tournamentState.matches[nextMatchId][`team${slot}`] = winnerName;
            }
        }
        // 決勝戦終了時の処理は後続 (手順4の最後) に移動
    }
    // --- ★★★ 勝者進行処理ここまで ★★★ ---
    // ▲▲▲ 修正箇所ここまで ▲▲▲


    // --- 2. 試合後のデータ更新（ティッカー、称号、スタメン記録など） ---
    const newHeadline = generateTickerHeadline({ winnerName, loserName, score1: dbMatch.score1, score2: dbMatch.score2 });
    if (newHeadline) {
        tournamentState.tickerHeadlines.unshift(newHeadline);
        if (tournamentState.tickerHeadlines.length > 20) tournamentState.tickerHeadlines.pop();
        updateTicker(); // ティッカー表示を更新
    }

    // 勝者と敗者の前回のスタメン情報を記録 (詳細データがある場合)
    if (dbMatch.details && dbMatch.details.batting) {
        const winnerTeamKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
        if (tournamentState.teamRecords[winnerName] && dbMatch.details.batting[winnerTeamKey]) {
            tournamentState.teamRecords[winnerName].previousStarters = dbMatch.details.batting[winnerTeamKey].filter(p => p.order && !p.order.toString().includes('sub')).map(p => ({ order: p.order, name: p.name, pos: p.pos }));
        }
        const loserTeamKey = dbMatch.team1 === loserName ? 'team1' : 'team2';
        if (tournamentState.teamRecords[loserName] && dbMatch.details.batting[loserTeamKey]) {
            tournamentState.teamRecords[loserName].previousStarters = dbMatch.details.batting[loserTeamKey].filter(p => p.order && !p.order.toString().includes('sub')).map(p => ({ order: p.order, name: p.name, pos: p.pos }));
        }
    }

    // ジャイアントキリング称号の付与判定
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    if ((rankValues[loserRank] - rankValues[winnerRank]) >= 2) { // ランク差が2以上あれば
        const winnerRecord = tournamentState.teamRecords[winnerName];
        if (winnerRecord && !winnerRecord.teamTraits.includes('giant_killer')) {
            winnerRecord.teamTraits.push('giant_killer'); // 称号を追加
        }
    }

    // --- 3. AIコンテンツ生成の準備と実行 ---
    // ★★★ この時点で findNextOpponent が正しい情報を取得できる ★★★
    const matchContext = createMatchContext(matchId, winnerName);
    if (!matchContext) {
        console.error("AIコンテンツ生成に必要なmatchContextの作成に失敗しました。");
        renderTournament(tournamentState); // とりあえず画面は更新
        saveState();
        return; // AI処理を中断
    }

    let articlePromise = Promise.resolve(null);
    let commentsPromise = Promise.resolve(null);

    // 設定に応じてAI記事生成を開始
    if (tournamentState.settings.enableArticleGeneration) {
        newsContainer.innerHTML = `<div class="loader">AI記者が記事を執筆中...</div>`;
        const documentary = tournamentState.documentary;

        // ドキュメンタリー対象チームの試合かどうかで生成関数を切り替え
        if (documentary && documentary.target && (documentary.target === winnerName || documentary.target === loserName)) {
            const isWin = documentary.target === winnerName;
            const opponentName = isWin ? loserName : winnerName;
            const opponentData = TEAM_DATA[opponentName]; // TEAM_DATAから相手情報を取得

            const matchInfoForArticle = {
                round: matchId.includes('-R') ? parseInt(matchId.split('-R')[1].split('-')[0]) : 1,
                opponent: opponentName,
                score: isWin ? `${dbMatch.score1}-${dbMatch.score2}` : `${dbMatch.score2}-${dbMatch.score1}`, // 勝者のスコアが先
                highlights: matchContext.highlights, // createMatchContextで生成済みのものを使用
                summary: dbMatch.summary,
                opponentInfo: opponentData?.info || '対戦相手の情報なし' // 相手の背景情報
            };

            articlePromise = generateDocumentaryArticle(isWin ? 'win' : 'lose', documentary.type, documentary.target, matchInfoForArticle);

            if (!isWin) tournamentState.documentary = { target: null, type: null }; // 敗退したらドキュメンタリー終了
        } else {
            // 通常の記事生成
            articlePromise = generateNewsArticle(matchContext);
        }
    }

    // 設定に応じてAI掲示板コメント生成を開始
    if (tournamentState.settings.enableBbsGeneration) {
        bbsCommentsContainer.innerHTML = `<div class="loader">AIが掲示板を監視中...</div>`;
        commentsPromise = generateBbsComments(matchContext); // 修正済み関数を呼び出し
    }

    // --- 4. トーナメント進行ロジック (秋季・春季の特殊処理) ---
    // ★★★ 上で実行済みの Summer/Main Tournament 以外の進行処理がここに来る ★★★
    if (tournamentState.currentTournament === 'autumn' && tournamentState.autumnPhase !== 'main') {
        // 秋季地区ブロック予選の勝者進行
        const [region, bracketId, roundStr, matchStr] = matchId.split('-');
        if (bracketId.startsWith('B')) { // 通常のブロック
            const block = tournamentState.autumnData.regions[region].blocks.find(b => b.id === `${region}-${bracketId}`);
            if (block) {
                const roundNum = parseInt(roundStr.slice(1));
                const matchNum = parseInt(matchStr.slice(1));
                if (roundNum === 0) { // プレイインマッチ
                    block.matches[`${block.id}-R1-M1`].team1 = winnerName;
                } else if (roundNum === 1) { // 準決勝
                    const finalMatch = block.matches[`${block.id}-R2-M1`];
                    if (matchNum === 1) finalMatch.team1 = winnerName; else finalMatch.team2 = winnerName;
                } else if (roundNum === 2) { // 決勝
                    tournamentState.autumnData.regions[region].blockWinners.push(winnerName);
                    tournamentState.autumnData.regions[region].blockRunnersUp.push(loserName);
                }
            }
        } else if (bracketId === 'AUTUMN' && region === '伊豆') { // 伊豆地区
             const izuBracket = tournamentState.autumnData.regions['伊豆'].izuBracket;
             if(izuBracket){
                const roundNum = parseInt(roundStr.slice(1));
                const matchNum = parseInt(matchStr.slice(1));
                if (roundNum === 1) { // 準決勝
                    const finalMatch = izuBracket.matches[`${izuBracket.id}-R2-M1`];
                    if (matchNum === 1) finalMatch.team1 = winnerName; else finalMatch.team2 = winnerName;
                } else if (roundNum === 2) { // 決勝
                    tournamentState.autumnData.regions['伊豆'].finalReps.push({ team: winnerName, rank: 1 });
                }
             }
        }
        // 秋季地区順位決定戦の勝者進行
        else if (tournamentState.autumnPhase === 'regional_ranking') {
            const roundNum = parseInt(roundStr.slice(1));
            const matchNum = parseInt(matchStr.slice(1));
            const isChamp = bracketId === 'CHAMP'; // 本来は廃止されているが念のため
            const bracket = tournamentState.autumnData.regions[region]?.repechageBracket; // 敗者復活のみ

            if (bracket && roundNum === 1) { // 敗者復活1回戦
                const finalMatch = bracket.matches[`${bracket.id}-R2-M1`]; // 5位決定戦
                if (matchNum === 1) finalMatch.team1 = winnerName; else finalMatch.team2 = winnerName;
            } else if (bracket && roundNum === 2) { // 5位決定戦
                tournamentState.autumnData.regions[region].finalReps.push({ team: winnerName, rank: 5 });
                // 敗退チーム(loserName)の順位は記録しない (県大会に出られないため)
            }
        }
    } else if (tournamentState.currentTournament === 'spring' && tournamentState.springPhase === 'regional_qualifiers') {
        // 春季地区予選の勝者進行
        const [region, bracketType] = matchId.split('-');
        // 代表決定ブロック
        if (bracketType.startsWith('SB')) {
            const block = tournamentState.springData.regions[region].blocks.find(b => b.id === `${region}-${bracketType}`);
            if (block) {
                // 準決勝以前の試合の場合、勝者を決勝に進める
                if (matchId.includes('-R1-') || matchId.includes('-R0-')) {
                    // 決勝戦のIDを見つける (R2-M1 or R1-M1 for 2/3 team blocks)
                    const finalMatchKey = Object.keys(block.matches).find(k => k.includes('-R2-') || (Object.keys(block.matches).length <= 2 && k.includes('-R1-')));
                    if (finalMatchKey) {
                        const finalMatch = block.matches[finalMatchKey];
                        // どっちの山から来たかで team1 or team2 に入れる
                        if (matchId.endsWith('M1')) finalMatch.team1 = winnerName; else finalMatch.team2 = winnerName;
                    }
                } else { // 決勝戦の場合、敗者を敗者復活トーナメントに送る
                    const repBracket = tournamentState.springData.regions[region].repechageBracket;
                    repBracket.teams.push(loserName); // 敗者復活に参加するチームリストに追加
                    // 敗者復活トーナメントの空きスロットに敗者をセット
                    if (repBracket.teams.length === 1) repBracket.matches[`${repBracket.id}-R1-M1`].team1 = loserName;
                    if (repBracket.teams.length === 2) repBracket.matches[`${repBracket.id}-R1-M1`].team2 = loserName;
                    if (repBracket.teams.length === 3) repBracket.matches[`${repBracket.id}-R1-M2`].team1 = loserName;
                    if (repBracket.teams.length === 4) repBracket.matches[`${repBracket.id}-R1-M2`].team2 = loserName;
                }
            }
        }
        // 第5代表決定トーナメント (敗者復活)
        else if (bracketType.startsWith('SREP')) {
             const repBracket = tournamentState.springData.regions[region].repechageBracket;
             if (repBracket){
                const finalMatch = repBracket.matches[`${repBracket.id}-R2-M1`]; // 代表決定戦
                 // 1回戦の勝者を代表決定戦に進める
                if (matchId.endsWith('M1')) finalMatch.team1 = winnerName;
                if (matchId.endsWith('M2')) finalMatch.team2 = winnerName;
             }
        }
        // 伊豆地区予選
        else if (bracketType.startsWith('SIZU')) {
            const izuBracket = tournamentState.springData.regions['伊豆'].izuBracket;
            if(izuBracket){
                const finalMatch = izuBracket.matches[`${izuBracket.id}-R2-M1`]; // 決勝戦
                // 準決勝の勝者を決勝に進める
                 if (izuBracket.teams.length === 3 && matchId.includes('-R1-')) { // 3チームの場合の準決勝
                     finalMatch.team1 = winnerName; // 不戦勝の team2 は setupSpringRegionalQualifiers で設定済み
                 } else if (matchId.endsWith('M1')) { // 4チームの場合の準決勝1
                     finalMatch.team1 = winnerName;
                 } else if (matchId.endsWith('M2')) { // 4チームの場合の準決勝2
                     finalMatch.team2 = winnerName;
                 }
            }
        }
    }
    // 決勝戦終了時の後処理 (先に勝者進行処理を行ったため、ここでは最終成績記録と甲子園/センバツ処理のみ)
    else if (matchId.startsWith('F-R1-M1')) {
        updateTournamentFinishRecords(); // 全チームの最終順位を記録

        if (tournamentState.currentTournament === 'summer') {
            // 夏大会優勝 → 甲子園シミュレーション
            const winnerRecord = tournamentState.teamRecords[winnerName];
            if (winnerRecord) { // 念のため存在確認
                const winnerRank = calculateRank(winnerName, tournamentState);
                const koshienResultKey = simulateKoshien(winnerRank); // ランクに基づき甲子園の結果を決定
                const koshienResult = KOSHIEN_RESULTS[koshienResultKey];
                winnerRecord.lastFinish = koshienResult.rank; // 最終成績を甲子園のものに更新
                const newHistoryRecord = { year: tournamentState.tournamentYear, tournament: 'summer_koshien', rank: koshienResult.rank }; // 'summer_koshien' として記録
                winnerRecord.history.unshift(newHistoryRecord); // 履歴に追加
                // 最高成績も更新
                if (!winnerRecord.best || newHistoryRecord.rank < winnerRecord.best.rank) {
                    winnerRecord.best = newHistoryRecord;
                }
                // 甲子園結果の記事生成を非同期で開始 (完了を待たない)
                generateKoshienSummaryArticle(winnerName, koshienResult.label, 'summer')
                    .then(koshienArticle => {
                        if(koshienArticle) {
                            tournamentState.news.push(koshienArticle);
                            renderNews(tournamentState.news); // 記事ができたら再描画
                            saveState(); // 保存
                        }
                    });
            }
        } else if (tournamentState.currentTournament === 'autumn') {
            // 秋大会優勝/準優勝 → センバツ選出判定
            tournamentState.senbatsuTeams = []; // リセット
            const finalists = [winnerName, loserName];
            const selectionPromises = finalists.map(async (teamName) => {
                // 70%の確率で選出 (仮の確率)
                if (Math.random() < 0.70) {
                    tournamentState.senbatsuTeams.push(teamName);
                    // 選出記事生成を非同期で開始
                    const senbatsuArticle = await generateKoshienSummaryArticle(teamName, 'センバツ出場決定', 'tokai'); // 'tokai' タイプで呼び出し
                    if (senbatsuArticle) {
                        tournamentState.news.push(senbatsuArticle);
                    }
                }
            });
            // 全ての選出記事生成が終わるのを待つ
            await Promise.all(selectionPromises);
            // 記事ができたら再描画・保存
            renderNews(tournamentState.news);
            saveState();
        }
    }

// --- 5. AIコンテンツの処理と最終的な画面更新 ---
    const [generatedArticle, generatedComments] = await Promise.all([articlePromise, commentsPromise]);

    // ▼▼▼ ここから BBSコメントのエラーハンドリングを修正 ▼▼▼
    if (generatedComments) {
        // AIが配列を返し、かつエラーオブジェクトを含まないかチェック
        if (Array.isArray(generatedComments) && !generatedComments.some(c => c.error)) {
            const validComments = generatedComments.filter(comment => !comment.error);
            if (validComments.length > 0) {
                tournamentState.bbsComments.push(...validComments); // 成功コメントをBBSに追加
            }
        // AIが配列を返したが、中にエラーオブジェクトが含まれる場合の処理
        } else if (Array.isArray(generatedComments)) {
            const errorCommentData = generatedComments.find(comment => comment.error);
            if (errorCommentData && errorCommentData.context) {
                // ★★★ 変更点: newsではなくbbsCommentsにエラーを追加 ★★★
                tournamentState.bbsComments.push({
                    title: "掲示板コメント生成エラー", // renderBbsCommentsで表示するためtitleを追加
                    body: "AIによるコメント生成に一部失敗しました。", // bodyは使われないが一応保持
                    timestamp: Date.now(),
                    error: true,
                    errorId: `error-${matchId}-bbs-partial`,
                    context: errorCommentData.context
                });
            }
        // AIがオブジェクト形式のエラーを返した場合 (例: { error: true, ... })
        } else if (generatedComments.error) {
            // ★★★ 変更点: newsではなくbbsCommentsにエラーを追加 ★★★
            tournamentState.bbsComments.push({
                title: generatedComments.title || "掲示板コメント生成エラー",
                body: generatedComments.body || "AIによるコメント生成に失敗しました。",
                timestamp: Date.now(),
                error: true,
                errorId: generatedComments.errorId || `error-${matchId}-bbs`,
                context: generatedComments.context || matchContext
            });
        // 予期しない形式の場合
        } else {
            console.error("Unexpected format from generateBbsComments:", generatedComments);
            // ★★★ 変更点: newsではなくbbsCommentsにエラーを追加 ★★★
            tournamentState.bbsComments.push({ title: "掲示板コメント形式エラー", body:"予期しないデータ形式です。", timestamp: Date.now(), error: true, context: matchContext });
        }
    }
    // ▲▲▲ BBSコメントのエラーハンドリング修正ここまで ▲▲▲  

    // --- 記事の処理 (変更なし) ---
    if (generatedArticle) {
        if (!generatedArticle.error) {
             generatedArticle.context = matchContext;
             showArticleReviewModal(generatedArticle);
        } else {
            // エラー記事をニュースリストに追加
            const errorArticle = {
                title: generatedArticle.title || "記事生成エラー",
                body: generatedArticle.body || "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                errorId: matchContext.matchId || 'error',
                context: matchContext
            };
            tournamentState.news.push(errorArticle);
        }
    }

    // --- スキャンダル、画面更新、保存処理 (変更なし) ---
    if (!tournamentState.activeScandal && Math.random() < 0.1) {
        triggerScandalEvent(winnerName, loserName);
    }

    renderTournament(tournamentState); // この中で renderBbsComments が呼ばれる
    saveState();

    // --- 春季大会の進行確認 (変更なし) ---
    if (tournamentState.currentTournament === 'spring' && tournamentState.springPhase === 'main_round1') {
        const round1Matches = Object.values(tournamentState.matches).filter(m => m.id.includes('-R1-'));
        if (round1Matches.length === 8 && round1Matches.every(m => m.winner)) {
            const confirmed = await showConfirm("1回戦がすべて終了しました。シード校が登場する2回戦に進みますか？");
            if (confirmed) {
                await setupSpringMainTournament_Round2();
            }
        }
    }
} // processMatchWin 関数の終了
// processMatchWin 関数の終了
// ▼▼▼ この関数をまるごと追加 ▼▼▼
/**
 * スキャンダルイベントを発生させる
 * @param {string} winnerName 
 * @param {string} loserName 
 */
function triggerScandalEvent(winnerName, loserName) {
    const potentialTargets = [winnerName, loserName];
    const eligibleScandals = [];

    for (const team of potentialTargets) {
        for (const scandal of SCANDAL_DEFINITIONS) {
            if (scandal.condition(team)) {
                eligibleScandals.push({ team, scandal });
            }
        }
    }

    if (eligibleScandals.length > 0) {
        const selected = eligibleScandals[Math.floor(Math.random() * eligibleScandals.length)];
        
        tournamentState.activeScandal = {
            teamName: selected.team,
            scandalId: selected.scandal.id
        };

        // ▼▼▼ この部分を修正 ▼▼▼
        const rumorArticle = {
            title: selected.scandal.rumorTitle(selected.team), // 関数として呼び出し、teamNameを渡す
            body: selected.scandal.rumorBody(selected.team),   // 関数として呼び出し、teamNameを渡す
            timestamp: Date.now(),
            isScandalRumor: true
        };
        // ▲▲▲ ここまで修正 ▲▲▲

        tournamentState.news.push(rumorArticle);
        renderNews(tournamentState.news);
        saveState();
    }
}
// ▲▲▲ ここまで追加 ▲▲▲

// --- 編集モーダル用のグローバル変数 ---
let articleForReview = null; // レビュー中の記事データを一時的に保持する

/**
 * AIが生成した記事を確認・編集するためのモーダルを表示する
 * @param {object} article - AIが生成した記事オブジェクト
 */
function showArticleReviewModal(article) {
    articleForReview = article; // 記事データを一時保存

    document.getElementById('review-title').value = article.title;
    document.getElementById('review-body').value = article.body.replace(/\\n/g, '\n');
    
    document.getElementById('review-modal').classList.remove('hidden');
}

/**
 * 編集モーダルを閉じる
 */
function closeReviewModal() {
    articleForReview = null;
    document.getElementById('review-modal').classList.add('hidden');
}

// --- 遊び方説明書モーダルのイベントリスナー ---
    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('help-modal');
    const helpModalClose = document.getElementById('help-modal-close');

    helpBtn.addEventListener('click', () => {
        helpModal.classList.remove('hidden');
    });
    helpModalClose.addEventListener('click', () => {
        helpModal.classList.add('hidden');
    }); 


// ▼▼▼ 抽選会イベント関連の関数群 ▼▼▼

const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

/**
 * 効果音を読み込む
 */
async function loadSoundEffects() {
    try {
        const drumroll = new Audio("https://actions.google.com/sounds/v1/sports/drum_roll_long.ogg");
        const cheer = new Audio("https://actions.google.com/sounds/v1/crowds/battle_crowd_cheer_med.ogg");
        const gasp = new Audio("https://actions.google.com/sounds/v1/human_sounds/gasp.ogg");
        soundEffects = { drumroll, cheer, gasp };
    } catch (e) {
        console.error("効果音の読み込みに失敗しました:", e);
    }
}

/**
 * 抽選会イベントを開始する
 */
/**
 * 抽選会イベントを開始する（BGM再生機能付き・完全版）
 */
async function startLotteryEvent() {
    const lotteryModal = document.getElementById('lottery-modal');
    lotteryModal.classList.remove('hidden');
    lotteryModal.classList.add('flex');

    // 抽選順を決める（トーナメントの組み合わせの元）
    const seeds = INITIAL_TEAM_POOL.map(teamName => ({
        name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last)
    })).sort((a, b) => a.rank - b.rank).slice(0, 8).map(t => t.name);
    
    const nonSeeds = INITIAL_TEAM_POOL.filter(t => !seeds.includes(t));
    const lotteryOrder = [...seeds, ...shuffleArray(nonSeeds)];

    // 簡易トーナメント表を作成
    const leftBracket = document.getElementById('lottery-bracket-left');
    const rightBracket = document.getElementById('lottery-bracket-right');
    leftBracket.innerHTML = '';
    rightBracket.innerHTML = '';
    for(let i=0; i<64; i++){
        const slot = document.createElement('div');
        slot.className = 'lottery-slot';
        slot.dataset.index = i;
        slot.innerHTML = `<span>${i+1}.</span> <span class="team-name-placeholder">---</span>`;
        document.getElementById(i < 32 ? 'lottery-bracket-left' : 'lottery-bracket-right').appendChild(slot);
    }

    // ボタンのイベントリスナーを設定
    document.getElementById('start-lottery-btn').onclick = () => runLotteryAnimation(lotteryOrder, seeds);
    
    document.getElementById('skip-lottery-btn').onclick = () => {
        lotteryModal.classList.add('hidden');
        SoundManager.stopBgm(); // スキップ時もBGMを停止
        createNewTournament(false, 'summer');
    };

    // BGM再生開始
    SoundManager.startBgm();
}
/**
 * 抽選会のアニメーションを実行する（強豪校の禍々しい雰囲気演出付き・完全版）
 * @param {Array<string>} lotteryOrder - シード校と、シャッフル済みのノーシード校を含む全チームの配列
 * @param {Array<string>} seeds - シード校8チームの配列
 */
/**
 * 抽選会のアニメーションを実行する（サウンドマネージャー対応の最終完成版）
 */
async function runLotteryAnimation(lotteryOrder, seeds) {
    // --- 1. 初期設定 ---
    document.getElementById('lottery-pot').onclick = null;
    document.getElementById('skip-lottery-btn').style.display = 'none';

    const commentaryEl = document.getElementById('lottery-commentary').querySelector('p');
    const drawnTeamContainer = document.getElementById('drawn-team-container');
    const drawnTeamEl = document.getElementById('drawn-team');
    const potEl = document.getElementById('lottery-pot');
    const potNameEl = document.getElementById('pot-name');
    
    const teamPositions = Array(64).fill(null);
    const seedPositionsTemplate = [0, 32, 16, 48, 8, 40, 24, 56];
    let availableSeedSlots = [...seedPositionsTemplate];
    let availableNonSeedSlots = Array.from({length: 64}, (_, i) => i).filter(p => !availableSeedSlots.includes(p));
    
    const blockDeathAnnounced = { A: false, B: false, C: false, D: false };

    // --- 内部ヘルパー関数：安全に音声を再生する ---
    const playSound = (id) => {
        const soundElement = document.getElementById(id);
        if (soundElement) {
            soundElement.currentTime = 0;
            soundElement.play().catch(e => console.warn(`Audio play failed for ${id}:`, e));
        }
    };
    
    const isStrongRank = (team) => ['S', 'A'].includes(calculateRank(team, {}));

    const checkDeathBlock = (position) => {
        const blockName = position < 16 ? 'A' : position < 32 ? 'B' : position < 48 ? 'C' : 'D';
        const startIdx = position < 16 ? 0 : position < 32 ? 16 : position < 48 ? 32 : 48;
        if (blockDeathAnnounced[blockName]) return false;
        const teamsInBlock = teamPositions.slice(startIdx, startIdx + 16);
        const strongTeamsCount = teamsInBlock.filter(team => team && isStrongRank(team)).length;
        if (strongTeamsCount >= 3) {
            commentaryEl.textContent = `これは...！ ${blockName}ブロックは有力校が集中する「死のブロック」になりました！`;
            blockDeathAnnounced[blockName] = true;
            playSound('sound-gasp');
            return true;
        }
        return false;
    };

    // --- 2. 抽選会フェーズ1：シード校の配置 ---
    potNameEl.textContent = "シード校";
    for (const teamName of seeds) {
        let dreadBg = null;
        if (isStrongRank(teamName)) {
            dreadBg = document.createElement('div');
            dreadBg.className = 'dread-mode-bg';
            document.body.appendChild(dreadBg);
            potEl.classList.add('dread');
            commentaryEl.textContent = `会場が静まり返る... 次は ${teamName} です...`;
            await sleep(2500);
        }

        commentaryEl.textContent = `${teamName}がクジを引きます...`;
        playSound('sound-drumroll');
        await sleep(1500);

        drawnTeamEl.textContent = teamName;
        drawnTeamContainer.classList.add('fade-in-out');

        const slotIndex = Math.floor(Math.random() * availableSeedSlots.length);
        const position = availableSeedSlots.splice(slotIndex, 1)[0];
        teamPositions[position] = teamName;

        await sleep(1250);

        const targetSlot = document.querySelector(`.lottery-slot[data-index="${position}"]`);
        targetSlot.querySelector('.team-name-placeholder').textContent = teamName;
        targetSlot.classList.add('filled');
        playSound('sound-cymbal');
        
        if (dreadBg) {
            dreadBg.remove();
            potEl.classList.remove('dread');
            playSound('sound-gasp');
        }
        
        const opponentIndex = position % 2 === 0 ? position + 1 : position - 1;
        if (teamPositions[opponentIndex]) {
            commentaryEl.textContent = `${teamName}の相手は${teamPositions[opponentIndex]}に決定！`;
        } else {
            commentaryEl.textContent = `${teamName}は ${position + 1}番！ 相手はまだ決まりません！`;
        }
        await sleep(1500);
        drawnTeamContainer.classList.remove('fade-in-out');
    }

    // --- 3. 抽選会フェーズ2：ノーシード校の配置 ---
    potNameEl.textContent = "ノーシード校";
    const nonSeeds = lotteryOrder.filter(t => !seeds.includes(t));
    for (const teamName of nonSeeds) {
        let dreadBg = null;
        if (isStrongRank(teamName)) {
            dreadBg = document.createElement('div');
            dreadBg.className = 'dread-mode-bg';
            document.body.appendChild(dreadBg);
            potEl.classList.add('dread');
            commentaryEl.textContent = `会場が静まり返る... 強豪 ${teamName} が登場...`;
            await sleep(2500);
        }

        commentaryEl.textContent = `${teamName}がクジを引きます...`;
        playSound('sound-drumroll');
        await sleep(250);

        drawnTeamEl.textContent = teamName;
        drawnTeamContainer.classList.add('fade-in-out');

        const slotIndex = Math.floor(Math.random() * availableNonSeedSlots.length);
        const position = availableNonSeedSlots.splice(slotIndex, 1)[0];
        teamPositions[position] = teamName;
        
        await sleep(200);

        const targetSlot = document.querySelector(`.lottery-slot[data-index="${position}"]`);
        targetSlot.querySelector('.team-name-placeholder').textContent = teamName;
        targetSlot.classList.add('filled');
        playSound('sound-cymbal');
        
        if (dreadBg) {
            dreadBg.remove();
            potEl.classList.remove('dread');
            playSound('sound-gasp');
        }
        
        commentaryEl.textContent = `${teamName}は ${position + 1}番 に決定！`;
        let didComment = checkDeathBlock(position);

        if (!didComment) {
            const opponentIndex = position % 2 === 0 ? position + 1 : position - 1;
            if(teamPositions[opponentIndex]) {
                const opponentName = teamPositions[opponentIndex];
                const isRival = RIVALRIES.some(r => r.teams.includes(teamName) && r.teams.includes(opponentName));
                if (isRival || (isStrongRank(teamName) && isStrongRank(opponentName))) {
                    commentaryEl.textContent = `決まったー！1回戦から屈指の好カード！ ${teamName} vs ${opponentName}`;
                    playSound('sound-gasp');
                    document.querySelector(`.lottery-slot[data-index="${opponentIndex}"]`).classList.add('highlight');
                    targetSlot.classList.add('highlight');
                    await sleep(1500);
                }
            }
        }
        await sleep(250);
        drawnTeamContainer.classList.remove('fade-in-out');
    }

    // --- 4. 終了処理 ---
    commentaryEl.textContent = '全ての組み合わせが決定しました！';
    await sleep(2000);
    
    await generateCaptainInterviews(teamPositions);
 // 最後に、決定した組み合わせを渡してトーナメントを生成
    document.getElementById('lottery-modal').classList.add('hidden');
    createNewTournament(false, 'summer', teamPositions); 
}

/**
 * 抽選会後の主将インタビューを生成・表示する（ランク差対応・最終版）
 * @param {Array<string>} teamPositions - 抽選会で決定した最終的なチームの組み合わせ
 */
async function generateCaptainInterviews(teamPositions) {
    const interviewModal = document.getElementById('interview-modal');
    const interviewContent = document.getElementById('interview-content');
    interviewContent.innerHTML = `<div class="loader">AI記者が主将インタビューを作成中...</div>`;
    interviewModal.classList.remove('hidden');

    const matchups = [];
    for(let i=0; i<64; i+=2){
        matchups.push({team1: teamPositions[i], team2: teamPositions[i+1]});
    }

    // 注目カードを3つに増やす
    const notableMatchups = shuffleArray(matchups).slice(0, 3);

    // ▼▼▼ ここからが新しい処理 ▼▼▼
    const matchupsWithRanks = notableMatchups.map(m => ({
        team1: m.team1,
        rank1: calculateRank(m.team1, tournamentState),
        team2: m.team2,
        rank2: calculateRank(m.team2, tournamentState)
    }));
    const promptDataText = matchupsWithRanks.map(m => 
        `- ${m.team1} (ランク: ${m.rank1}) vs ${m.team2} (ランク: ${m.rank2})`
    ).join('\n');
    // ▲▲▲

    const prompt = `あなたは高校野球専門のAI記者です。夏の大会の組み合わせ抽選会が終了しました。
以下の注目カードについて、両チームの主将になりきって、抽選結果に対するリアルな反応を語ってください。

### 注目カードと各チームのランク
${promptDataText}

### あなたがなりきる「高校生の主将」の思考パターン
- **格下の相手と当たった場合 (例: Aランク vs Dランク):**
  - 少し安堵した様子を見せる。「正直、ホッとした」「自分たちの野球をすれば負けない」
  - しかし油断は禁物だと付け加える。「どのチームも強いので、一戦必勝で戦いたい」
- **格上の相手と当たった場合 (例: Eランク vs Aランク):**
  - 明らかに絶望したり、驚いたりする。「まさか初戦で当たるとは…」「正直、厳しい相手」
  - しかし、挑戦者として「胸を借りるつもりで全力でぶつかりたい」「一矢報いたい」と闘志も見せる。
- **実力が拮抗している相手と当たった場合 (例: Cランク vs Cランク):**
  - 「ここが最初の山場になる」「厳しい戦いになることは覚悟している」と、相手への敬意を示す。
  - 「最高の試合をしたい」と、ライバルとの対戦を心待ちにしている様子を見せる。

### 指示
- 上記の思考パターンに基づき、各カードの両主将のコメントを生成してください。
- チームの背景（例：王者、古豪）も少しだけコメントに反映させてください。

### 出力形式 (JSON配列)
[
    {"team": "〇〇高校", "captain_comment": "（主将のコメント）"},
    {"team": "△△高校", "captain_comment": "（主将のコメント）"}
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        const interviews = parseJsonFromText(result.candidates[0].content.parts[0].text);

        if (interviews && Array.isArray(interviews)) {
            interviewContent.innerHTML = interviews.map(iv => `
                <div class.p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-bold text-lg text-gray-800">${iv.team} 主将</h4>
                    <p class="mt-1 text-gray-700">「${iv.captain_comment}」</p>
                </div>
            `).join('');
        } else {
            throw new Error("Parsed JSON is not an array or is null.");
        }
    } catch (e) {
        interviewContent.innerHTML = `<p class="text-center text-red-600">インタビューの生成に失敗しました。</p>`;
        console.error(e);
    }
    
    document.getElementById('close-interview-btn').onclick = () => {
        interviewModal.classList.add('hidden');
        document.getElementById('lottery-modal').classList.add('hidden');
        SoundManager.stopBgm();
        createNewTournament(false, 'summer', teamPositions);
    };
}
     
    async function initializeApp() {
  SoundManager.init(); 
 // --- 1. Preload the background image ---
    const bgContainer = document.querySelector('.ballpark-background');
    if (bgContainer) {
        const img = new Image();
        const imageUrl = 'ballpark.jpg'; // The local image path
        
        img.onload = function() {
            // Image loaded successfully, set it as the background and start the dust effect
            bgContainer.style.backgroundImage = `url(${imageUrl})`;
            createDustEffect();
        };
        img.onerror = function() {
            // If the image fails to load, log an error but still start the dust effect
            console.error('Failed to load the background image.');
            createDustEffect();
        };
        
        img.src = imageUrl; // This starts the image download
    } else {
        // If the background container doesn't exist, just start the dust effect
        createDustEffect();
    }
       
 // --- ここから診断コード ---
        try {
            alert('デバッグ開始：initializeApp関数が実行されました。');
            
            if (teamsTextarea) {
                alert('成功：チーム一覧を表示するテキストエリアが見つかりました。');
            } else {
                alert('エラー：チーム一覧を表示するテキストエリアが見つかりません！ id="teams-list" を確認してください。');
                return;
            }

            if (INITIAL_TEAM_POOL && INITIAL_TEAM_POOL.length > 0) {
                alert(`成功：${INITIAL_TEAM_POOL.length}件のチームデータが読み込まれました。`);
            } else {
                alert('エラー：チームデータが読み込めていません！ TEAM_DATAの定義を確認してください。');
                return;
            }

            teamsTextarea.value = INITIAL_TEAM_POOL.join('\n');
            alert('成功：チーム一覧をテキストエリアに表示しました。');

        } catch (e) {
            alert('致命的なエラーが発生しました： ' + e.message);
        }

        // --- ここまで診断コード ---

        
    const savedStateJSON = localStorage.getItem('tournamentState');
    if (savedStateJSON) {
        try {
            const lastState = JSON.parse(savedStateJSON);
            if (lastState && lastState.tournamentYear) {
                const confirmed = await showConfirm("前回の続きから再開しますか？\n（「いいえ」で最初から、または「合い言葉」で再開）");
                
                if (confirmed) { // 「はい」が押された場合
                    tournamentState = lastState;
                    setupEl.classList.add('hidden');
                    tournamentDisplayEl.classList.remove('hidden');
                    renderTournament(tournamentState);
                    return; 
                } else { // ▼▼▼ 「いいえ」が押された場合の処理を追加 ▼▼▼
                    // 古いセーブデータを完全に消去する
                    localStorage.removeItem('tournamentState');
                }
            }
        } catch (e) {
            console.error("保存されたデータの読み込みに失敗:", e);
            localStorage.removeItem('tournamentState'); 
        }
    }        
        setupEl.classList.remove('hidden');
        tournamentDisplayEl.classList.add('hidden');
　　　　teamsTextarea.value = INITIAL_TEAM_POOL.join('\n');

 updateTicker();
}

    // --- Event Listeners ---
    
    generateBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("新しいトーナメントを開始すると、現在の進行状況は失われます。よろしいですか？");
    if (confirmed) startLotteryEvent();
});
    resumeBtn.addEventListener('click', () => {
        saveLoadModal.classList.remove('hidden');
        loadTabBtn.click();
    });

    nextTournamentBtn.addEventListener('click', async () => {
        const confirmed = await showConfirm("現在の大会を終了し、次の大会へ進みますか？");
        if(confirmed) {
            let nextTournamentType;
            if (tournamentState.currentTournament === 'summer') nextTournamentType = 'autumn';
            else if (tournamentState.currentTournament === 'autumn') nextTournamentType = 'spring';
            else nextTournamentType = 'summer';
            createNewTournament(true, nextTournamentType);
        }
    });

    resetBtn.addEventListener('click', async () => {
        const confirmed = await showConfirm("すべての大会記録をリセットして、最初の状態に戻しますか？");
        if(confirmed){
            localStorage.clear();
            location.reload();
        }
    });

    saveBtn.addEventListener('click', () => {
        document.getElementById('save-code-area').classList.add('hidden');
        saveLoadModal.classList.remove('hidden');
        saveTabBtn.click();
    });
    
    startRankingPlayoffsBtn.addEventListener('click', async () => {
         const confirmed = await showConfirm("全ブロックの予選が終了しました。地区内順位決定戦に進みますか？");
         if(confirmed) setupAutumnRankingTournaments();
    });
    
    // startMainTournamentBtn のイベントリスナー内

startMainTournamentBtn.addEventListener('click', async () => {
    // ★★★ 春季大会用の分岐を追加 ★★★
    if (tournamentState.currentTournament === 'spring') {
        const confirmed = await showConfirm("全代表校が決定しました。県大会本戦に進みますか？");
        if (confirmed) setupSpringMainTournament_Round1();
    } 
    // ★★★ ここまで追加 ★★★
    else { // 秋季大会の既存ロジック
        const confirmed = await showConfirm("全代表校が決定しました。県大会本戦に進みますか？");
        if (confirmed) setupAutumnMainTournament();
    }
});

    skipR1Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("1回戦を自動で進行しますか？");
        if (confirmed) skipRound(1);
    });
    skipR2Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("2回戦を自動で進行しますか？");
        if (confirmed) skipRound(2);
    });
    skipR3Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("3回戦を自動で進行しますか？");
        if (confirmed) skipRound(3);
    });

skipR4Btn.addEventListener('click', async () => {
    const confirmed = await showConfirm("準々決勝を自動で進行しますか？");
    if (confirmed) skipRound(4);
});

skipR5Btn.addEventListener('click', async () => {
    const confirmed = await showConfirm("準決勝を自動で進行しますか？");
    if (confirmed) skipRound(5);
});

skipFinalBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("決勝戦を自動で進行しますか？");
    if (confirmed) skipFinal();
});
skipAutumnBlocksBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("秋季地区ブロック予選をすべて自動で進行しますか？");
    if (confirmed) skipAutumnRegionalBlocks();
});

skipAutumnRankingBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("秋季地区の第5代表決定戦をすべて自動で進行しますか？");
    if (confirmed) skipAutumnRankingTournaments();
});

skipAutumnMainBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("秋季県大会本戦をすべて自動で進行しますか？");
    if (confirmed) skipAutumnMainTournament();
});
    
skipSpringQualifiersBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("春季地区予選をすべて自動で進行しますか？");
    if (confirmed) skipSpringQualifiers();
});

skipSpringRound1Btn.addEventListener('click', async () => {
    const confirmed = await showConfirm("春季県大会1回戦を自動で進行しますか？");
    if (confirmed) skipSpringMainRound1();
});

skipSpringMainBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("春季県大会2回戦以降をすべて自動で進行しますか？");
    if (confirmed) skipSpringMainTournament();
});

    generateSummaryBtn.addEventListener('click', async () => {
        generateSummaryBtn.disabled = true;
        generateSummaryBtn.textContent = '記事を生成中...';
        newsContainer.innerHTML = `<div class="loader">AI記者がハイライト記事を執筆中...</div>`;
        const summaryArticle = await generateBest8PreviewArticle();
        if (summaryArticle) {
            tournamentState.news.push(summaryArticle);
            saveState();
            renderNews(tournamentState.news);
        }
        generateSummaryBtn.classList.add('hidden');
        generateSummaryBtn.disabled = false;
        generateSummaryBtn.textContent = 'ベスト8ハイライト記事を生成';
    });

document.body.addEventListener('click', async (e) => {



    // --- 試合進行ボタン (▶) ---
    if (e.target.matches('.win-btn')) {
        const teamSlot = e.target.closest('.team-slot');
        const matchEl = e.target.closest('[data-match-id]');
        if (!teamSlot || !matchEl || teamSlot.classList.contains('empty')) return;

        const matchId = matchEl.dataset.matchId;
        const winnerName = teamSlot.dataset.teamName;
        if (!winnerName) return;

        const score1El = matchEl.querySelector('[data-team-pos="1"]');
        const score2El = matchEl.querySelector('[data-team-pos="2"]');

        if(!score1El || !score2El || score1El.value === '' || score2El.value === '') {
            showAlert('スコアを入力してください。');
            return;
        }

        let dbMatch = findMatchById(matchId);
        if (dbMatch) {
            dbMatch.score1 = score1El.value;
            dbMatch.score2 = score2El.value;
            dbMatch.summary = matchEl.querySelector('.match-summary-input')?.value || '';
        }

        await processMatchWin(matchId, winnerName);
    }

// --- 「勢力図をアニメーションで見る」ボタン（モーダルを開く） ---
    else if (e.target.matches('.view-analysis-btn')) {
        document.getElementById('analysis-modal').classList.remove('hidden');
        currentBlock = 'A'; // 初期表示はAブロック
        playBlockAnimation(currentBlock);
    }
    // --- 【新しく追加】勢力図モーダル内のタブボタン ---
    else if (e.target.matches('.analysis-block-tab-btn')) {
        const blockId = e.target.dataset.block;
        if (blockId && blockId !== currentBlock) {
            currentBlock = blockId;
            playBlockAnimation(currentBlock);
        }
    }
    // --- 勢力図モーダルを閉じるボタン ---
    else if (e.target.matches('#analysis-modal-close-btn')) {
        document.getElementById('analysis-modal').classList.add('hidden');
    }
    // --- 試合詳細入力ボタン ---
    else if (e.target.matches('.details-btn')) {
        openDetailsModal(e.target.dataset.matchId);
    }

    // --- 【詳細モーダル内】イニング追加ボタン ---
    else if (e.target.matches('.add-inning-btn') || e.target.matches('#add-inning-score-btn')) {
        e.preventDefault();
        addExtraInning();
    }

// ▼▼▼ この else if ブロックを追加 ▼▼▼
    // --- 【詳細モーダル内】守備ファインプレーを追加ボタン ---
    else if (e.target.matches('.add-fielding-play-btn')) {
        e.preventDefault();
        const teamKey = e.target.dataset.teamKey;
        const tableBody = document.getElementById(`fielding-table-${teamKey}`).querySelector('tbody');
        
        // 選手リストを取得
        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        const playersOnField = Array.from(battingTable.querySelectorAll('.player-name')).map(input => ({name: input.value.trim()})).filter(p => p.name);
        const playerOptions = playersOnField.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
        
        const newRow = tableBody.insertRow();
        newRow.dataset.fieldingIndex = tableBody.rows.length; // 新しいインデックス
        newRow.innerHTML = `
            <td class="w-16"><input type="number" class="fielding-inning" min="1"></td>
            <td>
                <select class="player-name w-full">
                    <option value="">- 選手 -</option>
                    ${playerOptions}
                </select>
            </td>
            <td><input type="text" class="fielding-play" placeholder="例: ダイビングキャッチ"></td>
            <td class="w-12 text-center">
                <button class="remove-fielding-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </td>
        `;
    }
    // --- 【詳細モーダル内】守備ファインプレーを削除ボタン ---
    else if (e.target.matches('.remove-fielding-play-btn')) {
        e.preventDefault();
        e.target.closest('tr').remove();
    }
    // ▲▲▲ 追加ここまで ▲▲▲
    
    // --- 天候ボタン ---
    else if (e.target.matches('.weather-btn')) {
        const weatherType = e.target.dataset.weather;
        setWeather(weatherType);
    }


   // document.body.addEventListener('click', ...) 内の、まとめサイト関連の if ブロックを全てこれで置き換える

    // ▼▼▼ このブロックで、統合型まとめサイト関連の処理を全て書き換える ▼▼▼

    // --- 「まとめサイトを見る」ボタン ---
    const showMatomeBtn = e.target.closest('#show-matome-site-btn');
    if (showMatomeBtn) {
        const modal = document.getElementById('integrated-matome-modal');
        const articlesContainer = document.getElementById('matome-articles-container');
        modal.classList.remove('hidden');
        
        // ローダーを表示し、最新記事を読み込む
        articlesContainer.innerHTML = `<div class="loader text-center py-8">記事を読み込んでいます...</div>`;
        
        // 初期表示は「トップ」タブ
        document.querySelectorAll('.matome-tab-content').forEach(tab => tab.classList.add('hidden'));
        document.getElementById('matome-tab-top').classList.remove('hidden');
        document.querySelectorAll('.matome-tab-btn').forEach(btn => btn.classList.remove('active', 'bg-blue-600', 'text-white'));
        document.querySelector('.matome-tab-btn[data-tab="top"]').classList.add('active', 'bg-blue-600', 'text-white');

        (async () => {
            const matomeHtml = await generateMatomeSiteHtml();
            articlesContainer.innerHTML = matomeHtml;
        })();
    }

 // --- 設定モーダルを開く/閉じる ---
    if (e.target.closest('#open-settings-btn')) {
        // 現在の設定をモーダルに反映
        document.getElementById('toggle-article-generation').checked = tournamentState.settings.enableArticleGeneration;
        document.getElementById('toggle-bbs-generation').checked = tournamentState.settings.enableBbsGeneration;
        document.getElementById('settings-modal').classList.remove('hidden');
    }
    if (e.target.closest('#settings-modal-close-btn')) {
        document.getElementById('settings-modal').classList.add('hidden');
    }


    // --- 統合型まとめサイトモーダルを閉じるボタン ---
    if (e.target.closest('#matome-modal-close-btn')) {
        document.getElementById('integrated-matome-modal').classList.add('hidden');
        // BBSスレッド表示エリアも隠す
        document.getElementById('bbs-thread-display-area').classList.add('hidden');
    }

    // --- まとめサイト内のタブ切り替え ---
    const tabBtn = e.target.closest('.matome-tab-btn');
    if (tabBtn) {
        document.querySelectorAll('.matome-tab-btn').forEach(btn => {
            btn.classList.remove('active', 'bg-blue-600', 'text-white', 'hover:bg-blue-700');
            btn.classList.add('text-gray-700', 'hover:bg-gray-100');
        });
        tabBtn.classList.add('active', 'bg-blue-600', 'text-white');
        tabBtn.classList.remove('text-gray-700', 'hover:bg-gray-100');

        const tabId = tabBtn.dataset.tab;
        document.querySelectorAll('.matome-tab-content').forEach(content => {
            content.classList.add('hidden');
        });
        document.getElementById(`matome-tab-${tabId}`).classList.remove('hidden');

        // タブ切り替え時にBBSスレッド表示エリアは隠す
        document.getElementById('bbs-thread-display-area').classList.add('hidden');

        // 「トップ」タブに戻ったら記事を再読み込み (必要に応じて)
        if (tabId === 'top') {
            const articlesContainer = document.getElementById('matome-articles-container');
            articlesContainer.innerHTML = `<div class="loader text-center py-8">記事を読み込んでいます...</div>`;
            (async () => {
                const matomeHtml = await generateMatomeSiteHtml();
                articlesContainer.innerHTML = matomeHtml;
            })();
        }
    }
    
    // --- まとめサイト内の記事リンククリック ---
    const matomeLink = e.target.closest('.matome-article-link');
    if (matomeLink) {
        e.preventDefault();
        const headline = matomeLink.dataset.headline; // ★スレッドタイトルはここから取得
        const type = matomeLink.dataset.type;
        const category = matomeLink.dataset.category;
        const matchId = matomeLink.dataset.matchId;

        const threadDisplayArea = document.getElementById('bbs-thread-display-area');
        const threadTitleEl = document.getElementById('bbs-thread-title');
        const threadContentEl = document.getElementById('bbs-thread-content');

        document.querySelectorAll('.matome-tab-content').forEach(content => content.classList.add('hidden'));
        threadDisplayArea.classList.remove('hidden');

        threadTitleEl.textContent = headline;
        threadContentEl.innerHTML = `<div class="loader text-center py-8">AIが掲示板の反応を生成中...</div>`;

        (async () => {
            let commentsArray; // 変数名を配列と分かるように変更

            if (type === 'game' && matchId) {
                const match = findMatchById(matchId);
                if (match && match.winner) {
                    const matchContext = createMatchContext(matchId, match.winner);
                    commentsArray = await generateGameMatchBbsComments(matchContext);
                }
            } else if (type === 'real') {
                commentsArray = await generateRealNewsBbsComments(headline, category);
            }

            // ▼▼▼ ここからが重要な修正点 ▼▼▼
            // 「result.comments」ではなく、「commentsArray」が配列であるかを直接チェックする
            if (commentsArray && Array.isArray(commentsArray)) {
                threadTitleEl.textContent = `【スレ】${headline}`; // タイトルを設定
                threadContentEl.innerHTML = ''; // ローダーを消す

                // ライブ感のある描画処理
                for (const comment of commentsArray) { // commentsArray を直接ループ
                    const commentEl = document.createElement('div');
                    commentEl.className = 'bbs-comment opacity-0 transition-opacity duration-500';
                    commentEl.innerHTML = `
                        <p class="font-semibold text-gray-700 text-sm">${comment.personality}</p>
                        <p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>
                    `;
                    threadContentEl.appendChild(commentEl);

                    setTimeout(() => {
                        commentEl.classList.remove('opacity-0');
                    }, 50);

                    const delay = Math.random() * 800 + 200;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    threadContentEl.scrollTop = threadContentEl.scrollHeight;
                }

            } else {
                threadContentEl.innerHTML = `<p class="text-center text-red-500">スレッドの生成に失敗しました。</p>`;
            }
            // ▲▲▲ 修正ここまで ▲▲▲
        })();
    }


    // --- BBSスレッドから一覧に戻るボタン ---
    if (e.target.closest('#bbs-thread-back-btn')) {
        document.getElementById('bbs-thread-display-area').classList.add('hidden');
        document.getElementById('matome-tab-top').classList.remove('hidden'); // トップタブに戻る
    }
    // ▲▲▲ ここまで置き換え ▲▲▲ 
   
 // --- スキャンダル告発/無視ボタン ---
  // document.body.addEventListener('click', ...) 内のスキャンダルボタンの処理を置き換え

    // --- スキャンダル告発/無視ボタン ---
    const scandalBtn = e.target.closest('.report-scandal-btn, .ignore-scandal-btn');
    if (scandalBtn && tournamentState.activeScandal) {
        const { teamName, scandalId } = tournamentState.activeScandal;
        const scandalDef = SCANDAL_DEFINITIONS.find(s => s.id === scandalId);
        if (!scandalDef) return;

        const choice = scandalBtn.classList.contains('report-scandal-btn') ? 'report' : 'ignore';
        const consequence = scandalDef.consequences[choice];

        // 効果を適用
        consequence.applyEffect(teamName, tournamentState);

        // 結果記事を生成
        const outcomeArticle = {
            title: consequence.outcomeTitle(teamName),
            body: consequence.outcomeBody(teamName),
            timestamp: Date.now()
        };
        
        // 噂記事をニュースリストから削除し、結果記事を追加
        tournamentState.news = tournamentState.news.filter(n => !n.isScandalRumor);
        tournamentState.news.push(outcomeArticle);
        
        // スキャンダルを解決済みにする
        tournamentState.activeScandal = null;

        renderTournament(tournamentState); // トーナメント表とニュースを再描画
        saveState();
    }
// --- ドキュメンタリー密着取材ボタン ---
    // --- ドキュメンタリー密着取材ボタン（逆境） ---
    else if (e.target.matches('.underdog-doc-btn')) { // ← クラス名を変更
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？...`);
        if (confirmed) {
            startDocumentary('underdog', teamName); // ← type を渡すように変更
        }
    }

    // ▼▼▼ ここから追加 ▼▼▼
    // --- ドキュメンタリー密着取材ボタン（強豪） ---
    else if (e.target.matches('.powerhouse-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) {
            startDocumentary('powerhouse', teamName);
        }
    }

// ▼▼▼ ここから追加 ▼▼▼
    // --- ドキュメンタリー密着取材ボタン（古豪復活） ---
    else if (e.target.matches('.powerhouse-revival-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) {
            startDocumentary('powerhouse_revival', teamName);
        }
    }

 else if (e.target.matches('.one-man-team-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) {
            startDocumentary('one_man_team', teamName);
        }
    }

    // --- 「＋ 走者プレーを追加」ボタン ---
    else if (e.target.matches('.add-runner-play-btn')) {
        e.preventDefault();
        const container = e.target.closest('.at-bat-block').querySelector('.runner-plays-container');
        if (!container) return;

        if (container.children.length >= 3) {
            alert('一度に追加できる走者プレーは3つまでです。');
            return;
        }

        const table = e.target.closest('.batting-table');
        const playersOnField = Array.from(table.querySelectorAll('.player-name')).map(input => ({name: input.value.trim()})).filter(p => p.name);
        const nameOptions = playersOnField.map(p => `<option value="${p.name}">${p.name}</option>`).join('');

        const baserunningPlays = ['盗塁', '盗塁死', 'タッチアップ', '進塁', '生還', '走塁死', '牽制死', '挟殺プレーでアウト'];
        const bases = ['一塁へ', '二塁へ', '三塁へ', '本塁へ(生還)'];
        const playOptions = baserunningPlays.map(p => `<option value="${p}">${p}</option>`).join('');
        const baseOptions = bases.map(b => `<option value="${b}">${b}</option>`).join('');

        const newPlayHTML = `
            <div class="runner-play-input flex gap-1 items-center mt-1">
                <select class="runner-name w-1/3 text-xs p-1 border rounded"><option value="">-誰が-</option>${nameOptions}</select>
                <select class="runner-play w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-何をした-</option>${playOptions}</select>
                <select class="runner-base w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-どこへ-</option>${baseOptions}</select>
                <button class="remove-runner-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </div>
        `;
        container.insertAdjacentHTML('beforeend', newPlayHTML);
    }
    
    // --- 走者プレーの「×」削除ボタン ---
    else if (e.target.matches('.remove-runner-play-btn')) {
        e.target.closest('.runner-play-input').remove();
    }

    // --- おまかせ入力ボタン ---
    else if (e.target.matches('.quick-sim-btn')) {
        e.preventDefault();
        autoFillMatchDetails(e.target.dataset.matchId);
    }

    // --- 1イニングに複数打席を追加するボタン ---
    else if (e.target.matches('.add-at-bat-btn')) {
        e.preventDefault();
        const table = e.target.closest('.batting-table');
        const playersOnField = Array.from(table.querySelectorAll('.player-name')).map(input => ({ name: input.value.trim() })).filter(p => p.name);
        
        // 新しい空の打席ブロック（打者入力欄＋走者入力欄の正しいセット）を生成
        const newAtBatHTML = createBattingResultDropdowns(playersOnField, '');
        
        // クリックされたボタンの直前に、新しいブロックを挿入
        e.target.insertAdjacentHTML('beforebegin', newAtBatHTML);
    }

    // --- 交代選手追加ボタン ---
    else if (e.target.matches('.add-substitute-btn')) {
        e.preventDefault();
        const teamKey = e.target.dataset.teamKey;
        const tableBody = document.getElementById(`batting-table-${teamKey}`).querySelector('tbody');
        if (!tableBody) return;

        const orderInput = prompt("何番打者の交代選手を追加しますか？（例：3）");
        if (!orderInput || isNaN(orderInput) || orderInput < 1 || orderInput > 9) {
            alert("1から9の正しい打順を入力してください。");
            return;
        }
        const order = parseInt(orderInput);

        const allOrderRows = Array.from(tableBody.querySelectorAll(`tr[data-order^="${order}"]`));
        if (allOrderRows.length === 0) {
            alert(order + '番打者が見つかりません。');
            return;
        }
        const targetRow = allOrderRows[allOrderRows.length - 1];

        const newRow = document.createElement('tr');
        const subCount = allOrderRows.filter(row => row.dataset.order.includes('sub')).length + 1;
        newRow.dataset.order = `${order}-sub-${subCount}`;
        
        const numInnings = tableBody.parentElement.querySelector('thead tr').children.length - 6;
        let resultInputs = '';
        for (let j = 0; j < numInnings; j++) {
            resultInputs += `<td class="col-inning batting-result-cell align-top p-1">
                                ${createBattingResultDropdowns('')}
                                ${createRunnerInputsHTML([], '')}
                             </td>`;
        }
        
        newRow.innerHTML = `
            <td class="col-order"></td>
            <td><select class="player-number w-full bg-transparent"><option value=""></option>${Array.from({length:20},(_,i)=>`<option value="${i+1}">${i+1}</option>`).join('')}</select></td>
            <td class="pl-4"><input type="text" class="player-name" placeholder="交代選手名"></td>
            <td><select class="player-pos w-full bg-transparent"><option value=""></option>${['投', '捕', '一', '二', '三', '遊', '左', '中', '右'].map(p=>`<option value="${p}">${p}</option>`).join('')}</select></td>
            <td>
                <select class="sub-type-select w-full bg-transparent">
                    <option value="" selected>-</option><option value="PH">代打</option><option value="PR">代走</option>
                    <option value="DEF">守備</option><option value="PITCHER">投手</option>
                </select>
            </td>
            ${resultInputs}
        `;
        targetRow.parentNode.insertBefore(newRow, targetRow.nextSibling);
    }

    // --- 守備変更ボタン ---
    else if (e.target.matches('.pos-change-btn')) {
        const playerName = e.target.dataset.playerName;
        const teamKey = e.target.dataset.teamKey;
        const inning = prompt(`${playerName}選手が何回からポジションを変更しましたか？`);
        if (!inning || isNaN(inning)) return;
        const newPos = prompt(`${inning}回から、${playerName}選手の守備位置はどこになりましたか？ (例: 投, 一, 中)`);
        if (!newPos) return;

        const match = findMatchById(currentMatchIdForDetails);
        if (match) {
            if (!match.details) match.details = {};
            if (!match.details.positionChanges) match.details.positionChanges = [];
            match.details.positionChanges.push({ inning: parseInt(inning), teamKey, playerName, newPos });
            alert(`${inning}回から${playerName}選手が${newPos}を守るように記録しました。`);
        }
    }

    // --- 投手追加ボタン ---
    else if (e.target.matches('.add-row-btn')) {
        e.preventDefault();
        const tableId = e.target.dataset.tableId;
        const table = document.getElementById(tableId).querySelector('tbody');
        const newRow = table.insertRow();
        newRow.innerHTML = `
            <td><select><option value="" selected>-</option><option value="W">○</option><option value="L">●</option><option value="S">S</option><option value="H">H</option></select></td>
            <td><input type="text" value=""></td><td><input type="text" value=""></td><td><input type="number" value=""></td>
            <td><input type="number" value=""></td><td><input type="number" value=""></td><td><input type="number" value=""></td>
            <td><input type="number" value=""></td><td><input type="number" value=""></td><td><input type="number" value=""></td>
        `;
    }

    // --- 先攻後攻入れ替えボタン ---
    else if (e.target.matches('#swap-teams-btn')) {
        swapTeamDetails(e.target.dataset.matchId);
    }

    // --- チーム名クリック（ステータス表示） ---
    else if (e.target.matches('.clickable-team-name')) {
        const teamName = e.target.dataset.teamName;
        if(teamName && teamName !== 'null' && teamName !== '') {
            showTeamStatusModal(teamName);
        }
    }
    // --- 記事表示ボタン（通常記事の「本文」） ---
    else if (e.target.matches('.news-article-btn')) {
        const article = tournamentState.news[parseInt(e.target.dataset.index, 10)];
        if (article && article.body) {
            document.getElementById('modal-title').textContent = article.title;
            document.getElementById('modal-body').textContent = article.body;
            document.getElementById('modal-meta').innerHTML = `<p>${new Date(article.timestamp).toLocaleDateString('ja-JP')}</p>`;
            newsModal.classList.remove('hidden');
            newsModal.classList.add('flex');
        } else {
            alert('記事の本文データを取得できませんでした。');
        }
    }

    // --- 記事表示ボタン（新聞の「新聞を読む」） ---
    else if (e.target.matches('.newspaper-view-btn')) {
        const article = tournamentState.news[parseInt(e.target.dataset.index, 10)];
        if (article.isNewspaper && article.newspaperData) {
            renderNewspaperModal(article.newspaperData);
            newspaperModal.classList.remove('hidden');
        }
    }

 // ▼▼▼ 抜け落ちていたのは、このブロックです ▼▼▼
    // --- 掲示板の「返信する」ボタン ---
    const replyBtn = e.target.closest('.reply-btn');
    if (replyBtn) {
        e.preventDefault();
        const commentId = replyBtn.dataset.commentId;
        const formContainer = document.getElementById(`reply-form-container-${commentId}`);
        if (formContainer) {
            formContainer.classList.toggle('hidden');
        }
        return;
    }
    // ▲▲▲ ▲▲▲

// document.body.addEventListener('click', ...) の中

    
    // document.body.addEventListener('click', ...) 内の該当箇所を、以下のように修正・追記

    // ▼▼▼ 既存の「.retry-btn」の else if ブロックを、以下の内容にまるごと置き換える ▼▼▼
    // --- AI記事の再生成ボタン（エラー記事・成功記事の両方に対応） ---
    // --- AI記事の再生成ボタン（成功した記事用） ---
     // --- AI記事の再生成ボタン（成功・失敗記事の両方に対応） ---
    const regenerateBtn = e.target.closest('.regenerate-btn, .retry-btn');
    if (regenerateBtn) {
        const articleIndex = parseInt(regenerateBtn.dataset.index, 10);
        const originalArticle = tournamentState.news[articleIndex];
        if (!originalArticle || !originalArticle.context) {
            alert("この記事は再生成できません。");
            return;
        }
        articleForRegeneration = { index: articleIndex, article: originalArticle };
        document.getElementById('feedback-include').value = '';
        document.getElementById('feedback-exclude').value = '';
        document.getElementById('feedback-modal').classList.remove('hidden');
    }
    
    // --- フィードバックモーダルからの再生成実行ボタン ---
    // ▼▼▼ このブロックで、既存の該当箇所を置き換えてください ▼▼▼

   // --- フィードバックモーダルからの再生成実行ボタン ---
    const feedbackSubmitBtn = e.target.closest('#feedback-submit-btn');
    if (feedbackSubmitBtn) {
        if (!articleForRegeneration) return;
        const { index, article } = articleForRegeneration;
        const context = article.context;

        // UIを準備
        feedbackSubmitBtn.textContent = '生成中...';
        feedbackSubmitBtn.disabled = true;
        const userFeedback = {
            include: document.getElementById('feedback-include').value,
            exclude: document.getElementById('feedback-exclude').value
        };
        document.getElementById('feedback-modal').classList.add('hidden');
        articleForRegeneration = null;
        tournamentState.news.splice(index, 1); // 古い記事（またはエラー）を一旦削除
        renderNews(tournamentState.news);
        newsContainer.innerHTML = `<div class="loader">AI記者があなたの指示を基に記事を再執筆中です...</div>`;

        // 非同期でAIの再生成処理を開始
        (async () => {
            let articlePromise;

            // 再生成する記事がドキュメンタリーかどうかを context の中身で判断する
            if (context.isDocumentary) {
                // 【ドキュメンタリー記事の場合】
                const { type, teamName, matchData } = context;
                articlePromise = generateDocumentaryArticle('intro', type, teamName, matchData, userFeedback);

            } else {
                // 【通常の試合記事の場合】
                articlePromise = generateNewsArticle(context, userFeedback);
            }

            const newArticle = await articlePromise;

            const createErrorArticle = () => ({
                title: "記事生成エラー", body: "記事の再生成に失敗しました。",
                timestamp: Date.now(), error: true, errorId: context.matchId || 'error',
                context: context
            });

            if (newArticle && !newArticle.error) {
                newArticle.context = context; // 新しい記事にもコンテキストを付与

tournamentState.news.splice(index, 0, newArticle); // 元の位置に新しい記事を挿入
                showArticleReviewModal(newArticle); // 事実確認なしでレビューモーダル表示
                // ▲▲▲ 変更点ここまで ▲▲▲

            } else {
                tournamentState.news.splice(index, 0, createErrorArticle()); // 元の位置にエラー記事を挿入
            }

            saveState();
            renderNews(tournamentState.news);
            feedbackSubmitBtn.textContent = 'この指示で再生成';
            feedbackSubmitBtn.disabled = false;
        })();
    }
// ▲▲▲ ここまで置き換え ▲▲▲
    // --- フィードバックモーダルの「キャンセル」ボタン ---
    if (e.target.matches('#feedback-cancel-btn')) {
        document.getElementById('feedback-modal').classList.add('hidden');
        articleForRegeneration = null;
    }
    // ▲▲▲ ここまで追加 ▲▲▲    // ▲▲▲ ここまで追加 ▲▲▲

// --- 掲示板コメントのエラー再生成ボタン ---
    else if (e.target.matches('.retry-bbs-btn')) {
        const btn = e.target;
        const index = parseInt(btn.dataset.index, 10);
        const errorItem = tournamentState.bbsComments[index];
        const regenType = btn.dataset.type; // 'bracket-thread' or 'match-comments'

        if (!errorItem || !errorItem.context) {
            alert("再生成に必要な情報が見つかりません。");
            return;
        }

        btn.textContent = '生成中...';
        btn.disabled = true;
        // エラー表示を一時的にローダーに置き換えても良い
        // btn.closest('.article-error').innerHTML = `<div class="loader text-sm">再生成中...</div>`;

        let newBbsData = null; // 再生成結果を格納する変数

        try {
            if (regenType === 'bracket-thread') {
                // 組み合わせスレッドの再生成
                newBbsData = await generateBracketBbsThread(tournamentState); // state全体を渡す
            } else if (regenType === 'match-comments' && errorItem.context.matchId) {
                // 試合後コメントの再生成
                // contextに必要な情報が揃っているか確認
                if (errorItem.context.winnerName && errorItem.context.dbMatch) {
                     newBbsData = await generateBbsComments(errorItem.context); // 保存されたcontextを渡す
                } else {
                    throw new Error("試合後コメント再生成のためのContext情報が不足しています。");
                }
            } else {
                 throw new Error("不明な再生成タイプです: " + regenType);
            }

            // --- 再生成結果の処理 ---
            if (newBbsData && !newBbsData.error) {
                // 成功した場合：エラー項目を新しいデータで置き換える
                if (Array.isArray(newBbsData)) { // generateBbsComments は配列を返す
                    tournamentState.bbsComments.splice(index, 1, ...newBbsData);
                } else { // generateBracketBbsThread はオブジェクトを返す
                    tournamentState.bbsComments.splice(index, 1, newBbsData);
                }
            } else {
                 // 再生成に失敗した場合：エラー表示はそのまま or 更新
                 alert('再生成に失敗しました。');
                 btn.textContent = '再生成'; // ボタンを元に戻す
                 btn.disabled = false;
                 // エラー表示を元に戻す処理が必要な場合
                 // const errorEl = btn.closest('.article-error');
                 // if(errorEl) errorEl.innerHTML = `<span>${errorItem.title}</span> ... 再生性ボタンHTML ...`;
            }
        } catch(err) {
             console.error("BBS再生成中にエラー:", err);
             alert('再生成処理中にエラーが発生しました。');
             btn.textContent = '再生成'; // ボタンを元に戻す
             btn.disabled = false;
        }

        renderBbsComments(tournamentState.bbsComments); // 掲示板を再描画
        saveState();
    }
    // ▲▲▲ 追加ここまで ▲▲▲
});
    

// <script>タグの、他のイベントリスナーの近くに追加

document.body.addEventListener('change', (e) => {
    if (e.target.matches('#toggle-article-generation')) {
        tournamentState.settings.enableArticleGeneration = e.target.checked;
        saveState();
    }
    if (e.target.matches('#toggle-bbs-generation')) {
        tournamentState.settings.enableBbsGeneration = e.target.checked;
        saveState();
    }
});

   // ==========================================================
//  2.「送信」イベントを処理するリスナー (新設)
// ==========================================================
document.body.addEventListener('submit', async (e) => {
    
    // --- 掲示板の「返信フォーム」が送信された場合 ---
    if (e.target.matches('.reply-form')) {
        e.preventDefault();
        const form = e.target;
        const parentCommentId = form.dataset.commentId;
        const bbsType = form.dataset.bbsType;
        const textarea = form.querySelector('textarea');
        const userReplyText = textarea.value;

        if (!userReplyText.trim()) return;

        form.innerHTML = `<div class="loader text-xs">AIが返信を考えています...</div>`;
        
        const commentSource = bbsType === 'general' ? tournamentState.bbsComments : tournamentState.daiyaBbsComments;
        const parentComment = findCommentById(commentSource, parentCommentId);
        const aiPersona = parentComment.personality;
        const context = { tournamentSummary: getTournamentStatusSummary() };
        
        const aiReply = await generateBbsReply(parentCommentId, userReplyText, bbsType, aiPersona, context);

        if (aiReply) {
            const freshParentComment = findCommentById(commentSource, parentCommentId);
            if (freshParentComment) {
                if (!freshParentComment.replies) {
                    freshParentComment.replies = [];
                }
                freshParentComment.replies.push(aiReply);
            }
            if (bbsType === 'general') renderBbsComments(tournamentState.bbsComments);
            else renderDaiyaBbsComments(tournamentState.daiyaBbsComments);
            saveState();
        } else {
            form.innerHTML = `<textarea class="w-full p-2 border rounded text-sm" placeholder="返信を入力..." required></textarea><button type="submit" class="mt-1 bg-blue-500 text-white px-3 py-1 text-xs rounded hover:bg-blue-600">送信</button>`;
            alert("AIが返信を生成できませんでした。");
        }
    } 
    // --- メインのコメント投稿フォームが送信された場合 ---
    else if (e.target.matches('#main-comment-form')) {
        e.preventDefault();
        const textarea = document.getElementById('main-comment-textarea');
        const userCommentText = textarea.value;
        if (!userCommentText.trim()) return;

        textarea.disabled = true;
        e.target.querySelector('button').disabled = true;
        e.target.querySelector('button').textContent = 'AIが返信中...';

        const userComment = {
            id: crypto.randomUUID(),
            personality: 'あなた',
            text: userCommentText,
            timestamp: Date.now(),
            replies: []
        };
        
        const aiReplies = await generateMultipleReplies(userCommentText);
        userComment.replies = aiReplies;

        tournamentState.bbsComments.push(userComment);
        renderBbsComments(tournamentState.bbsComments);
        saveState();

        textarea.value = '';
        textarea.disabled = false;
        e.target.querySelector('button').disabled = false;
        e.target.querySelector('button').textContent = '投稿する';
    }

}); // ★★★ 閉じカッコ } の正しい位置はここです ★★★

// --- 編集モーダルの「この記事で確定」ボタン ---
    document.getElementById('review-save-btn').addEventListener('click', () => {
        if (articleForReview) {
            // テキストボックスの現在の内容で記事データを更新
            articleForReview.title = document.getElementById('review-title').value;
            articleForReview.body = document.getElementById('review-body').value.replace(/\n/g, '\\n');
            
            // 更新した記事をニュースリストに追加
            tournamentState.news.push(articleForReview);
            renderNews(tournamentState.news);
            saveState();
            
            closeReviewModal();
        }
    });

    // --- 編集モーダルの「キャンセル」ボタン ---
    document.getElementById('review-cancel-btn').addEventListener('click', () => {
        closeReviewModal();
    });

document.body.addEventListener('input', (e) => {
        if (e.target.matches('.match-summary-input')) {
            const matchId = e.target.dataset.matchId;
            let match;
            if (tournamentState.matches[matchId]) {
                match = tournamentState.matches[matchId];
            } else {
                 const [region, bracketId] = matchId.split('-');
                 if (tournamentState.autumnData?.regions[region]) {
                    const regionData = tournamentState.autumnData.regions[region];
                    if(bracketId.startsWith('B')) match = regionData.blocks.find(b=>b.id === `${region}-${bracketId}`).matches[matchId];
                    else if(bracketId === 'CHAMP') match = regionData.champBracket.matches[matchId];
                    else if(bracketId === 'REP') match = regionData.repechageBracket.matches[matchId];
                 }
            }
            if (match) {
                match.summary = e.target.value;
                saveState();
            }
        }



// イニングスコアが入力された場合
    else if (e.target.closest('#inning-score-table')) {
        updateTotalScores();
    }


    
// ▼▼▼ THIS IS THE NEW BLOCK TO ADD ▼▼▼
    // --- When an "Inning Event" is typed in ---
    else if (e.target.matches('.inning-events-input')) {
        const teamKey = e.target.dataset.teamKey;
        const inningIndex = parseInt(e.target.dataset.inningIndex, 10);
        if (inningIndex >= 0) {
            updateInningState(teamKey, inningIndex); // Instantly update the out count
        }
    }
    // ▲▲▲ END OF ADDITION ▲▲▲
});
// ==========================================================
//  プルダウン変更イベントの監視 (change)
// ==========================================================
document.body.addEventListener('change', (e) => {
    // --- 打席結果プルダウンが変更された場合 ---
    if (e.target.matches('.batting-result-part')) {
        const cell = e.target.closest('td.batting-result-cell');
        if (!cell) return;
        
        const inningIndex = Array.from(cell.parentElement.children).indexOf(cell) - 5;
        const teamKey = e.target.closest('table.batting-table').id.includes('team1') ? 'team1' : 'team2';
        
        if (inningIndex >= 0) {
            updateInningState(teamKey, inningIndex); // 即座にアウトカウントを更新
        }
    }
});

    modalBg.addEventListener('click', () => newsModal.classList.add('hidden'));
    modalClose.addEventListener('click', () => newsModal.classList.add('hidden'));
    document.getElementById('details-save').addEventListener('click', saveDetailedStats);
    document.getElementById('details-close').addEventListener('click', () => detailsModal.classList.add('hidden'));
    saveLoadCloseBtn.addEventListener('click', () => saveLoadModal.classList.add('hidden'));
    newspaperCloseBtn.addEventListener('click', () => newspaperModal.classList.add('hidden'));
document.getElementById('status-modal-close').addEventListener('click', () => {
    document.getElementById('team-status-modal').classList.add('hidden');
});

    saveTabBtn.addEventListener('click', () => {
        saveTabBtn.classList.add('border-blue-500'); saveTabBtn.classList.remove('text-gray-500');
        loadTabBtn.classList.remove('border-blue-500'); loadTabBtn.classList.add('text-gray-500');
        saveTabContent.classList.remove('hidden'); loadTabContent.classList.add('hidden');
    });
    loadTabBtn.addEventListener('click', () => {
        loadTabBtn.classList.add('border-blue-500'); loadTabBtn.classList.remove('text-gray-500');
        saveTabBtn.classList.remove('border-blue-500'); saveTabBtn.classList.add('text-gray-500');
        loadTabContent.classList.remove('hidden'); saveTabContent.classList.add('hidden');
    });
    generateSaveCodeBtn.addEventListener('click', () => {
        const jsonString = JSON.stringify(tournamentState);
        const compressed = pako.deflate(jsonString);
        const base64 = uint8ArrayToBase64(compressed);
        document.getElementById('save-code-output').textContent = base64;
        document.getElementById('save-code-area').classList.remove('hidden');
    });
    copySaveCodeBtn.addEventListener('click', () => {
        navigator.clipboard.writeText(document.getElementById('save-code-output').textContent);
        const feedback = document.getElementById('copy-feedback');
        feedback.textContent = 'コピーしました！';
        setTimeout(() => { feedback.textContent = '' }, 2000);
    });
    loadFromCodeBtn.addEventListener('click', () => {
        try {
            const code = document.getElementById('load-code-input').value;
            const binaryString = atob(code);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) { bytes[i] = binaryString.charCodeAt(i); }
            const decompressed = pako.inflate(bytes, { to: 'string' });
            const loadedState = JSON.parse(decompressed);
            tournamentState = loadedState;
            saveState();
            location.reload();
        } catch (e) {
            showAlert('データの読み込みに失敗しました。');
        }
    });




    // アプリケーション起動
    initializeApp();
</script>

<script>
    mermaid.initialize({ startOnLoad: true });
</script>

    </body>
</html>