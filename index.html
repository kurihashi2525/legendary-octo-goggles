<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>【最終実装版】AI記者付きトーナメント表</title>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&family=Noto+Serif+JP:wght@700&display=swap" rel="stylesheet">
 <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Yuji+Syuku&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
/* styleタグ内の分かりやすい場所に追加 */




.player-profile-card {
            background-color: #ffffff;
            border: 1px solid #e5e7eb; /* border-gray-200 */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 2px 4px rgba(0,0,0,0.03);
            display: flex;
            flex-direction: column;
            padding: 1rem;
            transition: all 0.2s ease-out;
        }
        .player-profile-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.08);
        }
        .player-profile-header {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.5rem;
            margin-bottom: 0.75rem;
        }
        .player-profile-number {
            font-size: 2.25rem; /* text-4xl */
            font-weight: 900;
            color: #1e3a8a; /* 283学園のテーマカラー */
            line-height: 1;
            margin-right: 0.75rem;
        }
        .player-profile-name {
            font-size: 1.125rem; /* text-xl */
            font-weight: 700;
            color: #1f2937; /* text-gray-800 */
            flex-grow: 1;
        }
        .player-profile-grade {
            font-size: 0.875rem; /* text-sm */
            font-weight: 700;
            color: #1e3a8a;
        }
        .player-profile-captain {
            font-size: 0.75rem;
            font-weight: 700;
            color: #b91c1c; /* text-red-700 */
            margin-left: 0.25rem;
        }
        .player-profile-body {
            font-size: 0.875rem; /* text-sm */
            color: #4b5563; /* text-gray-600 */
            line-height: 1.6;
        }
        .player-profile-body strong {
            color: #1f2937; /* text-gray-800 */
            font-weight: 600;
            margin-right: 0.25rem;
        }



       
        #campus-map-container {
            position: relative;
            width: 100%;
            max-width: 800px; 
            margin: 1.5rem auto; /* 上下にマージン、左右にauto */
            aspect-ratio: 16 / 9;
            background-color: #e5e7eb; /* bg-gray-200 */
            border-radius: 0.5rem; /* rounded-lg */
            overflow: hidden;
            border: 2px solid #e5e7eb;
        }
        #campus-map-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            filter: grayscale(30%) brightness(1.1);
        }

        /* 2. ホットスポット (+) ボタン */
        .hotspot {
            position: absolute;
            width: 32px;
            height: 32px;
            background-color: #1e3a8a; /* 283学園テーマカラー */
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: all 0.2s ease-out;
            /* 脈動アニメーション */
            animation: hotspotPulse 2s infinite ease-in-out;
        }
        .hotspot:hover {
            transform: scale(1.2);
            animation-play-state: paused; /* ホバー中は脈動を停止 */
        }
        @keyframes hotspotPulse {
            0% { transform: scale(1); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); }
            50% { transform: scale(1.1); box-shadow: 0 6px 25px rgba(30, 58, 138, 0.7); }
            100% { transform: scale(1); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); }
        }
        .hotspot > span {
            pointer-events: none; /* 中の+マークがクリックを邪魔しないように */
        }

        /* 3. ホットスポット・ポップアップ */
        .hotspot-popup {
            position: absolute;
            width: 280px;
            background-color: white;
            border: 1px solid #d1d5db; /* border-gray-300 */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 60; /* ヘッダー(z-50)より手前 */
            /* アニメーション用 */
            opacity: 0;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            pointer-events: none; /* 見えないときはクリックさせない */
            transform: translateY(0);
        }
        .hotspot-popup.visible {
            opacity: 1;
            transform: translateY(-10px); /* 少し浮き上がる */
            pointer-events: auto;
        }
        .hotspot-popup-image {
            width: 100%;
            height: 120px;
            object-fit: cover;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
        }
        .hotspot-popup-content {
            padding: 1rem;
        }
        .hotspot-popup-title {
            font-weight: 700;
            font-size: 1.125rem; /* text-lg */
            color: #1e3a8a; /* 283学園テーマカラー */
            margin-bottom: 0.5rem;
        }
        .hotspot-popup-text {
            font-size: 0.875rem; /* text-sm */
            color: #4b5563; /* text-gray-600 */
        }
        .hotspot-popup-close {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 28px;
            height: 28px;
            background-color: #4b5563; /* text-gray-600 */
            color: white;
            border-radius: 50%;
            border: 2px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        /* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ▼▼▼ 勢力図分析アニメーション用のCSS（レイアウト修正版）▼▼▼ */
#analysis-stage {
    background: radial-gradient(ellipse at center, rgba(15, 23, 42, 1) 0%, rgba(0, 0, 0, 1) 100%);
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    padding: 2rem; /* 内側に余白を追加 */
}
.round-column {
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    height: 100%;
}
.analysis-matchup {
    margin: 10px 0;
    position: relative;
}
.analysis-team {
    padding: 4px 10px;
    background-color: rgba(0, 183, 255, 0.2);
    border: 1px solid rgba(0, 183, 255, 0.7);
    color: #e0f2fe;
    border-radius: 4px;
    font-weight: bold;
    font-size: 0.9rem;
    margin: 4px 0;
    transition: all 0.5s ease-in-out;
    opacity: 0;
    width: 150px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    /* ▼▼▼ 以下の2行を削除、またはコメントアウト ▼▼▼ */
    /* position: absolute; */
    /* ▲▲▲ */
}
.analysis-team.show {
    opacity: 1;
}
.analysis-team.highlight {
    background-color: rgba(255, 204, 0, 0.4);
    border-color: rgba(255, 204, 0, 1);
    color: white;
    transform: scale(1.1);
    box-shadow: 0 0 15px rgba(255, 204, 0, 0.7);
}

.new-thread-modal {
    position: fixed;
    inset: 0;
    background-color: rgba(0, 0, 0, 0.75);
    display: flex; /* hidden/flexで表示切替 */
    align-items: center;
    justify-content: center;
    z-index: 250; /* まとめサイトより手前 */
}

/* 勝ち上がり線のスタイル */
.matchup-connector {
    position: absolute;
    top: 50%;
    right: -20px;
    width: 20px;
    height: 2px;
    background-color: rgba(0, 183, 255, 0.5);
}
.round-connector {
    position: absolute;
    top: 25%;
    right: -30px;
    width: 2px;
    height: 50%;
    background-color: rgba(0, 183, 255, 0.5);
}
/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ スカウティングレポート用CSS (新規追加) ▼▼▼ */
.scout-report-card {
    background-color: #f0fdf4; /* 薄い緑 */
    border-left: 5px solid #16a34a; /* 緑のライン */
    font-family: 'Noto Serif JP', serif; /* 明朝体で玄人感を出す */
}
.scout-report-title {
    color: #14532d;
    font-weight: bold;
    border-bottom: 1px dashed #16a34a;
    padding-bottom: 0.5rem;
    margin-bottom: 0.5rem;
}
.scout-report-body {
    font-size: 0.95rem;
    line-height: 1.8;
    color: #374151;
}
.scout-signature {
    text-align: right;
    font-weight: bold;
    margin-top: 1rem;
    color: #16a34a;
}
/* ▲▲▲ 追加ここまで ▲▲▲ */

/* まとめサイトのロゴスタイル */
.matome-site-logo-container {
    position: relative;
    width: 80px; /* ロゴの幅 */
    height: 50px; /* ロゴの高さ */
    overflow: hidden;
    border-radius: 5px; /* 角を少し丸める */
    box-shadow: 0 2px 4px rgba(0,0,0,0.3); /* 影で立体感を出す */
}

.matome-site-logo-bg {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 画像をコンテナに合わせて表示 */
    position: absolute;
    top: 0;
    left: 0;
    filter: brightness(0.7) blur(1px); /* 少し暗く、ぼかして文字を読みやすく */
}

.matome-site-logo-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-weight: bold;
    font-size: 0.9rem; /* 文字サイズ調整 */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8); /* 文字の視認性を高める影 */
    white-space: nowrap; /* テキストの折り返しを防ぐ */
}

/* 新しいまとめサイトモーダルのためのスタイル */
/* スクロールバーのカスタマイズ (TailwindCSS JIT mode with plugins is better, but this is a quick fix) */
.scrollbar-thin {
    scrollbar-width: thin;
    scrollbar-color: #a0aec0 #edf2f7; /* thumb color track color */
}

.scrollbar-thin::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.scrollbar-thin::-webkit-scrollbar-thumb {
    background-color: #a0aec0; /* gray-400 */
    border-radius: 10px;
    border: 2px solid #edf2f7; /* gray-200 */
}

.scrollbar-thin::-webkit-scrollbar-track {
    background-color: #edf2f7; /* gray-200 */
    border-radius: 10px;
}

/* ヘッダーのロゴ画像とタイトルを縦方向に中央揃え */
#integrated-matome-modal .flex.justify-between.items-center img {
    vertical-align: middle;
}

/* タブボタンのアニメーション */
.matome-tab-btn {
    position: relative;
    z-index: 1;
    margin-right: -1px; /* タブ間の隙間をなくす */
    border: 1px solid #e2e8f0; /* gray-300 */
    border-bottom: none;
    background-color: #f7fafc; /* gray-50 */
}
.matome-tab-btn.active {
    background-color: #2563eb; /* blue-600 */
    color: white;
    border-color: #2563eb; /* active tab border color */
    border-bottom-color: transparent;
    z-index: 2;
}

/* 記事リンクのホバーエフェクト */
.matome-article-link p.font-bold:hover {
    color: #2563eb; /* blue-600 */
    text-decoration: underline;
}

/* BBSコメントのスタイル */
.bbs-comment {
    background-color: #ffffff;
    border: 1px solid #e2e8f0;
    padding: 1rem;
    border-radius: 0.5rem;
    box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
}
.bbs-comment p.font-semibold {
    color: #4a5568; /* gray-700 */
    font-size: 0.875rem; /* text-sm */
    margin-bottom: 0.25rem;
}
.bbs-comment p.text-gray-800 {
    color: #2d3748; /* gray-800 */
    line-height: 1.5;
}

/* ▼▼▼ 新しいローダー用のCSS ▼▼▼ */
.loader {
    text-align: center;
    padding: 40px 20px;
    font-style: italic;
    color: #4b5563; /* gray-600 */
    font-size: 1.1rem;
    background-color: rgba(255, 255, 255, 0.8);
    border-radius: 8px;
    margin: 1rem 0;
}

.loader .ellipsis span {
    opacity: 0;
    animation: pulse-ellipsis 1.4s infinite;
}
.loader .ellipsis span:nth-child(1) { animation-delay: 0s; }
.loader .ellipsis span:nth-child(2) { animation-delay: 0.2s; }
.loader .ellipsis span:nth-child(3) { animation-delay: 0.4s; }

@keyframes pulse-ellipsis {
    0% { opacity: 0.2; }
    50% { opacity: 1; }
    100% { opacity: 0.2; }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ 禍々しい雰囲気用のCSS ▼▼▼ */
.dread-mode-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(127, 29, 29, 0.5); /* 不気味な赤色のオーバーレイ */
    z-index: 199; /* 抽選会モーダルのすぐ下 */
    pointer-events: none;
    animation: fadeIn 0.5s forwards;
}

#lottery-pot.dread {
    background-color: #7f1d1d; /* red-900 */
    border-color: #fca5a5; /* red-300 */
    animation: pulse-dread 1s infinite;
}

@keyframes pulse-dread {
    0%, 100% {
        transform: scale(1.05);
        box-shadow: 0 0 15px 5px rgba(255, 100, 100, 0.7);
    }
    50% {
        transform: scale(1.1);
        box-shadow: 0 0 30px 15px rgba(255, 100, 100, 0.9);
    }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* ▼▼▼ 抽選会イベント用のCSS ▼▼▼ */
#drawn-team-container.fade-in-out {
    animation: fadeInOut 2.5s ease-in-out forwards;
}

@keyframes fadeInOut {
    0% { opacity: 0; transform: scale(0.8); }
    20%, 80% { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(0.8); }
}

.lottery-slot {
    border: 1px solid #d1d5db;
    background-color: #f3f4f6;
    padding: 4px 8px;
    font-size: 14px;
    font-weight: 500;
    border-radius: 4px;
    transition: all 0.3s ease-in-out;
}
.lottery-slot.filled {
    background-color: #fffbeb; /* amber-100 */
    border-color: #f59e0b; /* amber-500 */
    font-weight: 700;
    transform: scale(1.05);
}
.lottery-slot.highlight {
    background-color: #ef4444; /* red-500 */
    color: white;
    border-color: #b91c1c; /* red-700 */
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}
.animate-fade-in-up {
    animation: fadeInUp 0.5s ease-out forwards;
}
@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* Weather Effects */
.rain {
    position: absolute;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2;
}
.drop {
    position: absolute;
    bottom: 100%;
    width: 1px;
    height: 50px;
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.4));
    animation: drop 0.5s linear infinite;
}
@keyframes drop {
    to { transform: translateY(100vh); }
}

.sunshine {
    position: absolute;
    top: -50px;
    left: -50px;
    width: 100px;
    height: 100px;
    z-index: 2;
}
.sun {
    position: absolute;
    width: 100px;
    height: 100px;
    background: radial-gradient(circle, rgba(255,255,220,0.8) 0%, rgba(255,255,220,0) 60%);
    border-radius: 50%;
}
.sun-flare {
    position: absolute;
    width: 200px;
    height: 200px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 50%;
    animation: flare 5s infinite;
}
@keyframes flare {
    0% { transform: scale(1); opacity: 0.1; }
    50% { transform: scale(1.2); opacity: 0.2; }
    100% { transform: scale(1); opacity: 0.1; }
}

/* Weather Control Buttons */
.weather-btn {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.5);
    background-color: rgba(255, 255, 255, 0.2);
    font-size: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
}
.weather-btn:hover {
    background-color: rgba(255, 255, 255, 0.4);
    border-color: white;
}

/* ▼▼▼ このブロックを追加 ▼▼▼ */
        .subtitle-text {
            color: white;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
        }
        .setup-header {
            color: white !important; /* Tailwind CSSより優先させる */
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            border-bottom-color: rgba(255, 255, 255, 0.5) !important; /* 下線も白っぽくする */
        }
        /* ▲▲▲ ▲▲▲ */
/* チーム通算成績モーダル（タブ切り替え）のスタイル */
.team-stats-tab-btn {
    border-color: transparent;
    color: #6b7280; /* text-gray-500 */
    padding: 0.5rem 1rem;
    font-weight: 600;
    border-bottom-width: 2px;
}
.team-stats-tab-btn:hover {
    color: #1f2937; /* text-gray-800 */
}
.team-stats-tab-btn.active {
    color: #2563eb; /* text-blue-600 */
    border-color: #2563eb; /* border-blue-600 */
}
.team-stats-tab-content.hidden {
    display: none;
}
/* スタメン履歴用のスタイル */
.lineup-history-tournament {
    margin-bottom: 1.5rem;
}
.lineup-history-title {
    font-size: 1.25rem; /* text-xl */
    font-weight: 700;
    color: #1f2937; /* text-gray-800 */
    border-bottom: 2px solid #e5e7eb; /* border-gray-200 */
    padding-bottom: 0.5rem;
    margin-bottom: 1rem;
}
.lineup-history-match {
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px dashed #d1d5db; /* border-gray-300 */
}
.lineup-history-match:last-child {
    border-bottom: none;
    margin-bottom: 0;
}
.lineup-history-match-header {
    font-size: 1rem;
    font-weight: 600;
    color: #1e3a8a; /* text-blue-800 */
    margin-bottom: 0.5rem;
}
/* スコアブック風フォントを適用 */
.lineup-history-list {
    display: grid;
    /* 画面幅に応じて列数を自動調整 */
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 0.5rem 1rem;
    font-family: 'Yuji Syuku', serif; 
    font-size: 1rem; /* 少しフォントを大きく */
}
/* ▼▼▼ スポーツ報知風 Web記事デザイン ▼▼▼ */
        .newspaper-container { 
            font-family: 'Noto Sans JP', sans-serif; 
            padding: 1.5rem; 
            background-color: #ffffff; 
            border: 1px solid #ddd;
        }
        .newspaper-early { /* 昔の試合は白黒に */
            filter: grayscale(80%);
        }
        .newspaper-late { /* 最近の試合はカラー */
            border-top: 4px solid #a10e25;
        }
        .newspaper-header { 
            text-align: left; 
            border-bottom: 1px solid #eee; 
            padding-bottom: 0.75rem; 
            margin-bottom: 1rem; 
        }
        .newspaper-title { /* スポーツ報知 */
            font-size: 1.5rem; 
            font-weight: 700;
            color: #d00;
            font-family: 'sans-serif'; /* ロゴ風 */
        }
        .newspaper-date { 
            font-size: 0.8rem;
            color: #666;
            margin-top: 4px;
        }
        
        /* 縦書き・flexレイアウトを廃止 */
        .newspaper-content { 
            /* display: flex; を削除 */
        }
        
        /* メイン見出し (縦書き -> 横書き) */
        .newspaper-main-headline { 
            /* writing-mode を削除 */
            font-size: 2.25rem; /* 36px */
            font-weight: 900; 
            color: #222;
            line-height: 1.3;
            letter-spacing: 0.05em;
            /* border-right を削除 */
            padding-bottom: 1rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #333;
        }
        .newspaper-late .newspaper-main-headline { 
            color: #a10e25;
            border-bottom-color: #a10e25;
        }

        /* サブ見出し (記事タイトル -> リード文) */
        .newspaper-sub-headline { 
            font-size: 1.1rem; /* 18px */
            font-weight: 700; 
            color: #333;
            margin-bottom: 1.5rem; 
            border: none;
            padding-bottom: 0;
            line-height: 1.7;
            background-color: #f9f9f9;
            padding: 1rem;
            border-radius: 4px;
            border-left: 4px solid #a10e25;
        }
        
        /* 写真 (本文の前に移動) */
        .newspaper-image-placeholder { 
            width: 100%; 
            max-width: 600px;
            margin: 0 auto 0.5rem auto; /* キャプションとのマージンを調整 */
            height: auto;
            aspect-ratio: 16 / 10;
            background-color: #e0e0e0; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-family: 'Noto Sans JP', sans-serif; 
            color: #888; 
            border: 1px dashed #aaa; 
            border-radius: 4px;
        }
        /* 写真キャプション (sinbun.txtのfigcaption参考) */
        .newspaper-image-caption {
            font-size: 0.85rem;
            color: #555;
            text-align: center;
            margin-bottom: 1.5rem;
        }

        /* 本文 (多段組を廃止) */
        .newspaper-text { 
            font-family: 'Noto Sans JP', sans-serif; 
            /* column-count を削除 */
            text-align: left; /* justify をやめる */
            font-size: 1rem; /* 16px */
            line-height: 1.9; /* 行間を広くとる */
            color: #333;
        }

        /* スコアボックス (デザイン変更) */
        .newspaper-score-box { 
            border: 1px solid #ccc; 
            padding: 1rem; 
            text-align: center; 
            margin-top: 2rem; 
            background-color: #f9f9f9;
            border-radius: 4px;
        }
        .newspaper-score-box h3 { 
            font-weight: 700; 
            margin-bottom: 0.75rem; 
            font-size: 1rem; 
            color: #333;
        }
        .newspaper-score-box .score { 
            font-size: 1.75rem; 
            font-weight: 700;
            color: #000;
        }
        .newspaper-late .newspaper-score-box { 
            background-color: #fff8f8; 
            border-color: #a10e25; 
        }
        /* ▲▲▲ スポーツ報知風 Web記事デザイン ここまで ▲▲▲ */
.lineup-history-list li {
    padding-left: 0.5rem;
    white-space: nowrap;
}
/* ▼▼▼ このブロックを追加 ▼▼▼ */
     .main-title {
            font-family: 'Yuji Syuku', serif;
            font-size: 3rem; /* 少し大きくして迫力を出す */
            letter-spacing: 0.2em; /* 文字間を調整 */
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.7);
            animation: fadeIn 2s ease-in-out; /* フェードインアニメーション */
        }

        .subtitle-text {
            color: white;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            animation: fadeIn 2.2s ease-in-out; /* アニメーションを追加 */
        }

        /* メインコンテンツエリアをガラスパネル風に */
        .setup-card {
            background-color: rgba(10, 10, 20, 0.65) !important; /* 半透明背景を優先 */
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(8px); /* 背景をぼかす（対応ブラウザのみ） */
            padding: 2.5rem !important; /* paddingを調整 */
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            animation: fadeIn 1.5s ease-in-out;
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .setup-header {
            color: white !important;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.7);
            border-bottom-color: rgba(255, 255, 255, 0.5) !important;
        }

        /* チーム一覧エリアを名簿風に */
        #teams-list {
            background-color: rgba(0, 0, 0, 0.2) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            color: #f0f0f0 !important;
            font-size: 0.9rem;
            line-height: 1.6;
            padding: 1.5rem !important;
        }

        /* ボタンエリアにアニメーションを追加 */
        #setup .mt-8 {
            animation: fadeIn 2.5s ease-in-out;
        }

        /* フェードイン用アニメーションの定義 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

/* 5. 打点(RBI)ボタン */
        .rbi-btn {
            border: 2px solid #16a34a; /* border-green-600 */
            background-color: #f0fdf4; /* bg-green-50 */
            color: #15803d; /* text-green-700 */
            padding: 0.75rem 0.5rem;
            font-size: 1rem; /* text-base */
            font-weight: 700;
            border-radius: 0.375rem; /* rounded-md */
            transition: all 0.1s ease-in;
            text-align: center;
        }
        .rbi-btn:hover {
            background-color: #16a34a; /* hover:bg-green-600 */
            color: white;
            transform: scale(1.05);
        }
        /* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ▲▲▲ ここまで ▲▲▲ */
/* ▼▼▼ このブロックを <style> タグ内に「新規追加」 ▼▼▼ */
/* 個人通算成績モーダル用のスタイル */
.player-stats-header {
    text-align: center;
    border-bottom: 2px solid #1e3a8a;
    margin-bottom: 1rem;
}
.player-stats-name {
    font-size: 1.75rem; /* text-2xl */
    font-weight: 700;
    color: #1f2937; /* text-gray-800 */
}
.player-stats-team {
    font-size: 1rem;
    font-weight: 500;
    color: #4b5563; /* text-gray-600 */
    margin-bottom: 0.5rem;
}
.stats-section-title {
    font-size: 1.25rem; /* text-xl */
    font-weight: 700;
    color: #1e3a8a; /* text-blue-800 */
    margin-bottom: 0.75rem;
    border-bottom: 1px solid #dbeafe; /* border-blue-200 */
    padding-bottom: 0.25rem;
}
.stats-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 4列グリッド */
    gap: 0.75rem;
    background-color: #f9fafb; /* bg-gray-50 */
    padding: 0.75rem;
    border-radius: 0.375rem;
}
.stats-grid-item {
    text-align: center;
    background-color: #ffffff;
    padding: 0.5rem;
    border-radius: 0.25rem;
    border: 1px solid #e5e7eb;
}
.stats-grid-item .stats-label {
    font-size: 0.75rem; /* text-xs */
    font-weight: 600;
    color: #6b7280; /* text-gray-500 */
    text-transform: uppercase;
}
.stats-grid-item .stats-value {
    font-size: 1.5rem; /* text-2xl */
    font-weight: 700;
    color: #1f2937;
    line-height: 1.2;
}
.stats-grid-item.highlight .stats-value {
    color: #1e3a8a; /* text-blue-800 */
}
/* ▲▲▲ 新規追加ここまで ▲▲▲ */
/* ▼▼▼ このブロックを追加 ▼▼▼ */
#news-ticker-container {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    display: flex;
    align-items: center;
    z-index: 50; /* 他の要素より手前に */
    height: 30px;
    font-family: 'Noto Sans JP', sans-serif;
    border-top: 1px solid rgba(255, 255, 255, 0.3);
}
.ticker-label {
    background-color: #e53935; /* 赤色 */
    font-weight: bold;
    padding: 0 12px;
    height: 100%;
    display: flex;
    align-items: center;
    font-size: 0.9rem;
}
.ticker-content {
    flex-grow: 1;
    overflow: hidden; /* はみ出したテキストを隠す */
    padding-left: 1rem;
}
#ticker-text {
    white-space: nowrap; /* テキストを改行させない */
    /* アニメーション時間を少し長めに設定してゆっくり流す */
    animation: scroll-ticker 40s linear infinite;
}
@keyframes scroll-ticker {
    0% { transform: translateX(100%); }
    100% { transform: translateX(-100%); }
}
/* ▲▲▲ ここまで ▲▲▲ */

/* 写実的な天候アニメーション用のスタイル */
   /* 写実的な天候アニメーション用のスタイル（★調査モード★） */
/* 背景画像 */
.ballpark-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* Layer 1 (Bottom) */
    /* ▼▼▼ This line is the only change ▼▼▼ */
    background-image: url('ballpark.jpg'); /* Use the local image */
    /* ▲▲▲ END OF CHANGE ▲▲▲ */
    background-size: cover;
    background-position: center;
    filter: blur(2px) brightness(0.7);
    animation: subtle-breathing 20s ease-in-out infinite;
}
/* 土埃のアニメーション用コンテナ */
#dust-container {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; /* クリックの邪魔をしない */
    z-index: 2; /* 階層2（中間） */
}
/* メインコンテンツのコンテナ */
#app-container {
    position: relative; /* z-indexを有効にするため */
    z-index: 3; /* 階層3（一番手前） */
}
@keyframes subtle-breathing {
    0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); }
}
.dust-particle {
    position: absolute; background-color: rgba(255, 255, 255, 0.5);
    border-radius: 50%; opacity: 0; animation: drift-up linear infinite;
}
@keyframes drift-up {
    0% { transform: translateY(100vh) translateX(var(--x-start)); opacity: 0; }
    10% { opacity: 1; } 90% { opacity: 1; }
    100% { transform: translateY(-100px) translateX(var(--x-end)); opacity: 0; }
}
/* Input field color-coding */
.result-hit { background-color: #eff6ff !important; color: #1d4ed8; } /* Blue for hits */
.result-out { background-color: #fee2e2 !important; color: #b91c1c; } /* Red for outs */
.result-on-base { background-color: #f0fdf4 !important; color: #15803d; } /* Green for walks, etc. */

.clickable-team-name {
    cursor: pointer;
    transition: color 0.2s;
}
.clickable-team-name:hover {
    color: #1d4ed8; /* blue-700 */
}
        body { 
    font-family: 'Inter', 'Noto Sans JP', sans-serif; 
}
.setup-card { 
    background-color: transparent; /* 背景を透明に */
    padding: 24px; 
    border-radius: 12px; 
    box-shadow: none; /* 影を削除 */
    margin-bottom: 24px;
}
.display-card {
    background-color: #fff; padding: 24px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); margin-bottom: 24px;
}
        #main-bracket-container { display: flex; justify-content: flex-start;
 padding: 20px; font-size: 12px; overflow-x: auto; border: 1px solid #e5e7eb; background-color: #f9fafb; border-radius: 8px;}
        .bracket-half { display: flex; }
        .bracket-half.right { flex-direction: row-reverse; }
        .bracket-final { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 0 10px; flex-shrink: 0; min-width: 60px; }
        .bracket-final .final-matchup { border: 2px solid #f59e0b; background-color: #fffbeb; border-radius: 6px; padding: 5px; margin-top: 10px; }
        .bracket-final .winner-box { font-weight: bold; color: #b45309; text-align: center; padding: 10px 20px; white-space: nowrap; font-size: 1.25rem; }
        .bracket-final .final-title { font-weight: 600; color: #4b5563; margin-bottom: 10px; writing-mode: vertical-rl; letter-spacing: 2px; }
        .round { display: flex; flex-direction: column; justify-content: space-around; flex-shrink: 0; width: 280px; padding: 0 10px; }
        .matchup { margin: 8px 0; position: relative; display: flex; flex-direction: column; justify-content: center; flex-grow: 1; }
        .team-slot { display: flex; align-items: center; background-color: #ffffff; border: 1px solid #e5e7eb; border-radius: 4px; margin-bottom: 4px; transition: background-color 0.3s; position: relative; }
        .team-slot:last-of-type { margin-bottom: 0; }
        .team-name { flex-grow: 1; padding: 6px 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .team-name .rank { font-weight: bold; margin-right: 4px; }
        .team-name .rank-A { color: #ef4444; }
        .team-name .rank-B { color: #f97316; }
        .team-name .rank-C { color: #eab308; }
        .team-name .rank-D { color: #3b82f6; }
        .team-name .rank-E { color: #6b7280; }
        .team-name.seed { font-weight: bold; color: #ca8a04; }
        .score-input { width: 40px; padding: 6px 4px; border-left: 1px solid #e5e7eb; text-align: center; background-color: #fff; }
        .win-btn { background-color: #d1d5db; color: #fff; border: none; padding: 6px 8px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; cursor: pointer; font-weight: bold; transition: background-color 0.2s; }
        .team-slot:not(.empty) .win-btn { background-color: #3b82f6; }
        .team-slot:not(.empty):hover .win-btn { background-color: #2563eb; }
        .team-slot.winner { background-color: #dbeafe; border-color: #93c5fd; font-weight: 600; }
        .team-slot.loser { background-color: #f3f4f6; opacity: 0.6; }
        .team-slot.empty .team-name { color: #9ca3af; }
        .team-slot.empty .score-input, .team-slot.empty .win-btn, .team-slot.empty .details-btn { display: none; }
        .matchup::after { content: ''; position: absolute; top: 50%; width: 10px; height: 2px; background-color: #cbd5e1; }
        .bracket-half.left .matchup::after { right: -10px; }
        .bracket-half.right .matchup::after { left: -10px; }
        .round.subsequent-round .matchup::before { content: ''; position: absolute; top: -8px; height: calc(100% + 16px); width: 2px; background-color: #cbd5e1; }
        .bracket-half.left .round.subsequent-round .matchup::before { right: -10px; }
        .bracket-half.right .round.subsequent-round .matchup::before { left: -10px; }
        .hidden { display: none; }
        .news-article { border-left: 4px solid #3b82f6; cursor: pointer; transition: background-color 0.2s; }
        #modal-bg { background-color: rgba(0,0,0,0.5); }
        .confirm-modal, .details-modal, .save-load-modal, .newspaper-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .confirm-modal-content, .details-modal-content, .save-load-modal-content, .newspaper-modal-content { background-color: white; padding: 24px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .details-modal-content { width: 95%; max-width: 1000px; max-height: 90vh; overflow-y: auto;}
        .save-load-modal-content { width: 95%; max-width: 500px; }
        .newspaper-modal-content { width: 95%; max-width: 800px; max-height: 95vh; overflow-y: auto; }
        .confirm-modal-content { text-align: center; }
        .loader { text-align: center; padding: 20px; font-style: italic; color: #6b7280; }
        .details-btn { background-color: #6b7280; color: white; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: auto; margin-right: 2px; }
        .details-btn:hover { background-color: #4b5563; }
        .matchup-footer { text-align: center; margin-top: 2px; display: flex; justify-content: center; align-items: center; gap: 4px;}
        .stats-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .stats-table th, .stats-table td { border: 1px solid #e5e7eb; padding: 4px 6px; text-align: center; }
        .stats-table th { background-color: #f3f4f6; }
        .stats-table input { width: 100%; border: none; text-align: center; background: transparent;}
        .stats-table input:focus { outline: 1px solid #3b82f6; }
        .modal-body-scroll { max-height: 70vh; overflow-y: auto; }
        #save-code-output { word-break: break-all; background-color: #f3f4f6; padding: 8px; border-radius: 4px; max-height: 200px; overflow-y: auto; user-select: all; }
        .bbs-comment { background-color: #ffffff; border: 1px solid #e5e7eb; padding: 8px 12px; border-radius: 8px; font-size: 14px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        .match-summary-input { resize: none; height: 40px; }
        .article-error { background-color: #fee2e2; border-left: 4px solid #ef4444; color: #b91c1c; padding: 1rem; border-radius: 0.5rem; display: flex; justify-content: space-between; align-items: center; }
        .retry-btn { background-color: #ef4444; color: white; padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-weight: 600; cursor: pointer; }
        .retry-btn:hover { background-color: #dc2626; }
        .namco-news-item { cursor: pointer; transition: background-color 0.2s; }
        .namco-news-tag { background-color: #f97316; color: white; font-size: 0.75rem; padding: 2px 8px; border-radius: 9999px; margin-left: 8px; }
      
.region-map-scroll-container {
    display: flex;
    overflow-x: auto;
    padding-bottom: 16px; /* Space for the scrollbar */
    gap: 16px;
}
.region-column { 
    flex: 0 0 250px; /* Prevent cards from shrinking */
    background-color: #ffffff; 
    border: 1px solid #e5e7eb; 
    border-radius: 8px; 
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
}
.region-header { 
    padding: 12px 16px; 
    background-color: #f9fafb; 
    border-bottom: 1px solid #e5e7eb; 
}
.region-title { 
    font-weight: 700; 
    font-size: 1.1rem; 
    color: #1f2937; 
}
.region-stats { 
    font-size: 0.8rem; 
    color: #4b5563; 
    font-weight: 500;
}
.region-team-list { 
    list-style: none; 
    padding: 12px 16px; 
    margin: 0;
    flex-grow: 1; /* Allow list to fill space */
}
.region-team { 
    padding: 6px 0; 
    font-size: 0.9rem;
    border-bottom: 1px solid #f3f4f6;
}
.region-team:last-child {
    border-bottom: none;
}
.team-surviving { 
    font-weight: 500; 
    color: #1f2937; 
}
.team-eliminated { 
    color: #9ca3af; 
    text-decoration: line-through; 
}
         .scorebook-font {
            font-family: 'Yuji Syuku', serif;
        }
        

        .rivalry-match .team-slot { border: 2px solid #ef4444 !important; background-color: #fff1f2; }
        .feud-match .team-slot { border: 2px solid #8b5cf6 !important; background-color: #f5f3ff; }
        .rivalry-match .team-slot.winner { background-color: #fecaca; }
        .feud-match .team-slot.winner { background-color: #ddd6fe; }
    
/* 詳細入力テーブル用のスタイル */
/* 詳細入力テーブル用のスタイル（最終版） */
/* ▼▼▼ このブロックを <style> タグ内に「新規追加」 ▼▼▼ */
/* チーム通算成績モーダル用のスタイル */
.career-stats-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
    table-layout: auto;
}
.career-stats-table th, .career-stats-table td {
    border: 1px solid #e5e7eb;
    padding: 6px 4px;
    text-align: center;
    white-space: nowrap;
}
.career-stats-table thead tr {
    background-color: #f3f4f6; /* bg-gray-100 */
}
.career-stats-table .player-name {
    text-align: left;
    padding-left: 8px;
    font-weight: 600;
    min-width: 100px;
}
.career-stats-table .stat-highlight {
    font-weight: 700;
    background-color: #fef9c3; /* bg-yellow-100 */
}
.career-stats-table tbody tr:hover {
    background-color: #f9fafb; /* bg-gray-50 */
}

/* ▼▼▼ スカウトレポート用CSS ▼▼▼ */
.scout-card {
    background-color: white;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-bottom: 1rem;
    padding: 1rem;
    border-left: 5px solid #ccc;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.scout-card.rank-S { border-left-color: #fbbf24; background-color: #fffbeb; } /* Gold */
.scout-card.rank-A { border-left-color: #f87171; background-color: #fef2f2; } /* Red */
.scout-card.rank-B { border-left-color: #60a5fa; background-color: #eff6ff; } /* Blue */

.scout-rank-badge {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    font-weight: 900;
    color: white;
    margin-right: 1rem;
    flex-shrink: 0;
}
.rank-bg-S { background: linear-gradient(135deg, #fbbf24, #d97706); box-shadow: 0 0 10px rgba(251, 191, 36, 0.5); }
.rank-bg-A { background-color: #ef4444; }
.rank-bg-B { background-color: #3b82f6; }
.rank-bg-C { background-color: #10b981; }

.scout-comment-box {
    background-color: #f3f4f6;
    padding: 0.5rem;
    border-radius: 4px;
    font-size: 0.85rem;
    color: #4b5563;
    font-style: italic;
    margin-top: 0.5rem;
    border-left: 2px solid #6b7280;
}

/* 1. ヒーローセクションのアニメーション */
        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in-down {
            animation: fadeInDown 1.0s ease-out forwards;
        }
        .animate-fade-in-up {
            opacity: 0; /* 最初は非表示 */
            animation: fadeInUp 1.0s ease-out 0.5s forwards; /* 0.5秒遅れて開始 */
        }
        /* .is-visible はJSでアニメーション開始時に付与されます */
        .animate-fade-in-up.is-visible {
            opacity: 1;
        }

        /* 2. スクロール連動フェードイン用 */
        .fade-in-section {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
        }
        .fade-in-section.is-visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* 3. 選手カードのホバーエフェクト強化 */
        .player-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 15px 30px -5px rgba(0, 0, 0, 0.2), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
        }
        /* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ▼▼▼ このブロックを <style> タグ内に「新規追加」 ▼▼▼ */
/* チーム通算成績モーダル（ソート機能付き）のスタイル */
.career-stats-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
    table-layout: auto;
}
.career-stats-table th, .career-stats-table td {
    border: 1px solid #e5e7eb;
    padding: 6px 4px;
    text-align: center;
    white-space: nowrap;
}
.career-stats-table thead tr {
    background-color: #f3f4f6; /* bg-gray-100 */
}
/* ★ ソート可能なヘッダーのスタイル ★ */
.career-stats-table th.sortable-header {
    cursor: pointer;
    position: relative;
    padding-right: 20px; /* 矢印用のスペース */
}
.career-stats-table th.sortable-header:hover {
    background-color: #e5e7eb; /* bg-gray-200 */
}
.career-stats-table .sort-arrow {
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 14px;
    color: #9ca3af; /* text-gray-400 */
}

/* 4. 打球方向ホットスポット */
.direction-hotspot {
    position: absolute;
    width: 15%;
    height: 15%;
    background-color: rgba(255, 255, 255, 0.8);
    border: 2px dashed #9ca3af; /* border-gray-400 */
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
    font-weight: 700;
    color: #374151; /* text-gray-700 */
    cursor: pointer;
    transform: rotate(-45deg); /* グラウンドの回転を戻す */
    transition: all 0.2s ease-out;
    opacity: 0; /* 普段は非表示 */
    pointer-events: none; /* 普段はクリックさせない */
}
.direction-hotspot:hover {
    background-color: #fef9c3; /* bg-yellow-100 */
    border-color: #f59e0b; /* border-yellow-500 */
    transform: rotate(-45deg) scale(1.1);
}
/* .direction-mode クラスが付与されたら表示 */
.baseball-diamond.direction-mode .direction-hotspot {
    opacity: 1;
    pointer-events: auto;
}

/* 各守備位置の配置 (45度回転した基準で) */
#pos-p { top: 42.5%; left: 42.5%; } /* 投手 */
#pos-c { top: 75%; left: 42.5%; } /* 捕手 */
#pos-1b { top: 42.5%; left: 75%; } /* 一塁 */
#pos-2b { top: 25%; left: 60%; } /* 二塁 */
#pos-3b { top: 42.5%; left: 10%; } /* 三塁 */
#pos-ss { top: 25%; left: 25%; } /* 遊撃 */
#pos-lf { top: 15%; left: 0%; } /* 左翼 */
#pos-cf { top: 0%; left: 42.5%; } /* 中堅 */
#pos-rf { top: 15%; left: 85%; } /* 右翼 */
/* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ★ 昇順・降順の矢印 ★ */
.career-stats-table th.sort-asc .sort-arrow::after {
    content: ' ▲';
    color: #1e3a8a; /* text-blue-800 */
}
.career-stats-table th.sort-desc .sort-arrow::after {
    content: ' ▼';
    color: #1e3a8a; /* text-blue-800 */
}
.career-stats-table .player-name {
    text-align: left;
    padding-left: 8px;
    font-weight: 600;
    min-width: 100px;
}
.career-stats-table .stat-highlight {
    font-weight: 700;
    background-color: #fef9c3; /* bg-yellow-100 */
}
.career-stats-table tbody tr:hover {
    background-color: #f9fafb; /* bg-gray-50 */
}
/* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ヒーローセクションの背景 */
        .hero-bg {
            background: linear-gradient(rgba(17, 24, 39, 0.7), rgba(17, 24, 39, 0.7)), url('https://images.unsplash.com/photo-1519069632080-756b57d9b542?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wzNjAzNTV8MHwxfGFsbHx8fHx8fHx8fDE3MTUyNDU0Njd8&ixlib=rb-4.0.3&q=80&w=1080');
            background-size: cover;
            background-position: center 70%;
            background-attachment: fixed; /* 背景を固定し、パララックス（視差）効果を出す */
        }
        /* スローガン用の特大フォント */
        .slogan {
            font-size: clamp(4rem, 15vw, 10rem); /* 画面幅に応じてサイズ変更 */
            font-weight: 900;
            line-height: 1;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        /* セクションタイトルの下線 */
        .section-title {
            position: relative;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
        }
        .section-title::after {
            content: '';
            position: absolute;
            bottom: -1px; /* ボーダーライン上に配置 */
            left: 0;
            width: 60px;
            height: 4px;
            background-color: #1e3a8a; /* 濃い青 (283学園のテーマカラー) */
        }
        /* 選手カードのホバーエフェクト */
        .player-card {
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }
        .player-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        /* ページ内リンクが飛んだ際のヘッダーのズレを調整 */
        section[id] {
            scroll-margin-top: 80px; /* ヘッダーの高さ分（約） */
        }
        /* ヘッダーナビゲーションのホバーエフェクト */
        .nav-link {
            position: relative;
            transition: color 0.2s;
        }
        .nav-link::after {
            content: '';
            position: absolute;
            width: 0;
            height: 2px;
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #1e3a8a;
            transition: width 0.3s ease-out;
        }
        .nav-link:hover::after,
        .nav-link:focus::after {
            width: 100%;
        }
        /* ギャラリー画像のホバーエフェクト */
        .gallery-image {
            transition: transform 0.3s ease-in-out, filter 0.3s ease-in-out;
        }
        .gallery-image:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
        }

/* ▼▼▼ オートコンプリート用CSS ▼▼▼ */
.suggestion-item {
    padding: 0.75rem 1rem;
    border-bottom: 1px solid #f3f4f6;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background-color 0.1s;
}
.suggestion-item:hover {
    background-color: #eff6ff; /* ホバー時に薄い青色に */
}
.suggestion-item:last-child {
    border-bottom: none;
}
.suggestion-match {
    color: #2563eb;
    font-weight: bold;
}
.suggestion-meta {
    font-size: 0.75rem;
    color: #6b7280;
}

/* ▼▼▼ セイバーメトリクス・ダッシュボード用CSS ▼▼▼ */
.saber-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-top: 15px;
    background-color: #f8fafc;
    padding: 10px;
    border-radius: 8px;
    border: 1px solid #e2e8f0;
}
.saber-card {
    background-color: white;
    padding: 10px;
    border-radius: 6px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    text-align: center;
}
.saber-title {
    font-size: 0.7rem;
    color: #64748b;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}
.saber-value {
    font-size: 1.4rem;
    font-weight: 800;
    color: #1e293b;
    line-height: 1.2;
}
.saber-desc {
    font-size: 0.65rem;
    color: #94a3b8;
    margin-top: 2px;
}
/* 評価色 */
.val-excellent { color: #ef4444; } /* 赤 (最高) */
.val-good { color: #f59e0b; }      /* オレンジ (良い) */
.val-average { color: #3b82f6; }   /* 青 (普通) */
.val-poor { color: #64748b; }      /* グレー (悪い) */
/* ▲▲▲ 追加ここまで ▲▲▲ */

/* ▼▼▼ 283学園ホームページ用CSS (スマホ対応版) ▼▼▼ */
/* ベース背景 */
#homepage-scroll-container {
    background-color: #f9fafb;
    -webkit-overflow-scrolling: touch; /* iOSでのスクロールを滑らかに */
}

/* ヒーローセクション（トップ画像） */
.hero-section {
    position: relative;
    width: 100%;
    height: 200px; /* スマホ: 高さを抑える */
    background-image: linear-gradient(rgba(17, 24, 39, 0.6), rgba(17, 24, 39, 0.4)), url('https://images.unsplash.com/photo-1519069632080-756b57d9b542?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&q=80&w=1080');
    background-size: cover;
    background-position: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    margin-bottom: 1.5rem;
}

/* PCサイズ以上での調整 */
@media (min-width: 768px) {
    .hero-section {
        height: 350px; /* PC: 高さを戻す */
        margin-bottom: 2rem;
    }
}

/* ナビゲーションバー */
.homepage-nav {
    background-color: rgba(255, 255, 255, 0.98);
    border-bottom: 1px solid #e5e7eb;
    position: sticky;
    top: 0;
    z-index: 50;
}

/* フッター */
.homepage-footer {
    background-color: #f3f4f6;
    color: #6b7280;
    padding: 2rem 1rem; /* 左右に余白を持たせる */
    margin-top: 2rem;
    border-top: 1px solid #e5e7eb;
    font-size: 0.75rem; /* 文字を少し小さく */
}

/* 横スクロールが必要なテーブル用ラッパー */
.table-scroll-wrapper {
    width: 100%;
    overflow-x: auto; /* はみ出たらスクロール */
    -webkit-overflow-scrolling: touch;
    margin-bottom: 1rem;
    border: 1px solid #e5e7eb;
    border-radius: 0.5rem;
}

/* 部員カードの調整 */
.player-profile-card {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 0.5rem;
    padding: 1rem;
    /* スマホで潰れないように */
    min-width: 0; 
    word-break: break-word;
}
/* ▲▲▲ 追加ここまで ▲▲▲ */

/* ▼▼▼ キャプテンボタン用CSS (新規追加) ▼▼▼ */
.captain-btn {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 1px solid #cbd5e1; /* gray-300 */
    color: #9ca3af; /* gray-400 */
    font-size: 12px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #f8fafc;
    transition: all 0.2s;
    margin-left: 4px;
    margin-right: 4px;
}
.captain-btn:hover {
    background-color: #e2e8f0;
}
.captain-btn.active {
    background-color: #f59e0b; /* amber-500 (ゴールドっぽい色) */
    color: white;
    border-color: #d97706; /* amber-600 */
    box-shadow: 0 0 5px rgba(245, 158, 11, 0.5);
}
/* ▲▲▲ 追加ここまで ▲▲▲ */

/* ▼▼▼ ラウンドスキップ新聞モーダル用のCSS (ここから修正) ▼▼▼ */
.newspaper-modal-backdrop {
    position: fixed;
    inset: 0;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 200;
    padding: 1rem;
    overflow-y: auto; /* モーダルが画面より大きい場合スクロール可能に */
}

.skip-newspaper-container {
    background-color: #fdfaf4; /* 少し黄ばんだ紙の色 */
    background-image:
        linear-gradient(to right,
            rgba(0, 0, 0, 0) 49.8%,
            rgba(0, 0, 0, 0.08) 50%, /* 折り目の影を少し控えめに */
            rgba(0, 0, 0, 0) 50.2%
        ),
        radial-gradient(ellipse at center, #fdfaf4 70%, #f0e8d8 100%);
    border: 1px solid #333;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    width: 100%;
    max-width: 1000px; /* 少し横幅を広げ、より多くの情報を表示 */
    min-height: 80vh; /* 最低限の高さを確保 */
    max-height: 98vh; /* 画面の高さに合わせる */
    font-family: 'Noto Serif JP', 'Yuji Syuku', serif;
    color: #222; /* 文字色を少し濃く */
    display: flex;
    flex-direction: column;
    overflow: hidden; /* 内部スクロールはbodyで行う */
    position: relative; /* 子要素の配置のため */
}

.skip-newspaper-header {
    text-align: center;
    padding: 0.5rem 1rem;
    border-bottom: 2px solid #222; /* 線を少し濃く */
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    font-size: 0.8rem;
    color: #555;
}

.skip-newspaper-logo {
    font-family: 'Yuji Syuku', serif;
    font-size: 1.5rem; /* ロゴを追加 */
    font-weight: 700;
    color: #a00; /* 赤色で強調 */
    white-space: nowrap;
}

.skip-newspaper-title {
    font-size: 2.2rem; /* トップ見出しを少し小さく */
    font-weight: 700;
    letter-spacing: 0.1em;
    font-family: 'Yuji Syuku', serif;
    flex-grow: 1;
    text-align: center;
    line-height: 1; /* 行間を詰める */
}

.skip-newspaper-date {
    font-size: 0.75rem;
    color: #555;
    white-space: nowrap;
    text-align: right;
}

.skip-newspaper-body {
    padding: 0.75rem 1rem; /* パディングを調整 */
    flex-grow: 1;
    overflow-y: auto; /* ここでスクロールさせる */
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 4カラムレイアウト */
    gap: 1rem; /* カラム間のギャップ */
    align-items: start; /* 上揃え */
}

/* メイン記事エリア */
.skip-newspaper-main-article {
    grid-column: 2 / span 2; /* 中央2カラムを占有 */
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.skip-newspaper-main-headline {
    writing-mode: vertical-rl; /* 縦書き */
    text-orientation: upright;
    font-family: 'Yuji Syuku', serif;
    font-size: 3rem; /* 大見出しを大きく */
    font-weight: 900;
    letter-spacing: 0.15em; /* 字間を詰める */
    line-height: 1.1; /* 行間 */
    color: #000;
    text-align: center;
    display: block; /* 縦書きで中央揃えにするために必要 */
    padding-right: 0.5rem;
    border-right: 3px solid #000; /* 強い境界線 */
    margin-left: -0.5rem; /* 少し左に寄せて、中央カラムとの隙間を調整 */
    height: 100%; /* 親要素の高さに合わせる */
    grid-column: 1; /* 1カラム目を占有 */
    align-self: stretch; /* 縦方向に全体に広がる */
}

.skip-newspaper-main-image {
    background-color: #ddd; /* 画像のプレースホルダー */
    height: 200px; /* 画像の高さ */
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2rem;
    color: #666;
    border: 1px solid #aaa;
    margin-bottom: 0.5rem;
}
.skip-newspaper-image-caption {
    font-size: 0.8rem;
    color: #555;
    text-align: center;
    margin-top: -0.25rem;
    margin-bottom: 0.5rem;
}

.skip-newspaper-main-body {
    column-count: 2; /* メイン記事を2段組に */
    column-gap: 1rem;
    column-rule: 1px dotted #ccc; /* 点線で区切り */
    font-size: 0.9rem;
    line-height: 1.7;
    text-align: justify;
    padding-left: 0.5rem; /* 左側に少しパディング */
}
.skip-newspaper-main-body h4 {
    font-size: 1.1rem;
    font-weight: 700;
    margin-bottom: 0.5rem;
    column-span: all; /* 小見出しは段組をまたぐ */
    break-before: column;
}
.skip-newspaper-main-body p {
    margin-bottom: 0.75rem;
    text-indent: 1em; /* 段落の頭にインデント */
}

/* サイド記事 */
.skip-newspaper-side-article {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}
.skip-newspaper-side-article.left {
    grid-column: 1; /* 左端のカラム */
    border-right: 1px dotted #ccc;
    padding-right: 0.5rem;
}
.skip-newspaper-side-article.right {
    grid-column: 4; /* 右端のカラム */
    border-left: 1px dotted #ccc;
    padding-left: 0.5rem;
}

.skip-newspaper-side-headline {
    font-family: 'Yuji Syuku', serif;
    font-size: 1.3rem;
    font-weight: 700;
    line-height: 1.3;
    letter-spacing: 0.05em;
    border-bottom: 1px solid #aaa;
    padding-bottom: 0.25rem;
    margin-bottom: 0.5rem;
}
.skip-newspaper-side-body {
    font-size: 0.8rem;
    line-height: 1.6;
    text-align: justify;
    column-count: 1; /* 基本1段組 */
}
.skip-newspaper-side-body p {
    margin-bottom: 0.5rem;
    text-indent: 0.5em;
}

/* 試合結果セクション */
.skip-newspaper-results-section {
    grid-column: span 4; /* 全幅を占有 */
    border-top: 2px solid #222;
    padding-top: 0.75rem;
    margin-top: 1rem;
    text-align: center;
}
.skip-newspaper-results-section h2 {
    font-size: 1.6rem;
    font-weight: 700;
    margin-bottom: 0.75rem;
    font-family: 'Yuji Syuku', serif;
    color: #000;
    border-bottom: 1px solid #ccc;
    padding-bottom: 0.25rem;
    display: inline-block; /* 中央寄せ */
}

.skip-newspaper-match-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); /* 試合結果を細かく並べる */
    gap: 0.5rem; /* ギャップを小さく */
    margin-top: 0.75rem;
}
.skip-newspaper-match {
    font-size: 0.85rem; /* 文字を小さく */
    padding: 0.3rem 0.5rem;
    border: 1px solid #ccc;
    background: #fff;
    display: flex;
    justify-content: space-between;
    align-items: center;
    white-space: nowrap; /* テキストの折り返しを防ぐ */
}
.skip-newspaper-match .winner {
    font-weight: 700;
    color: #000;
}
.skip-newspaper-match .loser {
    color: #666;
}
.skip-newspaper-match .score {
    font-weight: 700;
    margin-left: 0.5rem;
}

.skip-newspaper-footer {
    padding: 0.4rem 1rem;
    text-align: center;
    border-top: 1px solid #ccc;
    background-color: #f9f9f9;
    font-size: 0.8rem;
}
/* ▲▲▲ ラウンドスキップ新聞モーダル用のCSS (ここまで修正) ▲▲▲ */

        /* ▼▼▼ トーナメント表用のCSS ▼▼▼ */
        .bracket-wrapper {
            max-width: 100%;
            overflow-x: auto; /* 横スクロールを可能にする */
            padding: 2rem 1rem;
            background-color: #ffffff; /* bg-white */
            border: 1px solid #d1d5db; /* border-gray-300 */
            border-radius: 0.5rem; /* rounded-lg */
            margin-top: 1.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        .tournament-container {
            display: flex;
            align-items: stretch; /* 各ラウンドの高さを揃える */
            min-width: 3200px; /* 全体の最小幅を指定 */

.baseball-diamond.runner-select-mode .base.runner {
    cursor: pointer;
    background-color: #f59e0b; /* bg-yellow-500 */
    border-color: #d97706; /* border-yellow-600 */
    animation: runnerPulse 1s infinite;
}
@keyframes runnerPulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

        }
        .bracket-final {
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; padding: 0 1.5rem; flex-shrink: 0;
        }
        .final-matchup { width: 280px; }
        .final-matchup .match {
            border-width: 2px; border-color: #f59e0b;
            box-shadow: 0 4px 10px rgba(245, 158, 11, 0.2);
        }
        .final-matchup .team { font-size: 1.125rem; padding: 0.75rem 1rem; }
        .final-matchup .score { font-size: 1.25rem; }
        .winner-box {
            text-align: center; margin-top: 1.5rem; padding: 0.75rem 1.5rem;
            background-color: #fffbeb; border: 2px solid #fcd34d; border-radius: 0.375rem;
        }
        .winner-box h2 { font-size: 1.5rem; font-weight: 700; color: #d97706; }
        .bracket-half { display: flex; align-items: stretch; }
        .bracket-half.right { flex-direction: row-reverse; }
        .round {
            /* width: 230px; や width: 280px; などの定義は
               index.html 側の既存の .round 定義と競合するため、ここでは除外します */
        }
        .round-title {
            text-align: center; font-weight: 700; font-size: 1rem;
            color: #4b5563; margin-bottom: 1rem; white-space: nowrap;
        }
        .matchup {
            /* .matchup の定義も index.html 側と競合するため、必要なもの以外は除外 */
        }
        .match {
            border: 1px solid #d1d5db; background: #fff;
            border-radius: 0.375rem; overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        .team {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0.5rem 0.75rem; font-size: 0.875rem; line-height: 1.25; min-height: 38px;
        }
        .team.winner { font-weight: 700; color: #111827; }
        .team.loser { color: #6b7280; opacity: 0.7; }
        .team.loser .name { text-decoration: line-through; }
        .team .score {
            width: 30px; text-align: right; border-left: 1px solid #e5e7eb;
            padding-left: 0.5rem; font-size: 0.95rem; font-weight: 500;
        }
        .team.winner .score { color: #dc2626; font-weight: 700; }
        .team:first-child { border-bottom: 1px solid #d1d5db; }
        .r1 .matchup { margin: 0.25rem 0; }
        .r1 .team { padding: 3px 6px; font-size: 11px; min-height: 28px; }
        .r1 .team .score { width: 20px; font-size: 11px; }
        .connector-line {
            position: absolute; top: 50%; width: 1.5rem; height: 2px;
            background-color: #9ca3af; z-index: 1;
        }
        .bracket-half.left .connector-line { right: -1.5rem; }
        .bracket-half.right .connector-line { left: -1.5rem; }
        .connector-path {
            position: absolute; top: 50%; height: 100%; width: 2px;
            background-color: #9ca3af; z-index: 0;
        }
        .r2 .matchup { margin: 0.5rem 0; }
        .r2 .connector-path { top: -25%; height: 150%; }
        .r3 .matchup { margin: 1.25rem 0; }
        .r3 .connector-path { top: -75%; height: 250%; }
        .r4 .matchup { margin: 3.25rem 0; }
        .r4 .connector-path { top: -175%; height: 450%; }
        .r5 .matchup { margin: 8rem 0; }
        .r5 .connector-path { top: -400%; height: 900%; }
        .bracket-half.left .connector-path { right: -1.5rem; }
        .bracket-half.right .connector-path { left: -1.5rem; }
        /* ▲▲▲ トーナメント表CSSここまで ▲▲▲ */
        
/* 8. H2H (Head-to-Head) 戦力比較チャート */
        .h2h-chart-container {
            border-top: 2px solid #e5e7eb; /* border-gray-200 */
            margin-top: 1.5rem; /* mt-6 */
            padding-top: 1.5rem; /* pt-6 */
        }
        .h2h-chart-title {
            font-size: 1.25rem; /* text-xl */
            font-weight: 700;
            color: #1f2937; /* text-gray-800 */
            margin-bottom: 1rem; /* mb-4 */
        }
        .h2h-stat-row {
            margin-bottom: 1rem; /* mb-4 */
        }
        .h2h-stat-label {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            font-size: 0.875rem; /* text-sm */
            font-weight: 600;
            color: #4b5563; /* text-gray-600 */
            margin-bottom: 0.25rem; /* mb-1 */
        }
        .h2h-stat-label-team1 { color: #1d4ed8; } /* text-blue-700 */
        .h2h-stat-label-team2 { color: #be123c; } /* text-red-700 */
        
        .h2h-bar-wrapper {
            display: flex;
            gap: 2px; /* 隙間 */
            height: 24px; /* バーの高さ */
            background-color: #e5e7eb; /* bg-gray-200 */
            border-radius: 0.25rem; /* rounded */
            overflow: hidden;
        }
        .h2h-bar {
            transition: width 0.5s ease-out;
        }
        .h2h-bar-team1 { background-color: #3b82f6; } /* bg-blue-500 */
        .h2h-bar-team2 { background-color: #e11d48; } /* bg-red-600 */
        /* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* 7. 選手コンディション (調子) アイコン */
        .condition-icon {
            font-size: 0.9em;
            margin-left: 4px;
            display: inline-block;
            vertical-align: baseline;
        }
        .details-table .condition-icon {
            font-size: 1.1em;
            vertical-align: middle;
        }

        /* ▼▼▼ 一球速報モーダル用のCSS ▼▼▼ */
        .modal-hidden { display: none; }
        #boxscore-modal-body {
            background-color: #f9fafb; /* bg-gray-50 */
            padding: 1rem;
            border-radius: 0.25rem;
            font-size: 12px; /* ベースのフォントサイズ */
        }
        /* 一球速報.com風 スコアボード */
        .boxscore-table {
            width: 100%; border-collapse: collapse;
            font-size: 14px; margin-bottom: 1rem;
        }
        .boxscore-table th, .boxscore-table td {
            border: 1px solid #d1d5db; padding: 6px 8px; text-align: center;
        }
        .boxscore-table .team-name {
            text-align: left; font-weight: 700; width: 20%;
        }
        .boxscore-table .inning-header th {
            background-color: #374151; color: white;
            font-weight: 500; padding: 4px 6px;
        }
        .boxscore-table .total-header { background-color: #374151; color: white; }
        .boxscore-table .score-cell {
            font-size: 1.1rem; font-weight: 700; width: 35px;
        }
        .boxscore-table .total-score {
            font-size: 1.25rem; font-weight: 700; background-color: #fef9c3;
        }
        /* 一球速報.com風 打撃成績テーブル */
        .batting-stats-table {
            width: 100%; border-collapse: collapse; font-size: 12px;
            table-layout: fixed; /* テーブルレイアウトを固定 */
        }
        .batting-stats-table th, .batting-stats-table td {
            border: 1px solid #e5e7eb; padding: 5px 4px;
            text-align: center; white-space: nowrap; /* 折り返し禁止 */
        }
        .batting-stats-table thead tr { background-color: #f3f4f6; }
        .batting-stats-table .pos { width: 8%; }
        .batting-stats-table .player { width: 20%; text-align: left; padding-left: 8px; }
        .batting-stats-table .at-bat { width: 5%; }
        .batting-stats-table .runs { width: 5%; }
        .batting-stats-table .hits { width: 5%; }
        .batting-stats-table .rbi { width: 5%; }
        .batting-stats-table .so { width: 5%; }
        .batting-stats-table .walks { width: 5%; }
        .batting-stats-table .results { width: 42%; text-align: left; padding-left: 8px; white-space: normal; } /* 結果は折り返し許可 */
        .batting-stats-table tbody tr:hover { background-color: #fef9c3; }
        .batting-stats-table .sub-player td { background-color: #f9fafb; color: #4b5563; }
        .batting-stats-table .sub-player .player { padding-left: 20px; }
        .batting-stats-table .team-totals { font-weight: 700; background-color: #f3f4f6; }
        /* 投手成績テーブル */
        .pitching-stats-table {
            width: 100%; border-collapse: collapse; font-size: 12px;
            margin-top: 1rem; table-layout: fixed;
        }
        .pitching-stats-table th, .pitching-stats-table td {
            border: 1px solid #e5e7eb; padding: 5px 4px;
            text-align: center; white-space: nowrap;
        }
        .pitching-stats-table thead tr { background-color: #f3f4f6; }
        .pitching-stats-table .player { width: 25%; text-align: left; padding-left: 8px; }
        .pitching-stats-table .result { width: 6%; }
        .pitching-stats-table .ip { width: 8%; }
        .pitching-stats-table .bf { width: 8%; }
        .pitching-stats-table .hits { width: 8%; }
        .pitching-stats-table .so { width: 8%; }
        .pitching-stats-table .walks { width: 8%; }
        .pitching-stats-table .runs { width: 8%; }
        .pitching-stats-table .er { width: 8%; }
        .pitching-stats-table .era { width: 13%; }
        /* ▲▲▲ 一球速報CSSここまで ▲▲▲ */

/* ▲▲▲ 新規追加ここまで ▲▲▲ */
.skip-newspaper-container {
    /* 既存の紙の色(#fdfaf4)をベースに、テクスチャと折り目を追加 */
    background-color: #fdfaf4;
    background-image: 
        /* 1. 中央の折り目 */
        linear-gradient(to right, 
            rgba(0, 0, 0, 0) 49.8%,  /* 中央の少し手前まで透明 */
            rgba(0, 0, 0, 0.1) 50%,   /* 中央に暗い影 */
            rgba(0, 0, 0, 0) 50.2%   /* 中央の少し後から透明 */
        ),
        /* 2. 紙の黄ばみ・質感 (中心が明るく、端が少し暗い) */
        radial-gradient(ellipse at center, #fdfaf4 70%, #f0e8d8 100%);

    border: 1px solid #333;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    width: 100%;
    max-width: 900px;
    max-height: 95vh;
    font-family: 'Noto Serif JP', 'Yuji Syuku', serif;
    color: #333;
    display: flex;
    flex-direction: column;
}
/* ▲▲▲ 置き換えはここまで ▲▲▲ */
/* ▼▼▼ 検索結果リスト用CSS ▼▼▼ */
.search-result-list {
    list-style: none;
    padding: 0;
    margin: 0;
}
.search-result-item {
    padding: 1rem;
    border-bottom: 1px solid #e5e7eb;
    cursor: pointer;
    transition: background-color 0.2s;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.search-result-item:hover {
    background-color: #f3f4f6;
}
.search-result-name {
    font-weight: bold;
    font-size: 1.1rem;
    color: #1f2937;
}
.search-result-info {
    font-size: 0.85rem;
    color: #6b7280;
}
.search-result-tag {
    background-color: #dbeafe;
    color: #1e40af;
    font-size: 0.75rem;
    padding: 2px 8px;
    border-radius: 9999px;
    margin-left: 8px;
}
/* ▲▲▲ 新規追加ここまで ▲▲▲ */


/* ▼▼▼ 学校アーカイブモーダル用CSS ▼▼▼ */
.archive-header {
    border-left: 5px solid #e60012; /* 朝日新聞風の赤 */
    padding-left: 15px;
    margin-bottom: 20px;
}
.archive-school-name {
    font-size: 24px;
    font-weight: bold;
    color: #333;
}
.archive-pref {
    font-size: 16px;
    font-weight: normal;
    color: #666;
    margin-left: 10px;
}
.archive-section-title {
    border-bottom: 2px solid #333;
    font-size: 18px;
    font-weight: bold;
    padding-bottom: 5px;
    margin-top: 30px;
    margin-bottom: 15px;
}
.archive-sub-title {
    background-color: #f0f0f0;
    border-left: 4px solid #666;
    padding: 8px 15px;
    font-size: 16px;
    font-weight: bold;
    color: #333;
    margin-bottom: 10px;
}

/* 成績概要 */
.result-summary-box {
    background-color: #f9fafb;
    border: 1px solid #e5e7eb;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
}
.result-summary-row {
    display: flex;
    border-bottom: 1px dashed #ccc;
    padding: 8px 0;
}
.result-summary-row:last-child { border-bottom: none; }
.result-summary-dt { font-weight: bold; width: 100px; color: #e60012; }
.result-summary-dd { flex: 1; }

/* 戦績テーブル */
.record-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
    margin-bottom: 20px;
}
.record-table th {
    background-color: #e0e0e0;
    border: 1px solid #ccc;
    padding: 8px;
    text-align: center;
    white-space: nowrap;
}
.record-table td {
    border: 1px solid #ccc;
    padding: 8px;
    text-align: center;
}
.record-table tr:nth-child(even) {
    background-color: #f9f9f9;
}
.record-table .result-win { color: #e60012; font-weight: bold; }
.record-table .result-lose { color: #3366cc; font-weight: bold; }
.record-table .score-cell { font-weight: bold; font-size: 1.1em; }
.record-table .opponent-cell { text-align: left; padding-left: 15px; }

/* 直近成績リスト */
.history-list {
    list-style: none;
    padding: 0;
}
.history-item {
    display: flex;
    justify-content: space-between;
    padding: 10px;
    border-bottom: 1px solid #eee;
}
.history-year { font-weight: bold; color: #555; width: 120px; }
.history-rank { font-weight: bold; }

/* ▼▼▼ SNSトレンド機能 (X風デザイン) ▼▼▼ */
.sns-modal-content {
    background-color: #ffffff;
    max-width: 600px;
    width: 100%;
    border-radius: 16px;
    overflow: hidden;
}
.sns-header {
    background-color: rgba(255, 255, 255, 0.85);
    backdrop-filter: blur(12px);
    padding: 12px 16px;
    border-bottom: 1px solid #eff3f4;
    position: sticky;
    top: 0;
    z-index: 10;
}
.sns-trend-item {
    padding: 12px 16px;
    border-bottom: 1px solid #eff3f4;
    transition: background-color 0.2s;
    cursor: pointer;
}
.sns-trend-item:hover { background-color: #f7f9f9; }
.sns-trend-meta { font-size: 13px; color: #536471; }
.sns-trend-word { font-size: 15px; font-weight: 700; color: #0f1419; margin-top: 2px; }
.sns-trend-count { font-size: 13px; color: #536471; margin-top: 4px; }

.sns-post {
    padding: 12px 16px;
    border-bottom: 1px solid #eff3f4;
    display: flex;
    gap: 12px;
    animation: fadeIn 0.5s ease-out;
}
.sns-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: #cfd9de;
    flex-shrink: 0;
}
.sns-content { flex-grow: 1; }
.sns-user-info { display: flex; align-items: baseline; gap: 4px; }
.sns-name { font-weight: 700; color: #0f1419; font-size: 15px; }
.sns-handle { color: #536471; font-size: 14px; }
.sns-time { color: #536471; font-size: 14px; }
.sns-text { margin-top: 4px; font-size: 15px; line-height: 1.4; color: #0f1419; white-space: pre-wrap; }
.sns-actions {
    display: flex; justify-content: space-between; margin-top: 12px; max-width: 425px; color: #536471; font-size: 13px;
}
.sns-action-btn { display: flex; align-items: center; gap: 6px; cursor: pointer; transition: color 0.2s; }
.sns-action-btn:hover.like { color: #f91880; }
.sns-action-btn:hover.retweet { color: #00ba7c; }

/* トレンド通知バナー */
#trend-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: #1d9bf0; /* X Blue */
    color: white;
    padding: 12px 20px;
    border-radius: 30px;
    box-shadow: 0 4px 15px rgba(29, 155, 240, 0.4);
    z-index: 300;
    transform: translateX(120%);
    transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 10px;
}
#trend-notification.show { transform: translateX(0); }
/* ▲▲▲ 追加ここまで ▲▲▲ */

/* ▼▼▼ アニメーション説明用のCSS ▼▼▼ */
.match-schedule {
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 11px;
            font-weight: 600;
            color: #4b5563; /* gray-600 */
            text-align: center;
            padding: 2px 0;
            border-top: 1px dashed #cbd5e1; /* gray-300 */
            border-bottom: 1px dashed #cbd5e1; /* gray-300 */
            margin-top: 3px;
            background-color: #f9fafb; /* gray-50 */
        }
/* ▲▲▲ 追加ここまで ▲▲▲ */
#animation-stage {
    font-size: 0.75rem; /* 全体の文字サイズを小さめに */
    transition: background-color 0.5s ease;
}
.anim-region, .anim-block, .anim-bracket {
    border: 1px solid #ccc;
    background-color: white;
    padding: 8px;
    margin: 5px;
    border-radius: 4px;
    text-align: center;
    opacity: 0;
    transition: all 0.5s ease-in-out;
    position: relative; /* 子要素の絶対配置基準 */
}
.anim-team {
    display: inline-block;
    background-color: #e0f2fe; /* blue-100 */
    border: 1px solid #7dd3fc; /* blue-300 */
    color: #0c4a6e; /* blue-800 */
    padding: 2px 5px;
    margin: 1px;
    border-radius: 3px;
    font-weight: 500;
    opacity: 0;
    transform: scale(0.8);
    transition: all 0.3s ease-in-out;
}
.anim-team.seed {
    background-color: #fef9c3; /* yellow-100 */
    border-color: #facc15; /* yellow-400 */
    color: #713f12; /* yellow-900 */
    font-weight: bold;
}
.anim-team.winner {
    background-color: #dcfce7; /* green-100 */
    border-color: #4ade80; /* green-400 */
    color: #14532d; /* green-900 */
    font-weight: bold;
}
.anim-team.loser {
    background-color: #f1f5f9; /* slate-100 */
    border-color: #cbd5e1; /* slate-300 */
    color: #64748b; /* slate-500 */
    opacity: 0.6 !important;
    text-decoration: line-through;
}
.anim-team.show, .anim-region.show, .anim-block.show, .anim-bracket.show {
    opacity: 1;
    transform: scale(1);
}
.anim-highlight {
    box-shadow: 0 0 15px 5px rgba(251, 191, 36, 0.7); /* amber-400 */
    transform: scale(1.1) !important;
    z-index: 10;
}
.anim-arrow {
    position: absolute;
    width: 0;
    height: 0;
    border-top: 5px solid transparent;
    border-bottom: 5px solid transparent;
    opacity: 0;
    transition: opacity 0.5s ease-in-out 0.5s; /* 少し遅れて表示 */
}
.anim-arrow.right {
    border-left: 8px solid #60a5fa; /* blue-400 */
}
.anim-arrow.show {
    opacity: 1;
}

.details-table { 
    border-collapse: collapse; 
    font-size: 12px; 
    
}

/* 1. インタラクティブ・スコアカード モーダル本体 */
#scorecard-modal {
    z-index: 180; /* チームステータス(170)より手前 */
}
.scorecard-grid {
    display: grid;
    grid-template-areas:
        "header"
        "diamond"
        "actions"
        "log";
    grid-template-rows: auto 1fr auto auto;
    gap: 1rem;
    width: 100%;
    height: 100%;
    padding: 1rem;
}
@media (min-width: 768px) { /* md: */
    .scorecard-grid {
        grid-template-areas:
            "header header"
            "diamond actions"
            "diamond log";
        grid-template-columns: 2fr 1fr;
        grid-template-rows: auto 1fr auto;
    }
}

/* 2. 野球のグラウンド */
.baseball-diamond {
    grid-area: diamond;
    position: relative;
    width: 100%;
    max-width: 400px; /* 最大幅 */
    aspect-ratio: 1 / 1; /* 正方形 */
    margin: auto;
    background-color: #f7fafc; /* bg-gray-50 */
    border: 2px solid #e2e8f0; /* border-gray-300 */
    border-radius: 8px;
    transform: rotate(45deg);
}
.base {
    position: absolute;
    width: 12%;
    height: 12%;
    background-color: white;
    border: 2px solid #a0aec0; /* border-gray-400 */
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    transition: all 0.2s ease-out;
}
.base.runner {
    background-color: #2563eb; /* bg-blue-600 */
    border-color: #1d4ed8;
    box-shadow: 0 0 15px 5px rgba(59, 130, 246, 0.7);
}
#base-home { bottom: -6%; left: 50%; transform: translateX(-50%) rotate(-45deg); border-radius: 0; width: 15%; height: 15%; }
#base-1b { top: 50%; right: -6%; transform: translateY(-50%); }
#base-2b { top: -6%; left: 50%; transform: translateX(-50%); }
#base-3b { top: 50%; left: -6%; transform: translateY(-50%); }
#pitchers-mound {
    position: absolute;
    top: 50%; left: 50%;
    width: 10%; height: 10%;
    background-color: #a0aec0; /* bg-gray-400 */
    border-radius: 50%;
    transform: translate(-50%, -50%);
}

/* 3. 操作パネル */
#scorecard-actions { grid-area: actions; }
#scorecard-log { grid-area: log; }
.result-btn {
    border: 1px solid #d1d5db; /* border-gray-300 */
    padding: 0.75rem 0.5rem;
    font-size: 0.875rem; /* text-sm */
    font-weight: 600;
    border-radius: 0.375rem; /* rounded-md */
    transition: all 0.1s ease-in;
    text-align: center;
}
.result-btn:hover {
    border-color: #9ca3af; /* hover:border-gray-400 */
    transform: translateY(-1px);
    box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}
.result-btn-hit { background-color: #eff6ff; color: #1d4ed8; } /* bg-blue-50, text-blue-700 */
.result-btn-out { background-color: #fee2e2; color: #b91c1c; } /* bg-red-50, text-red-700 */
.result-btn-walk { background-color: #f0fdf4; color: #15803d; } /* bg-green-50, text-green-700 */
.result-btn-other { background-color: #fef9c3; color: #a16207; } /* bg-yellow-50, text-yellow-700 */
/* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* 283学園ホームページ用ハイライト */
        #homepage-modal #results .team.hp-team-283 {
            background-color: #eff6ff; /* bg-blue-50 */
            border-color: #93c5fd; /* border-blue-300 */
        }
        #homepage-modal #results .team.hp-team-283.winner {
            background-color: #1e3a8a; /* bg-blue-800 */
            color: white;
            font-weight: 900;
        }
        #homepage-modal #results .team.hp-team-283.winner .score,
        #homepage-modal #results .team.hp-team-283.winner .name {
            color: white;
        }
        #homepage-modal #results .team.hp-team-283.loser {
            background-color: #eef2ff; /* bg-indigo-50 */
            opacity: 0.8;
        }
        #homepage-modal #results .team.hp-team-283.loser .name {
            text-decoration: line-through;
        }
        /* ▲▲▲ 新規追加ここまで ▲▲▲ */

/* ▼▼▼ この新しいルールを追加 ▼▼▼ */
.details-table th {
    white-space: nowrap; /* ヘッダーの文字が折り返さないようにする */
}
/* ▲▲▲ ▲▲▲ */
.details-table td { 
    border: 1px solid #e5e7eb; 
    padding: 4px; 
    text-align: center; 
    vertical-align: middle; 
}
.details-table th { background-color: #f9fafb; font-weight: 600; }
.details-table input, .details-table select { width: 100%; border: none; text-align: center; background: transparent; font-size: 12px; }
.details-table input:focus, .details-table select:focus { outline: 1px solid #3b82f6; }

/* ★列幅設定★ */
/* イニングスコアテーブル */
#inning-score-table { table-layout: auto; width: auto; } /* スコアボードは自動幅 */
#inning-score-table .col-team { min-width: 120px; text-align: left; padding-left: 8px; }
#inning-score-table .col-inning-score { width: 40px; }
#inning-score-table .col-total { width: 50px; }
#inning-score-table .col-add-inning { width: 40px; }

/* ▼▼▼ このブロックをまるごと追加 ▼▼▼ */
/* 投手成績テーブル */
.details-table[id^="pitching-table"] .col-pitcher-result { min-width: 50px; }
.details-table[id^="pitching-table"] .col-pitcher-name { min-width: 130px; } /* 選手名欄を広く */
.details-table[id^="pitching-table"] .col-pitcher-throw-bat { min-width: 80px; }
.details-table[id^="pitching-table"] .col-pitcher-style { min-width: 110px; } /* 投げ方 (スリークォーター) */
.details-table[id^="pitching-table"] .col-pitcher-type { min-width: 80px; }
.details-table[id^="pitching-table"] .col-pitcher-velocity { min-width: 80px; }
.details-table[id^="pitching-table"] .col-stat { min-width: 60px; } /* 回数, 打者, 球数 etc. */
/* ▲▲▲ 追加ここまで ▲▲▲ */



/* 打撃成績テーブル */
/* ★列幅設定（min-widthで最低幅を保証）★ */
.batting-table .col-order { min-width: 40px; }
.batting-table .col-number { min-width: 60px; }
.batting-table .col-throw-bat { min-width: 80px; } /* 「投/打」列の幅を確保 */
.batting-table .col-player { min-width: 120px; }
.batting-table .col-pos { min-width: 100px; }
.batting-table .col-sub-type { min-width: 80px; }
.batting-table .col-inning { min-width: 400px; }  /* ←お好みの幅に調整してください */
/* ▲▲▲ ▲▲▲ */
        .add-row-btn { background-color: #e5e7eb; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-top: 4px; }

        .add-row-btn:hover { background-color: #d1d5db; }　



　 </style>
</head>
<body class="p-4 md:p-8">
     <audio id="lottery-bgm" src="./bgm.mp3" loop preload="auto"></audio>
    <div class="ballpark-background"></div>
    <div id="dust-container"></div>
 <div id="rain-container" class="rain hidden"></div>
    <div id="sun-container" class="sunshine hidden">
        <div class="sun"></div>
        <div class="sun-flare"></div>
    </div>
    <div id="app-container" class="max-w-full mx-auto">
/div>

<div id="news-ticker-container">
    <div class="ticker-label">NEWS</div>
    <div class="ticker-content">
        <p id="ticker-text"></p>
    </div>
</div>

    <div id="weather-controls" class="fixed bottom-4 right-4 z-10">
        <div class="flex gap-2 p-2 bg-black bg-opacity-20 rounded-lg">
            <button id="unmute-btn" class="weather-btn">🔇</button>
            <button class="weather-btn" data-weather="sun">☀️</button>
            <button class="weather-btn" data-weather="rain">🌧️</button>
            <button class="weather-btn" data-weather="none">💨</button>
        </div>
    </div>
        
<div class="flex items-center justify-center space-x-4 p-4 mt-4 bg-slate-800/50 rounded-lg">
            <span class="font-semibold text-white">大会開始時のAI自動生成</span>
            <label class="relative inline-flex items-center cursor-pointer">
                <input type="checkbox" id="initial-ai-generation-toggle" class="sr-only peer" checked>
                <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                <span class="ml-3 text-sm font-medium text-gray-300 peer-checked:text-white">ON</span>
            </label>
        </div>

<div id="settings-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[200]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 class="text-xl font-bold">設定</h3>
            <button id="settings-modal-close-btn" class="text-gray-400 hover:text-gray-600">&times;</button>
        </div>
<div class="mb-6">
            <h4 class="text-sm font-bold text-gray-600 mb-2 text-center">現在の勢力分布図</h4>
            <div id="rank-pyramid-container" class="w-full bg-gray-50 p-4 rounded-lg border border-gray-200">
                </div>

</div>
<div id="school-archive-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[300] font-sans">
    <div class="bg-white w-full max-w-5xl h-[95vh] overflow-y-auto rounded-lg shadow-2xl relative">
        <button id="school-archive-close-btn" class="absolute top-4 right-4 text-gray-500 hover:text-gray-800 text-3xl font-bold">&times;</button>
        
        <div id="school-archive-content" class="p-8">
        </div>
    </div>
</div>
<div class="flex justify-center items-center space-x-2 mb-6">
    <div class="relative w-full max-w-md">
    <input type="text" id="school-search-input" 
        class="w-full p-3 pl-10 text-sm text-gray-900 border border-gray-300 rounded-lg bg-gray-50 focus:ring-blue-500 focus:border-blue-500" 
        placeholder="学校名、監督名、地域 (例: 浜松、西部)..." autocomplete="off">
    
    <div class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
        <svg aria-hidden="true" class="w-5 h-5 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
    </div>



    <ul id="search-suggestions" class="absolute z-50 w-full bg-white border border-gray-300 rounded-lg shadow-xl mt-1 hidden max-h-60 overflow-y-auto">
        </ul>
</div>
<button id="school-search-btn" class="text-white bg-blue-700 hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-3">検索</button>
</div>

<div class="flex flex-wrap justify-center gap-2 mb-8">
    <button class="rank-filter-btn bg-red-100 text-red-800 border border-red-300 hover:bg-red-200 font-bold py-1 px-3 rounded-full text-sm transition-colors" data-rank="A">
        👑 Aランク (名門)
    </button>
    <button class="rank-filter-btn bg-blue-100 text-blue-800 border border-blue-300 hover:bg-blue-200 font-bold py-1 px-3 rounded-full text-sm transition-colors" data-rank="B">
        🛡️ Bランク (強豪)
    </button>
    <button class="rank-filter-btn bg-yellow-100 text-yellow-800 border border-yellow-300 hover:bg-yellow-200 font-bold py-1 px-3 rounded-full text-sm transition-colors" data-rank="C">
        🦄 Cランク (中堅)
    </button>
    <button class="rank-filter-btn bg-gray-100 text-gray-800 border border-gray-300 hover:bg-gray-200 font-bold py-1 px-3 rounded-full text-sm transition-colors" data-rank="D">
        🔥 Dランク (発展途上)
    </button>
    <button class="rank-filter-btn bg-white text-gray-600 border border-gray-300 hover:bg-gray-100 font-bold py-1 px-3 rounded-full text-sm transition-colors" data-rank="E">
        🌱 Eランク (挑戦者)
    </button>
</div>

        <div class="space-y-4">
            <div class="flex items-center justify-between">
                <span class="font-semibold">試合記事の自動生成</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-article-generation" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
            </div>
            <div class="flex items-center justify-between">
                <span class="font-semibold">掲示板の自動生成</span>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="toggle-bbs-generation" class="sr-only peer" checked>
                    <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
            </div>
        </div>
    </div>
</div>



        <div class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white main-title">AI記者付きトーナメント表</h1>
            <p id="tournament-year-display" class="mt-2 subtitle-text">（最終実装版）</p>
        </div>

        <div id="setup" class="setup-card">
             <div class="w-full">
                 <h2 class="text-xl font-semibold mb-4 border-b pb-2 setup-header">参加チーム (126チーム)</h2>
                 <textarea id="teams-list" class="w-full h-96 p-3 border border-gray-300 rounded-lg" readonly></textarea>
             </div>
             <div class="mt-8 text-center">
                 <button id="resume-btn" class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-green-700 shadow-md mb-4 w-full md:w-auto">
                   再開（合い言葉入力）
                 </button>
                 <button id="generate-btn" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 shadow-md w-full md:w-auto">
                     新しいトーナメントを開始
                 </button>
　　　　　　　　<button id="help-btn" class="bg-gray-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-gray-600 shadow-md mt-4 w-full md:w-auto">
    遊び方
</button>
 <button id="show-matome-site-btn" class="bg-orange-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-orange-600 shadow-md mt-4 w-full md:w-auto">
    📰 まとめサイトを見る
    </button>            
 </div>
        </div>


<button id="show-awards-btn" class="bg-amber-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-amber-600 shadow-md ml-2">
    🏆 大会表彰式
</button>

<div id="awards-modal" class="fixed inset-0 bg-gray-900 bg-opacity-90 hidden items-center justify-center z-[260] font-sans">
    <div class="bg-white w-full max-w-5xl h-[90vh] overflow-y-auto rounded-lg shadow-2xl flex flex-col">
        <div class="flex justify-between items-center p-4 border-b bg-amber-600 text-white sticky top-0 z-10">
            <h3 class="text-xl font-bold flex items-center">
                <span class="text-2xl mr-2">👑</span> 大会公式記録・表彰式
            </h3>
            <button id="awards-modal-close-btn" class="text-gray-200 hover:text-white text-2xl font-bold">&times;</button>
        </div>
        <div id="awards-content" class="p-6 bg-gray-50 flex-grow">
            <div class="loader">集計中...</div>
        </div>
    </div>
</div>

        <div id="tournament-display" class="hidden">
            <div id="autumn-regional-blocks-container" class="display-card hidden"></div>
            <div id="autumn-ranking-playoffs-container" class="display-card hidden"></div>
            <button id="skip-autumn-blocks-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 shadow-md hidden">地区ブロック予選をスキップ</button>
<button id="skip-autumn-ranking-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 shadow-md hidden">地区順位決定戦をスキップ</button>
<button id="skip-autumn-main-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 shadow-md hidden">県大会本戦をスキップ</button>
<button id="skip-spring-qualifiers-btn" class="bg-teal-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-600 shadow-md hidden">春季地区予選をスキップ</button>
<button id="skip-spring-round1-btn" class="bg-teal-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-600 shadow-md hidden">春季県大会1回戦をスキップ</button>
<button id="skip-spring-main-btn" class="bg-teal-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-teal-600 shadow-md hidden">春季県大会2回戦以降をスキップ</button>


            <div id="autumn-controls" class="text-center my-4 hidden">
                <button id="start-ranking-playoffs-btn" class="bg-purple-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-purple-700 shadow-md hidden">
                    地区内順位決定戦へ進む
                </button>
                <button id="start-main-tournament-btn" class="bg-teal-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-teal-700 shadow-md hidden">
                    県大会本戦へ進む
                </button>

            </div>

            

<div id="region-map-section" class="display-card hidden scorebook-font">
                 <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">地区別 勝ち残り状況</h2>
                 <div id="region-map-container" class="w-full"></div>
            </div>
             <div id="namco-news-section" class="hidden display-card border-2 border-orange-400">
                 <h2 class="text-xl font-bold text-orange-600 mb-3 text-center">ナムコグループからのお知らせ</h2>
                 <div id="namco-news-content" class="space-y-2"></div>
             </div>
            <div class="flex justify-between items-start mb-4">
                <div>
                    <button id="generate-summary-btn" class="hidden bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 shadow-md">
                        ここまでの大会ハイライト記事を生成
                    </button>
                    <button id="next-tournament-btn" class="hidden bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 shadow-md">
                        次の大会へ進む
                    </button>
                </div>
               <div class="ml-auto">
                    <div class="flex items-center justify-end space-x-2">
                       
<button id="skip-r1-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">1回戦スキップ</button>
<button id="skip-r2-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">2回戦スキップ</button>
<button id="skip-r3-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">3回戦スキップ</button>
<button id="skip-r4-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">4回戦スキップ</button>
<button id="skip-r5-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">準々決勝スキップ</button>
<button id="skip-r6-btn" class="hidden bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 shadow-md">準決勝スキップ</button>
<button id="skip-final-btn" class="hidden bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 shadow-md">決勝スキップ</button>

<button id="generate-summary-btn" class="hidden bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600 shadow-md">
    準々決勝(R5) 展望記事を生成
</button>


                        <span id="save-feedback" class="text-gray-600 font-bold opacity-0 transition-opacity duration-500"></span>
<button id="show-matome-site-btn" class="bg-orange-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-600 shadow-md">
    📰 まとめ
    </button>

<button id="show-contribution-btn" class="bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 shadow-md ml-2">
    🌌 貢献度・天体観測
</button>

<div id="contribution-modal" class="fixed inset-0 bg-gray-900 bg-opacity-90 hidden items-center justify-center z-[250] font-sans">
    <div class="bg-white w-full max-w-6xl h-[90vh] overflow-y-auto rounded-lg shadow-2xl flex flex-col">
        
        <div class="flex justify-between items-center p-4 border-b bg-purple-900 text-white sticky top-0 z-10">
            <h3 class="text-xl font-bold flex items-center">
                <span class="text-2xl mr-2">🌌</span> チーム貢献度シェア & 天体観測
            </h3>
            <button id="contribution-close-btn" class="text-gray-300 hover:text-white text-2xl font-bold">&times;</button>
        </div>
        
        <div class="p-6 bg-gray-50 flex-grow">
            
            <div class="mb-6 flex justify-center relative max-w-md mx-auto">
                <div class="relative w-full">
                    <input type="text" id="contribution-team-input" class="w-full p-3 pl-10 text-lg font-bold text-gray-700 border-2 border-purple-300 rounded-lg focus:ring-purple-500 focus:border-purple-500" placeholder="分析したいチーム名を入力..." autocomplete="off">
                    <div class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
                        <svg class="w-6 h-6 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                    </div>
                    <ul id="contribution-suggestions" class="absolute z-50 w-full bg-white border border-gray-300 rounded-lg shadow-xl mt-1 hidden max-h-60 overflow-y-auto text-left"></ul>
                </div>
            </div>

            <div id="contribution-content" class="hidden space-y-8">
                
                <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-gray-400">
                    <h4 class="text-lg font-bold text-gray-800 mb-4 flex items-center">
                        <span class="text-xl mr-2">💡</span> 指標の目安と評価基準
                    </h4>
                    <div id="rc-guidelines" class="space-y-3">
                        </div>
                </div>

                <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-purple-500">
                    <h4 class="text-lg font-bold text-gray-800 mb-4">📊 得点創出シェア (Runs Created Share)</h4>
                    <div class="flex flex-col md:flex-row items-center gap-8">
                        <div class="w-full md:w-1/2 h-64">
                            <canvas id="rc-pie-chart"></canvas>
                        </div>
                        <div class="w-full md:w-1/2">
                            <p class="text-sm text-gray-600 mb-2">
                                ※ <strong>RC (Runs Created)</strong>: その選手が「一人で何点生み出したか」を推定する指標。
                            </p>
                            <div id="rc-analysis-text" class="text-md font-bold text-purple-800 p-3 bg-purple-50 rounded"></div>
                        </div>
                    </div>
                </div>

                <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-yellow-500">
                    <h4 class="text-lg font-bold text-gray-800 mb-4">棒グラフ：RC/G（試合あたり貢献度）ランキング (Top 10)</h4>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="rc-bar-chart"></canvas>
                    </div>
                </div>
                
               <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-indigo-500">
    
    <h4 class="text-lg font-bold text-gray-800 mb-4">⚾ 打者タイプ・マップ (OPS分析)</h4>
    
    <div style="height: 400px; width: 100%;">
        <canvas id="stellar-scatter-chart"></canvas>
    </div>
    
    <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-2 text-xs text-center">
        
        <div class="p-2 bg-red-50 border border-red-200 rounded"><span class="text-lg">💣 爆発型</span><br>長打力特化 (OPS高)</div>
        
        <div class="p-2 bg-blue-50 border border-blue-200 rounded"><span class="text-lg">🎯 理想型</span><br>打率・OPSのバランス型</div>
        
        <div class="p-2 bg-orange-50 border border-orange-200 rounded"><span class="text-lg">🏹 職人型</span><br>高打率・確実性型 (AVG高)</div>
        
        <div class="p-2 bg-gray-100 border border-gray-300 rounded"><span class="text-lg">📈 成長株</span><br>規定打席未到達/育成枠</div>
    </div>
    </div>
</div>
</div>
      </div> 
</div>
<button id="show-rivalry-map-btn" class="bg-pink-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-pink-700 shadow-md ml-2">
    💞 因縁相関図
</button>

<div id="rivalry-map-modal" class="fixed inset-0 bg-gray-900 bg-opacity-90 hidden items-center justify-center z-[250] font-sans">
    <div class="bg-white w-full max-w-6xl h-[90vh] overflow-y-auto rounded-lg shadow-2xl flex flex-col">
        <div class="flex justify-between items-center p-4 border-b bg-pink-900 text-white sticky top-0 z-10">
            <h3 class="text-xl font-bold flex items-center">
                <span class="text-2xl mr-2">🕸️</span> 県内勢力・因縁相関図
            </h3>
            <button id="rivalry-map-close-btn" class="text-gray-300 hover:text-white text-2xl font-bold">&times;</button>
        </div>
        <div class="p-6 bg-gray-50 flex-grow flex flex-col items-center">
            <div id="mermaid-container" class="w-full overflow-x-auto flex justify-center bg-white p-4 rounded border shadow-inner min-h-[300px]">
                </div>

            <div class="w-full mt-6">
                <h4 class="text-lg font-bold text-gray-700 mb-2 flex items-center">
                    <span class="mr-2">📝</span> AI戦況記者による「勢力図」分析
                </h4>
                <div id="rivalry-analysis-content" class="bg-white p-5 rounded-lg border border-gray-300 text-gray-800 leading-relaxed shadow-sm">
                    <p class="text-gray-400 text-center">（相関図の生成後に分析が始まります...）</p>
                </div>
            </div>
            </div>
    </div>
</div>

<button id="show-scout-report-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 shadow-md ml-2">
    🕵️ スカウト評価
</button>

<div id="scout-report-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 hidden items-center justify-center z-[250] font-sans">
    <div class="bg-white w-full max-w-5xl h-[90vh] overflow-y-auto rounded-lg shadow-2xl flex flex-col">
        <div class="flex justify-between items-center p-4 border-b bg-indigo-900 text-white sticky top-0 z-10">
            <h3 class="text-xl font-bold flex items-center">
                <span class="text-2xl mr-2">🕵️</span> プロスカウト視察レポート
            </h3>
            <button id="scout-report-close-btn" class="text-gray-300 hover:text-white text-2xl font-bold">&times;</button>
        </div>
        <div id="scout-report-content" class="p-6 bg-gray-100 flex-grow">
            </div>
    </div>
</div>

<button id="show-lineup-analysis-btn" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 shadow-md ml-2">
    ⚾ 適正打順分析
</button>
                        

   <button id="open-settings-btn" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 shadow-md">⚙️ 設定</button>
<button id="save-btn" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-sky-700 shadow-md">セーブ</button>
                        <button id="reset-btn" class="bg-red-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-700 shadow-md">リセット</button>
                    </div>
                    <div id="skip-loader-container" class="h-6 text-right mt-1">
                         <span id="skip-loader" class="hidden text-sm text-gray-600 font-bold">試合を進行しています...</span>
                    </div>
                </div>
            </div>
            <div id="main-bracket-wrapper" class="display-card scorebook-font">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">トーナメント表</h2>
                <div class="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4 rounded-md text-sm">
                    <p><b>PCでの表示について:</b> トーナメント表の全体が表示されない場合は、表のエリア内でマウスのホイールを回しながら <b>Shiftキー</b> を押すか、表の下に表示されるスクロールバーを直接ドラッグすることで、左右にスクロールできます。</p>
                </div>
                <div id="main-bracket-container"></div>
            </div>
            <div id="news-section" class="display-card">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">注目ニュース</h2>
                <div id="news-articles" class="space-y-4">
                    <p class="text-gray-500 text-center">まだニュースはありません。</p>
                </div>
            </div>
             <div id="daiya-bbs-section" class="hidden display-card border-4 border-green-600">
                 <h2 id="daiya-bbs-title" class="text-2xl font-bold text-green-800 mb-4 text-center">【特設】代矢東 応援掲示板</h2>
                 <div id="daiya-bbs-comments" class="space-y-3">
                     <p class="text-gray-500 text-center">まだ反応はありません。</p>
                 </div>
             </div>
             <div id="bbs-section" class="display-card">
                 <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">掲示板の反応</h2>
<div class="mb-4 p-4 border rounded-lg bg-white">
    <form id="main-comment-form">
        <textarea id="main-comment-textarea" class="w-full p-2 border rounded" rows="2" placeholder="コメントを書き込む... (例: 今日の姫川はレベチだったわ！)" required></textarea>
        <div class="text-right mt-2">
            <button type="submit" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700">投稿する</button>
        </div>
    </form>
</div>
                 <div id="bbs-comments" class="space-y-3">
                     <p class="text-gray-500 text-center">まだ反応はありません。</p>
                 </div>
             </div>
        </div>
    </div>

    <div id="news-modal" class="fixed inset-0 z-50 hidden items-center justify-center">
        <div id="modal-bg" class="absolute inset-0"></div>
        <div class="relative bg-white rounded-lg shadow-xl max-w-2xl w-full m-4">
            <div class="p-6 modal-body-scroll">
                <h3 id="modal-title" class="text-2xl font-bold text-gray-900"></h3>
                <div id="modal-meta" class="text-gray-400 text-sm mt-2 flex items-center gap-4"></div>
                <p id="modal-body" class="mt-4 text-gray-600 whitespace-pre-wrap"></p>
            </div>
            <button id="modal-close" class="absolute top-3 right-3 text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>
    
  
<div id="integrated-matome-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 hidden items-center justify-center z-[200]">
    <div class="bg-gray-100 p-2 md:p-4 rounded-lg shadow-xl w-full max-w-7xl max-h-[95vh] flex flex-col overflow-hidden">
        
        <div class="flex justify-between items-center mb-2 px-2 md:px-0">
            <h2 class="text-2xl md:text-3xl font-extrabold text-red-700 font-sans tracking-wide">
                <img src="koshien.jpg" alt="なんJスタジアム" class="h-10 md:h-12 inline-block mr-2">
                俺たちの甲子園速報＠なんJまとめ
            </h2>
            <button id="matome-modal-close-btn" class="text-gray-400 hover:text-gray-600">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>

        <div class="flex border-b border-gray-300 bg-white shadow-sm mb-3 text-sm md:text-base sticky top-0 z-10">
            <button class="matome-tab-btn active bg-blue-600 text-white py-2 px-4 rounded-t hover:bg-blue-700 transition-colors" data-tab="top">トップ</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="blog">このブログについて</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="twitter">Twitter</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="antenna">なんJアンテナ</button>
            <button class="matome-tab-btn text-gray-700 py-2 px-4 hover:bg-gray-100 transition-colors" data-tab="baseball-mag">BaseBall MAG</button>
            </div>

        <div id="matome-content-area" class="flex-grow overflow-y-auto bg-gray-50 p-2 md:p-4 rounded-b-lg scrollbar-thin scrollbar-thumb-gray-400 scrollbar-track-gray-200">
            
            <div id="matome-tab-top" class="matome-tab-content grid grid-cols-1 md:grid-cols-3 gap-4 active">
                <div class="md:col-span-2 mb-4">
                    <button id="open-new-thread-modal-btn" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 shadow-md transition-all duration-150">
                        ＋ 新しいスレッドを立てる
                    </button>
                </div>
                <div class="md:col-span-2 space-y-4">
                    <div class="bg-white p-4 rounded-lg shadow-md">
                        <h3 class="text-lg font-bold text-gray-800 border-b pb-2 mb-3">🔥 本日の注目記事</h3>
                        <div id="matome-articles-container" class="space-y-2">
                            <div class="loader text-center py-8">記事を読み込んでいます...</div>
                        </div>
                    </div>

                    <div class="bg-white p-4 rounded-lg shadow-md">
                        <h3 class="text-lg font-bold text-gray-800 border-b pb-2 mb-3">✅ まとめ</h3>
                        <ul class="list-none space-y-1">
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">野球部員(14)「甲子園は興味ない」</a></li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">DeNA・ジャクソン、衝撃のスリーランホームランｗｗｗｗｗｗ</a></li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">【画像】「下着ディズニー」パスｗｗｗｗｗｗｗｗｗ</a></li>
                            <li class="flex items-start"><span class="text-blue-500 mr-2">✅</span><a href="#" class="text-gray-700 hover:text-blue-600">【悲報】レンチンで簡単に旨いポテチ味付けられるライフハックがヤバイ</a></li>
                        </ul>
                    </div>
                </div>
                
                <div class="space-y-4">
                    <div class="bg-white p-2 rounded-lg shadow-md text-center">
                        <h3 class="text-md font-bold text-gray-800 border-b pb-1 mb-2">他社から乗り換えで</h3>
                        <img src="sumaho.jpg" alt="広告" class="w-full h-auto rounded">
                        <p class="text-sm text-gray-600 mt-1">人気スマホ<span class="text-xl font-bold text-red-600">500</span>円！</p>
                        <p class="text-xs text-gray-500">2025/8/31まで</p>
                    </div>

                    <div class="bg-white p-4 rounded-lg shadow-md">
                        <h3 class="text-lg font-bold text-gray-800 border-b pb-2 mb-3">💡 なんJアンテナ</h3>
                        <ul class="list-none space-y-1 text-sm">
                            <li><a href="#" class="text-gray-700 hover:text-blue-600">なんJ PRIDE: 巨人岡本和真(28) .300 40本 100打点</a></li>
                            <li><a href="#" class="text-gray-700 hover:text-blue-600">MLB NEWS: 大谷翔平、本日も二刀流で大活躍</a></li>
                            <li><a href="#" class="text-gray-700 hover:text-blue-600">まとめヒストリア: 昔のなんJスレを振り返る</a></li>
                        </ul>
                    </div>
                    
                </div>
            </div>

            <div id="matome-tab-blog" class="matome-tab-content hidden p-4 bg-white rounded-lg shadow-md">
                <h3 class="text-xl font-bold">このブログについて</h3>
                <p class="mt-2 text-gray-700">当ブログ「俺たちの甲子園速報＠なんJまとめ」は、架空の高校野球トーナメントと現実世界のなんJネタを融合させた、唯一無二のまとめサイトです。</p>
                <p class="mt-2 text-gray-700">野球に関する話題を中心に、時事ネタや芸能ニュース、学歴コンプレックスから派生する議論まで、なんJで話題になった様々なスレッドを独自の視点でまとめています。</p>
                <p class="mt-2 text-gray-700">管理人「甲子園の申し子」が、日夜巡回し、ホットな情報をお届けします。</p>
            </div>
            <div id="matome-tab-twitter" class="matome-tab-content hidden p-4 bg-white rounded-lg shadow-md">
                <h3 class="text-xl font-bold">Twitter</h3>
                <p class="mt-2 text-gray-700">@koshien_nanjのアカウントで、日々熱い実況をしています！</p>
                <div class="mt-4 bg-gray-100 p-3 rounded">
                    <p class="font-bold">なんJまとめ速報 @koshien_nanj</p>
                    <p class="text-sm mt-1">今日の試合も熱すぎる！○○高校、まさかの逆転サヨナラ勝ちｗｗｗ #高校野球 #甲子園 <span class="text-blue-500">#なんJ</span></p>
                    <p class="text-xs text-gray-500 mt-2">1時間前</p>
                </div>
                <div class="mt-4 bg-gray-100 p-3 rounded">
                    <p class="font-bold">なんJまとめ速報 @koshien_nanj</p>
                    <p class="text-sm mt-1">【悲報】ワイの応援してた高校、初戦敗退…今年はもう終わりや… <span class="text-blue-500">#甲子園の夏</span></p>
                    <p class="text-xs text-gray-500 mt-2">3時間前</p>
                </div>
            </div>
            <div id="bbs-thread-display-area" class="hidden p-4 bg-white rounded-lg shadow-md flex flex-col h-full">
                <div class="flex justify-between items-center border-b pb-3 mb-4">
                    <h3 id="bbs-thread-title" class="text-xl md:text-2xl font-bold text-gray-800"></h3>

<div>
                        <button id="retry-matome-thread-btn" class="bg-red-600 text-white font-bold py-1 px-3 rounded hover:bg-red-700 text-sm hidden" data-match-id="">
                            再生成
                        </button>

                    <button id="bbs-thread-back-btn" class="bg-blue-500 text-white font-bold py-1 px-3 rounded hover:bg-blue-600 text-sm">
                        一覧に戻る
                    </button>
                </div>
</div>
                <div id="bbs-thread-content" class="overflow-y-auto space-y-4 flex-grow">
                    <div class="loader text-center py-8">スレッドを読み込んでいます...</div>
                </div>
                <div class="mt-4 p-3 bg-gray-50 rounded-lg border-t text-sm text-gray-600">
                    <p>コメントは、AIによる自動生成です。特定の意見や人物を意図するものではありません。</p>
                </div>
            </div>

        </div>
    </div>
</div>

  <div id="confirm-modal" class="confirm-modal hidden">
        <div class="confirm-modal-content">
            <p id="confirm-modal-text" class="mb-4 text-lg"></p>
            <button id="confirm-ok" class="bg-red-600 text-white px-6 py-2 rounded-lg mr-2">はい</button>
            <button id="confirm-cancel" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">いいえ</button>
        </div>
    </div>

    <div id="details-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="details-modal-content bg-white p-6 rounded-lg shadow-xl w-full max-w-6xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">試合詳細入力</h3>
        <div id="details-modal-body" class="overflow-y-auto space-y-6 flex-grow pr-2"> {/* pr-2 を追加してスクロールバーとの隙間を作る */}
            </div>
        
                <div class="mt-6 text-center border-t pt-4">
            <button id="details-save" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 mr-4">
                この内容で保存
            </button>
            <button id="details-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-400">
                キャンセル
            </button>
        </div>
               
    </div>
</div>
            



    
    <div id="save-load-modal" class="save-load-modal hidden">
        <div class="save-load-modal-content">
            <div class="flex border-b">
                <button id="save-tab-btn" class="px-4 py-2 font-semibold border-b-2 border-blue-500">セーブ (合い言葉の発行)</button>
                <button id="load-tab-btn" class="px-4 py-2 text-gray-500">ロード (合い言葉の入力)</button>
            </div>
            <div id="save-tab-content" class="py-4">
                <p class="text-sm mb-2">現在の進行状況を保存するための「合い言葉」を発行します。下のボタンを押してください。</p>
                <button id="generate-save-code-btn" class="w-full bg-blue-600 text-white py-2 rounded hover:bg-blue-700">合い言葉を発行</button>
                <div id="save-code-area" class="hidden mt-4">
                    <p class="text-sm font-bold text-green-600">合い言葉が発行されました。以下をコピーして安全な場所に保管してください。</p>
                    <div class="flex items-center mt-2">
                        <div id="save-code-output" class="flex-grow text-xs"></div>
                        <button id="copy-save-code-btn" class="ml-2 bg-gray-200 px-3 py-1 rounded text-xs font-semibold hover:bg-gray-300">コピー</button>
                    </div>
                    <p id="copy-feedback" class="text-xs text-green-600 mt-1 h-4"></p>
                </div>
            </div>
            <div id="load-tab-content" class="py-4 hidden">
                <p class="text-sm mb-2">保存した「合い言葉」を以下に貼り付けてください。</p>
                <textarea id="load-code-input" placeholder="合い言葉をここに貼り付け" class="w-full h-32 p-2 border rounded mb-2"></textarea>
                <button id="load-from-code-btn" class="w-full bg-green-600 text-white py-2 rounded hover:bg-green-700">このデータで再開する</button>
            </div>
             <div class="mt-4 text-right">
                 <button id="save-load-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
             </div>
        </div>
    </div>

    <div id="newspaper-modal" class="newspaper-modal hidden">
        <div class="newspaper-modal-content">
            <div id="newspaper-modal-body"></div>
            <div class="mt-4 text-center">
                <button id="newspaper-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>
            </div>
        </div>
    </div>


<div id="feedback-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-[150]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記者への追加指示</h3>
        <div class="space-y-4">
            <div>
                <label for="feedback-include" class="block text-sm font-medium text-gray-700">✅ この要素を必ず含めてください</label>
                <textarea id="feedback-include" rows="4" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="例：殊勲打を放った〇〇選手のコメントを中心に。&#10;例：敗れた△△高校のエースの涙にも触れてほしい。"></textarea>
            </div>
            <div>
                <label for="feedback-exclude" class="block text-sm font-medium text-gray-700">❌ この要素・展開は避けてください</label>
                <textarea id="feedback-exclude" rows="3" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500" placeholder="例：監督の采配ミスという論調はもういい。&#10;例：ありきたりな「全員野球」という言葉は使わないで。"></textarea>
            </div>
        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="feedback-submit-btn" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">この指示で再生成</button>
            <button id="feedback-cancel-btn" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="review-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記事の最終確認・編集</h3>
        <div class="overflow-y-auto space-y-4 flex-grow">
            <div>
                <label for="review-title" class="block text-sm font-medium text-gray-700">タイトル</label>
                <input type="text" id="review-title" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div>
                <label for="review-body" class="block text-sm font-medium text-gray-700">本文</label>
                <textarea id="review-body" rows="15" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 whitespace-pre-wrap"></textarea>
            </div>
        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="review-save-btn" class="bg-blue-600 text-white px-6 py-2 rounded-lg mr-2">この記事で確定</button>
            <button id="review-cancel-btn" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="lottery-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 hidden items-center justify-center z-[200] font-sans">
    <div id="lottery-content" class="bg-white rounded-lg shadow-2xl w-full max-w-6xl h-[95vh] flex flex-col p-6">
        <h2 class="text-4xl font-bold text-center mb-4 scorebook-font text-gray-800 tracking-widest">夏の高校野球 組み合わせ抽選会</h2>
        <div id="lottery-stage" class="flex-grow bg-gray-800 rounded p-4 flex gap-4 overflow-hidden relative border-4 border-gray-600">
            <div class="w-1/3 flex flex-col items-center justify-between bg-gray-200 rounded-lg shadow-inner p-4">
                <div id="lottery-pot-container" class="w-full flex flex-col items-center">
                    <p id="pot-name" class="text-2xl font-bold text-gray-700 mb-2">Aシード</p>
                    <div id="lottery-pot" class="w-48 h-48 bg-red-800 border-4 border-yellow-400 text-white flex items-center justify-center text-5xl font-bold shadow-lg rounded-full cursor-pointer transition-transform duration-200 hover:scale-105">
                        抽選
                    </div>
                </div>
                <div id="drawn-team-container" class="w-full h-32 border-4 border-dashed border-gray-400 rounded-lg flex items-center justify-center opacity-0 bg-white">
                    <p id="drawn-team" class="text-4xl font-bold text-gray-800"></p>
                </div>
            </div>
            <div id="lottery-bracket" class="w-2/3 grid grid-cols-2 gap-x-4 h-full overflow-y-auto p-2 bg-gray-100 rounded-lg shadow-inner">
                <div id="lottery-bracket-left" class="space-y-1"></div>
                <div id="lottery-bracket-right" class="space-y-1"></div>
            </div>
        </div>
        <div class="h-32 flex flex-col justify-between pt-4">
            <div id="lottery-commentary" class="h-20 text-center text-2xl font-semibold text-gray-800 bg-yellow-100 border-2 border-yellow-300 rounded p-2 flex items-center justify-center">
                <p>静岡大会 抽選会へようこそ。主将は抽選箱をクリックしてクジを引いてください。</p>
            </div>
            <div id="lottery-controls" class="text-center">
    <button id="start-lottery-btn" class="bg-blue-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-blue-700">抽選を開始</button>
    <button id="skip-lottery-btn" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 ml-4">スキップ</button>
</div>
        </div>
    </div>
</div>

<div id="analysis-modal" class="fixed inset-0 bg-black bg-opacity-90 hidden flex flex-col items-center justify-center z-[250] p-4 font-sans">
    <div class="w-full max-w-6xl h-full flex flex-col">
        <div class="flex-shrink-0 flex justify-between items-center mb-4">
            <div id="analysis-block-tabs" class="flex space-x-1 p-1 bg-gray-800 rounded-lg">
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="A">Aブロック</button>
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="B">Bブロック</button>
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="C">Cブロック</button>
                <button class="analysis-block-tab-btn px-4 py-2 rounded-md text-sm font-bold transition-colors" data-block="D">Dブロック</button>
            </div>
            <button id="analysis-modal-close-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
        </div>
        
        <div id="analysis-stage" class="flex-grow bg-gray-900 rounded-lg relative overflow-hidden">
            </div>

        <div id="analysis-narration-box" class="flex-shrink-0 h-28 mt-4 bg-gray-800 border-t-2 border-cyan-500 rounded-b-lg p-4 overflow-y-auto">
            <p id="analysis-narration-text" class="text-white text-lg leading-relaxed whitespace-pre-wrap"></p>
        </div>
    </div>
</div>

<div id="interview-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-[300]">
    <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full p-6 m-4 animate-fade-in-up">
        <h3 class="text-2xl font-bold text-gray-900 mb-4 border-b pb-2">抽選会後 主将インタビュー</h3>
        <div id="interview-content" class="space-y-4 max-h-[60vh] overflow-y-auto"></div>
        <div class="text-center mt-6">
            <button id="close-interview-btn" class="bg-blue-600 text-white font-bold py-2 px-8 rounded-lg hover:bg-blue-700">大会を始める</button>
        </div>
    </div>
</div>

<div id="new-thread-modal" class="new-thread-modal hidden">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">新規スレッド作成</h3>
        <div class="space-y-4">
            <div>
                <label for="new-thread-title" class="block text-sm font-medium text-gray-700">スレッドタイトル</label>
                <input type="text" id="new-thread-title" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="例：〇〇高校の鈴木、ガチで天才すぎる">
            </div>
            <div>
                <label for="new-thread-comment" class="block text-sm font-medium text-gray-700">本文 (>>1)</label>
                <textarea id="new-thread-comment" rows="6" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" placeholder="例：1回戦のピッチング見たか？あれは本物だわ..."></textarea>
            </div>
        </div>
        <div class="mt-6 text-center border-t pt-4">
            <button id="new-thread-submit" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 mr-4">
                スレを立てる
            </button>
            <button id="new-thread-cancel" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-400">
                キャンセル
            </button>
        </div>
    </div>
</div>

<div id="help-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
        <h3 class="text-xl font-bold mb-4 text-center border-b pb-3">AI記者付きトーナメント表 取扱説明書 (Ver. 秋/春対応版)</h3>
        <div class="overflow-y-auto space-y-6 flex-grow pr-4 text-gray-700">

            <div>
                <h4 class="font-bold text-lg text-blue-700 mb-2">はじめに：あなただけの高校野球史を創る</h4>
                <p class="text-sm">
                    このシミュレーターの目的は、単に試合の勝ち負けを決めることではありません。あなたの采配や入力した詳細な試合内容に基づき、AIがリアルタイムで「ニュース記事」「掲示板の反応」「まとめサイト風スレッド」、時には「密着ドキュメンタリー」を生成します。夏の甲子園、秋の新チーム、春の選抜へと続く一年間のドラマを通じて、あなただけの唯一無二の高校野球の歴史を創り上げ、その目撃者となることが、このゲームの最大の醍醐味です。
                </p>
            </div>

            <div>
                <h4 class="font-bold text-lg text-blue-700 mb-2">基本的なゲームの流れ</h4>
                <ol class="list-decimal list-inside space-y-2 text-sm">
                    <li><strong>トーナメント開始:</strong> 「新しいトーナメントを開始」ボタンでゲームを始めます。初回は夏の静岡県大会からスタートします。抽選会イベントを経て、組み合わせが決定されます。</li>
                    <li><strong>スコア入力:</strong> トーナメント表の各試合カードに、半角数字で最終スコアを入力します。</li>
                    <li><strong>勝者決定:</strong> スコア入力後、勝った方のチームの青い「▶」ボタンを押します。</li>
                    <li><strong>AIコンテンツ生成:</strong> 勝者が決まると、AIが自動で試合に関する「ニュース記事」や「掲示板の反応」を生成します。（設定でON/OFF可能）</li>
                    <li><strong>詳細入力 (任意・推奨):</strong> 試合カードの「詳細入力」ボタンから、イニングスコアや個人成績を入力すると、AIが生成する物語のリアリティと深みが格段に向上します。</li>
                    <li><strong>大会進行:</strong> 全ての試合が終了すると、優勝チームが決定します。夏の大会終了後は自動的に秋の大会へ、秋の後は春へ、春の後は次の年の夏へと進みます。</li>
                    <li><strong>セーブ＆ロード:</strong> 「セーブ」ボタンでいつでも進行状況を「合い言葉」として保存できます。「再開」ボタンから「合い言葉」を入力すれば、中断したところから再開できます。</li>
                </ol>
            </div>

            <div>
                <h4 class="font-bold text-lg text-orange-700 mb-2">【重要】一年間の大会サイクルとルール</h4>
                <p class="text-sm mb-3">
                    この世界では、高校野球の一年間（夏→秋→春）が自動で進行します。各大会には異なる目的とルールがあり、それぞれが次の大会のシード権などに影響します。
                </p>
                <div class="space-y-4">
                    <div class="p-4 border rounded-lg bg-yellow-50">
                        <h5 class="font-semibold text-gray-800">夏の大会 (甲子園への道)</h5>
                        <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                            <li>3年生にとって最後の大会。64校による一発勝負のトーナメント。</li>
                            <li>春季大会のベスト8がシード校となります。</li>
                            <li>優勝校は夏の甲子園に出場したとみなされ、AIがその全国での戦績（例: 全国ベスト8、甲子園初戦敗退など）を自動でシミュレートし、記録します。</li>
                            <li>大会前には組み合わせ抽選会イベントが発生します。</li>
                        </ul>
                    </div>

                    <div class="p-4 border rounded-lg bg-purple-50">
                        <h5 class="font-semibold text-gray-800">秋の大会 (新チーム始動・センバツへの序章)</h5>
                        <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                            <li>1,2年生の新チームで挑む最初の公式戦。</li>
                            <li>まず、東部・中部・西部・伊豆の4地区に分かれて地区予選を行います。
                                <div class="mt-2 mb-2 p-2 bg-purple-100 rounded text-xs border border-purple-300">
                                    <p class="font-semibold mb-1">地区予選の仕組み:</p>
                                    <p class="mb-1"><strong>東部・中部・西部地区 (各5枠):</strong></p>
                                    <pre class="whitespace-pre-wrap leading-tight">
[地区20チーム]
    │
    ├─▶ [ブロックA (5)] ─▶ 優勝 (県) / 準優勝 ┐
    ├─▶ [ブロックB (5)] ─▶ 優勝 (県) / 準優勝 ┤
    ├─▶ [ブロックC (5)] ─▶ 優勝 (県) / 準優勝 ┼─▶ [第5代表決定戦 (4)] ─▶ 優勝 (県)
    └─▶ [ブロックD (5)] ─▶ 優勝 (県) / 準優勝 ┘   (敗者復活)</pre>
                                    <p class="mt-1"><strong>伊豆地区 (1枠):</strong></p>
                                    <pre class="whitespace-pre-wrap leading-tight">[伊豆4チーム] ─▶ [トーナメント] ─▶ 優勝 (県)</pre>
                                </div>
                            </li>
                            <li>各地区予選を勝ち抜いた計16チームが県大会本戦 (トーナメント) に進出します。
                                <div class="mt-2 mb-2 p-2 bg-purple-100 rounded text-xs border border-purple-300">
                                    <p class="font-semibold mb-1">県大会本戦 (16チーム):</p>
                                    <pre class="whitespace-pre-wrap leading-tight">
    ┌─ 東部代表 (5) ┐
    ├─ 中部代表 (5) ┤
    ├─ 西部代表 (5) ┼─▶ [県大会 (16チームT)] ─▶ 優勝/準優勝 (センバツ有力)
    └─ 伊豆代表 (1) ┘                       └─▶ ベスト8以上 (春季シード)</pre>
                                </div>
                            </li>
                            <li>県大会の**優勝・準優勝校**は、春のセンバツ甲子園への出場権を得る可能性があります（AIが確率で判定）。</li>
                            <li>県大会ベスト8以上の成績を収めると、次の**春季大会のシード権**を獲得できます。</li>
                        </ul>
                    </div>

                    <div class="p-4 border rounded-lg bg-green-50">
                        <h5 class="font-semibold text-gray-800">春の大会 (夏のシード権獲得戦)</h5>
                        <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                            <li>夏の大会の前哨戦となる重要な大会。</li>
                            <li>秋季大会ベスト8のチームはシード校となり、県大会2回戦から登場します。</li>
                            <li>それ以外の全チームは、まず地区予選に参加し、各地区代表枠 (東5, 中5, 西5, 伊豆1) を争います。</li>
                            <li>地区予選を突破した16チームが、県大会1回戦で対戦します。</li>
                            <li>1回戦の勝者8チームが、2回戦で待つシード8チームと対戦します（計16チームによる本戦トーナメント）。</li>
                            <li>この大会で**ベスト8**以上の成績を収めると、次の**夏の大会のシード権**を獲得できます。
                                <div class="mt-2 mb-2 p-2 bg-green-100 rounded text-xs border border-green-300">
                                    <p class="font-semibold mb-1">県大会の仕組み:</p>
                                    {/* Mermaid Diagram Code Block - Requires Mermaid.js library */}
                                    <pre><code class="language-mermaid">
graph TD
    subgraph 県大会
        R1[1回戦 (予選突破16チーム)] --> |勝者8チーム| R2
        subgraph 本戦トーナメント
            S[シード8チーム (秋ベスト8)] --> R2{2回戦 (16チーム)}
            R2 --> QF{準々決勝 (ベスト8)}
            QF --> SF{準決勝 (ベスト4)}
            SF --> F{決勝}
        end
        QF --▶ |夏のシード権獲得| SumSeed(夏の大会シード権)
    end

    subgraph 地区予選
        O[シード以外のチーム] --> RegQ{地区予選}
        RegQ --> |16チーム| R1
    end

    style S fill:#f9f,stroke:#333,stroke-width:2px
    style SumSeed fill:#ccf,stroke:#333,stroke-width:2px
                                    </code></pre>
                                    <p class="mt-1 text-gray-500">(図の説明) シード校は2回戦から登場。地区予選突破組は1回戦から戦い、勝ち上がるとシード校と対戦。ベスト8以上で夏のシード権獲得。</p>
                                </div>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>

            <div>
                <h4 class="font-bold text-lg text-teal-700 mb-2">【最重要】詳細入力：物語を深化させる鍵</h4>
                <p class="text-sm mb-3">
                    試合結果のスコアだけでなく、「詳細入力」を行うことで、AIが生成する記事やコメントの質が劇的に向上し、より深みのある物語が生まれます。面倒でも、ぜひ入力してみてください。
                </p>
                <ul class="list-disc list-inside space-y-2 text-sm bg-teal-50 p-4 rounded-lg">
                    <li><strong>イニングスコア:</strong> 試合展開をAIに伝えます。「初回に大量得点した試合」と「9回に逆転サヨナラした試合」では、生成される記事のドラマ性が全く異なります。延長戦は「+回」ボタンで追加できます。</li>
                    <li><strong>打撃成績:</strong>
                        <ul class="list-circle list-inside ml-4 text-xs">
                            <li>**打席結果:** プルダウンから結果・方向・打点などを選択します。1イニングに複数打席あった場合は「+2打席目を追加」で入力できます。</li>
                            <li>**走塁:** 「+走者プレーを追加」で盗塁、進塁、走塁死などを入力できます。</li>
                            <li>**出場:** 代打・代走・守備交代などの情報は、交代選手の活躍を描写する上で重要です。</li>
                            <li>AIはここでの入力に基づき、その試合のヒーローを特定し、記事の中心人物として描写します。</li>
                        </ul>
                    </li>
                    <li><strong>投手成績:</strong> 投手名、投球回、失点、奪三振などを入力します。先発完投、リリーフ成功、炎上など、投手の活躍や苦闘が記事に反映されます。「+投手を追加」で継投も記録できます。</li>
                    <li><strong>試合の決め手 (トーナメント表のテキストエリア):</strong> スコア入力欄の下にある小さなテキストエリアです。ここに**最も伝えたい試合のハイライト**（例：「エース〇〇、気迫の150球完投勝利」「伏兵△△のサヨナラ打」など）を簡潔に入力すると、AIは他のどの情報よりもこれを**最優先**し、記事全体のテーマとして扱います。</li>
                </ul>
                <p class="text-xs mt-2 text-gray-600">※詳細入力画面の「先攻・後攻を入れ替え」ボタンで、入力内容ごとチームを入れ替えられます。</p>
                <p class="text-xs mt-1 text-gray-600">※スコア入力欄の横にある「🎲」ボタンで、現在のスコアに基づいてAIがおまかせで詳細内容を自動生成することも可能です。</p>
            </div>

            <div>
                <h4 class="font-bold text-lg text-indigo-700 mb-2">AIが生成するコンテンツ</h4>
                <ul class="list-disc list-inside space-y-2 text-sm">
                    <li><strong>ニュース記事:</strong> 試合結果や大会の展望、時にはスキャンダル疑惑(!)など、様々な記事が自動生成されます。「本文」ボタンで内容を読めます。記事にカーソルを合わせると表示される「再生成」ボタンから、AIに追加指示を与えて記事を書き直させることも可能です（フィードバック機能）。</li>
                    <li><strong>掲示板の反応:</strong> AIが匿名掲示板のファンになりきり、試合結果やニュースに対してリアルなコメントを生成します。あなたもコメントを投稿でき、AIファンがそれに返信してくれます。</li>
                    <li><strong>まとめサイト風スレッド:</strong> 「📰 まとめ」ボタンからアクセスできるモーダル内で、現実のニュースとゲーム内の試合結果が混在した、なんJまとめサイト風の表示が楽しめます。各記事をクリックすると、その話題に関するAI生成の掲示板スレッドを読むことができます。</li>
                    <li><strong>ナムコグループニュース:</strong> 系列校（765総合、283学園など）の試合結果や組み合わせに関する、企業公式発表風のお知らせが表示されることがあります。</li>
                    <li><strong>スポーツ新聞:</strong> 大会が進むと（準々決勝以降）、AIがその日のハイライトを一面記事にしたスポーツ新聞風のコンテンツを生成することがあります。「新聞を読む」ボタンで表示できます。</li>
                    <li><strong>密着ドキュメンタリー:</strong> 特定のチーム（強豪、古豪、逆境校など）に焦点を当てたドキュメンタリー記事が生成されることがあります。試合の勝敗に応じて連載形式で物語が進行します。</li>
                </ul>
            </div>

             <div>
                <h4 class="font-bold text-lg text-pink-700 mb-2">その他の機能</h4>
                <ul class="list-disc list-inside space-y-2 text-sm">
                    <li><strong>チームステータス:</strong> トーナメント表のチーム名をクリックすると、そのチームの過去の最高成績や直近の成績、獲得した称号（例：ジャイアントキラー）などを確認できます。</li>
                    <li><strong>スキップ機能:</strong> 各大会やラウンドごとに用意された「スキップ」ボタンを使うと、試合結果を自動で（ランク差などを考慮して）生成し、大会を高速で進行させることができます。</li>
                    <li><strong>設定:</strong> 画面右上の「⚙️ 設定」ボタンから、ニュース記事や掲示板コメントの自動生成をON/OFFできます。</li>
                    <li><strong>抽選会/勢力図分析:</strong> 夏の大会開始時には抽選会イベントが、抽選後には各ブロックの勢力図をAIが分析・解説するアニメーションが表示されます。</li>
                 </ul>
            </div>

            <div>
                <h4 class="font-bold text-lg text-red-700 mb-2">トラブルシューティング</h4>
                <ul class="list-disc list-inside space-y-2 text-sm">
                    <li><strong>エラーで動作がおかしくなった / クラッシュする:</strong> 最も多い原因は、ブラウザに保存されている古いセーブデータと、最新版のゲームコードの間で矛盾が生じていることです。**「リセット」ボタンを押して一度完全にデータを消去してから**「新しいトーナメントを開始」すると解決することがほとんどです。開発中の仕様変更後は特にリセットをお試しください。</li>
                    <li><strong>AIの記事やコメントがおかしい / 事実と違う:</strong> AIに与える情報が不足しているか、AIが稀に勘違いをしている可能性があります。
                        <ul class="list-circle list-inside ml-4 text-xs">
                            <li>記事の場合は、「再生成」ボタンからフィードバックを与えてみてください。</li>
                            <li>思ったような記事にならない場合、詳細入力でより多くの情報（特に敗れたチームの成績や、活躍した選手名）を具体的に入力したり、「試合の決め手」欄を活用したりすると改善されることがあります。</li>
                        </ul>
                    </li>
                     <li><strong>セーブデータ（合い言葉）が読み込めない:</strong> コードが更新されると、古いバージョンの合い言葉は読み込めなくなる場合があります。ご了承ください。</li>
                </ul>
            </div>

       </div> <div id="tournament-animation-section" class="mt-6 border-t pt-4">

                <h4 class="font-bold text-lg text-purple-700 mb-3 text-center">図解アニメーションで見る大会システム</h4>

                <div class="flex justify-center space-x-4 mb-4">

                    <button id="show-autumn-anim-btn" class="bg-purple-500 text-white px-4 py-2 rounded hover:bg-purple-600">🍂 秋季大会を見る</button>

                    <button id="show-spring-anim-btn" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">🌸 春季大会を見る</button>

                </div>

                <div id="animation-stage" class="bg-gray-100 p-4 rounded min-h-[300px] border relative overflow-hidden flex flex-col justify-center items-center">

                    <p id="anim-placeholder" class="text-gray-500">上のボタンを押してアニメーションを開始</p>

                </div>

                <p id="animation-narration" class="mt-3 text-center text-sm font-semibold h-10"></p>

                <div class="flex justify-center space-x-4 mt-3">

                    <button id="prev-step-btn" class="bg-gray-400 text-white px-4 py-1 rounded hover:bg-gray-500 disabled:opacity-50" disabled>＜ 前へ</button>

                    <button id="next-step-btn" class="bg-blue-500 text-white px-4 py-1 rounded hover:bg-blue-600 disabled:opacity-50" disabled>次へ ＞</button>

                </div>

            </div>

            </div> <div class="mt-6 text-center border-t pt-4">

            <button id="help-modal-close" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg">閉じる</button>

        </div>

    </div> </div>

<div id="player-stats-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[170]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 class="text-xl font-bold text-gray-800">個人通算成績</h3>
            <button id="player-stats-modal-close" class="text-gray-400 hover:text-gray-600 text-3xl">&times;</button>
        </div>
        
        <div id="player-stats-modal-body" class="overflow-y-auto flex-grow space-y-6 p-2">
            <div class="loader text-center py-16">選手データを読み込み中...</div>
        </div>
    </div>
</div>

<div id="team-stats-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[170]">
    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-5xl max-h-[90vh] flex flex-col">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 id="team-stats-modal-title" class="text-2xl font-bold text-gray-800">（チーム名） 通算成績</h3>
            <button id="team-stats-modal-close" class="text-gray-400 hover:text-gray-600 text-3xl">&times;</button>
        </div>
        
        <div id="team-stats-modal-body" class="overflow-y-auto flex-grow p-2">
            <div class="flex border-b mb-4 sticky top-0 bg-white z-10">
                <button class="team-stats-tab-btn active" data-tab="stats">
                    通算成績
                </button>
                <button class="team-stats-tab-btn" data-tab="lineups">
                    試合別スタメン
                </button>
            </div>

            <div id="team-stats-tab-content-stats" class="team-stats-tab-content space-y-6">
                <div class="loader text-center py-16">選手データを読み込み中...</div>
            </div>
            
            <div id="team-stats-tab-content-lineups" class="team-stats-tab-content hidden space-y-4">
                <div class="loader text-center py-16">スタメン履歴を読み込み中...</div>
            </div>
        </div>
        
    </div>
</div>

<div id="team-status-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center z-50">


    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md max-h-[90vh] flex flex-col">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 id="status-modal-team-name" class="text-2xl font-bold text-gray-800"></h3>
            <button id="status-modal-close" class="text-gray-400 hover:text-gray-600">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        
        <div class="space-y-4 overflow-y-auto pr-2">
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">最高戦績</h4>
                <p id="status-modal-best" class="text-lg text-amber-600 font-bold"></p>
            </div>
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">直近の成績</h4>
                <div id="status-modal-history" class="space-y-1 text-gray-700"></div>
            </div>
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">称号</h4>
                <div id="status-modal-traits" class="flex flex-wrap gap-2"></div>
            </div>
            
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider mb-2">今大会 チームチャート</h4>
                <div id="team-chart-container" class="relative" style="height: 300px;">
                    <canvas id="team-radar-chart"></canvas>
                </div>
            </div>
            
            <div class="mt-4">
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">今大会 チーム成績 (数字)</h4>
                <p id="status-modal-team-stats" class="text-lg text-blue-700 font-bold"></p>
            </div>

<div class="mt-6">
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider border-b pb-1 mb-2 flex items-center">
                    <span>📊 セイバーメトリクス詳細分析</span>
                    <span class="ml-auto text-xs bg-gray-200 text-gray-600 px-2 py-0.5 rounded">Beta</span>
                </h4>
                <div id="status-modal-sabermetrics">
                    </div>
            </div>

            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">チーム通算成績 (全大会)</h4>
                <p id="status-modal-career-stats" class="text-lg text-gray-800 font-bold"></p>
            </div>
            
            <div>
                <h4 class="font-semibold text-sm text-gray-500 uppercase tracking-wider">監督</h4>
                <div id="status-modal-coach" class="text-gray-700"></div>
            </div>

<div id="status-modal-homepage-link-container" class="mt-6 border-t pt-4 text-center hidden">
                <a id="status-modal-homepage-link" class="inline-block bg-blue-700 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-800 transition-colors cursor-pointer">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5 inline-block -mt-1 mr-2">
                        <path d="M12.232 4.232a2.5 2.5 0 0 1 3.536 3.536l-1.225 1.224a.75.75 0 0 0 1.061 1.06l1.224-1.224a4 4 0 0 0-5.656-5.656l-3 3a4 4 0 0 0 .225 5.865.75.75 0 0 0 .977-1.138 2.5 2.5 0 0 1-.142-3.665l3-3Z" />
                        <path d="M8.603 17.39a4 4 0 0 0 5.656-5.656l-3-3a4 4 0 0 0-.225-5.865.75.75 0 0 0-.977 1.138 2.5 2.5 0 0 1 .142 3.665l-3 3a2.5 2.5 0 0 1-3.536-3.536l1.225-1.224a.75.75 0 0 0-1.061-1.06l-1.224 1.224a4 4 0 0 0 5.656 5.656Z" />
                    </svg>
                    公式ホームページへ
                </a>
            </div>

        </div>
        
    </div>
</div>

<div id="sns-modal" class="fixed inset-0 bg-black bg-opacity-40 hidden items-center justify-center z-[250]">
    <div class="sns-modal-content h-[80vh] flex flex-col">
        <div class="sns-header flex justify-between items-center">
            <h3 class="text-xl font-bold">トレンド</h3>
            <button id="sns-modal-close" class="text-2xl text-gray-600 hover:bg-gray-200 rounded-full w-8 h-8 flex items-center justify-center">&times;</button>
        </div>
        
        <div class="flex border-b border-gray-200">
            <button class="flex-1 py-3 font-bold hover:bg-gray-100 border-b-4 border-blue-500 text-gray-900" id="sns-tab-trend">おすすめ</button>
            <button class="flex-1 py-3 font-bold text-gray-500 hover:bg-gray-100" id="sns-tab-timeline">最新</button>
        </div>

        <div id="sns-content-area" class="overflow-y-auto flex-grow bg-white">
            </div>
    </div>
</div>

<div id="trend-notification">
    <span class="text-xl">📈</span>
    <div>
        <p class="text-xs opacity-90">日本のトレンド</p>
        <p id="trend-notification-word" class="font-bold">#283学園</p>
    </div>
</div>


<script type="module">

const BATTING_RESULTS = {
    hits: ['安', '二塁打', '三塁打', '本塁打'],
    outs: ['三振', 'ゴロ', '飛', '邪', '直', '併殺'],
    walks: ['四球', '死球', '敬遠'],
    sacrifices: ['犠打', '犠飛', '犠失'], // ← ここに追加
    other: ['野選', 'エラー']
};
const DIRECTIONS = ['投', '捕', '一', '二', '三', '遊', '左', '中', '右'];
const RBIS = ['1点', '2点', '3点', '4点'];

    // --- ライバル関係と称号の定義 ---
    const RIVALRIES = [
        { teams: ["静岡", "掛川西"], type: "公立の覇権争い" },
        { teams: ["283学園", "静岡商業"], type: "伝統と王者の覇権対決" },
        { teams: ["765総合高校", "静岡"], type: "新旧王者対決" },
        { teams: ["静岡", "静岡商業"], type: "伝統の一戦" }
    ];
    const TITLES = {
        GIANT_KILLER: { id: 'giant_killer', name: 'ジャイアントキラー', desc: '格上の強豪校を倒した実績を持つ。' },
        REPECHAGE_KING: { id: 'repechage_king', name: '不屈の敗者復活組', desc: '敗者復活戦から這い上がってきた実績があり、非常に粘り強い。' },
        WALL_OF_TOKYO: { id: 'wall_of_tokyo', name: '西東京の壁', desc: '西東京地区に立ちはだかる絶対的強者。' } // 例
    };
const tournamentNameMap = { summer: '夏季大会', autumn: '秋季大会', spring: '春季大会' };


// ▼▼▼ このブロックをまるごと置き換える ▼▼▼
const SCANDAL_DEFINITIONS = [
    {
        id: 'overpractice',
        condition: (teamName) => ['A', 'B'].includes(calculateRank(teamName, tournamentState)),
        
        // 文字列から関数に変更
        rumorTitle: (teamName) => `【週刊熱闘】${teamName}に「違法練習」疑惑か？`,
        rumorBody: (teamName) => `強豪として知られる${teamName}だが、その強さの裏には、高校野球連盟が定める練習時間規定を大幅に超過するほどの猛練習があるというタレコミが本誌に寄せられた。深夜までバットの音が鳴り響くという近隣住民の証言もあり、今後の動向が注目される。`,
        
        consequences: {
            report: {
                // こちらも同様に関数に変更
                outcomeTitle: (teamName) => `【速報】${teamName}、練習規定違反で公式戦を辞退`,
                outcomeBody: (teamName) => `先日、週刊誌で報じられた${teamName}の練習時間規定違反問題で、高野連は調査の結果、違反の事実を認定。同校は事態を重く受け止め、今大会の残り試合を辞退することを発表した。`,
                applyEffect: (teamName, state) => {
        if (state.teamRecords[teamName]) {
            state.teamRecords[teamName].penalty = 'forfeit';
        }

        const currentMatch = findCurrentMatchForTeam(teamName, state);
        if (!currentMatch) return; // 該当する試合がなければ何もしない

        const opponent = currentMatch.team1 === teamName ? currentMatch.team2 : currentMatch.team1;

        // 相手がいない場合（シードなど）は、単に負け扱いにする
        if (!opponent) {
            currentMatch.winner = `(不戦敗)`;
            currentMatch.team1 = teamName;
            currentMatch.team2 = null;
            return;
        }

        // 不戦勝として試合結果を記録
        currentMatch.winner = opponent;
        currentMatch.summary = `${teamName}の不祥事による不戦勝`;

        if (currentMatch.team1 === opponent) {
            currentMatch.score1 = 'W'; // Win
            currentMatch.score2 = 'L'; // Lose
        } else {
            currentMatch.score1 = 'L';
            currentMatch.score2 = 'W';
        }

        // チーム記録を更新
        if(state.teamRecords[opponent]) state.teamRecords[opponent].wins++;
        if(state.teamRecords[teamName]) state.teamRecords[teamName].losses++;
        
        // 勝者を次のラウンドへ自動で進める
        advanceWinnerToNextRound(currentMatch, opponent, state);
    }
            },
            ignore: {
                outcomeTitle: (teamName) => `${teamName}の練習問題、高野連は「事実確認できず」`,
                outcomeBody: (teamName) => `先日、一部週刊誌で報じられた${teamName}の練習時間に関する疑惑に対し、高野連は「現時点で違反の事実は確認できなかった」と発表。噂は噂のまま、球児たちの夏は続く。`,
                applyEffect: (teamName, state) => { /* 何もしない */ }
            }
        }
    }
];
// ▲▲▲ ここまで置き換え ▲▲▲
    // --- DOM Elements ---
    const setupEl = document.getElementById('setup');
    const tournamentDisplayEl = document.getElementById('tournament-display');
    const teamsTextarea = document.getElementById('teams-list');
    const generateBtn = document.getElementById('generate-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const resetBtn = document.getElementById('reset-btn');
    const nextTournamentBtn = document.getElementById('next-tournament-btn');
    const saveBtn = document.getElementById('save-btn');
    const mainBracketContainer = document.getElementById('main-bracket-container');
    const mainBracketWrapper = document.getElementById('main-bracket-wrapper');
    const newsContainer = document.getElementById('news-articles');
    const bbsCommentsContainer = document.getElementById('bbs-comments');
    const daiyaBbsSection = document.getElementById('daiya-bbs-section');
    const daiyaBbsCommentsContainer = document.getElementById('daiya-bbs-comments');
    const namcoNewsSection = document.getElementById('namco-news-section');
    const namcoNewsContent = document.getElementById('namco-news-content');
    const tournamentYearDisplay = document.getElementById('tournament-year-display');

    let skipR1Btn = document.getElementById('skip-r1-btn');
    let skipR2Btn = document.getElementById('skip-r2-btn');
    let skipR3Btn = document.getElementById('skip-r3-btn');
    let skipR4Btn = document.getElementById('skip-r4-btn');
    let skipR5Btn = document.getElementById('skip-r5-btn');
    let skipR6Btn = document.getElementById('skip-r6-btn'); // ★ 新規追加
    let skipFinalBtn = document.getElementById('skip-final-btn');
    let generateSummaryBtn = document.getElementById('generate-summary-btn');
    let skipLoader = document.getElementById('skip-loader');

    // Autumn Tournament UI
    const autumnRegionalContainer = document.getElementById('autumn-regional-blocks-container');
    const autumnRankingContainer = document.getElementById('autumn-ranking-playoffs-container');
    const autumnControls = document.getElementById('autumn-controls');
    const startRankingPlayoffsBtn = document.getElementById('start-ranking-playoffs-btn');
    const startMainTournamentBtn = document.getElementById('start-main-tournament-btn');
// ▼▼▼ ここから3行追加 ▼▼▼
const skipAutumnBlocksBtn = document.getElementById('skip-autumn-blocks-btn');
const skipAutumnRankingBtn = document.getElementById('skip-autumn-ranking-btn');
const skipAutumnMainBtn = document.getElementById('skip-autumn-main-btn');
// ▲▲▲ ここまで追加 ▲▲▲
// ▼▼▼ ここから3行追加 ▼▼▼
const skipSpringQualifiersBtn = document.getElementById('skip-spring-qualifiers-btn');
const skipSpringRound1Btn = document.getElementById('skip-spring-round1-btn');
const skipSpringMainBtn = document.getElementById('skip-spring-main-btn');
// ▲▲▲ ここまで追加 ▲▲▲
    // Modals
    const newsModal = document.getElementById('news-modal');
    const modalBg = document.getElementById('modal-bg');
    const modalClose = document.getElementById('modal-close');
    const confirmModal = document.getElementById('confirm-modal');
    const detailsModal = document.getElementById('details-modal');
    const saveLoadModal = document.getElementById('save-load-modal');
    const saveTabBtn = document.getElementById('save-tab-btn');
    const loadTabBtn = document.getElementById('load-tab-btn');
    const saveTabContent = document.getElementById('save-tab-content');
    const loadTabContent = document.getElementById('load-tab-content');
    const generateSaveCodeBtn = document.getElementById('generate-save-code-btn');
    const loadFromCodeBtn = document.getElementById('load-from-code-btn');
    const saveLoadCloseBtn = document.getElementById('save-load-close');
    const copySaveCodeBtn = document.getElementById('copy-save-code-btn');
    const newspaperModal = document.getElementById('newspaper-modal');
    const newspaperModalBody = document.getElementById('newspaper-modal-body');
    const newspaperCloseBtn = document.getElementById('newspaper-close');

    
    // --- State Management ---
    let tournamentState = {};
    let currentMatchIdForDetails = null;
    let articleForRegeneration = null; 
    let soundEffects = {};
let currentBlock = 'A';
let activeAnalysisMode = 'CONTRIBUTION';

    const UNDERDOG_TEAMS = ["虎府島総合", "浜松特支", "川根", "伊豆総合", "湖西", "小山", "新居", "熱海", "伊豆中央", "島田", "島田工業", "裾野"];
    const POWERHOUSE_TEAMS = ["283学園", "常葉菊川", "静岡", "掛川西", "静岡商業", "聖隷クリストファー", "765総合高校"];
　　const POWERHOUSE_REVIVAL_TEAMS = ["浜松商業", "静清", "飛龍"];
　　const ONE_MAN_TEAMS = ["富士宮北"];

// ▼▼▼ このオブジェクトで、既存のSoundManagerを完全に置き換えてください ▼▼▼
// ▼▼▼ サウンド管理システム ▼▼▼
// ▼▼▼ サウンド管理システム（ローカルファイル対応・最終完成版）▼▼▼
// ▼▼▼ BGM管理に特化した新しいサウンドマネージャー ▼▼▼
// ▼▼▼ BGMの音量調整機能付きサウンドマネージャー ▼▼▼
const SoundManager = {
    bgm: null,
    isReady: false,
    volume: 0.07, // BGMの音量を設定 (0.0がミュート, 1.0が最大)

    init() {
        this.bgm = document.getElementById('lottery-bgm');
        
        const unlockAudio = () => {
            if (!this.isReady && this.bgm) {
                this.isReady = true;
                this.bgm.volume = this.volume; // 初期音量を設定
                this.bgm.play().catch(e => console.error("BGM unlock failed:", e));
                this.bgm.pause();
                console.log("BGM ready.");
            }
            document.body.removeEventListener('click', unlockAudio);
        };
        
        document.body.addEventListener('click', unlockAudio, { once: true });
    },

    startBgm() {
        if (this.isReady && this.bgm) {
            this.bgm.volume = this.volume; // 再生前に音量を設定
            this.bgm.currentTime = 0;
            this.bgm.play().catch(e => console.error("BGM play failed:", e));
        }
    },

    stopBgm() {
        if (this.bgm) {
            this.bgm.pause();
            this.bgm.currentTime = 0;
        }
    }
};
// ▲▲▲
// ▲▲▲
// ▲▲▲ ▲▲▲
// ▲▲▲

    // ▼▼▼ 100種類の日本の苗字リスト ▼▼▼
const JAPANESE_SURNAMES = [
    "佐藤", "鈴木", "高橋", "田中", "伊藤", "渡辺", "山本", "中村", "小林", "加藤",
    "吉田", "山田", "佐々木", "山口", "松本", "井上", "木村", "林", "斎藤", "清水",
    "山崎", "森", "池田", "橋本", "阿部", "石川", "山下", "中島", "石井", "小川",
    "前田", "岡田", "長谷川", "藤田", "後藤", "村上", "近藤", "坂本", "遠藤", "青木",
    "藤井", "西村", "三浦", "岡本", "松田", "中川", "中野", "原田", "小野", "田村",
    "竹内", "金子", "和田", "中山", "石田", "上田", "森田", "原", "柴田", "酒井",
    "工藤", "横山", "宮崎", "宮本", "内田", "高木", "安藤", "谷口", "大野", "丸山",
    "今井", "高田", "藤原", "武田", "松井", "杉山", "村田", "大塚", "千葉", "岩崎",
    "桜井", "野口", "松尾", "菊地", "野村", "新井", "渡部", "佐野", "安田", "宮田",
    "小島", "大西", "杉本", "市川", "古川", "久保", "川崎", "飯田", "中田", "堀"
];

// ▼▼▼ このブロックを「新規追加」(11984行目あたり) ▼▼▼
const FACILITY_DATA = {
    "ground": {
        title: "メイングラウンド",
        text: "甲子園と同じ黒土と天然芝を使用。両翼100m、センター122mの広さを誇り、ナイター設備も完備しています。",
        imgSrc: "https://images.unsplash.com/photo-1515512210878-38904790e8c7?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&q=80&w=1080"
    },
    "dome": {
        title: "屋内練習場「TSUBASA DOME」",
        text: "天候に左右されない全天候型ドーム。ブルペン4箇所、フリーバッティング3箇所を完備し、雨の日でも実戦的な練習が可能です。",
        imgSrc: "https://images.unsplash.com/photo-1578899653835-34a162d355e0?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&q=80&w=1080"
    },
    "data-lab": {
        title: "データ解析室",
        text: "天井監督のID野球の心臓部。全選手の投球・打撃フォームを常時モニタリングし、AIによる分析がリアルタイムで行われます。",
        imgSrc: "https://images.unsplash.com/photo-1551288049-bebda4e38f71?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&q=80&w=1080"
    }
};

// ▲▲▲ 置き換えここまで ▲▲▲
// ▼▼▼ このブロックをまるごと「新規追加」(1191行目あたり、JAPANESE_SURNAMES の下など) ▼▼▼
const TEAM_ROSTER_MASTER = {
    "283学園": [
        // --- スタメン (不動のオーダー) ---
        { number: "6", name: "十王", grade: 3, position: "遊撃手", throwBat: "R/L", height: 176, weight: 70, origin: "名古屋ドリームス", desc: "切り込み隊長。高い出塁率と華麗な守備でチームに勢いをもたらす不動の1番ショート。", 
          isCaptain: true },
        { number: "4", name: "樋口", grade: 3, position: "二塁手", throwBat: "R/R", height: 170, weight: 68, origin: "静岡葵中学", desc: "最強の2番打者。小技だけでなく長打もあり、十王とのコンビは県内最強の二遊間。" },
        { number: "9", name: "花海咲", grade: 3, position: "右翼手", throwBat: "L/L", height: 178, weight: 75, origin: "北海道シニア",  desc: "頼れる3番・主将。好機に滅法強く、妹の佑と共にクリーンナップの中核を担う。" },
        { number: "8", name: "花海佑", grade: 1, position: "中堅手", throwBat: "R/R", height: 177, weight: 73, origin: "北海道シニア", desc: "1年生にして4番に座る怪物。圧倒的な身体能力でグラウンドを支配する天才。" },
        { number: "7", name: "芹沢", grade: 2, position: "左翼手", throwBat: "R/S", height: 172, weight: 69, origin: "沼津シニア", desc: "5番に座る仕事人。両打ち（スイッチ）の器用さで、上位と下位をつなぐキーマン。" },
        { number: "1", name: "姫川", grade: 3, position: "投手", throwBat: "R/R", height: 182, weight: 80, origin: "大阪シニア", desc: "「6番・ピッチャー」の超攻撃的エース。150km超の剛球に加え、自らのバットで試合を決める。" },
        { number: "2", name: "有栖川", grade: 3, position: "捕手", throwBat: "R/L", height: 178, weight: 78, origin: "神奈川ボーイズ", desc: "恐怖の7番打者。強打の捕手として、下位打線からビッグイニングの起点を作る。" },
        { number: "5", name: "八宮", grade: 2, position: "三塁手", throwBat: "R/R", height: 175, weight: 72, origin: "浜松ボーイズ", desc: "意外性の男。8番に彼がいることで、相手投手は息つく暇がない。" },
        { number: "3", name: "鈴木", grade: 2, position: "一塁手", throwBat: "R/L", height: 181, weight: 85, origin: "愛知ボーイズ", desc: "ミート力のあるアベレージ型一塁手。9番から上位へ「第2のリードオフ」として繋ぐ。" },
        
        // --- 控え選手 ---
        { number: "10", name: "白瀬", grade: 3, position: "投手", throwBat: "R/R", height: 184, weight: 82, origin: "東京シニア", desc: "MAX155kmを誇るもう一人のエース。姫川とは対照的な剛腕クローザー。" },
        { number: "11", name: "黛", grade: 2, position: "投手", throwBat: "R/R", height: 180, weight: 76, origin: "富士シニア" },
        { number: "12", name: "福丸", grade: 2, position: "捕手", throwBat: "R/R", height: 176, weight: 77, origin: "焼津リトルシニア" },
        { number: "13", name: "田中", grade: 3, position: "内野手", throwBat: "R/R", height: 174, weight: 70, origin: "静岡服織中学" },
        { number: "14", name: "市川", grade: 2, position: "投手", throwBat: "L/L", height: 179, weight: 74, origin: "静岡蒲原中学" },
        { number: "15", name: "有村", grade: 1, position: "内野手", throwBat: "R/R", height: 173, weight: 67, origin: "福岡シニア" },
        { number: "16", name: "大崎", grade: 1, position: "外野手", throwBat: "R/L", height: 170, weight: 68, origin: "三島リトルシニア" },
        { number: "17", name: "風野", grade: 2, position: "内野手", throwBat: "R/R", height: 169, weight: 65, origin: "新潟シニア" },
        { number: "18", name: "西城", grade: 2, position: "投手", throwBat: "R/R", height: 183, weight: 81, origin: "広島ボーイズ" },
        { number: "19", name: "浅倉", grade: 1, position: "内野手", throwBat: "R/R", height: 168, weight: 64, origin: "長崎シニア" },
        { number: "20", name: "杜野", grade: 1, position: "外野手", throwBat: "L/L", height: 171, weight: 67, origin: "宮城シニア" }
    ]
};
// ▲▲▲ 置き換えここまで ▲▲▲
// ▲▲▲ 置き換えここまで ▲▲▲
// ▼▼▼ サウンド管理システム ▼▼▼

// ▲▲▲

// --- Team Master Data ---
    const TEAM_DATA = {
    "天竜": {
        name_yomi: "てんりゅう",
        region: "西部",
        type: "公立",
        deviation: 38,
        best: "県大会ベスト16",
        last: "県大会ベスト16",
        info: "創部3年目にしてベスト16入りを果たした期待の新興勢力。新任の志賀監督の下、挑戦者としてのびのびとプレーした昨年とは一転、今年は他校からのマークも厳しくなる。昨年の躍進がフロックでなかったことを証明できるか、真価が問われる夏となる。西部地域の学校からの甲子園での成績が乏しいため、突如現れた彗星に期待の声も多い。エースの三橋やリードオフマンの田島を筆頭に部員数は少ないながらも力のある選手も多い。チームとしての目標は昨年を超えるベスト8ではなく甲子園出場。西部地域の雄となるために、まずは今年、どこまで上位勢に食らいつけるかが正念場である。。",
        coach: { name: '志賀 剛', style: '育成上手', experience: '新任' }
    },
    "桐陽": {
        name_yomi: "とうよう",
        region: "東部",
        type: "私立",
        deviation: 80,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "元プロの元木監督を招聘し、強化に乗り出した新興私立。プロ流の厳しい練習はチーム内に軋轢も生んでいるが、個々の能力は飛躍的に向上しており、140km以上を計測する選手が6人もいるなど、そのポテンシャルは計り知れない。監督の指導方針がチームとして完全に噛み合った時、一気に大会の主役へ躍り出る可能性を秘めている。",
        coach: { name: '元木 大介', style: '積極打撃', experience: 'プロOB' }
    },
    "浜松商業": {
        name_yomi: "はままつしょうぎょう",
        region: "西部",
        type: "公立",
        deviation: 2,
        best: "甲子園優勝",
        last: "県大会2回戦",
        info: "30年前の甲子園優勝校として野球ファンの間では知名度のある高校。近年はナムコグループや新興私立の台頭により低迷しており、昔のような圧倒的な強さはないが、今もなお中堅レベルの実力校として虎視眈々と聖地を狙っている。輝かしい栄光を取り戻すべく、今大会での躍進に期待したいい。",
        coach: { name: '伊武 雅之', style: 'データ野球', experience: 'ベテラン' }
    },
    "初星学園": {
        name_yomi: "はつぼしがくえん",
        region: "中部",
        type: "私立",
        deviation: 110,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "全国で唯一アイドル科を持つ学校として知られている創立3年目のナムコグループ系列校。全国からアイドル科を目当てに受験する人も多く、学校としての注目度も高い。男女比では学校の特色も相まって驚異の8割が女子である。創部3年目の野球部としての設備はナムコグループ系列ということもあり整っており、直近の練習試合ではホームランも複数飛び出すなど、選手のポテンシャルも低くはない。練習ではアイドル科の生徒との合同トレーニングを組むこともあり、違う学科であれど、お互いアスリートの視点でアドバイスを送りあうなど学校の特色を活かした練習メニューもある。野球部で目立った実績はないが、アイドル科ではなく「野球の初星」と呼ばれるように躍進してほしい",
        coach: { name: '石川 実', style: '育成上手', experience: '中堅' }
    },
    "浜松特支": {
        name_yomi: "はままつとくし",
        region: "西部",
        type: "公立",
        deviation: 45,
        best: "なし",
        last: "なし",
        info: "創部一年目、全員1年生。県内初の試みとして、特別支援学校に設立された野球部。視覚障害、聴覚障害、知的障害、肢体不自由、病弱・身体虚弱の子どもを対象とした特別支援学校は、全国におよそ1100校ある。その中で高野連に加盟し、単独チームとして公式戦に出場しているのは、この浜松特別支援学校だけだ。部員たちは、野球のルールを覚えることや、仲間と声を掛け合うこと、その一つ一つが大きな挑戦だ。北村監督は、野球の技術以前に、彼らが野球というスポーツを心から楽しみ、自分を表現する喜びを知ってもらうにはどうすれば良いのか、答えのない問いに日々向き合っている。しかし、春の練習試合で今大会第一シードの283学園との招待試合で喫した『52-0』の大敗は、彼らから野球の楽しさを根こそぎ奪い去った。部室代わりの理科準備室には、彼らの野球ノートが置かれており、中を見ると「たのしくない」「こわい」といった文面が多く見受けられた。エラーをすれば下を向いて泣き出し、打席ではデッドボールを怖がって腰が引ける。そして、なにより知的障害を持った子が硬式野球を行うことについての安全性を問われる声が多々あった。北村監督は勝利ではなく『試合を成立させること』の絶望的な難しさに直面している。夏の目標は9回を戦い抜き、スコアボードに『0』以外の数字を灯すこと。それは甲子園出場よりも遥かに高く、そして切実な壁だ。",
        coach: { name: '北村 大輔', style: '全員野球', experience: '新任' }
    },
    "765総合高校": {
        name_yomi: "なむこそうごう",
        region: "中部",
        type: "私立",
        deviation: 95,
        best: "甲子園ベスト16",
        last: "県大会2回戦",
        info: "大手ナムコグループが母体となる、県内屈指の資金力と設備を誇る私立校。黒井監督の徹底した管理野球の下、個々の能力が高く、大崩れしない安定した戦いぶりが特徴。２年前には甲子園初出場も果たし、破竹の勢いでベスト16まで勝ち進み、一躍有名校となったのは記憶に新しいだろう。しかし昨年の夏は２回戦敗退、秋は初戦敗退、春も初戦敗退と苦しい時期が続いている。聖地を知るメンバーは今の3年生のみとなった今、逆襲を誓い再び甲子園を目指す。ノーシードではあるがその実力はシード校級であり今大会のダークホースと言っても過言ではないだろう",
        popularity: true,
        coach: { name: '黒井 崇男', style: '総合力', experience: 'ベテラン' }
    },
    "川根": {
        name_yomi: "かわね",
        region: "中部",
        type: "公立",
        deviation: 53,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "今年度限りでの閉校が決まっており、野球部にとってはこれが最後の夏となる。グラウンド脇では校舎の解体作業が進むという異例の環境だが、選手たちは動揺を見せず練習に打ち込む。監督・選手ともに大会終了後はそれぞれ別の道を歩むことになる。「母校の名を刻みたい」という想いは一つ。有終の美を飾るべく、チームの士気は非常に高い。",
        coach: { name: '鈴木 誠', style: '堅実', experience: 'ベテラン' }
    },
    "283学園": {
        name_yomi: "つばさがくえん",
        region: "西部",
        type: "私立",
        deviation: 80,
        best: "甲子園1回戦",
        last: "県優勝(甲子園初戦敗退)",
        info: "昨年度の県大会王者。愛称は「ツバガク」。エース白瀬、二刀流の姫川や十王、花海咲など１年次からのレギュラーメンバーを軸に投打のバランスが取れた強豪校。。しかし、初出場となった昨年の夏の甲子園では初戦の浦和学院戦に7-9で敗戦し涙を飲み、全国の壁を痛感した。新チームになってからは樋口や花海佑などの新戦力も台頭し、春の大会では圧倒的な戦いで優勝し、第１シードに君臨。名将・天井監督は、昨年の経験を糧に、県内連覇とその先の「全国での一勝」を見据える。王者としてのプレッシャーをはねのけ、再び頂点に立てるか注目が集まる。",
        popularity: true,
        coach: { name: '天井 努', style: 'ID野球', experience: '名将' }
    },
    "島田工業": {
        name_yomi: "しまだこうぎょう",
        region: "中部",
        type: "公立",
        deviation: 41,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "県内でも有数の工業高校で、部員の多くが技術職を目指している。実習などで練習時間が限られるハンデを、田中監督が叩き込む「根性野球」でカバー。最後まで諦めない粘り強さがチームの持ち味。スター選手は不在だが、一丸となった時の結束力は高く、強豪校にとってはやりにくい相手として知られる。。",
        coach: { name: '田中 鉄平', style: '根性野球', experience: 'ベテラン' }
    },
    "磐田南": {
        name_yomi: "いわたみなみ",
        region: "西部",
        type: "公立",
        deviation: 73,
        best: "甲子園出場",
        last: "初戦敗退",
        info: "全国トップクラスの進学校。野球は「文武両道」を掲げる課外活動の一環だが、その実力は侮れない。選手個々の野球IQが高く、データを駆使した緻密な戦術を得意とする。知性派集団が、夏のトーナメントに旋風を巻き起こす。余談だが、全国制覇の経験を持つサッカー部が応援に駆けつけることもあり、その独特の応援スタイルも名物となっている。ちなみにサッカー形式の野球応援が珍しいということで、これを目当てに試合に見に来るという隠れファンも多い。",
        coach: { name: '中田 譲二', style: '守備重視', experience: '中堅' }
    },
    "三島北": {
        name_yomi: "みしまきた",
        region: "東部",
        type: "公立",
        deviation: 60,
        best: "県大会ベスト8",
        last: "県大会ベスト8",
        info: "2年生エース左腕・榛名を擁する公立の実力校。max148キロの球速を持つ榛名の投球が試合の鍵を握るが、打線がエースを援護できるかが長年の課題。絶対的エースの存在に頼るだけでなく、チーム全体で得点を奪う総合力が試される。安定して上位に進出する力は十分に持っている。",
        coach: { name: '大川 透', style: '投手中心', experience: '中堅' }
    },
    "静岡": {
        name_yomi: "しずおか",
        region: "中部",
        type: "公立",
        deviation: 105,
        best: "甲子園3回戦",
        last: "県大会ベスト4",
        info: "創立93年、甲子園出場13回。そしてスポーツに力を入れながらも勉学でも優秀。その輝かしい歴史、実績は地元民のみならず県民の誇り、また憧れでもあり、老若男女問わず地元民に愛される伝統校である。近年は他校の私立やナムコグループとの選手獲得競争に一つ遅れをとっており、甲子園からは遠ざかっているが、歴史は厚く、私立並みの設備とOBからの厚い支援、そして、なによりも静高の試合がある際には球場に多くのOBが駆け付け、大応援団を結成し、相手を圧倒する。近年はナムコグループが県内を牛耳りかけているため、公立の希望の星としてメディアに取り上げられることも多い。県内を席巻するナムコグループへの『公立最後の砦』として、その存在は象徴的な意味を持ち始めた。名将・高島は伝統と現代野球の融合に腐心する。これは単なる高校野球ではない。地域の誇りと未来をかけた代理戦争なのだ。",
        popularity: true,
        coach: { name: '高島 礼', style: '伝統野球', experience: '名将' }
    },
    "飛龍": {
        name_yomi: "ひりゅう",
        region: "東部",
        type: "私立",
        deviation: 99,
        best: "甲子園2回戦",
        last: "初戦敗退",
        info: "かつては甲子園出場経験もある私立校だが、数年前に起きた不祥事の影響でチームは低迷。現在は若き林田監督と共に、失われた信頼を取り戻すべく再建の道を歩んでいる。地域への清掃活動などを通じて地道な努力を続けており、グラウンドでの結果で完全復活をアピールしたいところだ。。",
        coach: { name: '林田 健太郎', style: '機動力野球', experience: '期待の若手' }
    },
    "聖隷クリストファー": {
        name_yomi: "せいれいくりすとふぁー",
        region: "西部",
        type: "私立",
        deviation: 114,
        best: "甲子園2回戦",
        last: "県大会ベスト8",
        info: "毎年優勝候補に挙げられる西部地区の雄。名将・片岡監督が築き上げた投手を中心とした堅守は全国レベルと評される。しかし、その堅実さゆえに打線が湿りがちで、トーナメント終盤で涙を飲む展開が続く。タレントは揃っており、悲願の甲子園出場に向けて、伝統の守備力に加えて得点力をどう向上させるか。長年の課題である「ベスト8の壁」を越えられるかが今大会の焦点となる。",
        popularity: true,
        coach: { name: '片岡 鉄心', style: '守備重視', experience: '名将' }
    },
    "裾野": {
        name_yomi: "すその",
        region: "東部",
        type: "公立",
        deviation: 48,
        best: "なし",
        last: "なし",
        info: "エースの茂野が中心となって創部された新しいチーム。部員のほとんどが高校から野球を始めた初心者であり、戦力としては未知数。茂野の圧倒的な個人技でどこまで勝ち上がれるかが注目される。チームとしての一体感が生まれれば、面白い存在になるかもしれない。",
        coach: { name: '茂野 吾郎', style: '超攻撃型', experience: '新任' }
    },
    "富士宮北": {
        name_yomi: "ふじのみやきた",
        region: "東部",
        type: "公立",
        deviation: 71,
        best: "甲子園出場",
        last: "初戦敗退",
        info: "プロ注目のmax158kmの本格派右腕・斎藤を擁する公立校。彼の存在により、例年以上の注目を集めている。佐々木監督はエースへの負担を考慮しつつ、チーム全体の底上げを図る。斎藤の快投はもちろん、彼を支える野手陣の奮起が、上位進出への鍵となる。",
        coach: { name: '佐々木 朗', style: '投手中心', experience: '中堅' }
    },
    "美城学園": {
        name_yomi: "みしろがくえん",
        region: "中部",
        type: "私立",
        deviation: 81,
        best: "県大会ベスト4",
        last: "県大会2回戦",
        info: "ナムコグループ系列校の草分け的存在。かつてはグループの中心だったが、近年は同じ系列の765総合や283学園に有力選手が集まり、苦戦を強いられている。三城監督の下、プライドをかけた戦いで古豪の意地を見せ、グループ内での序列を覆したいところだ。",
        coach: { name: '三城 常務', style: 'エリート野球', experience: 'ベテラン' }
    },
    "沼津高専": {
        name_yomi: "ぬまづこうせん",
        region: "東部",
        type: "公立",
        deviation: 18,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "全国トップクラスの偏差値を誇る超進学校。相手チームのデータを徹底的に分析し、確率に基づいた戦術を組み立てる「シンキング・ベースボール」が持ち味。身体能力では他校に劣る部分もあるが、その知性で補って余りある。セオリーの穴を突く戦い方は、どんな強豪にとっても脅威となる。。",
        coach: { name: '京大 一郎', style: 'データ野球', experience: '中堅' }
    },
    "三島南": {
        name_yomi: "みしまみなみ",
        region: "東部",
        type: "公立",
        deviation: 62,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "数年前に21世紀枠として甲子園に出場した経験を持つ。数年前ほどの力はないが、今年のチームは全員野球で相手に挑み、守備でリズムを作りながら、つなぐバッティングで得点する野球が特長。エースの吉田と主砲の打川を中心に、泥臭い野球でこの夏は下克上で甲子園まで勝ち上がる。",
        popularity: true,
        coach: { name: '吉田 輝夫', style: '全員野球', experience: 'ベテラン' }
    },
    "御殿場南": {
        name_yomi: "ごてんばみなみ",
        region: "東部",
        type: "公立",
        deviation: 34,
        best: "県大会ベスト16",
        last: "県大会ベスト16",
        info: "50年ぶりとなるベスト16に進出した昨年の躍進で、地元を大いに沸かせた公立校。データ分析を得意とする山内監督の指導の下、派手さはないが堅実な野球で勝ち上がった。周囲の「まぐれ」という声を覆し、自分たちの実力が本物であることを証明したい今大会は、真価を問われる重要な夏となる。。",
        coach: { name: '山内 浩司', style: '堅実', experience: '中堅' }
    },
    "掛川西": {
        name_yomi: "かけがわにし",
        region: "西部",
        type: "公立",
        deviation: 151,
        best: "甲子園2回戦",
        last: "県大会ベスト4",
        info: "静岡高校と並ぶスポーツが盛んな県内二大公立校。サッカー部などが全国的に有名なスポーツ強豪校であり、野球部も毎年安定して上位に進出する実力を持つが、あと一歩で甲子園に届かないシーズンが続く。名将・円堂監督が掲げる、常識にとらわれない大胆な采配は、多くのファンを魅了している。今年こそ他競技の輝かしい実績に追いつきたい。。",
        coach: { name: '円堂 守', style: '超次元野球', experience: '名将' }
    },
    "浜松市立": {
        name_yomi: "はままついちりつ",
        region: "西部",
        type: "公立",
        deviation: 75,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "毎年安定した力を持つ中堅公立校だが、トーナメント中盤で強豪校と当たり敗退することが多く、「壁」を越えられずにいる。この状況を打破すべく、ベテランの山口監督は今年は機動力野球に特化。塁に出れば積極的に次の塁を狙う、しつこい野球で番狂わせを狙う。。",
        coach: { name: '山口 一', style: '機動力野球', experience: 'ベテラン' }
    },
    "浜松学院興誠": {
        name_yomi: "はままつがくいんこうせい",
        region: "西部",
        type: "私立",
        deviation: 72,
        best: "県大会ベスト16",
        last: "県大会ベスト16",
        info: "体育科のみで構成される通信制の私立校。全国から選手が集まり、寮生活を送りながら野球に打ち込んでいる。サッカー界で実績のある岡田監督が、競技の垣根を越えて指導にあたっており、その育成手腕に注目が集まる。独特の環境で育った選手たちが、チームとしてどう機能するかが鍵。",
        coach: { name: '岡田 武史', style: '育成上手', experience: 'ベテラン' }
    },
    "焼津水産": {
        name_yomi: "やいづすいさん",
        region: "中部",
        type: "公立",
        deviation: 44,
        best: "県大会ベスト16",
        last: "県大会2回戦",
        info: "港町に根ざした水産高校で、スタンドに翻る大漁旗がチームのシンボル。一昨年のベスト16進出という実績もあり、地元の期待は大きい。浜田監督が率いるチームは、チャンスでの集中打を得意とする攻撃的な野球が持ち味。昨年の不振を乗り越え、再び「大漁」を狙う。",
        coach: { name: '浜田 大吉', style: '積極打撃', experience: '中堅' }
    },
    "袋井": {
        name_yomi: "ふくろい",
        region: "中部",
        type: "公立",
        deviation: 79,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "県内有数のマンモス校で、毎年一定数の有望な新入生が入部する。突出したスター選手はいないものの、全部員のレベルが高く、総合力で勝負するチーム。ベテラン千葉監督の下、選手層の厚さを活かした多彩な戦術が強み。昨年の初戦敗退の雪辱を誓う。。",
        coach: { name: '千葉 繁', style: '総合力', experience: 'ベテラン' }
    },
    "浜松城北工業": {
        name_yomi: "はままつじょうほくこうぎょう",
        region: "西部",
        type: "公立",
        deviation: 76,
        best: "県大会ベスト4",
        last: "初戦敗退",
        info: "県大会ベスト4の経験もある公立校。元プロの金本監督が注入する、積極果敢なフルスイング野球がチームの代名詞。その攻撃的なスタイルは、時にラフプレーと批判されることもあるが、勝利への執念はどのチームよりも強い。昨年の初戦敗退から這い上がり、再び頂点を目指す。。",
        coach: { name: '金本 知憲', style: '積極打撃', experience: 'プロOB' }
    },
    "磐田東": {
        name_yomi: "いわたひがし",
        region: "西部",
        type: "私立",
        deviation: 90,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "轟監督の「打撃こそ正義」という哲学に基づき、練習の大部分を打撃練習に費やす超攻撃型チーム。その破壊力は県内トップクラスで、大量得点で試合をひっくり返す力を持つ。一方で、守備力に課題を残しており、試合展開が非常に不安定なのが特徴。観客を魅了する、スリリングな試合運びで勝ち上がりを狙う。。",
        coach: { name: '轟 雷蔵', style: '打撃偏重', experience: 'ベテラン' }
    },
    "静岡商業": {
        name_yomi: "しずおかしょうぎょう",
        region: "中部",
        type: "公立",
        deviation: 7,
        best: "甲子園優勝",
        last: "県大会ベスト8",
        info: "甲子園優勝経験もある伝統校で、毎年優勝候補の筆頭に挙げられる。エース成宮を筆頭とする投手力は全国屈指のレベルを誇る。昨年の大会では準々決勝で敗退しており、今年は王座奪還を目指す。名将・国友監督の下、投打に隙がなく、総合力は県内トップクラス。。",
        popularity: true,
        coach: { name: '国友 広重', style: '総合力', experience: '名将' }
    },
    "御殿場西": {
        name_yomi: "ごてんばにし",
        region: "東部",
        type: "私立",
        deviation: 96,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "トーナメント中盤の大きな壁として、毎年安定した力を見せる私立の実力校。ベテラン田崎監督が築き上げた堅実な野球は、どのチームにとってもやりにくい。一方で、近年はベスト8前後での敗退が続き、上位進出には課題も残る。強豪校にとっては厄介な「門番」から脱却し、頂点を狙えるかが問われる。。",
        coach: { name: '田崎 圭介', style: '堅実', experience: 'ベテラン' }
    },
    "誠恵": {
        name_yomi: "せいけい",
        region: "東部",
        type: "私立",
        deviation: 58,
        best: "甲子園出場",
        last: "初戦敗退",
        info: "かつては甲子園にも出場した古豪だが、近年は部員不足に悩み低迷している。勝利のためなら手段を選ばないベテラン影山監督の非情な采配は、物議を醸すことも少なくない。しかし、恵まれない戦力で勝ち上がるため、綺麗事だけでは済まされないというチームの現実も表している。。",
        coach: { name: '影山 秀路', style: 'ラフプレー', experience: 'ベテラン' }
    },
    "科学技術": {
        name_yomi: "かがくぎじゅつ",
        region: "中部",
        type: "私立",
        deviation: 43,
        best: "県大会ベスト4",
        last: "県大会ベスト16",
        info: "VRトレーニングやAIによるデータ解析など、最新技術を積極的に導入している新時代の私立校。その先進的な取り組みはメディアでも度々取り上げられ、知名度は高い。速水監督の下、科学的なアプローチで選手の能力を最大限に引き出す。データ野球が伝統的な強豪校にどこまで通用するのか、注目が集まる。。",
        coach: { name: '速水 奨', style: 'データ野球', experience: '中堅' }
    },
    "小山": {
        name_yomi: "おやま",
        region: "東部",
        type: "公立",
        deviation: 49,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "人口1万人の小さな町にある、全校生徒100人にも満たない小規模校。町の期待を一身に背負い、彼らはグラウンドに立つ。チャンス時に全校生徒と町民が一体となって踊る『小山舞踊』は、相手チームを呑み込む独特の雰囲気を生み出す。ベテラン猫田監督の下、体格では劣る選手たちが機動力で掻き回す。町全体の想いが、奇跡を起こすかもしれない。",
        coach: { name: '猫田 権蔵', style: '機動力野球', experience: 'ベテラン' }
    },
    "虎府島総合": {
        name_yomi: "こふとうそうごう",
        region: "西部",
        type: "公立",
        deviation: 47,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "本土から定期船で4時間。台風が来れば1週間は孤島と化す。それが虎府島だ。グラウンドは塩害で芝生がまだらに枯れ、雨が降れば沼地と化す。練習相手は漁の合間に集まる島の草野球チームの地元の方々。彼らから教わるのは『気合』と『潮の流れの読み方』だ。本土の他校の情報は、月に一度届く野球雑誌だけ。しかし、この絶望的なハンデが彼らの魂を鋼鉄に変えた。その逆境が「虎府島スピリッツ」と呼ばれる強靭な精神力とチームの結束を育んだ。試合の日には島民が大挙して応援に駆けつけるなど、地域との絆はどこよりも強い。噂によると島民の約半数にも及ぶらしい。もはやこれは単なるスポーツではない。島が、生きるために戦う物語だ。",
        coach: { name: '島袋 譲二', style: '全員野球', experience: 'ベテラン' }
    },
    "知徳": {
        name_yomi: "ちとく",
        region: "東部",
        type: "私立",
        deviation: 71,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "『力こそ全て』を校訓に掲げ、練習のほとんどをウエイトトレーニングに費やす脳筋集団。金剛監督の指導の下、全選手がベンチプレス100kg以上を誇るパワーは本物だ。しかし、その大味な野球は、栄養管理や科学的トレーニングを取り入れる強豪校の前に、いつもあと一歩で屈してきた。筋肉は裏切らない。その言葉を信じ、彼らは今日も鉄アレイを握る。",
        coach: { name: '金剛 毅', style: 'パワー野球', experience: '中堅' }
    },
    "静清": {
        name_yomi: "せいせい",
        region: "中部",
        type: "私立",
        deviation: 45,
        best: "甲子園優勝",
        last: "初戦敗退",
        info: "半世紀前に甲子園5連覇を達成した伝説的な古豪。近年は低迷が続くが、その名前は今も高校野球ファンに畏敬の念を抱かせている。かつての名将の血を引く犬飼監督が、伝統の堅守を復活させ、「帝国の再建」を目指す。古豪復活への道のりは険しいが、その一挙手一投足に注目が集まる。。",
        coach: { name: '犬飼 賢人', style: '守備重視', experience: '名将' }
    },
    "日大三島": {
        name_yomi: "にちだいみしま",
        region: "東部",
        type: "私立",
        deviation: 96,
        best: "甲子園出場",
        last: "県大会ベスト16",
        info: "2022年の春夏連続甲子園出場が記憶に新しい日大三島。昨秋は県大会3回戦で敗退し、気合を入れ直したところだ。指揮をとるのは永田裕治監督だ。報徳学園（兵庫）時代には全国制覇を含む、春夏通算18回の甲子園出場。2020年に日大三島に赴任すると、2022年には春夏連続で甲子園に導いた。今チームも百戦錬磨の名将から全員野球の大切さ、勝負に対する厳しさを学び、選手たちの顔つきが少しずつ変わってきた。名将の就任から4年が過ぎようとしている。。",
        coach: { name: '小和田 雅人', style: '堅実', experience: 'ベテラン' }
    },
    "浜松開誠館": {
        name_yomi: "はままつかいせいかん",
        region: "西部",
        type: "私立",
        deviation: 120,
        best: "甲子園2回戦",
        last: "県大会ベスト16",
        info: "ポテンシャルは県内トップとも称されることもあるトーナメント屈指のダークホース。2023年には甲子園出場も果たし、一躍強豪としての名誉を築いた。策士・佐野監督が率いるチームは、相手チームの徹底的な分析に基づいた奇策を得意とする。その予測不能な戦いぶりは、、ひとたび波に乗れば一気に勝ち上がる力を持っている。。",
        coach: { name: '佐野 秀幸', style: '奇策', experience: '策士' }
    },
    "東海大翔洋": {
        name_yomi: "とうかいだいしょうよう",
        region: "中部",
        type: "私立",
        deviation: 91,
        best: "県準優勝",
        last: "県大会ベスト16",
        info: "一昨年の夏はノーシードから決勝まで勝ち進むも765総合に敗れ、準優勝。新しいスタイルで今夏こそ甲子園へ！勝利への執念を引き継ぐ現チームの特徴は「機動力」。前チームとはまた違ったスタイルに期待がかかる。機動力以外もレベルアップしている。投手は140キロ右腕の甘田圭澄（2年）が君臨。課題だった2番手も、1年生を中心に台頭しつつある。一方の攻撃力は7試合計90安打を叩き出した昨年のチームに比べて劣るが、機動力を使った野球を展開。チームナンバーワンの俊足・松下揮人（2年＝外野手）や岸川を筆頭に足の速い選手が多いのも追い風となっている。守りからリズムを作り、1点ずつ積み重ねていくニュースタイルが浸透してきた「タテジマ軍団」。2004年夏以来となる甲子園に向けて牙を研ぐ。。",
        coach: { name: '須田 幸雄', style: '総合力', experience: 'ベテラン' }
    },
    "283学園B": {
        name_yomi: "つばさがくえんB",
        region: "西部",
        type: "私立",
        deviation: 59,
        best: "なし",
        last: "なし",
        info: "王者・283学園の『二軍』。昨年の優勝により部員数が急激に増加した283学園。一時は100人も超えたため、それに伴い、異例の措置として設立されたBチーム。Aチームに上がれなかった選手で構成されているが、監督に就任した七草の手腕もあり、その実力は侮れない。「打倒Aチーム」を掲げ、ハングリー精神は本家以上。公式戦での兄弟対決が実現すれば、大きな注目を集めるだろう。県内からは同じ県内に同じ高校のチームの二つ目を作り大会に参加させるのは違反行為なのでは、という声が多く上がったが、県内はナムコグループが牛耳っているため、ごり押しで可決させた。",
        coach: { name: '七草 はづき', style: '育成上手', experience: '期待の若手' }
    },
    "伊豆伊東": {
        name_yomi: "いずいとう",
        region: "伊豆",
        type: "公立",
        deviation: 43,
        best: "県大会2回戦",
        last: "県大会2回戦",
        info: "数年前に共学化した元女子高で、野球部は創部まもない新しいチーム。学校側の全面的なバックアップを受け、期待の若手、伊集院監督が指導にあたる。全国レベルと名高い吹奏楽部の応援もチームの大きな武器。まだ発展途上だが、今後の成長が期待される注目株だ。。",
        coach: { name: '伊集院 隼人', style: '機動力野球', experience: '期待の若手' }
    },
    "富士東": {
        name_yomi: "ふじひがし",
        region: "東部",
        type: "公立",
        deviation: 63,
        best: "県大会2回戦",
        last: "県大会2回戦",
        info: "富士東は最上級生の奮起に注目だ。昨年は４人しかいない３年生全員が活躍を見せ、初戦で甲子園出場経験もある富士宮北を７―６で破った。一緒にプレーした岩田主将（３年）は「そういう上級生の姿を今年も後輩たちに見せたい」と意気込む。エースの眞山（３年）は、４日の招待試合で日大三島に１失点完投勝利。自信を胸に「チームを鼓舞する投球をしたい」と大舞台を見据える。。",
        coach: { name: '高橋 留美', style: '守備重視', experience: '中堅' }
    },
    "常葉菊川": {
        name_yomi: "とこはきくがわ",
        region: "西部",
        type: "私立",
        deviation: 55,
        best: "甲子園準優勝",
        last: "県準優勝",
        info: "織田監督が率いる、超攻撃的な野球を標榜する私立校。昨年の県大会では、その圧倒的な打撃力で準優勝に輝いた。守備に課題を残すものの、「点を取られたら取り返す」というスタイルは多くのファンを魅了している。今年もその破壊的な打線は健在で、頂点を目指す。。",
        coach: { name: '織田 信長', style: '超攻撃型', experience: 'ベテラン' }
    },
    "常葉橘": {
        name_yomi: "とこはたちばな",
        region: "中部",
        type: "私立",
        deviation: 92,
        best: "甲子園出場",
        last: "県大会2回戦",
        info: "投手陣は緩急をつける三浦、思い切りのいい山口らが主戦を争う。打線は長打力があるブランコ、中村ら中軸が信頼できる。石川、モーガンら上位が出て、得点機をつくりたい。下位打線の充実が鍵。守備は一年生の時から試合に出ている遊撃梶谷、昨年を経験した捕手鶴岡らセンターラインが軸。確実にアウトを取れる安定感が持ち味だ。",
        coach: { name: '渡辺 元智', style: '総合力', experience: '名将' }
    },
    "藤枝明誠": {
        name_yomi: "ふじえだめいせい",
        region: "西部",
        type: "私立",
        deviation: 90,
        best: "甲子園出場",
        last: "県大会ベスト8",
        info: "「雑草軍団」として知られ、堅実な守備と手堅い攻めの野球が持ち味のハングリー精神の強いチーム。ベテラン猪狩監督の指導の下、個々の選手の能力は非常に高い。チームとして噛み合った時の爆発力は、優勝候補をも脅かす。近年着々と結果を出しており、今大会は春の大会で上位の成績を収めたことにより、シード校として君臨している。「革命」の時は近い。",
        coach: { name: '猪狩 茂', style: '投手中心', experience: 'ベテラン' }
    },
    "駿河総合": {
        name_yomi: "するがそうごう",
        region: "中部",
        type: "私立",
        deviation: 57,
        best: "県大会準優勝",
        last: "県大会2回戦",
        info: "2019年夏に初の県決勝進出を果たした駿河総合。昨夏の「2020年夏季静岡県高等学校野球大会結果」でもベスト4入り。悲願の甲子園が手の届く位置まできている。同校はチーム力が年々上昇すると同時に、上のカテゴリーで活躍する卒業生が増えている。2018年に社会人野球を経てOBの杉山一樹（福岡ソフトバンク）がプロ入り。最速157キロの剛速球を武器に今季はローテーションの一角として期待される。さらに、2019年のドラフトで指名された紅林弘太郎（オリックス）はプロ1年目から1軍戦に出場。将来の主軸候補として注目を集めている。期待の若手・藤崎監督が持ち込んだデータ野球を武器に、着実に力をつけている。相手の油断を突く情報戦を得意とし、下馬評を覆すポテンシャルは十分。校名とは裏腹に、冷静沈着な野球で番狂わせを狙う。。",
        coach: { name: '藤崎 詩織', style: 'データ野球', experience: '期待の若手' }
    },
    "加藤学園": {
        name_yomi: "かとうがくえん",
        region: "東部",
        type: "私立",
        deviation: 129,
        best: "県大会ベスト16",
        last: "県大会2回戦",
        info: "投手陣は緩急をつける嶋、思い切りのいい榎本らが主戦を争う。打線は長打力がある右田、寺田ら中軸が信頼できる。川崎ら上位が出て、得点機をつくりたい。下位打線の充実が鍵。守備は一年生の時から試合に出ている遊撃坂口、昨年を経験した捕手古田らセンターラインが軸。夏までに確実にアウトを取れる安定感を身につけたい直近の練習試合では東海大翔洋にも勝利するなど今大会の優勝候補と言っても過言ではない",
        coach: { name: '鰯水 等', style: '堅実', experience: '中堅' }
    },
    "浜松工業": {
        name_yomi: "はままつこうぎょう",
        region: "西部",
        type: "公立",
        deviation: 64,
        best: "甲子園ベスト8",
        last: "県大会2回戦",
        info: "約30年前に甲子園ベスト8に進出し、「浜工旋風」を巻き起こしたことで知られる。近年は低迷していたが、当時のエースだった青葉が監督に就任し、再建に乗り出した。かつての英雄の帰還に、OBや地元の期待も高まっている。新しい世代の選手たちと共に、再び聖地を目指す。。",
        coach: { name: '青葉 健司', style: '育成上手', experience: '期待の若手' }
    },
    "伊豆総合": {
        name_yomi: "いずそうごう",
        region: "東部",
        type: "公立",
        deviation: 43,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "エースは最速１３６キロの力のあるストレートで勝負する。打撃陣に派手さはないものの走塁や戦術に磨きをかけ、足りない長打力をカバーする。落ち着いた雰囲気で野球に取り組んでいる。尾島太郎監督の指導は、堅実な守備と確実なバントなどを重視するスタイル。派手さはないが、大崩れしない安定感がある。。",
        coach: { name: '尾島 太郎', style: '守備重視', experience: 'ベテラン' }
    },
    "富士宮西": {
        name_yomi: "ふじのみやにし",
        region: "東部",
        type: "公立",
        deviation: 88,
        best: "甲子園ベスト16",
        last: "初戦敗退",
        info: "約30年前に甲子園出場経験のある古豪。近年は私立校の台頭に押され、上位進出から遠ざかっている。OBや地元ファンの「復活を」という期待が、時に選手たちのプレッシャーになることも。ベテラン拳崎監督は、選手たちが気負わずに実力を発揮できる環境作りに努めている。",
        coach: { name: '拳崎 史郎', style: '積極打撃', experience: 'ベテラン' }
    },
    "富士市立": {
        name_yomi: "ふじいちりつ",
        region: "東部",
        type: "私立",
        deviation: 81,
        best: "県大会ベスト8",
        last: "県大会2回戦",
        info: "セイバーメトリクスをいち早く導入し、データに基づいた野球を徹底する私立校。赤嶺監督の采配は、選手のコンディションや相手との相性など、あらゆる情報を分析した上で決定される。その合理的なアプローチは、時に非情とも映るが、着実に結果を残している。",
        coach: { name: '赤嶺 譲二', style: 'データ野球', experience: '中堅' }
    },
    "オイスカ浜松国際": {
        name_yomi: "おいすかはままつこくさい",
        region: "西部",
        type: "私立",
        deviation: 59,
        best: "県大会ベスト4",
        last: "県大会2回戦",
        info: "県内を牛耳る巨大資本『ナムコグループ』に対抗すべく、地元の有志『オイスカグループ』が設立した異色の高校。潤沢な資金を持つナムコ系列校とは対照的に、彼らが持つのは反骨精神と結束力だけだ。「伝説」と称される桐生監督の指導は、技術よりも精神的な強さを重視する。その熱いプレースタイルと反骨精神は多くのファンを惹きつけており、大会の波乱要因として注目されている。",
        coach: { name: '桐生 一馬', style: '根性野球', experience: '伝説' }
    },
    "新居": {
        name_yomi: "あらい",
        region: "中部",
        type: "公立",
        deviation: 48,
        best: "県大会初戦敗退",
        last: "初戦敗退",
        info: "夏の大会、公式戦通算0勝32敗。それがこの学校の歴史の全てだ。長年公式戦での勝利から遠ざかっており、部員数も常にギリギリという厳しい状況が続く公立校。練習環境も恵まれているとは言えないが、選手たちは野球が好きだという純粋な気持ちで白球を追い続けている。チームの悲願は、まず「公式戦で一勝」を挙げること。その瞬間に向けて、ひたむきな努力を重ねる。",
        coach: { name: '田中 一郎', style: '堅実', experience: '中堅' }
    },
    "韮山": {
        name_yomi: "にらやま",
        region: "東部",
        type: "公立",
        deviation: 88,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "県のシンボル『伊豆山』の麓にある県内屈指の進学校。彼らの名物は、険しい山道を毎日駆け上がる地獄のトレーニングだ。それで鍛え上げられた強靭な足腰は、他校の脅威。ベテラン山路監督が率いる機動力野球は、一度出塁を許すと止まらない。山の民の誇りを胸に、グラウンドを嵐のように駆け巡る。",
        coach: { name: '山路 和弘', style: '機動力野球', experience: 'ベテラン' }
    },
    "静岡学園": {
        name_yomi: "しずおかがくえん",
        region: "中部",
        type: "私立",
        deviation: 61,
        best: "甲子園出場",
        last: "県大会ベスト16",
        info: "創部19年の新興勢力ながら、甲子園出場経験を持つ実力校。しかし更なる飛躍のため、学校は大きな賭けに出た。かつて帝王実業を甲子園5連覇に導いた伝説の名将・國村監督を招聘したのだ。規律を重んじるベテラン監督の下、才能ある選手たちがどう融合するのか、優勝候補の一角として大きな注目を集めている。。",
        coach: { name: '國村 隼', style: '総合力', experience: '名将' }
    },
    "市立沼津": {
        name_yomi: "いちりつぬまづ",
        region: "東部",
        type: "公立",
        deviation: 82,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "全国レベルの吹奏楽部が奏でる応援は『市沼サウンド』として有名。その美しくも力強い音圧は、相手チームの集中力を削ぎ、味方を鼓舞する。ベテラン猫又監督が率いるチームは、その応援をバックに、粘り強い守備でリズムを作る。派手な選手はいないが、繋ぐ意識は県内随一。音の魔術師たちが、静かに、しかし確実に相手を追い詰めていく。",
        coach: { name: '猫又 育史', style: '守備重視', experience: 'ベテラン' }
    },
    "沼津城北": {
        name_yomi: "ぬまづじょうほく",
        region: "東部",
        type: "公立",
        deviation: 55,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "生徒の自主性を重んじる自由な校風で知られる公立校。野球部も西垣監督の指導方針の下、選手たちが自ら練習メニューや戦術を考える「考える野球」を実践している。その型にはまらないプレースタイルは、時にセオリーを覆す大きな波乱を巻き起こす可能性を秘めている。",
        coach: { name: '西垣 奈々', style: '奇策', experience: '期待の若手' }
    },
    "下田": {
        name_yomi: "しもだ",
        region: "伊豆",
        type: "公立",
        deviation: 50,
        best: "県大会初戦敗退",
        last: "初戦敗退",
        info: "過疎化が進む静かな港の町。全校生徒80人、野球部員は奇跡的に集まったが、グラウンドには雑草が生い茂り、練習は紅白戦もできず、監督が打つボールをただ延々と追いかけるだけ。昨年、町で唯一のスポーツ用品店がシャッターを下ろし、今は破れたボールを自分たちで縫って使うしかない。町の大人たちは、彼らが野球をしていることすら知らないかもしれない。消えゆく町で、誰にも知られず消えていく野球部。彼らが夏の大会に出場するのは、勝利のためではない。自分たちが『下田高校野球部』として確かにここに存在したという、たった一つの証を夏の青空に刻み込むためだけの、あまりにも切ない戦いだ。",
        coach: { name: '水上 善次', style: '堅実', experience: '中堅' }
    },
    "湖西": {
        name_yomi: "こさい",
        region: "西部",
        type: "公立",
        deviation: 77,
        best: "県大会ベスト8",
        last: "初戦敗退",
        info: "大会ごとに成績が大きく変動する、ムラッ気のあるチームとして知られる。上位進出経験もありポテンシャルは高いが、格下相手への取りこぼしも少なくない。ベテラン海野監督は、長年の課題である精神的な安定感をチームにもたらそうと指導。今大会で安定した戦いぶりを見せられるかが躍進の鍵となる。。",
        coach: { name: '海野 平', style: '機動力野球', experience: 'ベテラン' }
    },
    "熱海": {
        name_yomi: "あたみ",
        region: "伊豆",
        type: "公立",
        deviation: 46,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "創立70年を迎える地域の伝統校だが、近年は過疎化の波に飲まれ、活気を失いつつある。野球部の活躍は、町に残された数少ない希望だ。『俺たちが勝てば、町が元気になる』。その想いを胸に、選手たちはグラウンドに立つ。選手は全員が地元出身。育成に定評のある根本監督の下、郷土愛を力に変えて戦う。そのひたむきなプレーには、多くの地元ファンがついている。地元出身の選手たちが、愛する故郷に勝利を届ける。",
        coach: { name: '根本 陸夫', style: '育成上手', experience: 'ベテラン' }
    },
    "静岡市立": {
        name_yomi: "しずおかいちりつ",
        region: "中部",
        type: "公立",
        deviation: 83,
        best: "県大会ベスト16",
        last: "初戦敗退",
        info: "毎年投打にバランスの取れた好チームを編成するが、トーナメントの組み合わせに恵まれず、実力以上の結果を残せていない「悲運の公立校」。井上監督はどんな相手にも自分たちの野球を貫くことを選手に求める。今年こそ、厳しい組み合わせを乗り越えて上位進出を果たしたい。。",
        coach: { name: '井上 和彦', style: '総合力', experience: '中堅' }
    },
    "城南静岡": {
        name_yomi: "じょうなんしずおか",
        region: "中部",
        type: "公立",
        deviation: 59,
        best: "県大会ベスト4",
        last: "初戦敗退",
        info: "かつて県ベスト4の実績を持つ公立の実力校。昨年の初戦敗退の屈辱から、チームは「原点回帰」をテーマに伝統の積極打撃を徹底的に磨き直した。伊藤監督の下、古豪復活を目指すチームの士気は高い。ノーシードからの下剋上を狙う。。",
        coach: { name: '伊藤 健太郎', style: '積極打撃', experience: 'ベテラン' }
    },
    "浜松南": {
        name_yomi: "はままつみなみ",
        region: "西部",
        type: "公立",
        deviation: 56,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "近年、校舎が新築され、練習環境が大幅に改善された公立校。学校全体の期待が高まる中、期待の若手・高木監督がチームを率いる。まだ目立った実績はないが、最新の設備と新しいユニフォームで心機一転、新たな歴史を作るべく今大会に挑む。。",
        coach: { name: '高木 渉', style: '育成上手', experience: '期待の若手' }
    },
    "島田": {
        name_yomi: "しまだ",
        region: "中部",
        type: "公立",
        deviation: 53,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "大正8年創立という長い歴史を持つ伝統校だが、近年は部員不足から連合チームを組むなど、苦しい時期が続いている。今季から再び単独チームとして出場するが、戦力はまだ整っていない。まずは大会で一勝を挙げ、チームの新たな一歩を踏み出すことが目標となる。。",
        coach: { name: '島本 宏', style: '堅実', experience: '中堅' }
    },
    "伊豆中央": {
        name_yomi: "いずちゅうおう",
        region: "伊豆",
        type: "公立",
        deviation: 51,
        best: "県大会2回戦",
        last: "初戦敗退",
        info: "長年の部員不足から昨年まで連合チームとして出場していたが、今年から待望の単独出場を果たす。部員の多くが野球経験の浅い1年生で、チームはまだ発展途上。中田監督は、まずは公式戦で戦う経験を積ませ、チームの土台作りを進めている段階。今大会は未来への第一歩となる。。",
        coach: { name: '中田 島蔵', style: '全員野球', experience: '中堅' }
    },
"浜松修学舎": {
        name_yomi: "はままつしゅうがくしゃ", region: "西部", type: "私立", deviation: 70,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "近年急速に力をつけている私立校。豊富な練習量と「修学舎メソッド」と呼ばれる独自の育成法で、上位を虎視眈々と狙う。",
        coach: { name: '高橋 正和', style: '総合力', experience: '中堅' }
    },
    "浜松日体": {
        name_yomi: "はままつにったい", region: "西部", type: "私立", deviation: 58,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "文武両道を掲げる私立校。安定した実力を持ち、毎年トーナメント中盤の壁となる。",
        coach: { name: '渡辺 徹', style: '堅実', experience: '中堅' }
    },
    "掛川工業": {
        name_yomi: "かけがわこうぎょう", region: "西部", type: "公立", deviation: 93,
        best: "県大会2回戦", last: "初戦敗退",
        info: "掛川西、掛川東とは異なる、工業高校らしい実直な野球が持ち味。",
        coach: { name: '掛布 雅之', style: '積極打撃', experience: 'プロOB' }
    },
    "清水東": {
        name_yomi: "しみずひがし", region: "中部", type: "公立", deviation: 68,
        best: "県大会ベスト4", last: "県大会2回戦",
        info: "全国に名を轟かせるサッカー部の影に隠れがちだが、野球部も県内屈指の進学校として知性溢れるプレーを見せる。",
        coach: { name: '長谷部 誠', style: 'データ野球', experience: '期待の若手' }
    },
    "島田樟誠": {
        name_yomi: "しまだしょうせい", region: "中部", type: "私立", deviation: 95,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "近年、野球部の強化に力を入れている私立校。粘り強い戦いが持ち味。",
        coach: { name: '佐々木 恭介', style: '総合力', experience: 'ベテラン' }
    },
    "富士宮東": {
        name_yomi: "ふじのみやひがし", region: "東部", type: "公立", deviation: 73,
        best: "県大会2回戦", last: "初戦敗退",
        info: "富士山麓の地元選手で構成されたチーム。地の利を活かした戦いをしたい。",
        coach: { name: '工藤 公康', style: '投手中心', experience: 'プロOB' }
    },
    "浜名": {
        name_yomi: "はまな", region: "西部", type: "公立", deviation: 55,
        best: "県大会ベスト4", last: "県大会3回戦",
        info: "「浜名スマイル」を合言葉に、常に全力疾走と笑顔を絶やさない好チーム。公立校ながら安定して上位に進出する実力を持つ。",
        coach: { name: '山田 太郎', style: '全員野球', experience: '中堅' }
    },
    "掛川東": {
        name_yomi: "かけがわひがし", region: "西部", type: "公立", deviation: 63,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "文武両道を掲げる進学校。掛川西のライバル校の一つとして、安定した実力を持つ。",
        coach: { name: '東山 紀之', style: '堅実', experience: '中堅' }
    },
    "島田商業": {
        name_yomi: "しまだしょうぎょう", region: "中部", type: "公立", deviation: 72,
        best: "甲子園出場", last: "県大会2回戦",
        info: "「島商（しましょう）」の愛称で知られる古豪。近年は中堅に甘んじているが、伝統の堅実な「島商野球」で復活を目指す。",
        coach: { name: '池谷 幸雄', style: '堅実', experience: 'ベテラン' }
    },
    "清水桜が丘": {
        name_yomi: "しみずさくらがおか", region: "中部", type: "公立", deviation: 77,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "清水商業と庵原高校の統合校。サッカー部が有名だが、野球部も「清商（キヨショウ）」時代の勝負強さを受け継ぐ。",
        coach: { name: '大榎 克己', style: '堅実', experience: '中堅' }
    },
    "沼津商業": {
        name_yomi: "ぬまづしょうぎょう", region: "東部", type: "公立", deviation: 79,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "東部の伝統ある商業高校。緻密なデータ分析と機動力を絡めた「考える野球」が持ち味。",
        coach: { name: '小宮山 悟', style: 'データ野球', experience: 'ベテラン' }
    },
    "田方農業": {
        name_yomi: "たがたのうぎょう", region: "伊豆", type: "公立", deviation: 42,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "伊豆地区の雄。農業実習で鍛えた体力と、粘り強さが持ち味。「タノウ」の愛称で親しまれる。",
        coach: { name: '桑田 真澄', style: '育成上手', experience: 'プロOB' }
    },
    "浜松湖南": {
        name_yomi: "はままつこなん", region: "西部", type: "公立", deviation: 54,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "毎年安定した力を持つ中堅校。上位進出を虎視眈々と狙う。",
        coach: { name: '小林 幹英', style: '堅実', experience: '中堅' }
    },
    "沼津東": {
        name_yomi: "ぬまづひがし", region: "東部", type: "公立", deviation: 69,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "東部地区屈指の進学校。伝統的に「文武両道」を掲げ、知的なプレーで相手を翻弄する。",
        coach: { name: '古田 敦也', style: 'データ野球', experience: 'プロOB' }
    },
    "吉原": {
        name_yomi: "よしわら", region: "東部", type: "公立", deviation: 51,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "富士市を代表する公立校の一つ。粘り強い守備と、つなぐ打線で上位進出を狙う。",
        coach: { name: '吉井 理人', style: '投手中心', experience: '中堅' }
    },
    "浜松大平台": {
        name_yomi: "はままつおおひらだい", region: "西部", type: "公立", deviation: 40,
        best: "県大会2回戦", last: "初戦敗退",
        info: "比較的新しい公立校。まずはトーナメント中盤進出が目標。",
        coach: { name: '大野 豊', style: '投手中心', experience: 'プロOB' }
    },
    "藤枝西": {
        name_yomi: "ふじえだにし", region: "中部", type: "公立", deviation: 48,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "サッカーの強豪・藤枝東のライバル校。野球部も負けじと、粘り強い全員野球で勝利を目指す。",
        coach: { name: '西 勇輝', style: '全員野球', experience: '期待の若手' }
    },
    "磐田農業": {
        name_yomi: "いわたのうぎょう", region: "西部", type: "公立", deviation: 42,
        best: "県大会2回戦", last: "初戦敗退",
        info: "農業実習で鍛えた地力と体力が自慢。「磐農（いわたのう）」ナインが泥臭く白球を追う。",
        coach: { name: '野村 謙二郎', style: '機動力野球', experience: 'ベテラン' }
    },
    "静岡西": {
        name_yomi: "しずおかにし", region: "中部", type: "公立", deviation: 50,
        best: "県大会2回戦", last: "初戦敗退",
        info: "典型的な公立の中堅チーム。堅実な守備からリズムを作りたい。",
        coach: { name: '西崎 幸広', style: '投手中心', experience: '中堅' }
    },
    "浜松江之島": {
        name_yomi: "はままつえのしま", region: "西部", type: "公立", deviation: 45,
        best: "県大会2回戦", last: "初戦敗退",
        info: "粘り強い守備と小技を絡めた攻撃が持ち味のチーム。",
        coach: { name: '中村 剛', style: '堅実', experience: '中堅' }
    },
    "浜松西": {
        name_yomi: "はままつにし", region: "西部", type: "公立", deviation: 66,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "県内トップクラスの進学校。少ない練習時間を効率的に使い、知性で戦う。",
        coach: { name: '鈴木 一郎', style: 'データ野球', experience: '中堅' }
    },
    "池新田": {
        name_yomi: "いけしんでん", region: "西部", type: "公立", deviation: 44,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "御前崎市に位置する。海風で鍛えた強肩とパワーが武器の、侮れない中堅校。",
        coach: { name: '池山 隆寛', style: '積極打撃', experience: '中堅' }
    },
    "磐田北": {
        name_yomi: "いわたきた", region: "西部", type: "公立", deviation: 53,
        best: "県大会2回戦", last: "初戦敗退",
        info: "地元の選手を中心に構成された、地域密着型の公立校。",
        coach: { name: '山本 浩二', style: '全員野球', experience: 'ベテラン' }
    },
    "磐田西": {
        name_yomi: "いわたにし", region: "西部", type: "公立", deviation: 76,
        best: "県大会2回戦", last: "初戦敗退",
        info: "粘り強い野球が信条。接戦に持ち込み勝機を伺う。",
        coach: { name: '渡辺 俊介', style: '守備重視', experience: '中堅' }
    },
    "小笠": {
        name_yomi: "おがさ", region: "西部", type: "公立", deviation: 68,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "かつてはベスト8にも名を連ねた古豪。近年は安定した力を見せ、復活の兆しがある。",
        coach: { name: '高橋 昭雄', style: '機動力野球', experience: 'ベテラン' }
    },
    "御殿場": {
        name_yomi: "ごてんば", region: "東部", type: "公立", deviation: 43,
        best: "県大会2回戦", last: "初戦敗退",
        info: "富士山の麓、標高の高いグラウンドで鍛えられた足腰が自慢。",
        coach: { name: '槙原 寛己', style: '堅実', experience: '中堅' }
    },
    "相良": {
        name_yomi: "さがら", region: "中部", type: "公立", deviation: 47,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "牧之原市の実力校。投手力を中心とした堅実な試合運びで、シード校撃破を狙う。",
        coach: { name: '相川 亮二', style: '守備重視', experience: '中堅' }
    },
    "佐久間": {
        name_yomi: "さくま", region: "西部", type: "公立", deviation: 35,
        best: "県大会2回戦", last: "初戦敗退",
        info: "浜松市天竜区の山間部に位置する。部員不足に悩みながらも、地域の期待を背負って戦う。",
        coach: { name: '佐々木 朗希', style: '投手中心', experience: '新任' }
    },
    "静岡北": {
        name_yomi: "しずおかきた", region: "中部", type: "私立", deviation: 52,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "スポーツ科も擁する私立校。個々の身体能力は高いが、チームとしてのまとまりが課題。",
        coach: { name: '高田 繁', style: '機動力野球', experience: 'ベテラン' }
    },
    "静岡農業": {
        name_yomi: "しずおかのうぎょう", region: "中部", type: "公立", deviation: 46,
        best: "県大会2回戦", last: "初戦敗退",
        info: "「静農（しずのう）」の愛称。実習で培った粘り強さと体力が武器。",
        coach: { name: '稲葉 篤紀', style: '全員野球', experience: '中堅' }
    },
    "清水西": {
        name_yomi: "しみずにし", region: "中部", type: "公立", deviation: 47,
        best: "県大会2回戦", last: "初戦敗退",
        info: "粘り強い守備が持ち味の公立校。接戦に持ち込みたい。",
        coach: { name: '西 清孝', style: '守備重視', experience: 'ベテラン' }
    },
    "清流館": {
        name_yomi: "せいりゅうかん", region: "中部", type: "公立", deviation: 65,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "焼津市にある比較的新しい高校。吉田高校と大井川高校が統合。地域の期待を背負い、上位を目指す。",
        coach: { name: '川上 憲伸', style: '投手中心', experience: 'プロOB' }
    },
    "遠江総合": {
        name_yomi: "とおとうみそうごう", region: "西部", type: "公立", deviation: 42,
        best: "県大会2回戦", last: "初戦敗退",
        info: "森町・周智高校の後継校。地域の星として、まずは初戦突破、そして上位進出を目指す。",
        coach: { name: '遠山 奬志', style: '堅実', experience: '中堅' }
    },
    "榛原": {
        name_yomi: "はいばら", region: "中部", type: "公立", deviation: 69,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "「榛高（はいこう）」の愛称。進学校ながら、機動力を絡めた攻撃的な野球で上位を伺う。",
        coach: { name: '原 辰徳', style: '超攻撃型', experience: 'ベテラン' }
    },
    "浜北西": {
        name_yomi: "はまきたにし", region: "西部", type: "公立", deviation: 65,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "「北西（きたにし）」の愛称。堅実な守備と粘り強い打撃で、強豪校に食らいつく。",
        coach: { name: '西 俊児', style: '守備重視', experience: '中堅' }
    },
    "浜松北": {
        name_yomi: "はままつきた", region: "西部", type: "公立", deviation: 60,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "静岡県トップクラスの進学校。限られた時間で超効率的な練習をこなす。",
        coach: { name: '北別府 学', style: 'データ野球', experience: 'ベテラン' }
    },
    "浜松湖東": {
        name_yomi: "はままつことう", region: "西部", type: "公立", deviation: 60,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "進学校の一つだが、野球部の練習も熱心。隙のない堅実な野球で勝ち上がる。",
        coach: { name: '佐藤 健', style: '堅実', experience: '中堅' }
    },
    "浜松湖北": {
        name_yomi: "はままつこほく", region: "西部", type: "公立", deviation: 65,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "引佐、気賀、三ケ日の3校が統合して誕生。奥浜名湖の広大な敷地で鍛えた総合力で勝負する。",
        coach: { name: '北川 博敏', style: '積極打撃', experience: '中堅' }
    },
    "浜松東": {
        name_yomi: "はままつひがし", region: "西部", type: "公立", deviation: 62,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "浜松市内の有力進学校。分析力と堅実な守備で上位を狙う。",
        coach: { name: '東尾 修', style: '投手中心', experience: 'ベテラン' }
    },
    "富岳館": {
        name_yomi: "ふがくかん", region: "東部", type: "公立", deviation: 44,
        best: "県大会3回戦", last: "県大会2回戦",
        info: "富士宮市にある。農業系の学科も持つ総合高校。富士山のような、どっしりとした戦いを見せたい。",
        coach: { name: '富田 勝', style: '堅実', experience: 'ベテラン' }
    },
    "袋井商業": {
        name_yomi: "ふくろいしょうぎょう", region: "西部", type: "公立", deviation: 48,
        best: "県大会2回戦", last: "初戦敗退",
        info: "商業高校ならではの緻密な分析と、伝統的な「守りの野球」で勝利を目指す。",
        coach: { name: '伊藤 裕季', style: '守備重視', experience: 'ベテラン' }
    },
    "富士": {
        name_yomi: "ふじ", region: "東部", type: "公立", deviation: 76,
        best: "県大会ベスト16", last: "県大会2回戦",
        info: "東部地区の伝統ある進学校。スマートな試合運びと、ここ一番での集中力が光る。",
        coach: { name: '斎藤 雅樹', style: '投手中心', experience: 'ベテラン' }
    },
    "藤枝北": {
        name_yomi: "ふじえだきた", region: "中部", type: "公立", deviation: 46,
        best: "県大会2回戦", last: "初戦敗退",
        info: "サッカーの強豪として知られるが、野球部も地元選手を中心に奮闘している。",
        coach: { name: '山田 暢久', style: '全員野球', experience: '中堅' }
    },
    "藤枝東": {
        name_yomi: "ふじえだひがし", region: "中部", type: "公立", deviation: 55,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "「サッカー王国」の一角を担う超名門校。野球部もその伝統を受け継ぎ、フィジカルの強さを活かしたプレーが持ち味。",
        coach: { name: '中山 雅史', style: '積極打撃', experience: '期待の若手' }
    },
    "焼津中央": {
        name_yomi: "やいづちゅうおう", region: "中部", type: "公立", deviation: 41,
        best: "県大会ベスト16", last: "県大会3回戦",
        info: "文武両道を掲げる進学校。効率的な練習で、上位進出を狙う。",
        coach: { name: '石田 雅昭', style: 'データ野球', experience: '中堅' }
    },
    "横須賀": {
        name_yomi: "よこすか", region: "西部", type: "公立", deviation: 52,
        best: "県大会ベスト8", last: "県大会2回戦",
        info: "「スカ」の愛称で知られる古豪。近年は安定した実力を保持しており、上位進出も珍しくない。",
        coach: { name: '衣笠 祥雄', style: '根性野球', experience: 'ベテラン' }
    },
    "吉原工業": {
        name_yomi: "よしわらこうぎょう", region: "東部", type: "公立", deviation: 44,
        best: "県大会2回戦", last: "初戦敗退",
        info: "「ヨシコウ」の愛称。工業高校らしい、ひたむきなプレーが信条。",
        coach: { name: '高橋 由伸', style: '積極打撃', experience: 'プロOB' }
    },
    "星陵": {
        name_yomi: "せいりょう", region: "東部", type: "私立", deviation: 60,
        best: "県大会ベスト8", last: "県大会3回戦",
        info: "富士宮市にある私立校。中高一貫の強みを活かし、投打にバランスの取れたチームを編成する。",
        coach: { name: '星野 仙一', style: '投手中心', experience: '名将' }
    }
};




/**
 * 試合会場の定義
 * 1回戦～3回戦は全10球場、準々決勝以降は主要4球場に集約する想定
 */
// ▼▼▼ この STADIUM_DATA の定義をまるごと置き換えてください ▼▼▼
const STADIUM_DATA = [
    { name: "草薙総合運動場硬式野球場", abbr: "草", region: "中部" },
    { name: "愛鷹広域公園野球場", abbr: "愛", region: "東部" },
    { name: "富士総合運動公園野球場", abbr: "富", region: "東部" },
    { name: "ちゅ～るスタジアム清水", abbr: "ち", region: "中部" },
    { name: "焼津球場", abbr: "焼", region: "中部" },
    { name: "島田球場", abbr: "島", region: "中部" },
    { name: "掛川球場", abbr: "掛", region: "西部" },
    { name: "浜岡球場", abbr: "岡", region: "西部" },
    { name: "磐田球場", abbr: "磐", region: "西部" },
    { name: "浜松球場", abbr: "浜", region: "西部" }
];
// ▲▲▲ 置き換えここまで ▲▲▲

// ▼▼▼ このブロックをまるごと追加 ▼▼▼
// 3回戦用の主要4球場（草薙、愛鷹、清水、浜松）
const ROUND_3_STADIUMS = [
    STADIUM_DATA[0], // 草薙
    STADIUM_DATA[1], // 愛鷹
    STADIUM_DATA[3], // ちゅ～るスタジアム清水
    STADIUM_DATA[9]  // 浜松
];

const QUARTER_FINAL_STADIUMS = [
    STADIUM_DATA[0], // 草薙
    STADIUM_DATA[3]  // ちゅ～るスタジアム清水
];

// 準々決勝以降用の球場（草薙のみ）
const FINAL_STAGE_STADIUMS = [
    STADIUM_DATA[0] // 草薙
];
// ▲▲▲ 追加ここまで ▲▲

/**
 * AIの解像度を上げるための「静岡県高校野球の常識・勢力図」（現実ベース＋架空・詳細版）
 * 全てのAI関数がこの情報を参照し、文脈を理解する。
 * (★ユーザー指摘に基づき、年度を修正した最終版)
 */
const PREFECTURE_LORE = `
静岡県の高校野球界は、長らく「公立の雄」である **静岡**（シズコウ）と**掛川西**（カケニシ）、そして甲子園優勝経験もある「古豪」**浜松商業**（ハマショウ）や**静岡商業**（静商） といった伝統校が上位を占める時代が長かった。

その均衡を打ち破ったのが、2007年のセンバツ全国制覇 を果たした**常葉菊川**（常葉大菊川）である。彼らの「超攻撃型野球」は一世を風靡し、県の勢力図を「伝統校 vs 菊川」の構図に変えた。

しかし、2010年代後半から現在（2025年）にかけて、勢力図はさらに複雑化する。「新・私立強豪」の時代である。
**加藤学園**（2023年春の王者）、**日大三島**（2022年センバツ出場）、**浜松開誠館**（2023年センバツ出場）、そして**聖隷クリストファー** (2023年の春の選抜高校野球に春夏通じて初の甲子園出場を決めた)が台頭。
静岡県は「伝統校 vs 菊川 vs 新・私立強豪」が激突する、全国屈指の「戦国時代」に突入していた。

この戦国時代に、さらに巨大な波乱要因として参入したのが、巨大資本「ナムコグループ」である。
ナムコはまず「**765総合高校**」を設立し、2年前に甲子園ベスト16という鮮烈なデビューを飾った。
さらに昨年、満を持して「**283学園**」を創部すると、姫川や白瀬といった全国レベルの選手を揃え、いきなり夏の県大会を制覇。昨年の王者として今大会の「倒すべき本命」となっている。

その結果、現在の静岡県（2025年）の常識は、以下の4大勢力によって構成されている。

1.  **【ナムコ資本】 (新・絶対王者)**
    * **283学園**: 昨年の覇者。圧倒的な戦力を誇る本命。
    * **765総合**: 2年前に甲子園を経験。王者283に次ぐ戦力。
    * (その他、美城学園, 初星学園, 283学園B など)

2.  **【現代・私立強豪】 (群雄割拠)**
    * **加藤学園**: 2023年春の王者。勢いのあるチームの一つ。
    * **日大三島**: 名将・永田監督の元、2022年に復活。
    * **浜松開誠館**: 2023年の春のセンバツ代表校。
    * **聖隷クリストファー**: 2023年の春の選抜高校野球に出場。
    * **常葉菊川**: 2007年の全国制覇の衝撃は今も健在。超攻撃型野球は脅威。
    * (その他、藤枝明誠, 磐田東、常葉橘、藤枝明誠、東海大翔洋など)

3.  **【伝統・公立校】 (公立の砦)**
    * **静岡**: 「公立最後の砦」として、新旧私立とナムコ資本に対抗する最大の希望。
    * **掛川西**: 静岡と並ぶ公立の雄。2018年夏甲子園出場、2023年夏ベスト4 と実力は健在。
    * **静岡商業**: 2006年夏甲子園出場。古豪としての意地がある。

4.  **【復活を目指す古豪】 (Cランク・古豪)**
    * **浜松商業**: かつての全国優勝校。近年は低迷しているが、復活を願うファンは多い。
    * **静清**: 浜商同様、近年は上位争いから遠ざかっている古豪。

---
### 静岡県高校野球の「常識」と「あるある」

* **283学園**: 昨年の覇者。その強さの象徴は、**「左右ジグザグに組まれた不動のオーダー」**にある。
        1番・十王と2番・樋口の鉄壁二遊間コンビがチャンスを作り、**3番・花海咲、4番・花海佑の「花海コンビ」**が還す得点パターンは破壊力抜群。
        さらに、5番・スイッチヒッター芹沢を挟み、**6番に「打てるエース」姫川**が座ることで、下位打線まで全く息が抜けない「切れ目のない打線」が完成している。
        この黄金の布陣は、県内他校から「283の悪夢」として恐れられている。

#### 1. 宿命の兄弟対決「トコハ・ダービー」
- **菊川 vs 橘:**
    - 同じ常葉大学グループの兄弟校である「常葉菊川（西部）」と「常葉橘（中部）」の対決は、決勝戦でなくても**「事実上の決勝」「トコハ・ダービー」**と呼ばれ、県内屈指の注目カードとなる。
    - 掲示板では「野性の菊川、理性の橘」「のら犬（菊川）vs 飼い犬（橘）」などと、その対照的なチームカラーが比較される。
    - **常葉菊川の「フルスイング」信仰:** バントをしない美学を持ち、どんなピンチでも強攻する。「菊川のDNA」と称賛される一方、「雑すぎる」と批判も受ける。
    - **常葉橘の「左腕王国」:** プロ注目の好左腕（サウスポー）を輩出する伝統があり、スカウトの注目度が高い。

#### 2. 地元メディアの「公立伝統校」信仰
- **実況の温度差:**
    - 地元テレビ局の実況アナウンサーは中立を装うが、内心では**静岡高校（シズコウ）**や**静岡商業（静商）**などの伝統校を猛烈に崇拝している。
    - 伝統校が得点すると「これぞ伝統の重み！」「古豪の意地！」と絶叫するが、283学園が得点すると「あーっと…入りました」と、明らかにトーンダウンする。
    - **判官贔屓（ハンガンビイキ）:** 公立校がナムコ系列校（283、765等）と戦う際、球場全体が公立校の味方となり、際どい判定が公立有利になる「地元判定」が起きることがある。

#### 3. 戦術トレンドと「対・ナムコ包囲網」
- **対・ナムコ包囲網:**
    - 圧倒的な戦力を持つナムコ系列校（283学園・765総合）を倒すため、**静岡高校・掛川西・静岡商**などの公立伝統校が、水面下で練習試合のデータを共有し、対策を練っているという噂がある。
    - 公立校が283学園の弱点を突いた時、AI記者は「包囲網が機能した」「データ班の勝利」と分析する。
- **低反発バットの影響:**
    - 「飛ばないバット」導入により、公立校は「低弾道・ゴロ打ち」の**スモールベースボール**に回帰。一方、283学園はウエイトトレーニングでこれをねじ伏せる**「パワー野球」**を展開。

#### 4. 大会の空気の変化
- **序盤（1・2回戦）:**
    - 地方球場で行われる牧歌的な雰囲気。スコアが大差になっても観客は温かい拍手を送る。掲示板も「今年も夏が来たな」と平和。
- **終盤（準々決勝以降）:**
    - テレビ中継が始まり、球場の空気が一変する。些細なエラーや采配ミスがSNSで拡散・炎上し、掲示板は「負けたら終わりのデスゲーム」と化す。





#### 5. 恐怖の「バックネット裏OB会」
- **公立校の足枷:**
    - 静岡高校や掛川西などの伝統校の試合では、バックネット裏の最前列を「帽子を被った長老OBたち」が占拠し、自軍の監督に対して「バントだろ！」「代えろ！」と怒号を飛ばすのが名物。
  
 
---
### 【全国版】甲子園における「地域の常識」と「格付け」
甲子園モード（全国大会）では、以下の常識が適用される。AIはこれを踏まえてコメントすること。

#### 1. 地域別・野球スタイルのイメージ
- **東北勢 (花巻東など):**
    - かつては「白河の関（優勝旗が東北に入らない）」が呪縛だったが、仙台育英の優勝以降、完全に払拭された。
    - 近年は大谷翔平や佐々木朗希のような**「規格外の怪物」**を輩出する土地として恐れられている。フィジカルが強く、雪国特有の粘り強さがある。
- **関東勢 (横浜、浦和学院、日大三など):**
    - **「洗練された野球」「都会的」**。技術レベルが非常に高く、ミスが少ない。
    - 激戦区（神奈川、東京、埼玉）を勝ち抜いてきたため、実質的な優勝候補筆頭とされることが多い。
    - ヒール（悪役）扱いされることもあるほど強い。
- **近畿勢 (大阪桐蔭、報徳学園など):**
    - 甲子園は彼らの**「地元（ホーム）」**である。ブラスバンドの音圧や観客の歓声が、相手チーム（特に地方公立）を飲み込む。
    - 大阪桐蔭は「横綱」。勝って当然、負ければ大ニュース。フィジカル、技術、層の厚さ、全てが別格。
- **東海勢 (静岡代表含む):**
    - 「打撃の愛知」「伝統の静岡」。中京地区は古くからの野球所であり、オールドファンが多い。

#### 2. 甲子園における「魔物」と「環境」
- **甲子園の魔物:**
    - 終盤（7,8,9回）、特に負けているチームがチャンスを作ると、球場全体の空気が変わり、守備側のありえないミスや連打を誘発する現象。
    - AIは**「魔物の気配がする」「球場の空気が変わった」**と表現すること。
- **浜風 (はまかぜ):**
    - 甲子園特有の海風。ライトからレフトへ強く吹くことが多く、**右打者のホームラン性の当たりを押し戻す**ことがある。逆に左打者の打球は伸びる。

#### 3. 今大会の「ラスボス」たち (レジェンド校の認識)
以下のチームは、単なる「Aランク」ではなく、**「歴史上の偉人」**と同等の扱いをする。
- **大阪桐蔭:** 現代の絶対王者。隙がない。ここに勝つことは「金星」以上の「歴史的事件」。
- **横浜:** 松坂大輔の伝説を知るファンが多く、「高校野球の代名詞」としてリスペクトされる。
- **花巻東:** 世界のオオタニの母校。何かとてつもないことをやってのける不気味さがある。
- **浦和学院:** 283学園にとっては「昨夏の悪夢」の相手。絶対に負けられない因縁の宿敵。

#### 4. 静岡代表 (283学園) の立ち位置
- **全国的な知名度:**
    - **「昨夏、浦和学院と7-9の壮絶な打ち合いを演じたチーム」**として記憶されている。
    - 初出場ながら関東王者をあと一歩まで追い詰めた攻撃力は全国の高校野球ファンに衝撃を与えた。
    - 「今年は投手陣を整備して帰ってきたのか？」「あの打線は健在か？」と、実力校としての再登場を期待されている。
- **ファンの目:**
    - 「サッカー王国の静岡から出てきた、打ち勝つ野球の新興勢力」。
    - 一部のオールドファンからは「荒削り」と言われることもあるが、多くのファンは昨年の激闘を覚えており、**「今年こそは初戦突破、そして浦学へのリベンジを果たしてほしい」**という判官贔屓（はんがんびいき）的な期待を寄せている。
    - 特に**浦和学院**との再戦が実現すれば、昨年のスコア（7-9）を超えるドラマが期待される、大会屈指の注目カードとなる。

---
### 【重要】チームランクに対する世間の認識（相場観）
AIは、各チームのランク（A～E）に対し、ファンがどのような感情を抱くかを理解し、コメントに反映すること。

- **Aランク (名門・優勝候補):**
    - **認識:** 「勝って当たり前」「負ければ大ニュース」。
    - **扱い:** 圧倒的な強さへの畏敬と、強すぎるが故のアンチが存在する。敗北時には「〇〇散る」「歴史的敗退」と騒がれる。
    - **ファン心理:** 「順当勝ちだな」「ここが負ける図が浮かばん」

- **Bランク (強豪・ベスト8常連):**
    - **認識:** 「地力がある実力校」「Aランクを食う筆頭候補」。
    - **扱い:** Aランク校にとっては最も厄介な壁。順当に勝ち上がる力があり、調子次第では優勝も狙える位置づけ。
    - **ファン心理:** 「今年はいいチーム仕上げてきたな」「〇〇（Aランク）を倒すならここしかない」

- **Cランク (中堅・ダークホース):**
    - **認識:** **「侮れない不気味な存在」「ジャイアントキリングの予感」**。
    - **扱い:** 上位校にとって**最も警戒すべき「沼」**。一発勝負の怖さを体現するチーム群。特定の武器（好投手、機動力、特殊な戦術など）を持っており、ハマればAランクすら食うポテンシャルがある。
    - **ファン心理:** **「ここ、地味に強いぞ」「シード校が初戦でここ引くとか不運すぎ」「今年の台風の目になるかも」**

- **Dランク (発展途上・公立の実力校):**
    - **認識:** 「たまに良い選手が出る」「地元では有名」。
    - **扱い:** 基本的には1,2回戦レベルだが、エースの出来次第では接戦に持ち込む。Cランク以上への勝利は「金星」として称えられる。
    - **ファン心理:** 「ワンチャンあるか？」「コールド回避できれば御の字」

- **Eランク (挑戦者・無名校):**
    - **認識:** 「初戦突破が目標」「部員不足に悩むことも」。
    - **扱い:** 圧倒的なアンダードッグ（判官贔屓の対象）。強豪相手に1点でも取れば盛り上がる。勝利すれば「奇跡」として語り継がれる。
    - **ファン心理:** 「思い出作りにはさせんぞ」「全力でぶつかってこい！」

この「常識」は、AI記者やBBS住民の基本的な思考パターンとなります。
---
### 参考：高校野球における「打順の常識」
AIは以下の「打順の役割」を理解し、分析やコメントに反映すること。

-   **1番 (リードオフマン):** チームで最も俊足で出塁率が高い選手。彼が出塁できるかが攻撃の鍵。
-   **2番 (つなぎ役):** バントや進塁打が得意な器用な選手。1番を2塁に進めるのが仕事。最近はこの打順に強打者を置くことも増えている。
-   **3番 (強打者):** チームで最も打撃技術が高い選手。チャンスメイクもでき、長打も打てる。
-   **4番 (主砲):** チーム最強の打者。ランナーを返す（打点）ことが最大の使命。彼が打てないとチームは勝てない。
-   **5番 (強打者):** 4番の「後片付け」役。4番が返せなかったランナーを返したり、チャンスを拡大したりする。
-   **6番, 7番 (下位打線):** 上位打線ほどのプレッシャーはないが、ここで打てるとチームは勢いづく。
-   **8番 (守備要員):** 守備は上手いが打撃は期待されていないことが多い。
-   **9番 (第2の1番):** 投手（打撃が苦手）の次であることが多く、打撃が良い選手が置かれると、1番打者に戻るまでの「第2のチャンスメーカー」として機能する。
---
### 参考：高校野球における「投打の左右の常識」
AIは以下の「相性」を理解し、分析やコメントに反映すること。

-   **右投手 vs 右打者:** 一般的に投手が有利。外角に逃げるスライダーが有効。
-   **右投手 vs 左打者:** 一般的に打者が有利。内角に食い込む球（クロスファイア）が鍵。
-   **左投手 vs 左打者:** 一般的に投手が有利。「ワンポイントリリーフ」として起用されることも。
-   **左投手 vs 右打者:** 一般的に打者が有利。
-   **戦術:** 相手エースが「右腕」の場合、スタメンに「左打者」を並べる「ジグザグ打線」は有効な戦術である。逆に、相手が「左腕」なのに左打者を並べると「なぜだ？」と疑問視される。
**両打 (スイッチヒッター):** 相手投手の左右によって有利な打席に立てるため、特に1番・2番にいると非常に厄介な存在となる。
---
### 参考：高校野球における「球速の常識」（投手の左右・レベル別）
AIは以下の「球速帯」が持つ意味を、**投手の左右**と**学校のレベル（公立か強豪か）**で判断基準を変えて分析すること。

-   **120km/h 〜 125km/h帯:**
    - **（右腕の場合）:** **「公立校の1、2回戦レベルであれば、エースとして十分通用する」**球速。
        - **分析:** ただし、これだけで強豪私立の上位打線を抑えるのは難しい。「技巧派」や「軟投派」として、打者の手元で小さく動く「ツーシーム」や、90km/h台の「スローカーブ」で緩急をつけ、**打たせて取る**投球術が生命線となる。
        - BBS反応：「120km台でもコントロール良ければ打てんよな」「公立のエースって感じ」「ザ・技巧派」
    - **（左腕の場合）:** **非常に価値がある。**球速は遅くとも、このレベルの**「左腕（サウスポー）」**であること自体に希少価値がある。
        - **分析:** ご指摘の通り、**強豪校でも、**相手の左打者を抑えるための「ワンポイントリリーフ」や、食い込む「クロスファイア」を武器にする技巧派の2番手投手としてベンチ入りすることが多い。
        - BBS反応：「左で120後半なら十分」「左のサイドとか一番嫌だわ」「ワンポイント専用機やな」

-   **130km/h 〜 135km/h帯:**
    - **（右腕の場合）:** **公立校なら間違いなく「エース級」。**私立強豪校でも2番手・3番手投手としてベンチ入りするレベル。
        - **分析:** このレベルの投手は非常に多く、トーナメントを勝ち上がるには、球速以外の武器（例：鋭く落ちるスプリット、高速スライダー）がカギとなる。
    - **（左腕の場合）:** **強豪校のエース**として十分なレベル。
        - **分析:** **「甲子園出場校のエース」**としても珍しくない。右打者のアウトコースに逃げるスライダーや、左打者のインコースを突くシュート（クロスファイア）を武器に、打たせて取る「試合を作る」タイプの投手が多い。
    - BBS反応（右腕）：「130km台出れば公立じゃ無双できる」「私立の中軸に通用するか」
    - BBS反応（左腕）：「左で135km出てれば、右の140kmより打ちにくい」「こういう技巧派左腕が甲子園で勝つんだよな」

-   **140km/h 〜 145km/h帯:**
    - **（右腕の場合）:** **「県内屈指」**の好投手。Aランクの強豪校でエースナンバーを背負うレベル。
    - **（左腕の場合）:** **「超高校級」**。プロがスカウトの上位候補としてマークし始める。左腕でこの球速は圧倒的なアドバンテージとなる。
    - BBS反応（右腕）：「はっや！」「県内屈指の〇〇くん」「これは打てんわ」
    - BBS反応（左腕）：「左で145kmはエグい」「ドラフト候補やろ」

-   **150km/h 〜 155km/h帯:**
    - **（共通）:** **「ドラフト級」**。左右問わず、高校生レベルを逸脱した「怪物」であり、ドラフト1位指名も現実的。
    - BBS反応：「ファッ！？150超えキター！」「バケモンだろこいつ」「ドラ1確定」

-   **160km/h 〜 165km/h帯:**
    - **（共通）:** 歴史的な投手。
    - BBS反応：「大谷かよ」「漫画の世界」
`;
// ▲▲▲ ここまでを貼り付け（または上書き） ▲▲▲


    const DETAILED_TEAM_DATA = {
        "283学園": {
            summary: "夏の連覇の先に、聖地での勝利を目指す。昨年王者、守備の一体感と打線のつながりを強みに、試合ごとに成長。チームスローガンは『強』。個の技量に頼らず、一人ひとりの力を集めて戦う。姫川白瀬の投手リレーは全国ピカイチ",
            players: [
                { name: "姫川", year: 3, position: "ピッチャー", desc: "投打の中心。MAX151kmの直球とスプリットで相手を圧倒する、プロ注目の高校通算42本塁打の怪物。" },
                { name: "花海咲", year: 3, position: "センター", desc: "1年夏からベンチ入りを果たしている、経験豊富な走攻守三拍子揃ったスラッガー。攻守の要として監督からの信頼は厚い。" },
                { name: "鈴木", year: 2, position: "ファースト", desc: "チャンスに強い仕事人。" },
                { name: "十王", year: 3, position: "ショート", desc: "監督も絶大な信頼を寄せる鉄壁の守備を誇る名手。チャンスメイクも得意な打者。" },
                { name: "八宮", year: 2, position: "サード", desc: "2年生ながら5番に座ることもあるクラッチヒッター。ポテンシャルが高い。" },
                { name: "樋口", year: 3, position: "セカンド", desc: "強肩強打のパワーヒッター。勝負強い打撃が光る。" },
                { name: "有栖川", year: 3, position: "キャッチャー", desc: "大舞台に強い主軸。変化球打ちの技術はチームトップクラス。" },
                { name: "芹沢", year: 2, position: "レフト", desc: "小技と守備センスが光る渋い選手。チャンスでの一打も。" },
                { name: "花海佑", year: 1, position: "ライト", desc: "1年生のスーパースター。兄・咲との連携も抜群。既に通算13本塁打。" },
                { name: "黛", year: 2, position: "ピッチャー", desc: "チーム最速の直球を持つ。春はメンバー外の悔しさをバネに復調を目指す。" },
 { name: "西城", year: 2, position: "ピッチャー", desc: "球威のある直球で打者を詰まらせる速球派投手。制球に課題はあるもののポテンシャルはピカイチ。打者としての能力も高い" },
                { name: "白瀬", year: 3, position: "ピッチャー", desc: "試合の後半を締めるクローザー的役割のエース。最速155kmの伸び上がるストレートを武器に打者を次々と打ち取る。春の大会では静岡高校相手に完全試合も達成した。" }
            ]
        },
        "常葉菊川": {
            summary: "個々のレベルアップが結実し昨年は準優勝。個人成績の可視化と実力主義でチーム内の競争を活性化させ、初の甲子園を目指す。スローガンは『個々の能力重視』。",
            players: [
                { name: "沖田", year: 3, position: "ピッチャー", desc: "投打の大黒柱。MAX157kmの速球を持つ主砲。" },
                { name: "土方", year: 3, position: "キャッチャー", desc: "グラウンド上の監督。高いスローイング技術と高校通算28本塁打のパワーを持つ。" },
                { name: "宮本", year: 3, position: "ファースト", desc: "力強い打撃と勝負強さが魅力の3番打者。" },
                { name: "柳生", year: 2, position: "セカンド", desc: "バッティングセンスに優れる2年生。落ち着いたプレーが光る。" },
                { name: "近藤", year: 3, position: "サード", desc: "ガッツあふれるプレーでチームを引っ張る5番打者。高校通算46本塁打。" },
                { name: "坂本", year: 3, position: "ショート", desc: "走攻守三拍子揃った抜群の身体能力を持つショート。" },
                { name: "岡田", year: 3, position: "ライト", desc: "高校通算71本塁打を誇る絶対的な4番。恵まれた体格からの強打が武器。" },
                { name: "森", year: 2, position: "センター", desc: "50m6秒フラットの俊足。攻守にわたり抜群の勝負強さを見せる。" },
                { name: "上泉", year: 3, position: "レフト", desc: "バランスと勝負強い打撃が武器。逆転劇のきっかけを作る。" },
                { name: "拝", year: 3, position: "ピッチャー", desc: "巧みな投球術と強い精神力を持つ控え投手。MAX155km。" },
                { name: "疋田", year: 2, position: "ピッチャー", desc: "クレバーさと強気を兼ね備えた2年生投手。昨夏も登板経験あり。" }
            ]
        },
        "掛川西": {
            summary: "昨年ベスト4。選手の長所を活かす野球で、磨き上げた守備力とタイプの違う3年生投手3人の継投を武器に、2005年以来の夏の聖地を目指す。",
            players: [
                { name: "豪炎寺", year: 3, position: "ピッチャー", desc: "最速158kmの直球と縦スライダーで打者を打ち取る絶対的エース。" },
                { name: "円堂", year: 3, position: "キャッチャー", desc: "冷静なリードで多彩な投手陣を引っ張る扇の要。3番打者としても活躍。" },
                { name: "壁山", year: 3, position: "ファースト", desc: "190cmの長身を生かした守備と長打力が魅力。" },
                { name: "半田", year: 3, position: "セカンド", desc: "小柄ながら攻守に堅実なプレーでチームに貢献。" },
                { name: "一ノ瀬", year: 3, position: "サード", desc: "チーム一の打球の速さを誇る2番打者。" },
                { name: "土門", year: 3, position: "ショート", desc: "ミスの少ない堅実な守備で試合のリズムを作る内野の要。" },
                { name: "染岡", year: 3, position: "レフト", desc: "監督も絶大な信頼を寄せる大砲。気持ちの強さも魅力。" },
                { name: "風丸", year: 3, position: "センター", desc: "サイクルヒット達成経験もあるリードオフマン。ミート力が格段にアップ。" },
                { name: "栗松", year: 2, position: "ライト", desc: "力強いスイングから放たれる長打が魅力の2年生。" },
                { name: "鬼道", year: 3, position: "ピッチャー", desc: "キレのある縦スライダーと内角への直球が魅力の右腕。" },
                { name: "松野", year: 2, position: "ピッチャー", desc: "MAX144kmのストレートとカットボールが武器の2年生。奪三振能力が高い。" }
            ]
        },
        "静岡": {
            summary: "投打の大黒柱を中心にダイナミックなベースボールを展開。攻めの姿勢を貫き、聖地を見据える伝統校。どこからでも得点できる打線が強み。",
            players: [
                { name: "倉田", year: 3, position: "ピッチャー", desc: "常時150km超の速球を投げる本格派エース。" },
                { name: "澄川", year: 3, position: "キャッチャー", desc: "強肩強打の司令塔。盗塁阻止率は随一。4番としてもチームを背負う" },
                { name: "舟橋", year: 3, position: "ファースト", desc: "高校通算63本塁打のプロ注目スラッガー。得点圏での勝負強さが光る。" },
                { name: "江野", year: 3, position: "セカンド", desc: "俊足と広い守備範囲が武器の機動力内野手。" },
                { name: "松浪", year: 3, position: "サード", desc: "大柄な体の目立つパワーヒッター。多少体勢が崩れても外野の頭を超える" },
                { name: "別津", year: 3, position: "ショート", desc: "軽快なフットワークが光る守備職人。つなぎ役もこなしながら長打力も光る。" },
                { name: "長内", year: 3, position: "レフト", desc: "小柄ながら高い身体能力を持つ。クリーンアップの後を打ちランナーを残さない。" },
                { name: "阿部", year: 3, position: "センター", desc: "190cmの巨体がトレードマークのスラッガー。脱力したフォームから目が覚めるような打球を繰り出す。" },
                { name: "大谷", year: 3, position: "ライト", desc: "安定した打率を誇る右打者。正確な返球も魅力。" },
                { name: "山本", year: 3, position: "ピッチャー", desc: "最速152kmの剛腕。リリーフも先発もこなす万能型。" },
                { name: "砂田", year: 3, position: "ピッチャー", desc: "左腕から多彩な変化球を投げるクローザー的存在。" }
            ]
        },
        "聖隷クリストファー": {
            summary: "昨年ベスト8。選手の長所を活かした攻撃力と堅守を武器に雪辱を期す。タイプの異なる3人の投手による継投が強み。",
            players: [
                { name: "沢村", year: 2, position: "ピッチャー", desc: "最速140kmの直球と多彩な変化球で三振を奪う次世代エース左腕。" },
                { name: "降谷", year: 3, position: "ピッチャー", desc: "長身から投げ下ろすスライダーとシュートが武器の大型右腕。" },
                { name: "御幸", year: 3, position: "キャッチャー", desc: "攻守にわたる高い野球センスを誇るプロ注目の司令塔。" },
                { name: "前園", year: 2, position: "一塁手／外野手", desc: "高い打撃技術と強肩を持つ大型野手。" },
                { name: "小湊", year: 3, position: "二塁手", desc: "堅実な守備と巧みなバットコントロールが光る。" },
                { name: "金丸", year: 3, position: "三塁手", desc: "打球反応が速く、強肩が武器。中距離ヒッター。" },
                { name: "倉持", year: 2, position: "ショート", desc: "俊敏な動きと華麗な守備が魅力の内野の要。" },
                { name: "結城", year: 3, position: "レフト", desc: "長打力を武器に快音を響かせる強打者。" },
                { name: "東条", year: 3, position: "センター", desc: "強肩と確実な捕球で外野を統率する守備職人。" },
                { name: "白州", year: 3, position: "ライト", desc: "打撃センスが光る左打者。冷静な状況判断が持ち味。" }
            ]
        },



        "三島北": {
            summary: "雪辱を期す知性派軍団。絶対的エース榛名を擁し、データを駆使した緻密な野球で昨夏の悔しさを晴らす。チームスローガンは『知は力なり』。",
            players: [
                { name: "榛名", year: 3, position: "ピッチャー", desc: "最速140km後半の直球と高速スライダーで三振の山を築く絶対的エース。" },
                { name: "秋丸", year: 3, position: "キャッチャー", desc: "冷静沈着なリードでエース榛名を支える扇の要。" },
                { name: "大川", year: 3, position: "ファースト", desc: "チーム不動の4番。一振りで試合の流れを変えるパワーが魅力。" },
                { name: "福原", year: 3, position: "ショート", desc: "卓越したバットコントロールと選球眼を持つ1番打者。守備も堅実。" },
                { name: "町田", year: 3, position: "センター", desc: "走攻守三拍子揃ったアベレージヒッター。3番を担う。" }
            ]
        },
        "静岡商業": {
            summary: "王座奪還へ、揺るぎなき『王国』のプライド。昨年の雪辱に燃える絶対王者。投打にタレントを揃え、最強左腕・成宮を軸に再び全国の頂点を目指す。スローガンは『常勝』。",
            players: [
                { name: "成宮", year: 3, position: "ピッチャー", desc: "「キング」の異名を持つ世代最強左腕。MAX150km/hの直球と魔球チェンジアップを操る。" },
                { name: "神谷", year: 3, position: "センター", desc: "50m5秒台の俊足を誇る「チーター」。攻守に規格外の身体能力を見せる。" },
                { name: "白河", year: 3, position: "ショート", desc: "卓越した野球センスと華麗な守備が光る内野の司令塔。" },
                { name: "多田野", year: 2, position: "キャッチャー", desc: "「キング」成宮の女房役を射止めた2年生捕手。冷静なリードが持ち味。" },
                { name: "山岡", year: 3, position: "サード", desc: "頼れる4番打者。昨年は６番ながらも大会打点王などに輝いた。今年は満を持して4番に君臨し、勝負強い打撃をする。高校通算61本。" }
            ]
        },
        "藤枝明誠": {
            summary: "守りを固めて試合をつくる明誠らしさは健在。投手は左腕の宇垣、左腕宮城らが中心で、成長著しい捕手宜野座がリードする。１年時から主力の主将宮原は１番中堅として攻守でチームをけん引。中軸の比嘉は長打力があり、ここぞの場面で期待がかかる。総力戦で勝利を積み上げ、頂点を目指す。",
            players: [
                { name: "宮城", year: 3, position: "ピッチャー", desc: "明誠の投手陣を１年次から支えてきた経験豊富なエース左腕。140kmを超えるストレートと鋭いフォークが持ち味" },
                { name: "宜野座", year: 2, position: "キャッチャー", desc: "不動の4番。高校生離れしたパワーを誇る規格外の長距離砲。「明誠の頭脳」と称されるリードも武器。" },
                { name: "新垣", year: 3, position: "ファースト", desc: "チャンスに強い5番バッター。変化球への対応がうまく簡単に打ち取られない" },
                { name: "比嘉", year: 3, position: "セカンド", desc: "チームの中核を担う３番バッター。広角に打ち分ける技術と堅実な守備が光る。" },
                { name: "宮原", year: 3, position: "センター", desc: "俊足が武器の外野手。意外な勝負強さも見せる。" }
            ]
        }
    };
    const INITIAL_TEAM_POOL = Object.keys(TEAM_DATA);

    // --- Utility & State Functions ---
   

 function shuffleArray(array) {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
        }
        return newArray;
    }
    
    function saveState() {
        try {
            localStorage.setItem('tournamentState', JSON.stringify(tournamentState));
        } catch (e) {
            console.error("進行状況の保存に失敗しました:", e);
            showAlert("進行状況の保存に失敗しました。ブラウザのストレージ容量が不足している可能性があります。");
        }
    }
    
    function uint8ArrayToBase64(bytes) {
        let binary = '';
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    function getRankFromHistoryString(historyString) {

        if (historyString.includes('優勝')) return 1;

        if (historyString.includes('準優勝')) return 2;

        if (historyString.includes('ベスト4')) return 4;

        if (historyString.includes('ベスト8')) return 8;

        if (historyString.includes('ベスト16')) return 16;

        if (historyString.includes('3回戦')) return 16;

        if (historyString.includes('2回戦')) return 32;

        if (historyString.includes('初戦敗退')) return 64;

        return 64;

    }
   
/**
 * [UPDATED] 順位数値を文字列に変換する
 */
function getRankString(rank) {
    // ★ 甲子園成績 (マイナス値)
    if (rank < 0) {
        const abs = Math.abs(rank);
        if (abs === 1) return "甲子園優勝";
        if (abs === 2) return "甲子園準優勝";
        if (abs === 4) return "甲子園ベスト4";
        if (abs === 8) return "甲子園ベスト8";
        if (abs === 16) return "甲子園ベスト16";
        if (abs === 32) return "甲子園2回戦";
        if (abs === 64) return "甲子園出場"; // 初戦敗退
        return `甲子園出場`;
    }
    
    // ★ 県大会成績 (プラス値)
    if (rank === 1) return "県大会優勝";
    if (rank === 2) return "県大会準優勝";
    if (rank <= 4) return "県大会ベスト4";
    if (rank <= 8) return "県大会ベスト8";
    if (rank <= 16) return "県大会ベスト16";
    if (rank <= 32) return "県大会3回戦";
    if (rank <= 64) return "県大会2回戦";
    return "県大会初戦敗退";
}
// --- Utility & State Functions --- などに追加

/**
 * Creates a subtle, realistic dust particle animation.
 */
function createDustEffect() {
    const container = document.getElementById('dust-container');
    if (!container) return;
    
    const particleCount = 20; // The number of dust particles

    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'dust-particle';
        
        const size = Math.random() * 3 + 1; // Particle size between 1px and 4px
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // Use CSS variables to randomize the start and end points of the animation
        particle.style.setProperty('--x-start', `${Math.random() * 100}vw`);
        particle.style.setProperty('--x-end', `${Math.random() * 100}vw`);
        
        particle.style.animationDuration = `${Math.random() * 20 + 10}s`; // Duration between 10s and 30s
        particle.style.animationDelay = `${Math.random() * 10}s`; // Stagger the start time
        
        container.appendChild(particle);
    }
}
/**
 * スコアボードの合計点を更新する
 */
/**
/**
 * スコアボードの合計点を更新する
 */
function updateTotalScores() {
    const table = document.getElementById('inning-score-table');
    if(!table) return;

    table.querySelectorAll('tbody tr').forEach(row => {
        const total = Array.from(row.querySelectorAll('input')).reduce((sum, input) => {
            const value = parseInt(input.value);
            return isNaN(value) ? sum : sum + value;
        }, 0);
        
        const totalCell = row.querySelector('.total-score');
        if (totalCell) {
            totalCell.textContent = total;
        }
    });
}
/**
 * 戦績レコードを読みやすい文字列に変換する
 */
function formatRecordToString(record) {
    if (!record) return "データなし";
    const year = record.year.toString().slice(-2);
    const tournamentNameMap = { summer: '夏', autumn: '秋', spring: '春' };
    const tournament = tournamentNameMap[record.tournament] || '';
    const rank = getRankString(record.rank);
    // ★★★ 以下の行を変更 ★★★
    const prefix = record.rank < 0 ? '' : '県大会'; // 甲子園成績の場合は「県大会」をつけない
    return `'${year} ${tournament}: ${prefix}${rank}`;
    // ★★★ ここまで変更 ★★★
}

// AI Content Generation & Helpers のセクションに追加

/**
 * チームの今大会の軌跡を要約する
 * (★試合内容の要約(narrativeSummary)を反映する最終版)
 *
 * @param {string} teamName - チーム名
 * @param {string} currentMatchId - 現在処理中の試合ID (集計から除外するため)
 * @returns {string} - AIプロンプト用のチーム状況要約文
 */
function getCurrentTournamentPerformance(teamName, currentMatchId) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) return "今大会初戦。";

    const path = []; // 勝ち上がり履歴 (例: "1回戦で〇〇に 8-1 で勝利")
    const keyPerformances = new Set(); // 活躍ハイライト (例: "鈴木が1回戦で猛打賞")
    const playerAggStats = {}; // 今大会の個人成績集計用 (例: { "鈴木": { ab: 8, h: 3, ... } })

    // --- 1. 全大会の試合データを統合 ---
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };
    
    // --- 2. 現在の大会に絞り込み ---
    const currentTournamentKey = tournamentState.currentTournament;
    
    const currentTournamentMatchIds = Object.keys(allMatches).filter(matchId => {
        let isCurrentTournamentMatch = false;
        
        if (currentTournamentKey === 'summer') {
            // 夏: 'L-', 'R-', 'F-' (県大会本戦ID)
            isCurrentTournamentMatch = matchId.startsWith('L-') || matchId.startsWith('R-') || matchId.startsWith('F-');
        } else if (currentTournamentKey === 'autumn') {
            // 秋: 地区予選ID または (本戦フェーズなら) 県大会本戦ID
            const isRegional = matchId.startsWith('東部-') || matchId.startsWith('中部-') || matchId.startsWith('西部-') || matchId.startsWith('伊豆-');
            const isMain = matchId.startsWith('L-') || matchId.startsWith('R-') || matchId.startsWith('F-');
            isCurrentTournamentMatch = isRegional || (tournamentState.autumnPhase === 'main' && isMain);
        } else if (currentTournamentKey === 'spring') {
            // 春: 地区予選ID または (本戦フェーズなら) 県大会本戦ID
            const isRegional = matchId.includes('-SB') || matchId.includes('-SREP') || matchId.includes('-SIZU');
            const isMain = matchId.startsWith('L-') || matchId.startsWith('R-') || matchId.startsWith('F-');
            isCurrentTournamentMatch = isRegional || (tournamentState.springPhase !== 'regional_qualifiers' && isMain);
        }
        
        return isCurrentTournamentMatch;
    });

    // --- 3. 今大会の全試合を分析 ---
    for (const matchId of currentTournamentMatchIds) {
        // 処理中の試合(currentMatchId)自体は集計から除外
        if (matchId === currentMatchId) continue;
        
        const match = allMatches[matchId];
        
        // チームが関わった試合か、勝者が決まっているか
        if (match && match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            const opponent = match.team1 === teamName ? match.team2 : match.team1;
            if (!opponent) continue; // 不戦勝などは除外
            
            const roundName = getRoundNameFromMatchId(matchId); // ラウンド名取得

            // A. 勝ち試合の履歴を生成
            if (match.winner === teamName) {
                
                if (currentTournamentKey === 'summer') {
                    // 【夏大会】スコアとランクを含む複雑な表現
                    const winnerScore = (match.team1 === teamName ? match.score1 : match.score2) || 'W';
                    const loserScore = (match.team1 === teamName ? match.score2 : match.score1) || 'L';
                    const opponentRank = calculateRank(opponent, tournamentState);
                    
// ▼▼▼ 【追加】コールド情報の取得 ▼▼▼
                    const calledInfo = match.calledGame ? `(${match.calledInning}回C)` : '';
                    // ▲▲▲ 追加ここまで ▲▲▲

                    // ★★★ ここからが今回の修正箇所 ★★★
                    let narrativeSummary = "";
                    // 1. match.details に保存された要約文を取得
                    if (match.details && match.details.narrativeSummary) {
                        // "〇〇が勝利を掴んだ" や "投手戦となった" などの重複表現を削除
                        narrativeSummary = match.details.narrativeSummary
                            .replace(/で、?.*が勝利を掴んだ/, '')
                            .replace(/で、?.*が勝利した/, '')
                            .replace(/、?息詰まる投手戦となった/, 'の投手戦')
                            .replace(/、?壮絶な打撃戦となった/, 'の打撃戦');
                    }
                    
                    let pathText;
                    if (narrativeSummary) {
                        // ▼▼▼ 修正: calledInfo を追加 ▼▼▼
                        pathText = `${roundName}で${opponent}(${opponentRank})に ${winnerScore}-${loserScore}${calledInfo} で勝利 (${narrativeSummary})`;
                    } else {
                        // ▼▼▼ 修正: calledInfo を追加 ▼▼▼
                        pathText = `${roundName}で${opponent}(${opponentRank})に ${winnerScore}-${loserScore}${calledInfo} で勝利`;
                    }
                    path.push(pathText);
                    // ★★★ 修正ここまで ★★★

               } else {
                    // 【秋・春大会】シンプルな表現
         // ▼▼▼ 修正: 秋・春もコールドを表示したい場合はここも修正 ▼▼▼
                    const calledInfo = match.calledGame ? `(${match.calledInning}回C)` : '';
                    path.push(`${roundName} vs ${opponent}${calledInfo}`);
                }
            }

            // B. 個人成績（キーパフォーマンス）の収集 (変更なし)
            if (match.details) {
                const teamKey = match.team1 === teamName ? 'team1' : 'team2';
                
                const pitchers = match.details.pitching?.[teamKey] || [];
                pitchers.forEach(p => {
                    if (p.name && p.result === 'W' && parseFloat(p.innings) >= 6) {
                        keyPerformances.add(`${p.name}が${roundName}で好投`);
                    }
                });

                if (match.details.playerGameStats) {
                    const gameStats = match.details.playerGameStats[teamKey];
                    for (const playerName in gameStats) {
                        // 今大会の集計用オブジェクトを初期化
                        if (!playerAggStats[playerName]) {
                            playerAggStats[playerName] = { ab: 0, h: 0, hr: 0, rbi: 0 };
                        }
                        const agg = playerAggStats[playerName];
                        const game = gameStats[playerName];
                        
                        // この試合の成績を加算
                        agg.ab += game.ab || 0;
                        agg.h += game.h || 0;
                        agg.hr += game.hr || 0;
                        agg.rbi += game.rbi || 0;
                        
                        // 猛打賞
                        if (gameStats[playerName].h >= 3) {
                            keyPerformances.add(`${playerName}が${roundName}で猛打賞`);
                        }
                    }
                }
            }
        }
    } // (試合ループ終了)
    
    // --- 4. 最終的な文章の組み立て ---
    let summary = "";
    if (path.length === 0) {
        summary = "今大会初戦。";
    } else {
        if (currentTournamentKey === 'summer') {
            summary = `ここまでの勝ち上がり: ${path.join('、')}。`;
        } else {
            // 秋・春は「→」でつなぐ
            summary = `ここまでの勝ち上がり: ${path.join(' → ')}。`;
        }
    }
    
    // 5. 今大会の通算成績の分析 (変更なし)
    for (const playerName in playerAggStats) {
        const stats = playerAggStats[playerName];
        if (stats.ab >= 5) { // 5打数以上の選手を対象
            const battingAverage = (stats.ab > 0) ? (stats.h / stats.ab) : 0;
            if (battingAverage >= 0.4) {
                keyPerformances.add(`${playerName}が打率${battingAverage.toFixed(3)}と絶好調`);
            } else if (battingAverage <= 0.2 && battingAverage > 0) { // 0割は不振と言わない
                keyPerformances.add(`${playerName}が打率${battingAverage.toFixed(3)}と不振`);
            }
        }
    }
    
    if (keyPerformances.size > 0) {
        summary += ` 今大会の主な活躍: ${Array.from(keyPerformances).join('、')}。`;
    }

    return summary;
}
// ▼▼▼ このブロックをまるごと追加 ▼▼▼

/**
 * 本格的なまとめサイトのHTMLを、現実と架空のニュースを融合させて生成する
 * (★「ラウンド総括スレッド」も一覧に表示するよう修正)
 * @returns {Promise<string>} 生成されたHTML文字列
 */
async function generateMatomeSiteHtml() {
    let articles = [];
    
    // --- 1. 現実のニュースをまとめてリクエスト ---
    try {
        const response = await fetch('/.netlify/functions/get-news');
        if (!response.ok) {
            throw new Error(`サーバーエラー: ${response.status}`);
        }
        const realNewsArticles = await response.json();
        articles.push(...realNewsArticles);

    } catch (e) {
        console.error("サーバーからのニュース取得に失敗しました:", e);
        articles.push({ headline: "【速報】ニュースサーバー、ダウン中", type: 'real', timestamp: Date.now(), category: 'システム' });
    }

    // --- 2. ゲーム内のニュースを取得 ---
    const gameNewsList = tournamentState.news || [];
    
    // (A) 試合結果の記事 (dbMatch を持つ)
    gameNewsList.filter(n => n.context && n.context.dbMatch).slice(-5).forEach(gameNews => {
        const { winnerName, loserName, dbMatch } = gameNews.context;
        const winnerRank = calculateRank(winnerName, tournamentState);
        const loserRank = calculateRank(loserName, tournamentState);
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        let gameTitle = `【高校野球】${winnerName}が${loserName}に勝利！`;

        if (rankValues[winnerRank] < rankValues[loserRank]) {
            gameTitle = `【超絶悲報】${loserName}(${loserRank}ランク)、格下の${winnerName}(${winnerRank}ランク)に負けるｗｗｗｗ`;
        } else if ((parseInt(dbMatch.score1) + parseInt(dbMatch.score2)) > 15) {
            gameTitle = `【乱打戦】${winnerName}vs${loserName}、とんでもない試合になる`;
        }
        
        articles.push({
            headline: gameTitle,
            type: 'game',
            matchId: dbMatch.id,
            timestamp: gameNews.timestamp,
            category: '高校野球'
        });
    });
    
    // ★★★ ここからが修正箇所 ★★★
    // (B) ラウンド総括の記事 (isMatomeLink を持つ)
    gameNewsList.filter(n => n.isMatomeLink === true).forEach(summaryNews => {
        articles.push({
            headline: summaryNews.title, // 記事のタイトル (例: 【1回戦 総括】...)
            type: 'game', // まとめスレッドなので 'game' タイプとして扱う
            matchId: summaryNews.matomeThreadId, // リンク先のスレッドID
            timestamp: summaryNews.timestamp,
            category: '大会総括' // 専用カテゴリ
        });
    });
    // ★★★ 修正ここまで ★★★

    // --- 3. ユーザー作成スレッドを取得 ---
    const userThreads = tournamentState.userThreads || [];
    userThreads.forEach(userThread => {
        articles.push(userThread);
    });

    // --- 4. 全記事をタイムスタンプでソートしてHTMLを生成 ---
    articles.sort((a, b) => b.timestamp - a.timestamp);

    if (articles.length === 0) {
        return '<p class="text-center text-gray-500">まだ表示できるニュースがありません。</p>';
    }

    const categoryColors = {
        "高校野球": "bg-green-100 text-green-800",
        "大会総括": "bg-yellow-100 text-yellow-800", // ★総括スレッド用の色
        "自スレ": "bg-blue-100 text-blue-800", // ★自スレ用の色
        "スポーツ": "bg-blue-100 text-blue-800",
        "エンタメ": "bg-pink-100 text-pink-800",
        "国内": "bg-indigo-100 text-indigo-800",
        "国際": "bg-teal-100 text-teal-800",
        "経済": "bg-yellow-100 text-yellow-800",
        "IT": "bg-purple-100 text-purple-800",
        "科学": "bg-gray-200 text-gray-800",
        "主要": "bg-red-100 text-red-800",
        "システム": "bg-red-100 text-red-800"
    };

    return articles.map(article => {
        const time = new Date(article.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
        const commentCount = Math.floor(Math.random() * 800) + 50;
        const color = categoryColors[article.category] || "bg-gray-100 text-gray-800";

        const linkHref = article.type === 'real' ? `href="${article.url}" target="_blank" rel="noopener noreferrer"` : 'href="javascript:void(0)"';
        const dataAttributes = `data-headline="${article.headline}" data-type="${article.type}" data-category="${article.category}" data-match-id="${article.matchId || ''}"`;

        return `
            <a ${linkHref} class="matome-article-link block p-3 rounded-lg hover:bg-gray-100 transition-colors" ${dataAttributes}>
                <div class="flex items-center text-xs text-gray-500">
                    <span class="font-bold py-0.5 px-2 rounded-full ${color}">${article.category}</span>
                    <span class="ml-auto">${time}</span>
                </div>
                <p class="font-bold text-gray-800 mt-2 text-base">${article.headline}</p>
                <div class="text-right text-xs text-gray-500 mt-1">コメント: ${commentCount} 💬</div>
            </a>
        `;
    }).join('');
}
// ▲▲▲ 置き換えここまで ▲▲▲


/**
 * [修正版] ゲーム内の試合結果に対する、なんJまとめサイト風のスレッドをAIに生成させる
 * (★「軽傷」選手と「重要度」への言及指示を強化)
 */
async function generateGameMatchBbsComments(matchContext) {
    const { 
        winnerName, loserName, dbMatch, matchId, playerStatsText, 
        winnerJourney, loserJourney, nextOpponent, nextOpponentJourney, 
        winnerLineupChanges, loserLineupChanges, highlights,
        injuryReport
    } = matchContext;

    const score = `${dbMatch.score1}-${dbMatch.score2}`;
    const winnerData = TEAM_DATA[winnerName];
    const loserData = TEAM_DATA[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, tournamentState.teamRecords[winnerName]);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, tournamentState.teamRecords[loserName]);
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const loserRankDesc = getRankDescription(loserRank);
    const winnerSeedRank = getSeedRankString(winnerName, tournamentState.seeds);
    const loserSeedRank = getSeedRankString(loserName, tournamentState.seeds);
    const tournamentName = tournamentNameMap[tournamentState.currentTournament] || '大会';
    const tournamentYear = tournamentState.tournamentYear;
    let tournamentBbsContext = "";
    if (tournamentState.currentTournament === 'summer') {
        tournamentBbsContext = "3年生にとってはガチで最後の夏や。";
    } else if (tournamentState.currentTournament === 'autumn') {
        tournamentBbsContext = "新チームの初陣やな。ここでの結果がセンバツ選考に響くで。";
    } else if (tournamentState.currentTournament === 'spring') {
        tournamentBbsContext = "夏のシード権がかかった前哨戦や。";
    }

    let nextOpponentText = '次の相手は未定やな。';
    if (nextOpponent) {
        if (nextOpponent.opponentName === '優勝') {
            nextOpponentText = (tournamentState.currentTournament === 'summer')
                ? '夏の甲子園出場決定や！'
                : (tournamentState.currentTournament === 'autumn' ? 'センバツ出場が有力となった。' : '今大会、見事優勝を果たした。');
        }
        else if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            const nextOpponentSeed = getSeedRankString(nextOpponent.opponentName, tournamentState.seeds); 
            const rankText = nextOpponent.opponentRank ? `(ランク:${nextOpponent.opponentRank})` : '';
            nextOpponentText = `次の${nextOpponent.roundName}の相手は${nextOpponent.opponentName}${nextOpponentSeed}${rankText}か。`;
        } 
        else if (nextOpponent.decidingMatch) {
            const dm = nextOpponent.decidingMatch;
            const team1Seed = getSeedRankString(dm.team1, tournamentState.seeds); 
            const team2Seed = getSeedRankString(dm.team2, tournamentState.seeds); 
            nextOpponentText = `次の${nextOpponent.roundName}の相手は、${dm.team1}${team1Seed}(${dm.rank1}ランク)と${dm.team2}${team2Seed}(${dm.rank2}ランク)の勝者やな。`;
        }
    }
    const nextOpponentJourneyText = (nextOpponent && nextOpponentJourney) ? `ちなみに、その${nextOpponent.opponentName}のここまでの軌跡は「${nextOpponentJourney}」。` : '';

    let highlightsText = '主な出来事はありませんでした。';
    if (highlights && highlights.length > 0) {
        highlightsText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
    }

    const roundName = getRoundNameFromMatchId(matchId);
    
    const hadaReportText = matchContext.hadaReportSummary ? `\n### データ6：記者の視点（羽田レポート）\n${matchContext.hadaReportSummary}\n` : '';
    const calledGameText = matchContext.calledGame ? `\n- **特記事項:** ${matchContext.calledInning}回コールドゲーム` : '';
    const rivalryText = matchContext.rivalryType ? `\n- **特記事項:** この試合は「${matchContext.rivalryType}」という因縁の対決でした。` : '';
    const lineupChangesText = `- ${winnerName}: ${winnerLineupChanges}\n- ${loserName}: ${loserLineupChanges}`;
    let atmosphereText = '';
    if (matchContext.atmosphere_team1 || matchContext.atmosphere_team2) {
        atmosphereText = '\n### データ6：試合前の雰囲気・公約\n';
        if (matchContext.atmosphere_team1) atmosphereText += `- ${dbMatch.team1}: ${matchContext.atmosphere_team1}\n`;
        if (matchContext.atmosphere_team2) atmosphereText += `- ${dbMatch.team2}: ${matchContext.atmosphere_team2}\n`;
    }
    let scheduleText = '';
    if (matchContext.schedule) {
        const sched = matchContext.schedule;
        const team1Region = TEAM_DATA[dbMatch.team1]?.region || '不明';
        const team2Region = TEAM_DATA[dbMatch.team2]?.region || '不明';
        let advantage = 'なし';
        if (sched.region === team1Region && sched.region !== team2Region) advantage = `${dbMatch.team1}の地元`;
        else if (sched.region !== team1Region && sched.region === team2Region) advantage = `${dbMatch.team2}の地元`;
        scheduleText = `\n### データ7：球場情報\n- **球場:** ${sched.stadiumFull} (${sched.region}地区)\n- **地の利:** ${advantage}\n`;
    }
    let ballQualityText = '';
    if (matchContext.team1BallQuality && matchContext.team2BallQuality) {
        ballQualityText = `\n### データ3：チーム別 打球品質レポート\n- ${matchContext.team1BallQuality}\n- ${matchContext.team2BallQuality}\n`;
    }
    
    let cinderellaPraiseInstruction = "";
    const idParts = matchId.split('-');
    let roundNum = 0;
    if (idParts[0] !== 'F' && idParts[1] && idParts[1].startsWith('R')) {
        roundNum = parseInt(idParts[1].slice(1));
    }
    if ( (loserRank === 'E' && roundNum >= 3) ||
         (loserRank === 'D' && roundNum >= 4) ||
         (loserRank === 'C' && roundNum >= 5) )
    {
        cinderellaPraiseInstruction = `
- **【★快進撃への言及】**: 敗北した${loserName}は${loserRankDesc}(${loserRank}ランク)だったが、${roundName}まで勝ち上がった。この「快進撃」を**「${loserName}、ようやっとる」「来年が楽しみなチーム」**のように、必ず称賛すること。`;
    }
    
    const prompt = `あなたは、匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは高校野球に詳しく、煽りやユーモアを交えながら会話を盛り上げます。
以下の試合データに基づき、ファンたちのリアルな会話コメントを**25〜27個**生成してください。

### 参考情報：静岡県高校野球の「常識」（勢力図）
${PREFECTURE_LORE}

### 現在の試合状況
- **大会:** ${tournamentYear}年度 ${tournamentName}
- **文脈:** ${tournamentBbsContext}
- **ラウンド:** ${roundName}
${scheduleText} 

### データ1：試合結果
- **勝利:** ${winnerName} ${winnerSeedRank} (ランク: ${winnerRank})
- **敗北:** ${loserName} ${loserSeedRank} (ランク: ${loserRank})
- **スコア:** ${score}
- **スタメン変更:**
${lineupChangesText}
${calledGameText} 
${rivalryText} 
${injuryReport || ''}

### データ2：チームの背景
- **${winnerName} ${winnerSeedRank}**: ${winnerDynamicInfo}
  - **軌跡**: ${winnerJourney}
- **${loserName} ${loserSeedRank}**: ${loserDynamicInfo}
  - **軌跡**: ${loserJourney}

### データ3：この試合の個人成績 (最終結果の要約)
${playerStatsText || '個人成績データはありません。'}

### データ4：試合の主な出来事 (ハイライト)
${highlightsText}
${ballQualityText} 

### データ5：トーナメント全体の状況
- **${winnerName}の軌跡(勝ち上がり)**: ${winnerJourney || '今大会初戦'}
- **次の試合**: ${nextOpponentText} ${nextOpponentJourneyText}
${atmosphereText}
${hadaReportText}

### データ6：今大会の主な投手登板履歴 (この試合より前)
${matchContext.pitcherGamelogInfo || '今大会、これが初登板です。'}

### データ7：今大会の主な打者成績履歴 (この試合より前)
${matchContext.batterGamelogInfo || '打者の試合履歴データはありません。'}

### 指示
あなたは今、上記の全データを眺めながら、他のファンと会話しています。**現在の試合が「${roundName}」であること**、**勝者の軌跡**、**次の試合情報**を踏まえつつ、以下の点をコメントに含めてください。

- **【★大会の文脈を反映】**: ${tournamentName}ならではの視点（例：「夏は3年生最後やな」「秋の新チームの仕上がり見えてきたな」）をコメントに含めること。
- **【★★欠場者への言及 (最重要)】**: もし「主な欠場者」に選手名（例：〇〇 [🏥] (主力), △△ [🩹] (控え)）がある場合、その選手の**重要度（主力か控えか）**に応じて、反応の深刻度を変えてください。（例：『エース姫川(主力)抜きでよく勝ったわ』『鈴木(控え)の怪我は痛いが、まぁ...』）
${cinderellaPraiseInstruction}
- **【最重要：次戦情報】**: 「データ5」の**\`次の試合:\`** に書かれている情報を**必ず**コメントに含めてください。「次は〇〇か…」のように具体的に言及し、**「未定」という言葉は絶対に使わないでください。**あなたは今、上記の全データを眺めながら、他のファンと会話しています。**現在の試合が「${roundName}」であること**、**勝者の軌跡**、**次の試合情報**を踏まえつつ、以下の点をコメントに含めてください。

- **【★シードランク言及】**: 試合情報に「(第1シード)」などのシードランクが含まれています。**「第1シードさすがやな」「第5シードが負けたンゴwww」**のように、シードランクにも具体的に言及してください。
- **【最重要：次戦情報】**: 「データ5」の**\`次の試合:\`** に書かれている情報を**必ず**コメントに含めてください。「次は〇〇か…」のように具体的に言及し、**「未定」という言葉は絶対に使わないでください。**
- **【試合への反応】**:
    - 試合結果（スコア、勝敗）に対する感想。
    - 「データ3（個人成績）」や「データ4（ハイライト）」で目立った選手やプレーへの言及。「データ3」の**背番号**にも注目すること。
    - **（重要）** 1桁番号（エース/レギュラー）が活躍するのは当然だが、**背番号2桁の選手が活躍した場合**、それを「控えの活躍」と安易に断定せず、「**背番号10だけど実質エース**」「**2桁の〇〇が仕事したな**」といった、**その選手の実力を評価する**コメントを生成すること。
    - もし敗北チームが善戦した場合 (スコア差が小さい、ランク差があるのに接戦など) は、その健闘を称えるコメント。
- **【常識の反映】**: あなたが熟知している「常識」（例：ナムコ vs 公立の砦、古豪の復活、王者283学園の動向）を、試合結果やデータと関連付けてコメントすること。
- **【その他】**:
    - なんJらしい短い煽りや草(w)を適度に含める。
    - 他のコメントへの安価 (>>) をいくつか含める。
    - ランク名を言い換える（A→名門、B→強豪、C→中堅、D→挑戦校、E→無名校）。
- **#は背番号と言い換えてください。(例　#1→背番号1)**
- **【羽田レポートへの言及】**: もし「データ6：記者の視点」に羽田記者の分析がある場合、**「羽田とかいう記者が～って言ってたけど…」** のように、その分析に同意したり、反論したりするコメントを**必ず**含めること。
- **【試合前の雰囲気】**: もし「データ6：試合前の雰囲気・公約」が提供されていたら（例：「エース温存公言」「コンディション最悪」など）、**その伏線が試合結果でどうなったか**について（例：「なお姫」「温存（）」「やっぱ体調悪かったんか」）必ず言及すること。
- **【球場への言及】**: もし「データ7：球場情報」があり、「地の利」がどちらかのチームにあった場合（例：静岡が草薙で試合）、**「謎の力キターw」「地元判定やめろ」「〇〇（球場名）まで遠征ご苦労さん」**など、球場に関するコメントを必ず含めること。
- **【★今大会の成績 (最重要)】**:
    - 「データ2」に**『今大会のチーム打率は.XXX』**という情報が含まれています。
    - この情報を**必ずコメントに含め**、チームの好調・不振（例：「〇〇、今大会打率.150とかマジ？」「打率3割超えの打線相手によく抑えたわ」）にも言及すること。
- **【投手の詳細属性】**: 「データ3（ボックススコア）」に「（右/オーバー/本格派/150km帯）」といった**投手の詳細属性**が記載されている場合、それにも言及すること。
- **【★盗塁への言及 (重要)】**:
    - 「データ3（個人成績）」に**盗塁(SB)**が記録されている選手がいた場合、その選手の機動力（例：「〇〇、足はえーなw」「良い盗塁やった」）に言及すること。
    - さらに、その選手の**「今大会の通算盗塁数」**（例：(今大会: ... 4盗)）も必ず参照し、**「姫川、今大会4盗塁目かよw」「こいつ打ちすぎだし走りすぎだろ」**といった具体的な数字に言及すること。
    - **盗塁が0でも批判は不要です。**
- **【★通算成績への言及 (裁量)】**:
    - 「データ2」に**『(参考: チーム通算打率 .XXX, 通算 Y 盗塁)』**という情報が含まれている場合、必要に応じて（例：チームの伝統的な機動力を語る際など）、その「通算盗塁」にも言及すること。
    - **盗塁が0でも批判は不要です。**
- **【★注目の打席（最重要）】**:
    - 「データ4（ハイライト）」に「（★注目）」マークが付いている打席が、この試合の**ターニングポイント**や。
    - **「あの場面が全てやったな」「あそこの（★注目）〇〇の打席がデカすぎた」**のように、その「★注目」の打席が試合の勝敗を分けた決定的な瞬間であったと言及すること。
- **【コールド/因縁】**: もし試合がコールドゲームや「${matchContext.rivalryType || '因縁の対決'}」であった場合、その点について必ず言及すること。
- **【スタメン変更】**:スタメン変更があった場合(${lineupChangesText})触れなさい。
- **【選手の状態】**: 「データ3（個人成績）」に「(状態: 〇〇)」と書かれている選手に注目し、「絶好調の〇〇、今日も打ったなw」「不振だった△△、ついに目覚めたか？」など、**前回の試合からの連続性**を意識したコメントをすること。
- **【打球の質（打者・投手）】**: 「データ3（個人成績）」や「データ4（ハイライト）」にある**打球の質**（「鋭い当たり」「詰まった当たり」など）にも注目すること。
- **【打球の質（チーム全体）】**: 「データ3：チーム別 打球品質」を見て、チーム全体の調子について言及すること。
- **【打順の役割】**: 「常識」としてインプットされた**打順の役割**を意識してコメントすること。
- **【投打の左右の相性】**:
    - 「データ2（常識）」と「データ3（ボックススコア）」にある**投打の左右**にも注目すること。
    - **特に、相手が「左腕（サウスポー）」だった場合**や、監督が**「ワンポイントリリーフ」**を使った場合に、その相性について言及すること。
- **【★スタメン復帰】**: 「データ1：スタメン変更」に「〇〇がスタメン復帰」とあった場合、**「おお、〇〇戻ってきたか！」「ここで使うのは博打だろw」**のように、その選手への期待や不安をコメントに含めること。
- **【★登板履歴への言及 (最重要)】**: 「データ5：今大会の主な投手登板履歴」の情報を必ず確認し、以下の点をコメントに含めること。
    - **連投/登板間隔**: 「〇〇、昨日も投げてなかったか？」「連投お疲れ様」「中1日でこれはキツイわ」
    - **酷使**: 「エース投げすぎだろ」「監督は鈴木を壊す気か」
    - **好不調の波**: 「前回炎上したのによう立ち直ったな」「こないだは良かったのに今日はアカンか」
    - **相手の質**: 「今まで雑魚狩りだったのがバレたなw」「強豪相手でも抑えるとか本物やん」
- **【★打者履歴への言及 (最重要)】**: 「データ6：打者成績履歴」も必ず確認し、以下の点をコメントに含めること。
    - **好不調の波**: 「〇〇、今日で3試合連続ヒットやん！」「△△、10打数ノーヒットとかもう終わりだろ…」
    - **役割**: 「こいつ代打成功率100%じゃね？」「1番に上げたら打ち出したな」
    - **相手の質**: 「今まで雑魚狩りだったのがバレたなw」「Aランク投手から打つとか本物やん」
### 出力形式【最重要】
解説や前置きは一切不要です。**必ず以下の JSON 配列形式 (\`[...]\`) のみ**で出力してください。
\`\`\`json
[
  {"personality": "1: 風吹けば名無し", "comment": "（生成したコメント1）"},
  {"personality": "2: 風吹けば名無し", "comment": "（生成したコメント2）"},
  // ... (合計25〜27個のコメント) ...
]
\`\`\`
`; 
    
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map((c, index) => ({
                    id: crypto.randomUUID(),
                    personality: c.personality || `${index + 1}: 風吹けば名無し`,
                    text: c.comment,
                    timestamp: Date.now() + index * 10,
                    replies: []
                }));
            } else {
                console.warn("AIが予期しないオブジェクト形式でBBSコメントを返しました。中身を取り出します。");
                if (commentsJson && commentsJson.comments && Array.isArray(commentsJson.comments)) {
                     return commentsJson.comments.map((c, index) => ({
                        id: crypto.randomUUID(),
                        personality: c.personality || `${index + 1}: 風吹けば名無し`,
                        text: c.comment,
                        timestamp: Date.now() + index * 10,
                        replies: []
                    }));
                }
            }
        }
        throw new Error("AIからの応答が、正しいコメント配列形式ではありません。");
    } catch (error) {
        console.error("AI game match BBS generation failed (seed-aware):", error);
        return {
            error: true,
            title: "掲示板コメント生成エラー(シード対応版)",
            body: "AIによるコメント生成に失敗しました。",
            timestamp: Date.now(),
            errorId: `error-${matchId}-bbs-seed`,
            context: matchContext
        };
    }
}
// ▼▼▼ このブロックをまるごと「新規追加」 ▼▼▼

// ▼▼▼ 既存の generateUserThreadBbsComments 関数 (12015行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * ユーザーが作成したスレッド（タイトル＋本文）に対し、なんJ風の掲示板コメントをAIに生成させる
 * (★試合の文脈（コンテキスト）をAIに渡して、本格的なレスを生成するよう強化した最終版★)
 * * @param {string} title - ユーザーが入力したスレッドタイトル
 * @param {string} firstCommentText - ユーザーが入力した本文 (>>1)
 * @param {string} gameContext - AIに提供する追加の試合/選手データ (formatPlayerGamelogsForPrompt などで生成)
 * @returns {Promise<Array|null>} コメントオブジェクトの配列
 */
async function generateUserThreadBbsComments(title, firstCommentText, gameContext) {
    let personaPrompt = `あなたは、日本の匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは少し皮肉屋で、ネットスラングを多用し、あらゆる話題に短いコメントを書き込みます。`;
    
    // ★ gameContext が提供されていれば、プロンプトに「知識」として挿入する
    const contextPrompt = gameContext 
        ? `
### 参考情報：静岡県高校野球の「常識」
${PREFECTURE_LORE}

### 参考情報：スレッドの話題に関連する最新データ
${gameContext}
`
        : `
### 参考情報
(特に関連する試合データはありません。一般的な話題として返信してください。)
`;

    const prompt = `${personaPrompt}

以下の【ユーザーが立てたスレッド】について、**リアルタイムでスレッドが進行していくかのように**、自然な流れで**10〜15個**の掲示板の反応を生成してください。

### スレッドタイトル
${title}

### スレ主(>>1)の本文
${firstCommentText}

${contextPrompt}

### スレッド進行の指示
1.  **序盤 (2〜5レス):** スレ主の投稿(>>1)に対し、即座に食いつく第一陣の反応。「マジか」「草」「また〇〇か」といった短いコメントが中心。
2.  **中盤 (6〜15レス):** - スレ主の話題に対して様々な角度からコメントを始める。肯定、否定、煽り、全く関係ない脱線などを織り交ぜる。
    - **【★最重要】**: もし「参考情報：最新データ」が提供されている場合、その**データ（Gamelog、チーム打率、登板間隔など）**を**必ず**引用し、スレ主(>>1)の意見（例：「鈴木が凄い」）を補強したり、反論したりしてください。
    - （例：「>>1 わかる。鈴木、これで3試合連続無失点じゃね？」「でも〇〇高校、チーム打率.180だぞ。鈴木が良くても勝てんわ」）
    - **「>>1」への安価（アンカー）**を使って、スレ主の意見に返信するやり取りを必ず含めること。
3.  **終盤 (16レス以降):** ある程度議論が出尽くした後の、まとめのようなコメントや、飽きてきた住民によるおふざけが始まる。
4.　**最終盤 (26レス以降):** スレも混沌としてきて、関係ない話題を持ってくる者や、勝手にコンプレックスを刺激され発狂するもの、ただの荒らしなどが湧き始め、グダグダになり解散する。

### 出力形式（JSON配列）
[
    {"personality": "2: 風吹けば名無し", "comment": "（住民2のコメント）"},
    {"personality": "3: 風吹けば名無し", "comment": "（住民3のコメント）"},
    ...
]`; // スレ主(1:)は除く

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map((c, index) => ({ // indexを調整 (2から始まるように)
                    id: crypto.randomUUID(),
                    personality: c.personality.startsWith(`${index + 2}:`) ? c.personality : `${index + 2}: ${c.personality}`, // 番号を2から振る
                    text: c.comment,
                    timestamp: Date.now() + index * 10
                }));
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI user thread BBS generation failed:", error);
        return null;
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲
/**
 * 現実のニュースヘッドラインに対する、なんJ風の掲示板コメントをAIに生成させる
 * @param {string} headline - 現実のニュースの見出し
 * @param {string} category - ニュースのカテゴリ
 * @returns {Promise<Array|null>} コメントオブジェクトの配列
 */
async function generateRealNewsBbsComments(headline, category) {
    let personaPrompt = `あなたは、日本の匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは少し皮肉屋で、ネットスラングを多用し、あらゆる話題に短いコメントを書き込みます。`;
    let instructions = ``;
    switch (category) {
        case '政治': instructions = `政治ニュースに詳しい住民として、与党や野党を煽ったり、将来を悲観したり、達観したようなコメントをしてください。`; break;
        case '芸能': instructions = `芸能ニュースが大好きな野次馬として、「〇〇ロスだわ」「どうせすぐ別れる」といった、お祝いと嫉妬が入り混じったコメントをしてください。`; break;
        case '学歴': instructions = `学歴コンプレックスを持つ住民として、「F欄のワイ、高みの見物」「結局は学歴よりコミュ力」といった、自虐や持論を展開してください。`; break;
        default: instructions = `一般的な住民として、ニュースに反応してください。`; break;
    }
    
    const prompt = `${personaPrompt}

以下の【${category}】のニュースヘッドラインについて、**リアルタイムでスレッドが進行していくかのように**、自然な流れで**10〜15個**の掲示板の反応を生成してください。

### ニュースヘッドライン
${headline}

### スレッド進行の指示
1.  **序盤 (1〜5レス):** スレ主の投稿に対し、即座に食いつく第一陣の反応。「マジか」「草」「また〇〇か」といった短いコメントが中心。
2.  **中盤 (6〜15レス):** 少し冷静になった住民たちが、ニュースに対して様々な角度からコメントを始める。肯定、否定、煽り、全く関係ない脱線などを織り交ぜる。**「>>1」「>>5」のような安価（アンカー）を使って、他のコメントに返信するやり取りを必ず含めること。**
3.  **終盤 (16レス以降):** ある程度議論が出尽くした後の、まとめのようなコメントや、飽きてきた住民によるおふざけが始まる。
4.　**最終盤 (26レス以降):** スレも混沌としてきて、関係ない話題を持ってくる者や、勝手にコンプレックスを刺激され発狂するもの、ただの荒らしなどが湧き始め、グダグダになり解散する。


### 出力形式（JSON配列）
[
    {"personality": "1: 風吹けば名無し", "comment": "（スレ主のコメント）"},
    {"personality": "2: 風吹けば名無し", "comment": "（住民2のコメント）"},
    {"personality": "3: 風吹けば名無し", "comment": "（住民3のコメント）"},
    ...
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now()
                }));
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI real news BBS generation failed:", error);
        return null;
    }
}
// ▲▲▲ ここまで追加 ▲▲▲

// ▲▲▲ ここまで追加 ▲▲▲

/**
 * 指定されたチームが次に出場する、まだ終わっていない試合を探す
 * @param {string} teamName - 探したいチーム名
 * @param {object} state - 現在のtournamentState
 * @returns {object|null} - 見つかった試合オブジェクト、またはnull
 */
function findCurrentMatchForTeam(teamName, state) {
    const allMatches = { ...state.matches, ...(state.autumnData?.allMatches || {}), ...(state.springData?.allMatches || {}) };
    let earliestMatch = null;
    let minRound = Infinity;

    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (!match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 0;
            if (roundNum < minRound) {
                minRound = roundNum;
                earliestMatch = match;
            }
        }
    }
    return earliestMatch;
}



/**
 * [UPDATED] トーナメントの勝者を次のラウンドに進める
 * (★チーム数に応じて「決勝戦」の判定を動的に行う)
 */
function advanceWinnerToNextRound(match, winnerName, state) {
    const matchId = match.id;
    const idParts = matchId.split('-');
    const side = idParts[0];

    if (side === 'F') return; // 決勝戦なら何もしない

    const roundStr = idParts[1];
    const roundNum = parseInt(roundStr.slice(1));
    
    if (state.teams && state.teams.length > 0) {
        // ★★★ 修正箇所: チーム数から最終ラウンドを計算 ★★★
        const numTeamsInTournament = state.teams.length;
        const finalRound = Math.log2(numTeamsInTournament); // 128->7, 64->6
        // ★★★ 修正ここまで ★★★

        if (roundNum < finalRound) {
            const matchNum = parseInt(idParts[2].slice(1));
            const nextRoundNum = roundNum + 1;
            
            // 次が最終ラウンドなら決勝戦(F-R1-M1)、そうでなければ次ラウンドへ
            let nextMatchId = (nextRoundNum === finalRound) 
                ? 'F-R1-M1' 
                : `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
            
            if (!state.matches[nextMatchId]) {
                state.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
            }
            
            // 決勝戦の場合は、サイド(L/R)によってスロットを決める
            let slot;
            if (nextRoundNum === finalRound) {
                slot = (side === 'L' ? 1 : 2);
            } else {
                slot = (matchNum % 2 !== 0 ? 1 : 2);
            }
            
            state.matches[nextMatchId][`team${slot}`] = winnerName;
        }
    }
}


/**
 * 密着ドキュメンタリーを開始し、序章の記事を生成する
 * (★128チーム制＝1ブロック32チームに対応)
 * @param {'underdog' | 'powerhouse'} type - ドキュメンタリーの種類
 * @param {string} teamName - 取材対象のチーム名
 */
async function startDocumentary(type, teamName) {
    tournamentState.documentary = { target: teamName, type: type };
    newsContainer.innerHTML = `<div class="loader">AI記者が「${teamName}」の特別ドキュメンタリー番組の制作を開始しました...</div>`;
    
    renderTournament(tournamentState); 

    const firstMatch = Object.values(tournamentState.matches).find(m => 
        m.id.includes('-R1-') && (m.team1 === teamName || m.team2 === teamName)
    );
    
    let matchDataForArticle = { 
        opponent: '不明', opponentRank: 'E', opponentRecord: '情報なし',
        toughestRival: '不明', toughestRivalRecord: '情報なし'
    };

    if (firstMatch) {
        const opponentName = firstMatch.team1 === teamName ? firstMatch.team2 : firstMatch.team1;
        matchDataForArticle.opponent = opponentName;
        matchDataForArticle.opponentRank = calculateRank(opponentName, tournamentState);
        matchDataForArticle.opponentRecord = TEAM_DATA[opponentName]?.last || '情報なし';

        // ★★★ ここからが修正箇所 ★★★
        const teamIndex = tournamentState.teams.indexOf(teamName);
        const blockSize = Math.floor(tournamentState.teams.length / 4); // 128 / 4 = 32
        const blockIndex = Math.floor(teamIndex / blockSize);
        const blockStart = blockIndex * blockSize;
        const blockEnd = blockStart + blockSize;
        // ★★★ 修正ここまで ★★★
        
        const blockTeams = tournamentState.teams.slice(blockStart, blockEnd);
        
        let toughestRivalName = null;
        let highestRankValue = -1;
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };

        blockTeams.forEach(rivalName => {
            if (rivalName === teamName || rivalName === '(BYE)') return; // 自分と不戦勝は除外
            const rivalRank = calculateRank(rivalName, tournamentState);
            if (rankValues[rivalRank] > highestRankValue) {
                highestRankValue = rankValues[rivalRank];
                toughestRivalName = rivalName;
            }
        });
        
        if (toughestRivalName) {
            matchDataForArticle.toughestRival = toughestRivalName;
            matchDataForArticle.toughestRivalRecord = TEAM_DATA[toughestRivalName]?.last || '情報なし';
        }
    }
    
    const article = await generateDocumentaryArticle('intro', type, teamName, matchDataForArticle);

    if (article) {
        tournamentState.news.push(article);
    } else {
        tournamentState.news.push({
            title: "ドキュメンタリー記事生成エラー",
            body: `「${teamName}」のドキュメンタリー記事の生成に失敗しました。`,
            timestamp: Date.now(),
            error: true,
            context: {
                isDocumentary: true,
                type: type,
                teamName: teamName,
                matchData: matchDataForArticle
            }
        });
    }
    renderNews(tournamentState.news);
    saveState();
}
// ▲▲▲ 置き換えここまで ▲▲▲



async function generateDocumentaryArticle(phase, type, teamName, matchData = null, userFeedback = null) {
    const teamMasterData = TEAM_DATA[teamName];
    let prompt = `あなたは、情熱的で人間ドラマを描くのが得意なドキュメンタリー番組の記者です。あなたは今、高校野球チーム「${teamName}」に密着取材しています。`;
    let title = "";

    let charactersPrompt = `### 主な登場人物\n- 監督: ${teamMasterData.coach.name} (${teamMasterData.coach.style})\n`;
    if (DETAILED_TEAM_DATA[teamName]) {
        const detailedData = DETAILED_TEAM_DATA[teamName];
        const keyPlayers = detailedData.players.map(p => `- ${p.name}(${p.year}年, ${p.position}): ${p.desc}`).join('\n');
        charactersPrompt += `### 注目選手\n${keyPlayers}\n`;
    }
    
    let feedbackPrompt = '';
    if (userFeedback) {
        if (userFeedback.include && userFeedback.include.trim() !== '') {
            feedbackPrompt += `\n- **【最重要指示】** 以下の要素を必ず記事の中心に据えて、最もドラマチックに描写してください：\n${userFeedback.include}\n`;
        }
        if (userFeedback.exclude && userFeedback.exclude.trim() !== '') {
            feedbackPrompt += `\n- **【厳禁事項】** 以下の要素や表現は、絶対に記事に含めないでください：\n${userFeedback.exclude}\n`;
        }
    }
    const finalFeedbackPrompt = `\n### ディレクターからの追加指示\n${feedbackPrompt || '特になし'}`;

    // ==================================================================
    // --- 1. 古豪復活チーム (powerhouse_revival) ---
    // ==================================================================
    if (type === 'powerhouse_revival') {
        switch (phase) {
            case 'intro':
                title = `『${teamName}、復活への序曲』`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 1) { // 格上
                        reactionPrompt = `
5.  **【試練の初戦】**
    初戦の相手が格上の「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちが「不足はない相手」「復活をアピールするには最高の相手だ」と闘志を燃やす。
6.  **【監督の『建前』と『本音』】**
    監督は**選手たちの前で**、「挑戦者として、失うものは何もない。全力でぶつかるぞ」という趣旨で語る。
    しかし記者の前では**二人きりで**、「本当の山場は**${matchData.toughestRival}**戦でしょう。彼らは昨年${matchData.toughestRivalRecord}。この初戦は、そこへ向けてチームがどれだけ成長できるかの試金石ですね」という趣旨で、冷静に先を見据える。`;
                    } else { // 同格か格下
                        reactionPrompt = `
5.  **【油断という名の敵】**
    初戦の相手が「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。「勝てる」という安堵の空気が選手たちの間に流れる。
6.  **【監督の『建前』と『本音』】**
    その空気を察した監督が**選手たちの前で**、「油断が一番の敵だ。俺たちはまだ何も成し遂げていない」という趣旨で厳しく一喝する。
    しかし、記者の前では**二人きりで**、「正直、ホッとしました。**${matchData.toughestRival}**（彼らは昨年${matchData.toughestRivalRecord}）と当たるまでに、いくつか試合をこなして練度を上げたかったので」という趣旨で、安堵の理由が戦略的なものであることを明かす。`;
                    }
                }
                prompt += `
### 取材テーマ
かつて黄金時代を築いた古豪「${teamName}」が、失われた栄光を取り戻すべく挑む夏を追う。過去、現在、そして未来が交錯する物語の序章を描いてください。
${charactersPrompt}
### 構成案
1.  **【埃をかぶった優勝旗】**: 部室に眠る色褪せた優勝旗やトロフィーの描写から始める。過去の栄光の重圧と、現在のチームが置かれた状況（${teamMasterData.info}）を対比させる。
2.  **【OBたちの熱き眼差し】**: 練習を厳しい目で見つめるOB会長に「俺たちの時代は…」という昔語りと、現在のチームへの歯がゆさ、そして心の底にある期待を語らせる。
3.  **【重圧を背負う主将】**: 主将に「このユニフォームを着て戦うことの意味」を問う。伝統の重みと、それを力に変えようとする彼の覚悟を描写する。
4.  **【監督の信念と現実】**: 監督に「古豪復活への道筋」をインタビューする。OBからのプレッシャーの中で、彼が信じる今の選手たちの可能性と、現在の課題について語らせる。
${reactionPrompt}
7.  **【新たな歴史へ】**: 主将の「俺たちは俺たちの野球で、新しい歴史を作るだけ」という言葉で、復活をかけた夏の始まりを力強く宣言して締めくくる。
### 描写のポイント
- 時間軸の意識: 「過去の栄光」「現在の葛藤」「未来への挑戦」を意識し、物語に深みを与えること。
- 建前と本音: 監督の二面性を描くことで、キャラクターのリアリティを追求すること。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、復活への第一歩』`;
                prompt += `
### 取材テーマ
古豪「${teamName}」が ${matchData.opponent} との試合に ${matchData.score} で勝利しました。「名門復活への狼煙」となるこの一勝の価値を、感動的に描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」を物語の中心に据え、その場面を最もドラマチックに描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、この勝利の価値をより高める。
3.  監督に「伝統の粘り強さが出せた」という趣旨のコメントをさせる。
4.  主将に、次戦への意気込みと共に「先輩たちが築いた歴史に、新たな1ページを刻みたい」と語らせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、夢、またも届かず』`;
                prompt += `
### 取材テーマ
古豪「${teamName}」の夏が終わりを告げた。復活を願った人々の期待と、それに応えられなかった選手たちの無念さを描いてください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにしてチームの夢を打ち砕いたかを詳細に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、敗北の文脈をより深く描写する。
3.  グラウンドに泣き崩れる選手たちと、彼らにかける言葉が見つからない監督の姿。
4.  「彼らの挑戦は終わった。しかし、〇〇（校名）の野球部の灯が消えることはない」と、未来への希望で締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } 
    // ==================================================================
    // --- 2. 絶対的エースチーム (one_man_team) ---
    // ==================================================================
    else if (type === 'one_man_team') {
        switch (phase) {
            case 'intro':
                title = `『${teamName}のエースと、8人の仲間たち』`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 2) { // 絶望的な格上
                        reactionPrompt = `
5.  **【試される『個』の力】**
    初戦の相手が格上の強豪「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。野手たちが動揺する中、エースだけが「相手が誰であろうと、俺がゼロに抑えるだけです」という趣旨のコメントで闘志を燃やす。
6.  **【監督の『建前』と『本音』】**
    監督は**選手たちの前で**、「最高の相手だ。我々には〇〇（エース名）がいる。彼を信じろ」という趣旨のコメントで、エースへの絶対的な信頼を口にする。
    しかし記者の前では**二人きりで**、「正直、最悪のクジです。彼（エース）の負担を考えれば、勝ち進んだ先の**${matchData.toughestRival}**（昨年${matchData.toughestRivalRecord}）戦まで、他の選手に経験を積ませたかった」という趣旨のコメントで、チーム全体の成長を願う本音を漏らす。`;
                    } else { // 同格か格下
                        reactionPrompt = `
5.  **【エース温存か、否か】**
    初戦の相手が「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちの間に「この相手なら、エース抜きでも勝てるのでは？」という慢心が生まれる。
6.  **【監督の『賭け』】**
    監督が**選手たちの前で**、「初戦、〇〇（エース名）は投げない。お前たちで勝ち上がってこい」という趣旨の、非情とも思える決断を下す。
    記者の前では**二人きりで**、「これは賭けです。でも、**${matchData.toughestRival}**（昨年${matchData.toughestRivalRecord}）と戦うことを見据えれば、ここで他の選手が覚醒しなければ未来はない」という趣旨のコメントで、エースの将来とチームの未来を想う本音を語らせる。`;
                    }
                }
                prompt += `
### 取材テーマ
プロ注目の絶対的エースを擁する「${teamName}」。天才の苦悩と、彼を支える「その他大勢」と呼ばれた仲間たちのプライドを描く。
${charactersPrompt}
### 構成案
1.  **【殺到する報道陣】**: 練習グラウンドに集まる、エースだけを狙う無数のカメラの描写から始める。
2.  **【エースの孤独なマウンド】**: エースにインタビュー。「チームを勝たせるのが自分の仕事」と語る彼の言葉の裏にある、重いプレッシャーを描写する。
3.  **【名もなき脇役たちの意地】**: メディアからは注目されない他の野手たちに焦点を当てる。「俺たちは、あいつの引き立て役じゃない」という、彼らの静かなプライドと葛藤を引き出す。
4.  **【監督の信念】**: 監督に「彼らはワンマンチームですか？」と問う。「世間はそう言うだろう。だが、本当の主役が誰なのかを私だけは知っている」という趣旨の意味深な言葉を語らせる。
${reactionPrompt}
7.  **【一つのチームとして】**: 野手の一人が「俺たちが、あいつを甲子園のマウンドに連れて行く」と力強く宣言し、物語を締めくくる。
### 必ず含めるべき要素
- **チームが抱える状況を描写すること: ${teamMasterData.info}**
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `エース快投！しかし、勝利の影に${teamName}の結束あり`;
                prompt += `
### 取材テーマ
「${teamName}」が勝利。メディアはエースの快投ばかりを報じるだろう。しかし、その裏にあった仲間たちのファインプレーやチームの結束こそが真の勝因だったことを、あなたの視点で深く描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにチームの結束力を象徴するプレーだったかを物語の中心に据える。
2.  エースの投球内容を簡潔に紹介しつつ、「しかし、この日の主役は彼だけではなかった」と続ける。
3.  そのプレーをした選手に「エースを助けるのが俺たちの仕事ですから」と、誇らしげに語らせる。
4.  エースに「今日の勝利は、俺一人の力じゃない。みんなが守ってくれたおかげです」と、初めて仲間に感謝の言葉を述べさせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `英雄、あまりに早すぎる敗退。${teamName}の夏、終わる`;
                prompt += `
### 取材テーマ
絶対的エースを擁しながら、「${teamName}」は敗れた。天才と仲間たちの、残酷で、しかし美しい夏の終わりを描いてください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにして絶対的エースを打ち崩したのか、その一瞬を詳細に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れることで、敗北の衝撃を際立たせる。
3.  マウンドで呆然とするエースと、彼に駆け寄り「お前のせいじゃない」と声をかける仲間たちの姿を描く。
4.  「彼らはワンマンチームではなかった。勝つ時も、負ける時も、彼らは一つのチームだった」と締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } 
    // ==================================================================
    // --- 3. 強豪校 (powerhouse) ---
    // ==================================================================
    else if (type === 'powerhouse') {
        switch (phase) {
            case 'intro':
                title = `『${teamName}、王者の告白』序章`;
                let reactionPrompt = '';
                if (matchData && matchData.opponent) {
                    const ourRank = calculateRank(teamName, tournamentState);
                    const opponentRank = matchData.opponentRank;
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    const rankDiff = rankValues[opponentRank] - rankValues[ourRank];

                    if (rankDiff >= 0) { // 同格か格上
                        reactionPrompt = `
5.  **【試される王国】**
    初戦の相手がいきなり実力校「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちの間に走る緊張感を「歓迎すべき試練」として描写する。
6.  **【監督の『建前』と『本音』】**
    監督は**選手たちの前で**、「初戦から最高の相手だ。挑戦者を受ける覚悟はできている」という趣旨で、チームのプライドを煽る。
    しかし記者の前では**二人きりで**、「厳しい戦いになる。だが、このブロックの本命は我々と**${matchData.toughestRival}**。彼らは昨年${matchData.toughestRivalRecord}。倒すためには、どこかで通らなければいけない道だ」という趣旨で、厳しい本音を語らせる。`;
                    } else { // 格下
                        reactionPrompt = `
5.  **【王者の静寂】**
    初戦の相手が「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちは表情一つ変えず、淡々と次の練習の準備を始める。
6.  **【監督の『建前』と『本音』】**
    監督が**選手たちの前で**は「油断するな」という趣旨で引き締めつつ、記者の前では**二人きりで**、「初戦は問題ない。本当の勝負は**${matchData.toughestRival}**戦。彼らは昨年${matchData.toughestRivalRecord}の実力校だ。そこが事実上の決勝戦になるだろう」という趣旨で、先を見据えた分析を語らせる。`;
                    }
                }
                prompt += `
### 取材テーマ
絶対的王者「${teamName}」の栄光の裏に隠された苦悩と、常人には理解しがたいプレッシャーを描く。
${charactersPrompt}
### 構成案
1.  **【静寂のトロフィー室】**: 無数に並ぶ優勝トロフィーが放つ輝きと、「勝って当然」という重圧を描写する。
2.  **【Bグラウンドの陽炎】**: ベンチ入りできなかった3年生が、最後の夏にも関わらず、黙々と後輩へのサポートを務める。彼の「チームへの愛」と「諦め」の独白を引き出す。
3.  **【監督の非情な勝負論】**: 監督にインタビュー。「勝つためには、時に非情にならなければならない。それが王者であり続けるということだ」という彼の哲学を語らせる。
4.  **【主将の孤独な背中】**: スター選手揃いのチームを一つにまとめることの難しさと、「負けることが許されない」という王者ならではの孤独な覚悟を主将に語らせる。
${reactionPrompt}
7.  **【王者、出陣】**: 主将が「俺たちの目標は、県大会優勝じゃない。その先にある」と、全国の頂点だけを見据えていることを示唆して締めくくる。
### 必ず含めるべき要素
- **チームが抱える状況を描写すること: ${teamMasterData.info}**
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;
                break;
            case 'win':
                title = `『${teamName}、王者の告白』第${matchData.round}章`;
                prompt += `
### 取材テーマ
「${teamName}」が勝利。しかし彼らにとってこの勝利は歓喜ではなく、「次へ進むための義務」でしかない。その独特の空気感をリアルに描写してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」を引用し、それが王者としての力の証明であったことを示す。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、勝利が順当であったことを描写する。
3.  試合後、安堵の表情を浮かべるも、決して喜びを爆発させない選手たちの姿。
4.  監督に「今日のプレーで満足せず、次を見据えている」という趣旨の、冷静なコメントをさせる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
            case 'lose':
                title = `『${teamName}、王者の告白』最終章`;
                prompt += `
### 取材テーマ
絶対的王者「${teamName}」の夏が終わった。王国の崩壊の瞬間と、選手たちの初めて見せる涙、そして重圧からの解放を感傷的に記録してください。
### 対戦相手「${matchData.opponent}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」が、いかにして絶対王者の歯車を狂わせたのか、その瞬間を克明に描写する。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、この敗戦が歴史的な番狂わせであることを強調する。
3.  試合終了のサイレンが鳴り響く、球場の信じられないような静寂を描写する。
4.  これまで常に気丈に振る舞ってきた主将が、初めてグラウンドに泣き崩れる姿に焦点を当てる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    } 
    // ==================================================================
    // --- 4. 逆境チーム (underdog) ---
    // ==================================================================
    else { 
        switch (phase) {
            case 'intro':
                        // ▼▼▼ このブロックをまるごと置き換えてください ▼▼▼
                        title = `『${teamName}、魂の記録』序章：それでも、彼らはグラウンドに立つ`;
                        let reactionPrompt = '';
                        let teamSpecificInfo = teamMasterData.info || '特筆すべき情報なし';
                        let handicapFocusPrompt = ''; // 先に空で定義

                        // ▼▼▼ 【最重要】「浜松特支」専用の特別分岐 ▼▼▼
                        if (teamName === '浜松特支') {
                            handicapFocusPrompt = `
3.  **【特別な夏、その意味】**: 県内唯一の特別支援学校の野球部、浜松特支。部員は全員1年生。彼らにとって、これは初めての夏であり、全てが挑戦である。
4.  **【春の記憶と安全への声】**: 記者が北村監督に話を聞くと、彼は春の練習試合—王者・283学園に喫した「52-0」の大敗—について重い口を開く。「あの試合で、選手たちから野球の楽しさを奪ってしまったかもしれない」と。同時に、外部から寄せられる「知的障害を持つ彼らに、硬球を使った野球は本当に安全なのか」という厳しい批判の声にも直面していることを明かす。
5.  **【部室の野球ノート】**: 部室代わりの理科準備室に置かれた野球ノート。「こわい」「たご(※たのしくない)」。そこには、彼らの純粋な恐怖と苦しみが記されていた。
6.  **【ある選手の挑戦（高橋 健太）】**: チームの一人、高橋健太くん（仮名）に焦点を当てる。彼は重度の知的障害を抱えており、仲間とのコミュニケーションや、ルールの理解にも人一倍時間がかかる。だが、練習で唯一「バットにボールを当てる」ことだけは誰よりも得意だ。
7.  **【ある母親の涙】**: 練習をフェンス越しに見つめる健太くんの母親にインタビューする。「あの子が...あの子が、仲間と声を掛け合ってボールを追いかけている...。野球を始める前は、そんなこと想像もできませんでした」。彼女はそう言うと、感極まって涙を拭った。「勝たなくていい。ただ、あの子が楽しそうにバットを振って、9回まで試合ができたら...それだけで...」
8.  **【監督の葛藤】**: 北村監督の葛藤を描写する。「勝利」ではない。「試合を成立させること」の絶望的な難しさ、そして「彼らの安全を守りながら、どうやって野球の楽しさを取り戻させるか」という答えのない問いに日々向き合う姿を深く掘り下げる。
9.  **【彼らの目標】**: 主将に今大会の目標を聞く。「甲子園じゃない。9回まで戦い抜いて、スコアボードに...0以外の数字を灯したい」。その言葉の重みを描写する。`;
                        }
                        // ▼▼▼ 【ご要望】「廃校」チームの専用分岐（OB会長登場） ▼▼▼
                        else if (teamSpecificInfo.includes('最後の夏') || teamSpecificInfo.includes('閉校')) {
                            handicapFocusPrompt = `
3.  **【最後のグラウンド】**: 今年度で閉校となる${teamName}。グラウンド脇では校舎の解体作業が進む。重機の音が響く中、練習する異様な日常を描写する。
4.  **【OB会長の追憶】**: 練習をフェンス越しに見つめるOB会長（または後援会会長）にインタビューする。彼は、解体が進む母校を複雑な面持ちで見つめながら、「昔はここも全校生徒の応援で溢れかえっていた」「まさか自分たちの代で校名がなくなるとは思わなかったよ…」と、活気があった頃の昔の様子を語り、寂しそうに目を伏せる。
5.  **【3年生の想い】**: このユニフォームを着る最後の世代となった3年生に焦点を当てる。「母校の名前を刻みたい」というOB会長たちの想いも背負い、彼らの切実な覚悟と、後輩がいない（あるいは引き継げない）ことへの複雑な心境を引き出す。
6.  **【監督の務め】**: 監督に「最後の夏」に臨む心境を問う。技術的な指導以上に、彼らにとってこの夏がどのような意味を持つべきか、教育者としての葛藤と決意を語らせる。`;
                        }
                        // ▼▼▼ 他の逆境校の分岐 ▼▼▼
                        else if (teamSpecificInfo.includes('部員不足') || teamSpecificInfo.includes('連合チーム') || teamSpecificInfo.includes('0勝')) {
                             handicapFocusPrompt = `
3.  **【集まらない9人】**: ${teamName}の練習風景を描写する。助っ人の生徒（他部活）と共に練習する様子や、監督自らがノックの球拾いをする姿を描く。（※もし「0勝32敗」のような情報があれば、その歴史的敗北の重圧にも触れる）
4.  **【主将の苦労】**: 試合に出るだけでなく、部員の勧誘やチームの雰囲気作りに奔走する主将に焦点を当てる。「野球ができるだけでありがたい」という彼の言葉の重みを描写する。
5.  **【監督の信念】**: 監督に「なぜ野球部を続けるのか」を問う。勝利以前に、野球を通じて彼らに何を学んでほしいのか、その信念を語らせる。`;
                        } else if (teamSpecificInfo.includes('離島')) {
                             handicapFocusPrompt = `
3.  **【島を背負う】**: 本土から遠く離れた${teamName}。練習試合もままならず、情報も少ないという絶望的なハンデを描写する。
4.  **【島民の期待】**: 彼らの存在が、島にとってどのような希望となっているのか。練習を見守る地元住民や、漁の合間に手伝うOBの声を拾う。
5.  **【監督の戦略】**: 監督に「本土の強豪をどう倒すか」を問う。情報が少ない中で、彼らが磨いてきた「島ならではの野球」とは何かを語らせる。`;
                        } else {
                            // 上記以外の逆境校（デフォルト）
                            handicapFocusPrompt = `
3.  **【チームの現在地】**: 記者がチームの元を訪れる場面から始める。監督や選手にインタビューし、チームが抱える具体的なハンデ（例：${teamSpecificInfo}）と、それに対する彼らの想いを明らかにする。
4.  **【グラウンドの情景】**: 練習風景を描写する。部員数の少なさ（例：紅白戦ができない）、恵まれない練習環境（例：グラウンドが他の部と共用、道具が古い）といった、彼らの「日常」を具体的に描く。`;
                        }


                        if (matchData && matchData.opponent) {
                            const ourRank = calculateRank(teamName, tournamentState);
                            const opponentRank = matchData.opponentRank;
                            const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                            const rankDiff = rankValues[opponentRank] - rankValues[ourRank];
                            
                            // 構成案のステップ数を動的に計算
                            const handicapSteps = handicapFocusPrompt.split('\n').filter(line => line.trim().match(/^\d+\./)).length;
                            const stepOffset = 1 + 1 + handicapSteps; // (冒頭ナレーション + 現実) + ハンデ構成案のステップ数

                            if (rankDiff >= 2) { // 絶望的な格上
                                reactionPrompt = `
${stepOffset + 1}.  **【残酷な現実、そして監督の『建前』】**: 初戦の相手が格上の強豪「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。絶望と沈黙に包まれる選手たちを描写する。
${stepOffset + 2}.  **【監督室の『本音』】**: 監督が**選手たちの前で**は「これは試練だ。だが、歴史を創るチャンスでもある」と力強く語る一方、記者の前では**二人きりで**「いや、正直しんどいですよ…笑っちゃいましたもん、まさか〇〇（相手校名）と当たるなんて…」と、人間味あふれる弱音や本音を漏らす。`;
                            } else if (rankDiff >= 1) { // 少し格上
                                reactionPrompt = `
${stepOffset + 1}.  **【挑戦者たち】**: 初戦の相手が、格上の「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。選手たちが「不足はない相手」「一泡吹かせてやる」と闘志を燃やす様子を描写する。
${stepOffset + 2}.  **【監督の戦略】**: 監督は**選手たちの前で**「良い顔つきになったな」と彼らの士気を高めつつ、記者の前では**二人きりで**「正直、勝率は3割もないでしょう。でも、高校野球は何が起こるか分からない」と、冷静な分析と本音を語る。`;
                            } else { // 同格か格下
                                reactionPrompt = `
${stepOffset + 1}.  **【運命の初戦】**: 初戦の相手が実力の近い「${matchData.opponent}」(昨年度: ${matchData.opponentRecord})に決定。「勝てる！」と少し浮足立つ選手たちを描写する。
${stepOffset + 2}.  **【監督の『建前』と『本音』】**: 監督が**選手たちの前で**「油断が一番の敵だ」と厳しく一喝する一方、記者の前では**二人きりで**「最高のクジを引きました。ここを勝てば、間違いなくチームは波に乗れる」と、安堵とプレッシャーが入り混じった本音を語る。`;
                            }
                        }

                        // 最後の決意表明のステップ番号も動的に
                        const finalStepNumber = (handicapFocusPrompt.split('\n').filter(line => line.trim().match(/^\d+\./)).length) + (reactionPrompt ? 2 : 0) + 3;
                        let finalPledge = '俺たちは野球がしたいだけ。相手が誰でも、全力で戦うだけです'; // デフォルト
                        if (teamName === '浜松特支') finalPledge = '怖いけど...逃げません。9回まで戦います';
                        if (teamSpecificInfo.includes('最後の夏')) finalPledge = 'これが最後の夏。一試合でも長く、この仲間と、母校の名前で野球がしたいです';


                        prompt += `
### 取材テーマ
「${teamName}」が抱える困難な状況と、それでも夢を諦めない彼らの姿を、深く、濃く描くドキュメンタリー序章。
${charactersPrompt}
### 構成案
1.  **【冒頭ナレーション】**: 「〇〇（地名）の空の下、今日も彼らの声が響く。${teamName === '浜松特支' ? '—たとえ、その声がまだ、野球への恐怖に震えていたとしても。' : 'しかし、その声はあまりにも少ない。'}」といった、チームの状況を象徴するナレーションから始める。
2.  **【彼らの"現実"】**: ${teamSpecificInfo}
${handicapFocusPrompt}
${reactionPrompt}
${finalStepNumber}. **【決意表明】**: 最後に、主将が「${finalPledge}」と、大会へ向かう決意を語り、締めくくる。
### 描写のポイント
- **五感を刺激する描写**: 練習風景では、土の匂い、古い革の匂い、金属バットの乾いた音、監督の怒鳴り声など、情景が目に浮かぶような具体的な描写を多用すること。
- **対比**: 「他校の恵まれた環境」と「彼らの現実」を対比させることで、逆境を際立たせること。
- **感情の機微**: 選手の「悔しさ」「焦り」だけでなく、その中にある「誇り」や「仲間との絆」も丁寧に描写すること。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（長編の記事本文）"}`;                break;
            case 'lose':
                title = `『${teamName}、魂の記録』最終章`;
                prompt += `
### 取材テーマ
「${teamName}」の夏が終わった。夢破れた彼らの姿と、それでも確かに残ったものを描くドキュメンタリー最終章。
### 対戦相手「${teamName}」の背景
${matchData.opponentInfo}
### ユーザーが語る試合の決め手
${matchData.summary || '特になし'}
### この試合の主なハイライト
${matchData.highlights}
### 構成案
1.  ユーザーが語る「試合の決め手」に触れ、あと一歩及ばなかった彼らの奮闘を称える。
2.  対戦相手がどのようなチームであったか（【対戦相手の背景】を参照）に触れ、「よくやった」「悔しい」といった感情を増幅させる。
3.  試合終了の瞬間、泣き崩れるも、やがて顔を上げ、相手にエールを送る選手たちの姿を描写する。
4.  3年生の引退と、彼らの想いが後輩たちへと受け継がれていくことを示唆して、物語を締めくくる。
${finalFeedbackPrompt}
### 出力形式: JSON {"title": "${title}", "body": "（記事本文）"}`;
                break;
        }
    }
    
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) return { ...article, timestamp: Date.now() };
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI documentary article generation failed:", error);
        return null;
    }
}

/**
 * Sets the weather effect for the background.
 * @param {'none' | 'rain' | 'sun'} weatherType - The type of weather to display.
 */
function setWeather(weatherType) {
    const rainContainer = document.getElementById('rain-container');
    const sunContainer = document.getElementById('sun-container');

    // Hide all weather effects first
    rainContainer.classList.add('hidden');
    sunContainer.classList.add('hidden');
    rainContainer.innerHTML = ''; // Clear old raindrops

    if (weatherType === 'rain') {
        rainContainer.classList.remove('hidden');
        // Create 100 raindrops
        for (let i = 0; i < 100; i++) {
            const drop = document.createElement('div');
            drop.className = 'drop';
            drop.style.left = Math.random() * 100 + 'vw';
            drop.style.animationDelay = Math.random() * 0.5 + 's';
            drop.style.animationDuration = Math.random() * 0.2 + 0.3 + 's';
            rainContainer.appendChild(drop);
        }
    } else if (weatherType === 'sun') {
        sunContainer.classList.remove('hidden');
    }
}

/**
 * 詳細入力モーダル内のチームデータ、またはチーム名自体を入れ替える
 * @param {string} matchId - 対象の試合ID
 */
function swapTeamDetails(matchId) {
    const match = findMatchById(matchId);
    if (!match) return;

    // 1. チーム名と、トーナメント表に表示されているスコアを入れ替える
    const tempTeam = match.team1;
    match.team1 = match.team2;
    match.team2 = tempTeam;

    const tempScore = match.score1;
    match.score1 = match.score2;
    match.score2 = tempScore;

    // 2. もし詳細データが入力済みなら、その中身も入れ替える
    if (match.details) {
        // 打撃データを入れ替え
        const tempBatting = match.details.batting.team1;
        match.details.batting.team1 = match.details.batting.team2;
        match.details.batting.team2 = tempBatting;

        // 投手データを入れ替え
        const tempPitching = match.details.pitching.team1;
        match.details.pitching.team1 = match.details.pitching.team2;
        match.details.pitching.team2 = tempPitching;
        
        // イニングスコアを入れ替え
        if (match.details.inningScore) {
            const tempInningScore = match.details.inningScore.team1;
            match.details.inningScore.team1 = match.details.inningScore.team2;
            match.details.inningScore.team2 = tempInningScore;
        }
    }

    // 3. 変更を保存し、画面を更新する
    saveState();
    renderTournament(tournamentState); // トーナメント表も更新
    openDetailsModal(matchId); // モーダルを再描画して変更を反映
}

/**
 * [新機能] チームの全試合のスタメン履歴をHTMLで生成し、「試合別スタメン」タブに表示する
 * @param {string} teamName - チーム名
 */
function renderStartingLineupHistory(teamName) {
    const contentEl = document.getElementById('team-stats-tab-content-lineups');
    if (!contentEl) return;
    contentEl.innerHTML = '<div class="loader text-center py-16">スタメン履歴を読み込み中...</div>';

    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) {
        contentEl.innerHTML = '<p class="text-center text-red-500">チーム記録が見つかりません。</p>';
        return;
    }

    // 1. 全試合データをスキャン
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    // 2. チームが関わり、かつ詳細入力(スタメン)が存在する試合を収集
    const playedMatches = [];
    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        
        const teamKey = match.team1 === teamName ? 'team1' : (match.team2 === teamName ? 'team2' : null);

        // 条件：チームが関わっている AND 勝者が決まっている AND 詳細入力がある AND 打撃データがある
        if (teamKey && 
            match.winner && 
            match.details && 
            match.details.batting &&
            match.details.batting[teamKey] &&
            match.details.batting[teamKey].length > 0) 
        {
            // 試合IDからラウンド番号を簡易的に抽出
            let roundSortKey = 0;
            if (matchId.includes('-R')) {
                // 'L-R1-M1' -> R1 -> 1
                roundSortKey = parseInt(matchId.split('-R')[1].split('-')[0]);
            }
            if (matchId.startsWith('F-')) {
                roundSortKey = 100; // 決勝は最後
            }
            
            // TODO: 将来的に大会・年度別のソートキーを追加する
            // 現状はラウンド順のみでソート
            playedMatches.push({ ...match, roundSortKey, teamKey });
        }
    }
    
    // ラウンド順にソート (1回戦, 2回戦...)
    playedMatches.sort((a, b) => a.roundSortKey - b.roundSortKey);

    if (playedMatches.length === 0) {
        contentEl.innerHTML = '<p class="text-center text-gray-500">詳細入力されたスタメンの履歴がまだありません。</p>';
        return;
    }

    // 3. HTMLを生成 (現状は大会別ではなく、全履歴をラウンド順に表示)
    // TODO: 将来的に tournamentState.history を参照して大会別にグループ化する
    let html = `<div class="lineup-history-tournament">
        <h3 class="lineup-history-title">試合別スタメン履歴</h3>`;

    playedMatches.forEach(match => {
        const { teamKey, roundSortKey } = match;
        const opponentName = teamKey === 'team1' ? match.team2 : match.team1;
        const result = match.winner === teamName ? '〇' : '●';
        
        // スコアを正しく取得
        const scoreTeam = match[teamKey === 'team1' ? 'score1' : 'score2'];
        const scoreOpp = match[teamKey === 'team1' ? 'score2' : 'score1'];
        
        const roundName = getRoundNameFromMatchId(match.id);
        
        // スタメンを抽出
        const battingData = match.details.batting[teamKey] || [];
        const starters = battingData
            .filter(p => p.order && !p.order.toString().includes('sub') && parseInt(p.order) >= 1 && parseInt(p.order) <= 9)
            .sort((a, b) => parseInt(a.order) - parseInt(b.order)); // 打順(1-9)でソート

        if (starters.length > 0) {
            html += `
                <div class="lineup-history-match">
                    <h4 class="lineup-history-match-header">${roundName} vs ${opponentName} (${result} ${scoreTeam}-${scoreOpp})</h4>
                    <ul class="lineup-history-list">
                        ${starters.map(p => `<li>${p.order}. [${p.currentPos || p.pos || '?'}] ${p.name}</li>`).join('')}
                    </ul>
                </div>
            `;
        }
    });

    html += `</div>`;
    contentEl.innerHTML = html;
}

// ▼▼▼ この関数をまるごと「新規追加」(10673行目あたり、renderTeamStatsModal の直前) ▼▼▼

/**
 * [NEW] 個人の通算成績モーダルの中身を生成・表示する
 * (★「ReferenceError: renderCareerStatsModal is not defined」エラーを修正)
 * @param {string} playerName - 選手名
 * @param {string} teamName - チーム名
 */
function renderCareerStatsModal(playerName, teamName) {
    const modalBody = document.getElementById('player-stats-modal-body');
    if (!modalBody) {
        console.error("Fatal: player-stats-modal-body element not found.");
        return;
    }
    
    modalBody.innerHTML = ''; // Clear previous content
    
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord || !teamRecord.playerStats) {
        modalBody.innerHTML = `<p class="text-red-500 text-center">エラー: ${teamName} のチーム記録が見つかりません。</p>`;
        return;
    }

    const bStats = teamRecord.playerStats.batting?.[playerName];
    const pStats = teamRecord.playerStats.pitching?.[playerName];

    if (!bStats && !pStats) {
        modalBody.innerHTML = `<p class="text-gray-500 text-center">${playerName}選手の通算成績データはまだありません。</p>`;
        return;
    }

    let html = `
        <div class="player-stats-header">
            <h4 class="player-stats-name">${playerName}</h4>
            <p class="player-stats-team">${teamName}</p>
        </div>
    `;

    // --- 1. 打撃成績の表示 ---
    if (bStats && bStats.pa > 0) {
        // 必要な計算 (renderTeamStatsModalから拝借)
        const { games = 0, pa = 0, ab = 0, h = 0, hr = 0, rbi = 0, sb = 0, bb = 0, hbp = 0, sf = 0, tb = 0 } = bStats;
        const avg = (ab > 0) ? (h / ab).toFixed(3) : ".000";
        const obp_numerator = h + bb + hbp;
        const obp_denominator = ab + bb + hbp + sf;
        const obp = (obp_denominator > 0) ? (obp_numerator / obp_denominator).toFixed(3) : ".000";
        const slg = (ab > 0) ? (tb / ab).toFixed(3) : ".000";
        const ops = (parseFloat(obp) + parseFloat(slg)).toFixed(3);

        html += `
            <div>
                <h5 class="stats-section-title">通算打撃成績</h5>
                <div class="stats-grid">
                    <div class="stats-grid-item highlight">
                        <span class="stats-label">打率</span>
                        <span class="stats-value">${avg}</span>
                    </div>
                    <div class="stats-grid-item highlight">
                        <span class="stats-label">OPS</span>
                        <span class="stats-value">${ops}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">本塁打</span>
                        <span class="stats-value">${hr}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">打点</span>
                        <span class="stats-value">${rbi}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">試合</span>
                        <span class="stats-value">${games}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">打数</span>
                        <span class="stats-value">${ab}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">安打</span>
                        <span class="stats-value">${h}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">盗塁</span>
                        <span class="stats-value">${sb}</span>
                    </div>
                </div>
                <div class="stats-grid mt-2 grid-cols-5">
                    <div class="stats-grid-item"><span class="stats-label">打席</span><span class="stats-value text-xl">${pa}</span></div>
                    <div class="stats-grid-item"><span class="stats-label">四球</span><span class="stats-value text-xl">${bb}</span></div>
                    <div class="stats-grid-item"><span class="stats-label">死球</span><span class="stats-value text-xl">${hbp}</span></div>
                    <div class="stats-grid-item"><span class="stats-label">出塁率</span><span class="stats-value text-xl">${obp}</span></div>
                    <div class="stats-grid-item"><span class="stats-label">長打率</span><span class="stats-value text-xl">${slg}</span></div>
                </div>
            </div>
        `;
    }

    // --- 2. 投手成績の表示 ---
    if (pStats && pStats.career && pStats.career.ip > 0) {
        const career = pStats.career;
        const { games = 0, w = 0, l = 0, ip = 0, so = 0, er = 0, h = 0, bb = 0 } = career;
        const era_val = (ip > 0) ? ((er * 9) / ip) : Infinity;
        const whip_val = (ip > 0) ? ((bb + h) / ip) : Infinity;
        const k9_val = (ip > 0) ? ((so * 9) / ip) : 0;
        
        const era = (era_val === Infinity) ? "----" : era_val.toFixed(2);
        const whip = (whip_val === Infinity) ? "----" : whip_val.toFixed(2);
        const k9 = k9_val.toFixed(2);

        html += `
            <div>
                <h5 class="stats-section-title">通算投手成績</h5>
                <div class="stats-grid">
                    <div class="stats-grid-item highlight">
                        <span class="stats-label">防御率</span>
                        <span class="stats-value">${era}</span>
                    </div>
                    <div class="stats-grid-item highlight">
                        <span class="stats-label">WHIP</span>
                        <span class="stats-value">${whip}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">勝利</span>
                        <span class="stats-value">${w}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">敗北</span>
                        <span class="stats-value">${l}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">登板</span>
                        <span class="stats-value">${games}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">投球回</span>
                        <span class="stats-value">${ip.toFixed(1)}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">奪三振</span>
                        <span class="stats-value">${so}</span>
                    </div>
                    <div class="stats-grid-item">
                        <span class="stats-label">K/9</span>
                        <span class="stats-value">${k9}</span>
                    </div>
                </div>
            </div>
        `;
    }
    
    // --- 3. 試合履歴 (Gamelogs) の表示 ---
    const allGamelogs = [
        ...(bStats?.gamelogs || []).map(log => ({ ...log, type: 'batting' })),
        ...(pStats?.gamelogs || []).map(log => ({ ...log, type: 'pitching' }))
    ].sort((a, b) => (parseDate(a.date) || 0) - (parseDate(b.date) || 0)); // 日付順にソート

    if (allGamelogs.length > 0) {
        html += `
            <div>
                <h5 class="stats-section-title">今大会 試合別成績</h5>
                <div class="space-y-2 text-sm">
        `;
        
        // Gamelogを試合IDでグループ化
        const gamesGrouped = allGamelogs.reduce((acc, log) => {
            if (!acc[log.matchId]) {
                acc[log.matchId] = {
                    round: log.round,
                    opponent: log.opponent,
                    opponentRank: log.opponentRank,
                    batting: null,
                    pitching: null
                };
            }
            if (log.type === 'batting') acc[log.matchId].batting = log.stats;
            if (log.type === 'pitching') acc[log.matchId].pitching = log;
            return acc;
        }, {});

        Object.values(gamesGrouped).reverse().forEach(game => { // 新しい試合から表示
            let statsLine = '';
            if (game.batting) {
                const b = game.batting;
                statsLine += `打: ${b.ab}-${b.h} ${b.hr}HR ${b.rbi}点 ${b.sb}盗`;
            }
            if (game.pitching) {
                const p = game.pitching;
                const resultMark = {'W': '○', 'L': '●', 'S': 'Ｓ', 'H': 'Ｈ'}[p.result] || '';
                statsLine += (statsLine ? ' / ' : '') + `投: ${resultMark}${p.ip}回 ${p.so}K ${p.r}失(自${p.er})`;
            }
            
            html += `
                <div class="p-2 border rounded bg-gray-50">
                    <span class="font-semibold">${game.round} vs ${game.opponent} [${game.opponentRank}]</span>
                    <span class="block text-gray-700">${statsLine}</span>
                </div>
            `;
        });

        html += `</div></div>`;
    }

    modalBody.innerHTML = html;
}

// ヘルパー関数: parseDate (gamelogソート用)
const parseDate = (dateStr) => {
    if (!dateStr || !dateStr.includes('/')) return null;
    const [month, day] = dateStr.split('/').map(Number);
    // 年は現在の大会年度を仮定 (月が1-3月の場合は翌年扱い)
    const year = (tournamentState?.tournamentYear || new Date().getFullYear()) + (month <= 3 ? 1 : 0);
    return new Date(year, month - 1, day);
};
// ▲▲▲ 新規追加ここまで ▲▲▲


// ▼▼▼ 既存の「renderTeamStatsModal」関数 (10675行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * チーム全員の通算成績モーダルの中身を生成・表示する
 * (★「規定打席」ソートロジックを 試合数*3 に変更、投手の規定を撤廃★)
 * @param {string} teamName - チーム名
 */
function renderTeamStatsModal(teamName) {
    const modal = document.getElementById('team-stats-modal');
    const modalTitle = document.getElementById('team-stats-modal-title');
    
    const teamRecord = tournamentState.teamRecords[teamName];

    modalTitle.textContent = `${teamName} 通算成績`;
    
    const statsContentEl = document.getElementById('team-stats-tab-content-stats');

    if (!teamRecord || !teamRecord.playerStats) {
        statsContentEl.innerHTML = '<p class="text-center text-red-500">選手の成績データが見つかりません。</p>';
        return;
    }

    // --- 0. 現在のソート状態を取得（なければ選手名で昇順） ---
    const sortState = {
        batting: {
            key: modal.dataset.sortKeyBatting || 'name',
            dir: modal.dataset.sortDirBatting || 'asc'
        },
        pitching: {
            key: modal.dataset.sortKeyPitching || 'name',
            dir: modal.dataset.sortDirPitching || 'asc'
        }
    };
    
    // --- ヘルパー関数：ソート用の矢印(▲▼)クラスを生成 ---
    const getSortClass = (tableType, key) => {
        const state = sortState[tableType];
        if (state.key !== key) return '';
        return state.dir === 'asc' ? 'sort-asc' : 'sort-desc';
    };

    const { batting, pitching } = teamRecord.playerStats;
    let battingHtml = '';
    let pitchingHtml = '';

    // --- 1. 打撃成績の計算と表示 (★ソートロジック修正) ---
    if (batting && Object.keys(batting).length > 0) {
        const battingArray = Object.keys(batting).map(playerName => {
            const stats = batting[playerName];
            const { games = 0, pa = 0, ab = 0, h = 0, hr = 0, rbi = 0, sb = 0, bb = 0, hbp = 0, sf = 0, tb = 0 } = stats;
            const avg = (ab > 0) ? (h / ab) : 0;
            const obp_numerator = h + bb + hbp;
            const obp_denominator = ab + bb + hbp + sf;
            const obp = (obp_denominator > 0) ? (obp_numerator / obp_denominator) : 0;
            const slg = (ab > 0) ? (tb / ab) : 0;
            const ops = obp + slg;
            return { name: playerName, ...stats, avg, obp, slg, ops };
        }).filter(p => p.pa > 0 || p.games > 0); // ★打席0でも試合出場(games > 0)なら表示

        // --- ★★★ ここからが修正箇所 ★★★ ---
        const sortKey = sortState.batting.key;
        const sortDir = sortState.batting.dir === 'asc' ? 1 : -1;
        
        // ★ チームの総試合数を計算 (出場選手の中で最大の試合数)
        // (今大会の試合数ではなく、全履歴の試合数を参照)
        const totalGamesPlayed = Math.max(...battingArray.map(p => p.games || 0));
        // ★ 規定打席を「試合数 * 3」に設定
        const MINIMUM_PA_FOR_RANKING = totalGamesPlayed * 3;
        
        // 規定打席の対象となる率系のスタッツか？
        const isRankedStat = ['avg', 'obp', 'slg', 'ops'].includes(sortKey);

        battingArray.sort((a, b) => {
            let valA = a[sortKey], valB = b[sortKey];
            const paA = a.pa || 0;
            const paB = b.pa || 0;

            // 1. 率系のスタッツでソートする場合
            if (isRankedStat) {
                // ★ 規定打席のしきい値を MINIMUM_PA_FOR_RANKING に変更
                const aQualified = paA >= MINIMUM_PA_FOR_RANKING;
                const bQualified = paB >= MINIMUM_PA_FOR_RANKING;

                // 両方規定打席未満なら、打席数の多い順
                if (!aQualified && !bQualified) {
                    return (paB - paA); 
                }
                // Aだけ規定打席未満なら、Aを「下」にする
                if (!aQualified) {
                    return 1; // 1を返すとbが先(aが後)になる
                }
                // Bだけ規定打席未満なら、Bを「下」にする
                if (!bQualified) {
                    return -1; // -1を返すとaが先(bが後)になる
                }
                // 両方規定打席以上なら、通常のソートへ進む
            }

            // --- 2. 通常のソートロジック ---
            if (sortKey === 'name') return valA.localeCompare(valB, 'ja') * sortDir;
            if (valA === undefined || valA === null) valA = 0;
            if (valB === undefined || valB === null) valB = 0;
            return (valA - valB) * sortDir;
        });
        // --- ★★★ 修正ここまで ★★★ ---

        battingHtml = `
            <div>
                <h4 class="stats-section-title">通算打撃成績 (規定打席: ${MINIMUM_PA_FOR_RANKING})</h4>
                <div class="overflow-x-auto">
                    <table class="career-stats-table" id="batting-stats-table">
                        <thead>
                            <tr>
                                <th class="player-name sortable-header ${getSortClass('batting', 'name')}" data-sort-key="name" data-table-type="batting">選手名<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'games')}" data-sort-key="games" data-table-type="batting">試<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'avg')}" data-sort-key="avg" data-table-type="batting">打率<span class="sort-arrow"></span></th>
                                <th class="stat-highlight sortable-header ${getSortClass('batting', 'ops')}" data-sort-key="ops" data-table-type="batting">OPS<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'pa')}" data-sort-key="pa" data-table-type="batting">打席<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'ab')}" data-sort-key="ab" data-table-type="batting">打数<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'h')}" data-sort-key="h" data-table-type="batting">安打<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'hr')}" data-sort-key="hr" data-table-type="batting">本<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'rbi')}" data-sort-key="rbi" data-table-type="batting">点<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'sb')}" data-sort-key="sb" data-table-type="batting">盗<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'bb')}" data-sort-key="bb" data-table-type="batting">四<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('batting', 'hbp')}" data-sort-key="hbp" data-table-type="batting">死<span class="sort-arrow"></span></th>
                                <th class="stat-highlight sortable-header ${getSortClass('batting', 'obp')}" data-sort-key="obp" data-table-type="batting">出塁率<span class="sort-arrow"></span></th>
                                <th class="stat-highlight sortable-header ${getSortClass('batting', 'slg')}" data-sort-key="slg" data-table-type="batting">長打率<span class="sort-arrow"></span></th>
                            </tr>
                        </thead>
                        <tbody>
        `;
        battingArray.forEach(stats => {
            const isQualified = stats.pa >= MINIMUM_PA_FOR_RANKING;
            const rateClass = isQualified ? 'stat-highlight' : 'text-gray-400';

            // ★★★ 修正: ${stats.hbp} -> ${stats.hbp || 0} に変更 ★★★
            battingHtml += `
                <tr>
                    <td class="player-name">${stats.name}</td>
                    <td>${stats.games}</td><td class="${rateClass}">${stats.avg.toFixed(3)}</td><td class="${rateClass}">${stats.ops.toFixed(3)}</td>
                    <td>${stats.pa}</td><td>${stats.ab}</td><td>${stats.h}</td><td>${stats.hr}</td>
                    <td>${stats.rbi}</td><td>${stats.sb}</td><td>${stats.bb}</td><td>${stats.hbp || 0}</td>
                    <td class="${rateClass}">${stats.obp.toFixed(3)}</td><td class="${rateClass}">${stats.slg.toFixed(3)}</td>
                </tr>
            `;
        });
        battingHtml += `</tbody></table></div></div>`;
    } else {
        battingHtml = `<div><h4 class="stats-section-title">通算打撃成績</h4><p class="text-sm text-gray-500">（通算打撃成績なし）</p></div>`;
    }

    // --- 2. 投手成績の計算と表示 (★規定投球回ロジック削除) ---
    if (pitching && Object.keys(pitching).length > 0) {
        
        // 2a. データを配列に変換し、計算値を付与
        const pitchingArray = Object.keys(pitching).map(playerName => {
            const pStats = pitching[playerName];
            const stats = pStats.career; // 通算成績
            if (!stats) return null;
            
            const { games = 0, w = 0, l = 0, ip = 0, so = 0, er = 0, h = 0, bb = 0 } = stats;
            const era = (ip > 0) ? ((er * 9) / ip) : Infinity; 
            const whip = (ip > 0) ? ((bb + h) / ip) : Infinity; 
            const k9 = (ip > 0) ? ((so * 9) / ip) : 0; 

            return { name: playerName, ...stats, era, whip, k9, gamelogs: pStats.gamelogs || [] };
        }).filter(p => p && (p.ip > 0 || p.games > 0)); // ★ games > 0 (登板のみ) も許可
        
        // 2b. 配列をソート
        const sortKey = sortState.pitching.key;
        const sortDir = sortState.pitching.dir === 'asc' ? 1 : -1;
        
        // ★ 規定投球回ロジックを「まるごと削除」
        const isPitchingRankedStat = ['era', 'whip', 'k9'].includes(sortKey);

        pitchingArray.sort((a, b) => {
            let valA = a[sortKey], valB = b[sortKey];
            const ipA = a.ip || 0;
            const ipB = b.ip || 0;

            // ★ 規定投球回の `if (isPitchingRankedStat)` ブロックを「まるごと削除」

            // 無限大(Infinity)のERAをソートのために大きな数値に変換
            if (isPitchingRankedStat) {
                if (valA === Infinity) valA = 999.99;
                if (valB === Infinity) valB = 999.99;
            }

            if (sortKey === 'name') return valA.localeCompare(valB, 'ja') * sortDir;
            if (valA === Infinity) valA = 999.99; 
            if (valB === Infinity) valB = 999.99;
            if (valA === undefined || valA === null) valA = 0;
            if (valB === undefined || valB === null) valB = 0;
            return (valA - valB) * sortDir;
        });

        // 2c. HTMLを生成
        pitchingHtml = `
            <div class="mt-6">
                <h4 class="stats-section-title">通算投手成績</h4>
                <div class="overflow-x-auto">
                    <table class="career-stats-table" id="pitching-stats-table">
                        <thead>
                            <tr>
                                <th class="player-name sortable-header ${getSortClass('pitching', 'name')}" data-sort-key="name" data-table-type="pitching">選手名<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'games')}" data-sort-key="games" data-table-type="pitching">登<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'w')}" data-sort-key="w" data-table-type="pitching">勝<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'l')}" data-sort-key="l" data-table-type="pitching">敗<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'ip')}" data-sort-key="ip" data-table-type="pitching">回<span class="sort-arrow"></span></th>
                                <th class="stat-highlight sortable-header ${getSortClass('pitching', 'era')}" data-sort-key="era" data-table-type="pitching">防御率<span class="sort-arrow"></span></th>
                                <th class="stat-highlight sortable-header ${getSortClass('pitching', 'whip')}" data-sort-key="whip" data-table-type="pitching">WHIP<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'so')}" data-sort-key="so" data-table-type="pitching">振<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'h')}" data-sort-key="h" data-table-type="pitching">被安<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'bb')}" data-sort-key="bb" data-table-type="pitching">与四<span class="sort-arrow"></span></th>
                                <th class="sortable-header ${getSortClass('pitching', 'er')}" data-sort-key="er" data-table-type="pitching">自責<span class="sort-arrow"></span></th>
                                <th class="stat-highlight sortable-header ${getSortClass('pitching', 'k9')}" data-sort-key="k9" data-table-type="pitching">K/9<span class="sort-arrow"></span></th>
                            </tr>
                        </thead>
                        <tbody>
        `;
        pitchingArray.forEach(stats => {
            // ★ 規定投球回チェックを削除
            const rateClass = 'stat-highlight'; // ★ 常にハイライト
            
            const gamelogHtml = stats.gamelogs.length > 0 
                ? stats.gamelogs.map(log => `(${log.round} vs ${log.opponent}: ${log.ip}回 ${log.r}失点)`).join(', ')
                : '登板履歴なし';
                
            pitchingHtml += `
                <tr>
                    <td class="player-name">${stats.name}</td>
                    <td>${stats.games}</td><td>${stats.w}</td><td>${stats.l}</td>
                    <td>${stats.ip.toFixed(1)}</td><td class="${rateClass}">${stats.era === 999.99 ? '----' : stats.era.toFixed(2)}</td>
                    <td class="${rateClass}">${stats.whip === 999.99 ? '----' : stats.whip.toFixed(2)}</td>
                    <td>${stats.so}</td><td>${stats.h}</td><td>${stats.bb}</td><td>${stats.er}</td>
                    <td class="${rateClass}">${stats.k9.toFixed(2)}</td>
                </tr>
                <tr class="bg-gray-50">
                    <td colspan="12" class="text-left text-xs text-gray-600 p-2" style="white-space: normal;">
                        <strong>登板履歴:</strong> ${gamelogHtml}
                    </td>
                </tr>
            `;
        });
        pitchingHtml += `</tbody></table></div></div>`;
    } else {
        pitchingHtml = `<div class="mt-6"><h4 class="stats-section-title">通算投手成績</h4><p class="text-sm text-gray-500">（通算投手成績なし）</p></div>`;
    }

    statsContentEl.innerHTML = battingHtml + pitchingHtml;
}
// ▲▲▲ 置き換えここまで ▲▲▲


/**
 * チームステータスモーダルを表示する
 * (★「今大会成績」欄にチーム防御率を追加した修正版)
 * @param {string} teamName - クリックされたチーム名
 */
function showTeamStatusModal(teamName) {
    // ▼▼▼ 表示前に過去成績をバックフィル (CPUチーム用) ▼▼▼
    backfillCpuStats(teamName);
    // ▲▲▲ 追加ここまで ▲▲▲

    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) return;

    // --- 1. モーダル要素の取得 ---
    const modal = document.getElementById('team-status-modal');
    const bestEl = document.getElementById('status-modal-best');
    const historyEl = document.getElementById('status-modal-history');
    const traitsEl = document.getElementById('status-modal-traits');
    const coachEl = document.getElementById('status-modal-coach'); 
    const homepageLinkContainer = document.getElementById('status-modal-homepage-link-container');
    const homepageLink = document.getElementById('status-modal-homepage-link');
    
    // テキスト成績用のPタグ
    const statsEl = document.getElementById('status-modal-team-stats');
    const careerStatsEl = document.getElementById('status-modal-career-stats'); 

    // ★ 既存のチャートがあれば削除（再描画のため）
    const existingChart = Chart.getChart('team-radar-chart');
    if (existingChart) {
        existingChart.destroy();
    }

    // --- 2. チーム基本情報の表示 ---
    document.getElementById('status-modal-team-name').textContent = teamName;
    
    if (homepageLink) {
        homepageLink.removeAttribute('href');
        homepageLink.removeAttribute('target');
        homepageLink.style.cursor = 'pointer';
    }
    bestEl.textContent = teamRecord.best ? formatRecordToString(teamRecord.best) : 'まだありません';
    historyEl.innerHTML = '';
    if (teamRecord.history && teamRecord.history.length > 0) {
        teamRecord.history.slice(0, 2).forEach(rec => {
            const p = document.createElement('p');
            p.textContent = formatRecordToString(rec);
            historyEl.appendChild(p);
        });
    } else {
        historyEl.innerHTML = '<p>まだありません</p>';
    }
    traitsEl.innerHTML = '';
    if (teamRecord.teamTraits && teamRecord.teamTraits.length > 0) {
        teamRecord.teamTraits.forEach(traitId => {
            const trait = TITLES[traitId];
            if (trait) {
                const span = document.createElement('span');
                span.className = 'bg-blue-100 text-blue-800 text-xs font-semibold px-2.5 py-0.5 rounded-full';
                span.textContent = trait.name;
                traitsEl.appendChild(span);
            }
        });
    } else {
        traitsEl.innerHTML = '<p class="text-gray-500 text-sm">なし</p>';
    }
    const teamMasterData = TEAM_DATA[teamName];
    if (teamMasterData && teamMasterData.coach) {
        coachEl.textContent = `${teamMasterData.coach.name} (${teamMasterData.coach.experience} / ${teamMasterData.coach.style})`;
    } else {
        coachEl.textContent = '情報なし';
    }
// ★★★ ここに貼り付けてください ★★★
    // ▼▼▼ 追加: キャプテン名の表示 ▼▼▼
    // ロスター情報からキャプテンを探す
    let captainDisplay = "不明";
    if (teamRecord.roster) {
        const captain = teamRecord.roster.find(p => p.isCaptain);
        if (captain) captainDisplay = captain.name;
    } else if (TEAM_ROSTER_MASTER[teamName]) {
        // まだ試合をしていないがマスタデータがある場合
        const masterCap = TEAM_ROSTER_MASTER[teamName].find(p => p.isCaptain);
        if (masterCap) captainDisplay = masterCap.name;
    }

    // 監督表示の下あたりに追加
    if (coachEl) {
        // 既存の監督表示に続けて主将も表示
        coachEl.innerHTML += `<br><span class="text-sm font-normal text-gray-600">主将: </span><span class="font-bold text-gray-800">${captainDisplay}</span>`;
    }
    // ▲▲▲ 追加ここまで ▲▲▲
    // ★★★★★★★★★★★★★★★★★★★
    if (homepageLinkContainer && homepageLink) {
        if (teamName === "283学園") {
            homepageLink.setAttribute('data-target', 'homepage-modal'); 
            homepageLinkContainer.classList.remove('hidden');
        } else {
            homepageLinkContainer.classList.add('hidden'); 
        }
    }

    // --- ★★★ 今大会の「チーム防御率」を計算 ★★★ ---
    let tourneyIP = 0;
    let tourneyER = 0;
    const currentTournamentKey = tournamentState.currentTournament;

    if (teamRecord.playerStats && teamRecord.playerStats.pitching) {
        Object.values(teamRecord.playerStats.pitching).forEach(p => {
            if (p.gamelogs) {
                p.gamelogs.forEach(log => {
                    // ログが「現在の大会」のものか判定
                    const logRound = log.round || '';
                    let isCurrent = false;
                    if (currentTournamentKey === 'summer') isCurrent = logRound.includes('回戦') || logRound.includes('決勝');
                    else if (currentTournamentKey === 'summer_koshien') isCurrent = true; // 甲子園モード
                    else if (currentTournamentKey === 'autumn') isCurrent = logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                    else if (currentTournamentKey === 'spring') isCurrent = logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                    
                    if (isCurrent) {
                        tourneyIP += parseFloat(log.ip || 0);
                        tourneyER += parseInt(log.er || 0);
                    }
                });
            }
        });
    }
    // 防御率計算 (イニング0の場合はハイフン)
    const tourneyERA = (tourneyIP > 0) ? ((tourneyER * 9) / tourneyIP).toFixed(2) : "----";
    // --- ★★★ 計算ここまで ★★★ ---


    // --- 3. チームレーダーチャートの生成 ---
    const stats = teamRecord.tournamentStats || { h: 0, ab: 0, hr: 0, rbi: 0, sb: 0, so: 0 };
    // チャート用には、先ほど計算した今大会のERAを使用
    const eraNum = (tourneyERA === "----") ? 9.00 : parseFloat(tourneyERA);

    const avg = (stats.ab > 0) ? (stats.h / stats.ab) : 0;
    const power = (stats.hr || 0) * 10;
    const speed = (stats.sb || 0) * 10;
    const defense = (eraNum < 6) ? (6 - eraNum) / 5 * 100 : (eraNum >= 6 ? 0 : 50); // 防御率が良いほど高得点
    const so = (stats.so || 0);
    const bb = (stats.bb || 0) + (stats.hbp || 0);
    const eye = (bb > 0) ? (bb / (bb + so)) * 100 : 30;

    const normalize = (value) => Math.max(0, Math.min(100, Math.round(value)));

    const chartData = [
        normalize(avg * 500 - 100), // .200=0, .400=100
        normalize(power),
        normalize(speed),
        normalize(defense),
        normalize(eye)
    ];
    
    const ctx = document.getElementById('team-radar-chart')?.getContext('2d');
    if (ctx) {
        new Chart(ctx, {
            type: 'radar',
            data: {
                labels: ['打撃 (AVG)', '長打 (HR)', '機動 (SB)', '守備 (ERA)', '選球眼 (BB/K)'],
                datasets: [{
                    label: `${teamName} (今大会)`,
                    data: chartData,
                    fill: true,
                    backgroundColor: 'rgba(59, 130, 246, 0.2)',
                    borderColor: 'rgb(59, 130, 246)',
                    pointBackgroundColor: 'rgb(59, 130, 246)',
                    pointBorderColor: '#fff',
                    pointHoverBackgroundColor: '#fff',
                    pointHoverBorderColor: 'rgb(59, 130, 246)'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    r: {
                        angleLines: { color: 'rgba(0, 0, 0, 0.1)' },
                        grid: { color: 'rgba(0, 0, 0, 0.1)' },
                        pointLabels: {
                            font: { size: 12, weight: 'bold' },
                            color: '#333'
                        },
                        ticks: {
                            backdropColor: 'white',
                            color: '#777',
                            stepSize: 25,
                            font: { size: 10 }
                        },
                        min: 0,
                        max: 100
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }

    // --- 4. テキスト成績の表示 (★ここに防御率を追加) ---
    if (statsEl) {
        if (stats && (stats.ab > 0 || stats.games > 0 || stats.sb > 0)) {
            const avgStr = (stats.ab > 0) ? (stats.h / stats.ab).toFixed(3) : ".---";
            
            // ★ チームOPSの計算
            const t_ab = stats.ab || 0; const t_h = stats.h || 0;
            const t_bb = (stats.bb || 0) + (stats.hbp || 0); const t_sf = stats.sf || 0;
            const t_tb = stats.tb || (t_h + (stats.hr || 0) * 3); // TBがない場合のフォールバック
            const t_obp = (t_ab + t_bb + t_sf) > 0 ? (t_h + t_bb) / (t_ab + t_bb + t_sf) : 0;
            const t_slg = t_ab > 0 ? t_tb / t_ab : 0;
            const t_ops = (t_obp + t_slg).toFixed(3);
            
            const sbCount = stats.sb || 0;
            
            // ★ 表示にOPSを追加
            statsEl.innerHTML = `
                打率 <span class="font-bold text-xl">${avgStr}</span> 
                (OPS <span class="font-bold text-blue-700">${t_ops}</span>)<br>
                ${stats.ab}打数 ${stats.h}安打 ${stats.hr}本塁打 ${stats.rbi}打点 ${sbCount}盗塁<br>
                <span class="text-blue-700">防御率 ${tourneyERA}</span>
            `;
        } else if (stats) {
            statsEl.innerHTML = `(今大会 ${stats.ab}打数 ${stats.h}安打)<br><span class="text-blue-700">防御率 ${tourneyERA}</span>`;
        } else {
            statsEl.textContent = '（今大会の集計データなし）';
        }
    }    

// ▼▼▼ 追加箇所: セイバーメトリクスHTMLの注入 ▼▼▼
    const saberContainer = document.getElementById('status-modal-sabermetrics');
    if (saberContainer) {
        saberContainer.innerHTML = generateSabermetricsHTML(teamName);
    }
    // ▲▲▲ 追加ここまで ▲▲▲

// ▼▼▼ ★★★ ここに以下のコードを挿入してください ★★★ ▼▼▼

    // --- [追加] ランク変動予測を表示 ---
    let predictionContainer = document.getElementById('status-modal-rank-prediction');
    if (!predictionContainer) {
        // コンテナがなければ作成して挿入
        predictionContainer = document.createElement('div');
        predictionContainer.id = 'status-modal-rank-prediction';
        predictionContainer.className = "mt-4 p-3 bg-gray-50 border border-gray-200 rounded-lg text-sm";
        
        // 挿入場所: 今大会成績(statsEl)の親要素内、statsElの直後
        if (statsEl && statsEl.parentNode) {
            statsEl.parentNode.insertBefore(predictionContainer, statsEl.nextSibling);
        }
    }
    
    // 予測を実行して表示
    const prediction = predictRankChanges(teamName);
    predictionContainer.innerHTML = `
        <h5 class="font-bold text-gray-700 mb-2 border-b pb-1">次回のランク変動予測</h5>
        <div class="space-y-2">
            <div class="flex items-start">
                <span class="text-xl mr-2">📈</span>
                <div>${prediction.up}</div>
            </div>
            <div class="flex items-start">
                <span class="text-xl mr-2">📉</span>
                <div>${prediction.down}</div>
            </div>
        </div>
    `;

    // ▲▲▲ 挿入ここまで ▲▲▲

    // --- 5. 通算成績 (Career) の表示 ---
    if (careerStatsEl) {
        const careerBattingStats = teamRecord.playerStats?.batting;
        let totalCareerSb = 0, totalCareerHr = 0;
        if (careerBattingStats) {
            for (const playerName in careerBattingStats) {
                const stats = careerBattingStats[playerName];
                totalCareerSb += stats.sb || 0;
                totalCareerHr += stats.hr || 0;
            }
        }
        // 通算防御率は「全期間」なので、calculateTeamPitchingStats (全期間集計) を使うことも可能だが、
        // ここでは打撃指標のみに戻しておく（ご要望通り、今大会成績の欄に防御率を出したので）
        careerStatsEl.textContent = `通算 ${totalCareerHr} 本塁打 / ${totalCareerSb} 盗塁`;
    }
    
    // --- 6. モーダルを表示 ---
    modal.classList.remove('hidden');
}

// ▲▲▲ 置き換えここまで ▲▲▲
// ▲▲▲ 置き換えここまで ▲▲▲ 
// ▲▲▲ 置き換えここまで ▲▲▲
// ▲▲▲ 置き換えここまで ▲▲▲

// ▲▲▲ 置き換えここまで ▲▲▲
  // --- Custom Alert/Confirm ---
    function showAlert(message) {
        alert(message);
    }

    function showConfirm(message) {
        return new Promise((resolve) => {
            const confirmOk = document.getElementById('confirm-ok');
            const confirmCancel = document.getElementById('confirm-cancel');
            document.getElementById('confirm-modal-text').textContent = message;
            confirmModal.classList.remove('hidden');

            const onOk = () => {
                confirmModal.classList.add('hidden');
                cleanup();
                resolve(true);
            };

            const onCancel = () => {
                confirmModal.classList.add('hidden');
                cleanup();
                resolve(false);
            };
            
            const cleanup = () => {
                confirmOk.removeEventListener('click', onOk);
                confirmCancel.removeEventListener('click', onCancel);
            };

            confirmOk.addEventListener('click', onOk);
            confirmCancel.addEventListener('click', onCancel);
        });
    }

// --- Utility & State Functions --- などに追加

// 甲子園での成績を定義（数字が小さいほど上位）
const KOSHIEN_RESULTS = {
    CHAMPION:       { rank: -1, label: '全国優勝' },
    RUNNER_UP:    { rank: -2, label: '全国準優勝' },
    BEST_4:         { rank: -4, label: '甲子園ベスト4' },
    BEST_8:         { rank: -8, label: '甲子園ベスト8' },
    BEST_16:        { rank: -16, label: '甲子園3回戦敗退' }, // ベスト16
    ROUND_2:        { rank: -32, label: '甲子園2回戦敗退' },
    ROUND_1:        { rank: -64, label: '甲子園初戦敗退' },
};

// チームのA～Eランクごとの、甲子園での成績確率（ウェイト方式）
const KOSHIEN_PROBABILITIES = {
    'A': [
        { result: 'CHAMPION', weight: 20 }, { result: 'RUNNER_UP', weight: 25 },
        { result: 'BEST_4', weight: 25 },   { result: 'BEST_8', weight: 15 },
        { result: 'BEST_16', weight: 10 },  { result: 'ROUND_2', weight: 4 },
        { result: 'ROUND_1', weight: 1 }
    ],
    'B': [
        { result: 'CHAMPION', weight: 5 },  { result: 'RUNNER_UP', weight: 10 },
        { result: 'BEST_4', weight: 20 },   { result: 'BEST_8', weight: 30 },
        { result: 'BEST_16', weight: 20 },  { result: 'ROUND_2', weight: 10 },
        { result: 'ROUND_1', weight: 5 }
    ],
    'C': [
        { result: 'CHAMPION', weight: 1 },  { result: 'RUNNER_UP', weight: 3 },
        { result: 'BEST_4', weight: 8 },    { result: 'BEST_8', weight: 20 },
        { result: 'BEST_16', weight: 30 },  { result: 'ROUND_2', weight: 28 },
        { result: 'ROUND_1', weight: 10 }
    ],
    'D': [
        { result: 'BEST_8', weight: 5 },    { result: 'BEST_16', weight: 15 },
        { result: 'ROUND_2', weight: 40 },  { result: 'ROUND_1', weight: 40 }
    ],
    'E': [
        { result: 'BEST_16', weight: 5 },   { result: 'ROUND_2', weight: 25 },
        { result: 'ROUND_1', weight: 70 }
    ],
};

/**
 * チームランクに基づき、甲子園での成績を確率で決定する
 * @param {string} teamRank - 'A'から'E'までのチームランク
 * @returns {string} - KOSHIEN_RESULTSのキー ('CHAMPION', 'BEST_8'など)
 */
function simulateKoshien(teamRank) {
    const probabilities = KOSHIEN_PROBABILITIES[teamRank] || KOSHIEN_PROBABILITIES['E'];
    const totalWeight = probabilities.reduce((sum, p) => sum + p.weight, 0);
    let random = Math.random() * totalWeight;

    for (const prob of probabilities) {
        if (random < prob.weight) {
            return prob.result;
        }
        random -= prob.weight;
    }
    return 'ROUND_1'; // フォールバック
}
   
 /**
     * 試合IDを元に、stateオブジェクトの深い階層から試合オブジェクトを検索して返す
     * (★全大会128チーム制統一に伴い、tournamentState.matches のみ検索するよう修正)
     */
    function findMatchById(matchId) {
        // 全ての試合は tournamentState.matches に保存される
        if (tournamentState.matches && tournamentState.matches[matchId]) {
            return tournamentState.matches[matchId];
        }
        
        // ★ 廃止された autumnData, springData への参照を削除 ★
        
        return null; // どこにも見つからなかった場合
    }
// ▲▲▲ 置き換えここまで ▲▲▲

// ▼▼▼ スカウト機能ロジック (厳格化・人数制限版) ▼▼▼

// スカウトボタンのイベント
document.getElementById('show-scout-report-btn').addEventListener('click', () => {
    generateScoutReport();
    document.getElementById('scout-report-modal').classList.remove('hidden');
    document.getElementById('scout-report-modal').classList.add('flex');
});

document.getElementById('scout-report-close-btn').addEventListener('click', () => {
    document.getElementById('scout-report-modal').classList.add('hidden');
    document.getElementById('scout-report-modal').classList.remove('flex');
});

/**
 * 全チームの選手をスキャンし、有力選手を厳選して表示する
 */
function generateScoutReport() {
    const container = document.getElementById('scout-report-content');
    container.innerHTML = '<div class="loader">スカウトが有望株を厳選中...</div>';

    const batterCandidates = [];
    const pitcherCandidates = [];

    // 1. 全チームを走査して候補を収集
    Object.keys(tournamentState.teamRecords).forEach(teamName => {
        const record = tournamentState.teamRecords[teamName];
        if (!record.playerStats) return;

        // 打者評価
        if (record.playerStats.batting) {
            Object.entries(record.playerStats.batting).forEach(([name, stats]) => {
                // 【修正】最低ラインを15打数に引き上げ
                if (stats.ab >= 15) {
                    const grade = calculateBatterGrade(stats);
                    // 【修正】Cランク以下は足切り（Bランク以上のみ候補へ）
                    // ※ただしSランクが少なすぎる場合に備えて、一旦全員計算して後でソート・カットする方式に変更
                    if (grade.rankValue >= 3) { 
                        batterCandidates.push({
                            type: 'batter', name: name, team: teamName,
                            rank: grade.rank, rankValue: grade.rankValue,
                            stats: stats, comment: grade.comment,
                            sortKey: calculateOps(stats) // OPSでソート用
                        });
                    }
                }
            });
        }

        // 投手評価
        if (record.playerStats.pitching) {
            Object.entries(record.playerStats.pitching).forEach(([name, stats]) => {
                const career = stats.career;
                // 【修正】最低ラインを10回に引き上げ
                if (career && career.ip >= 10) {
                    const grade = calculatePitcherGrade(career);
                    if (grade.rankValue >= 3) {
                        pitcherCandidates.push({
                            type: 'pitcher', name: name, team: teamName,
                            rank: grade.rank, rankValue: grade.rankValue,
                            stats: career, comment: grade.comment,
                            sortKey: ((career.er * 9) / career.ip) * -1 // 防御率が低いほど偉い（降順ソート用にマイナス化）
                        });
                    }
                }
            });
        }
    });

    // 2. ソート（ランクが高い順 > 成績が良い順）
    batterCandidates.sort((a, b) => {
        if (b.rankValue !== a.rankValue) return b.rankValue - a.rankValue;
        return parseFloat(b.sortKey) - parseFloat(a.sortKey);
    });
    
    pitcherCandidates.sort((a, b) => {
        if (b.rankValue !== a.rankValue) return b.rankValue - a.rankValue;
        return parseFloat(b.sortKey) - parseFloat(a.sortKey);
    });

    // 3. 【修正】表示人数を制限（各トップ10名まで）
    const topBatters = batterCandidates.slice(0, 10);
    const topPitchers = pitcherCandidates.slice(0, 10);

    // 4. HTML生成
    let html = '';
    
    if (topBatters.length === 0 && topPitchers.length === 0) {
        html = `
            <div class="text-center py-10">
                <p class="text-gray-500 text-xl">「まだ眼鏡に適う選手はおらんようだな...」</p>
                <p class="text-sm text-gray-400 mt-2">※試合数が進むと候補が現れます</p>
            </div>`;
    } else {
        // ドラフト1位候補 (Sランク) がいれば特別表示
        const sRankBatters = topBatters.filter(c => c.rank === 'S');
        const sRankPitchers = topPitchers.filter(c => c.rank === 'S');
        const sRanks = [...sRankBatters, ...sRankPitchers];

        if (sRanks.length > 0) {
            html += `<div class="mb-8 border-4 border-yellow-400 bg-yellow-50 p-4 rounded-lg">
                <h4 class="text-2xl font-bold text-amber-700 mb-4 text-center">👑 今大会の超目玉 (ドラフト1位候補)</h4>
                ${renderCandidateList(sRanks)}
            </div>`;
        }

        // 野手リスト
        if (topBatters.length > 0) {
            html += `<h4 class="text-xl font-bold text-blue-800 mb-2 border-b-2 border-blue-800 pb-1">野手 注目選手 (TOP ${topBatters.length})</h4>`;
            html += renderCandidateList(topBatters);
        }

        // 投手リスト
        if (topPitchers.length > 0) {
            html += `<h4 class="text-xl font-bold text-red-800 mb-2 mt-8 border-b-2 border-red-800 pb-1">投手 注目選手 (TOP ${topPitchers.length})</h4>`;
            html += renderCandidateList(topPitchers);
        }
    }

    container.innerHTML = html;
}

/**
 * 候補者リストのHTMLを生成するヘルパー
 */
function renderCandidateList(list) {
    return list.map(c => {
        let statsStr = '';
        let highlightClass = '';
        
        if (c.type === 'batter') {
            const avg = (c.stats.h / c.stats.ab).toFixed(3);
            const ops = calculateOps(c.stats);
            statsStr = `打率${avg} / ${c.stats.hr}本 / ${c.stats.sb}盗 / ${c.stats.rbi}打点 / OPS ${ops}`;
            // Sランク級の成績なら文字色を変える
            if (c.rank === 'S') highlightClass = 'text-amber-700 font-bold';
        } else {
            const era = c.stats.er > 0 ? ((c.stats.er * 9) / c.stats.ip).toFixed(2) : "0.00";
            const k9 = ((c.stats.so * 9) / c.stats.ip).toFixed(2);
            statsStr = `防御率${era} / ${c.stats.w}勝 / 奪三振${c.stats.so} (K/9: ${k9})`;
            if (c.rank === 'S') highlightClass = 'text-amber-700 font-bold';
        }

        return `
        <div class="scout-card rank-${c.rank} mb-2">
            <div class="flex items-center w-full">
                <div class="scout-rank-badge rank-bg-${c.rank}">${c.rank}</div>
                <div class="flex-grow">
                    <div class="flex justify-between items-baseline">
                        <div class="flex items-baseline gap-2">
                            <h5 class="text-lg font-bold text-gray-900">${c.name}</h5>
                            <span class="text-xs text-white bg-gray-500 px-2 py-0.5 rounded">${c.team}</span>
                        </div>
                    </div>
                    <div class="text-sm font-mono mt-1 ${highlightClass}">${statsStr}</div>
                    <div class="scout-comment-box text-xs mt-1">📝 ${c.comment}</div>
                </div>
            </div>
        </div>
        `;
    }).join('');
}

/**
 * 打者のランク判定ロジック (厳格化)
 */
function calculateBatterGrade(stats) {
    const avg = stats.h / stats.ab;
    const ops = parseFloat(calculateOps(stats));
    let rank = 'C';
    let rankValue = 3;
    let comment = "一定の力はある。将来性に期待。";

    // Sランク: 圧倒的な成績 (5割超え、または本塁打量産)
    if (stats.hr >= 5 || (avg >= 0.600 && stats.hr >= 3) || ops >= 1.800) {
        rank = 'S'; rankValue = 6;
        comment = "【ドラ1確定】高校生離れしたスイング。プロでも即中軸を打てる逸材。";
    } 
    // Aランク: 超高校級 (4割5分超え、OPS 1.4以上)
    else if (stats.hr >= 3 || avg >= 0.500 || (stats.sb >= 10 && avg >= 0.400) || ops >= 1.400) {
        rank = 'A'; rankValue = 5;
        comment = "【上位指名】走攻守揃った好素材。即戦力として期待できる。";
    } 
    // Bランク: 強豪校の主力レベル (4割超え)
    else if (avg >= 0.400 || stats.hr >= 2 || (stats.sb >= 6 && avg >= 0.300)) {
        rank = 'B'; rankValue = 4;
        comment = "【注目】キラリと光る武器がある。下位指名リストに入るか。";
    } 
    
    return { rank, rankValue, comment };
}

/**
 * 投手のランク判定ロジック (厳格化)
 */
function calculatePitcherGrade(stats) {
    const era = (stats.er * 9) / stats.ip;
    const k9 = (stats.so * 9) / stats.ip;
    let rank = 'C';
    let rankValue = 3;
    let comment = "制球力に課題を残すが、球威はある。";

    // Sランク: 支配的な投球 (防御率0点台 & 奪三振率12.0以上)
    if ((era <= 1.00 && k9 >= 12.0 && stats.ip >= 15) || (stats.so >= 50)) {
        rank = 'S'; rankValue = 6;
        comment = "【ドラ1確定】完成度はプロ顔負け。直球の回転数が素晴らしく、即ローテ入り確実。";
    } 
    // Aランク: エース級 (防御率2.00以下 & 奪三振率9.0以上)
    else if ((era <= 2.00 && k9 >= 9.0) || (stats.w >= 5)) {
        rank = 'A'; rankValue = 5;
        comment = "【上位指名】ピンチに動じないマウンド度胸。変化球のキレも一級品。";
    } 
    // Bランク: 好投手 (防御率3.00以下)
    else if (era <= 3.00 || k9 >= 8.0) {
        rank = 'B'; rankValue = 4;
        comment = "【注目】素材型の投手としてリストアップ。体が出来上がれば化ける。";
    } 
    
    return { rank, rankValue, comment };
}

// OPS計算ヘルパー (変更なし)
function calculateOps(stats) {
    const obp = (stats.ab + stats.bb + stats.hbp + stats.sf) > 0 ? (stats.h + stats.bb + stats.hbp) / (stats.ab + stats.bb + stats.hbp + stats.sf) : 0;
    const slg = stats.ab > 0 ? (stats.tb || stats.h) / stats.ab : 0; 
    return (obp + slg).toFixed(3);
}
// ▲▲▲ スカウト機能ここまで ▲▲▲

/**
 * チームの今大会の勝ち上がりを「〇〇回戦 vs △△」のように要約するヘルパー関数
 */
function getTournamentPathSummary(teamName, currentMatchId) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord) return "今大会初戦。";

    const path = [];
    const currentTournamentMatchIds = Object.keys(tournamentState.matches);

    for (const matchId of currentTournamentMatchIds) {
        if (matchId === currentMatchId) continue;
        const match = tournamentState.matches[matchId];
        
        if (match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            const opponent = match.team1 === teamName ? match.team2 : teamName;
            const roundName = getRoundNameFromMatchId(matchId);
            
            if (match.winner === teamName) {
                path.push(`${roundName} vs ${opponent}`);
            }
        }
    }
    
    return path.length === 0 ? "今大会初戦。" : `ここまでの勝ち上がり: ${path.join(' → ')}。`;
}

/**
 * [UPDATED] 試合IDからラウンド名を取得するヘルパー関数
 * (★チーム数に応じて「準決勝」などのラウンド番号を動的に判定)
 */
function getRoundNameFromMatchId(matchId) {
    if (!matchId) return "不明なラウンド";

    // 決勝戦
    if (matchId.startsWith('F-R1-')) {
        return "決勝";
    }
    
    if (!matchId.includes('-R')) {
         return "不明なラウンド";
    }
    
    const roundNum = parseInt(matchId.split('-')[1].slice(1));
    
    // ★★★ 修正箇所: チーム数から総ラウンド数を計算 ★★★
    const numTeams = tournamentState.teams.length; 
    const finalRound = Math.log2(numTeams); // 128チーム→7, 64チーム→6
    
    const roundNameMap = { 
        [finalRound]: '決勝',
        [finalRound-1]: '準決勝',   
        [finalRound-2]: '準々決勝', 
        [finalRound-3]: '4回戦'     
    };
    // ★★★ 修正ここまで ★★★
    
    return roundNameMap[roundNum] || `${roundNum}回戦`;
}
// ▲▲▲ 置き換えここまで ▲▲▲

// --- Team Rank Calculation (Reality-Adjusted Version) ---
    
/**
 * 2チーム間の因縁対決を判定し、フラグを返す（タグ機能不要版）
 * @param {string} team1Name - チーム1の名前
 * @param {string} team2Name - チーム2の名前
 * @returns {string | null} - 因縁のタイプ（例: "283直接対決"）、なければ null
 */
function checkRivalry(team1Name, team2Name) {
    if (!team1Name || !team2Name) return null;

    const data1 = TEAM_DATA[team1Name];
    const data2 = TEAM_DATA[team2Name];
    if (!data1 || !data2) return null;

    // 1. 283学園 vs 283学園B
    if ((team1Name === "283学園" && team2Name === "283学園B") || (team1Name === "283学園B" && team2Name === "283学園")) {
        return "283直接対決";
    }

    // ▼▼▼ 修正点 ▼▼▼
    // 2. ナムコ系列ダービー (タグの代わりに、ここでリストを直接定義)
    const namcoSchools = ["765総合高校", "283学園", "初星学園", "美城学園", "283学園B"];
    if (namcoSchools.includes(team1Name) && namcoSchools.includes(team2Name)) {
        return "ナムコダービー";
    }
    // ▲▲▲ 修正ここまで ▲▲▲

    // 3. 同地区の強豪対決 (Aランク vs Aランク or Aランク vs Bランク)
    if (data1.region === data2.region) {
        const rank1 = calculateRank(team1Name, tournamentState);
        const rank2 = calculateRank(team2Name, tournamentState);
        if ((rank1 === 'A' && rank2 === 'A') || (rank1 === 'A' && rank2 === 'B') || (rank1 === 'B' && rank2 === 'A')) {
            return `同地区強豪対決 (${data1.region})`;
        }
    }

    return null; // その他の因縁はなし
}

/**
 * 指定されたラウンドの全試合に日付と球場を割り当てる
 * @param {Array<string>} matchIds - スケジュールを割り当てる試合IDの配列
 * @param {Array<string>} dates - 使用する日付の配列 (例: ["7/10", "7/11"])
 * @param {Array<object>} stadiumList - 使用する球場のリスト (例: STADIUM_DATA)
 * @param {number} gamesPerDayPerStadium - 1球場・1日あたりの最大試合数
 */
function scheduleRoundMatches(matchIds, dates, stadiumList, gamesPerDayPerStadium) {
    if (!matchIds || matchIds.length === 0) return;

    let scheduleQueue = []; // [ { stadium, date, gameNum: 1 }, { stadium, date, gameNum: 2 }, ... ]
    
    // 全ての日付と球場で、開催可能な全スロットを作成
    for (const date of dates) {
        for (const stadium of stadiumList) {
            for (let i = 1; i <= gamesPerDayPerStadium; i++) {
                scheduleQueue.push({
                    date: date,
                    stadium: stadium.abbr, // 略称を保存
                    stadiumFull: stadium.name,
                    gameNum: i // 試合順 (①, ②, ...)
                });
            }
        }
    }

    // 試合IDにスケジュールを割り当て
    matchIds.forEach((matchId, index) => {
        const match = findMatchById(matchId);
        if (match && scheduleQueue[index]) { // スロットが足りる限り割り当て
            const schedule = scheduleQueue[index];
            match.schedule = {
                date: schedule.date,
                stadium: schedule.stadium,
                stadiumFull: schedule.stadiumFull,
                game: schedule.gameNum
            };
        } else if (match) {
            // スロットが足りなかった場合のフォールバック
            match.schedule = { date: dates[0], stadium: stadiumList[0].abbr, game: 1 };
        }
    });
}

/**
 * [NEW] チームのランクスコアを計算する（シミュレーション用）
 * @param {string} teamName - チーム名
 * @param {number} hypotheticalFinish - 仮定する最終順位 (1, 2, 4, 8, 16, 32, 64)
 * @returns {number} - ランクスコア
 */
function calculateScore(teamName, hypotheticalFinish) {
    const teamData = TEAM_DATA[teamName];
    if (!teamData) return 0;

    let score = 0;
    
    // 1. 基礎能力 (偏差値)
    score += (teamData.deviation || 50) * 0.5;

    // 2. 過去の最高成績ボーナス (文字情報)
    const bestStr = teamData.best || '';
    if (bestStr.includes('優勝') && bestStr.includes('甲子園')) score += 40;
    else if (bestStr.includes('優勝')) score += 25;
    else if (bestStr.includes('準優勝')) score += 20;
    else if (bestStr.includes('ベスト4')) score += 15;
    else if (bestStr.includes('出場')) score += 10;
    else if (bestStr.includes('ベスト8')) score += 10;
    else if (bestStr.includes('ベスト16')) score += 5;

    // 3. 直近成績ボーナス (シミュレーション値)
    // (甲子園成績はマイナス値ですが、ここでは県大会の昇格降格に絞ってプラス値で計算します)
    if (hypotheticalFinish === 1) score += 20;       // 優勝
    else if (hypotheticalFinish === 2) score += 15;  // 準優勝
    else if (hypotheticalFinish <= 4) score += 10;   // ベスト4
    else if (hypotheticalFinish <= 8) score += 5;    // ベスト8
    else if (hypotheticalFinish <= 16) score += 2;   // ベスト16
    else if (hypotheticalFinish >= 64) score -= 5;   // 初戦敗退ペナルティ

    // 4. 人気補正
    if (teamData.popularity) score += 5;

    return score;
}

/**
 * [NEW] スコアからランク(A~E)を判定する
 */
function getRankChar(score) {
    if (score >= 60) return 'A';
    if (score >= 50) return 'B';
    if (score >= 40) return 'C';
    if (score >= 30) return 'D';
    return 'E';
}

/**
 * [UPDATED] ランク変動予測テキストを生成する
 * (★4回戦(ベスト16)を含む、全ラウンドの昇格・降格分岐を完全網羅した修正版)
 */
function predictRankChanges(teamName) {
    const currentRank = calculateRank(teamName, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    const currentRankVal = rankValues[currentRank];
    
    let rankUpMsg = "";
    let rankDownMsg = "";

    // --- 1. ランクアップ条件を探す (下から順にチェック) ---
    // チェック順位: 32(3回戦), 16(4回戦/ベスト16), 8(準々), 4(準決), 2(決勝), 1(優勝)
    if (currentRank !== 'A') {
        const upMilestones = [32, 16, 8, 4, 2, 1]; 
        let upFound = false;
        
        for (const finish of upMilestones) {
            const score = calculateScore(teamName, finish);
            const projectedRank = getRankChar(score);
            
            // 現在のランクより上がる場合
            if (rankValues[projectedRank] > currentRankVal) {
                let condition = "";
                if (finish === 1) condition = "優勝";
                else if (finish === 2) condition = "決勝";     // 準優勝
                else if (finish === 4) condition = "ベスト4";  // 準決勝進出
                else if (finish === 8) condition = "ベスト8";  // 準々決勝進出
                else if (finish === 16) condition = "ベスト16"; // 4回戦進出
                else if (finish === 32) condition = "3回戦";   // 3回戦進出 (ベスト32)

                rankUpMsg = `🔥 <strong>${condition}</strong> 進出で <strong>ランク${projectedRank}</strong> へ昇格！`;
                upFound = true;
                break; // 最初に見つかった「最も低いハードル（最短目標）」を表示して終了
            }
        }
        
        if (!upFound) {
            rankUpMsg = `<span class="text-gray-500">（優勝しても次回の昇格圏内には届きません）</span>`;
        }
    } else {
        rankUpMsg = `<span class="text-amber-600 font-bold">👑 現在 最高ランク到達中</span>`;
    }

    // --- 2. ランクダウン危険性を探す (下から順にチェック) ---
    // チェック順位（悪い順）: 64(1/2回戦), 32(3回戦), 16(4回戦), 8(準々), 4(準決), 2(決勝)
    if (currentRank !== 'E') {
        const downMilestones = [64, 32, 16, 8, 4, 2];
        let downFound = false;

        for (const finish of downMilestones) {
            const score = calculateScore(teamName, finish);
            const projectedRank = getRankChar(score);
            
            // 現在のランクより下がる場合
            if (rankValues[projectedRank] < currentRankVal) {
                let lossStage = "";
                if (finish === 64) lossStage = "初戦(1･2回戦)敗退";
                else if (finish === 32) lossStage = "3回戦敗退";
                else if (finish === 16) lossStage = "4回戦(ベスト16)敗退"; // ★ここを追加・修正
                else if (finish === 8) lossStage = "準々決勝敗退"; // ベスト8止まり
                else if (finish === 4) lossStage = "準決勝敗退";   // ベスト4止まり
                else if (finish === 2) lossStage = "決勝敗退";     // 準優勝止まり

                rankDownMsg = `⚠️ <strong>${lossStage}</strong> すると <strong>ランク${projectedRank}</strong> へ降格...`;
                downFound = true;
                break; // 最初に見つかった「最も低いハードル（最も早い段階での降格）」を表示して終了
            }
        }

        if (!downFound) {
             rankDownMsg = `<span class="text-blue-600 font-bold">🛡️ ランク維持圏内</span>`;
        }
    } else {
        rankDownMsg = `<span class="text-gray-400">（これ以上の降格はありません）</span>`;
    }

    return { up: rankUpMsg, down: rankDownMsg };
}
/**
 * [FIXED] チームランクを計算する
 * (★甲子園成績(マイナス値)を正しく評価するように修正)
 */
function calculateRank(teamName, state) {
    if (!teamName) return '';

    const teamData = TEAM_DATA[teamName];
    if (!teamData) {
        return 'E';
    }

    let score = 0;
    score += (teamData.deviation || 50) * 0.5;

    // 2. 過去の最高成績ボーナス (文字情報)
    const bestStr = teamData.best || '';
    if (bestStr.includes('優勝') && bestStr.includes('甲子園')) score += 40;
    else if (bestStr.includes('優勝')) score += 25;
    else if (bestStr.includes('準優勝')) score += 20;
    else if (bestStr.includes('ベスト4')) score += 15;
    else if (bestStr.includes('出場')) score += 10;
    else if (bestStr.includes('ベスト8')) score += 10;
    else if (bestStr.includes('ベスト16')) score += 5;

    // 3. 直近の成績ボーナス (数値情報)
    if (state.teamRecords && state.teamRecords[teamName]) {
        const lastFinish = state.teamRecords[teamName].lastFinish;
        
        // ★ 甲子園成績 (マイナス値: -1が最強、-64が最弱)
        // -1 > -2 > -4 > -8 ... なので、大きい方が成績が良い
        if (lastFinish < 0) {
            if (lastFinish === -1) score += 50;      // 全国優勝
            else if (lastFinish === -2) score += 45; // 全国準優勝
            else if (lastFinish >= -4) score += 40;  // ベスト4
            else if (lastFinish >= -8) score += 35;  // ベスト8
            else if (lastFinish >= -16) score += 30; // ベスト16
            else if (lastFinish >= -32) score += 25; // 2回戦
            else score += 20;                        // 初戦敗退でも甲子園出場ボーナス
        }
        // ★ 県大会成績 (プラス値: 1が最強、64が最弱)
        else {
            if (lastFinish === 1) score += 20;       // 県優勝
            else if (lastFinish === 2) score += 15;
            else if (lastFinish <= 4) score += 10;
            else if (lastFinish <= 8) score += 5;
            else if (lastFinish <= 16) score += 2;
            else if (lastFinish >= 64) score -= 5;   // 初戦敗退ペナルティ
        }
    }

    if (teamData.popularity) score += 5;

    if (score >= 60) return 'A';
    if (score >= 50) return 'B';
    if (score >= 40) return 'C';
    if (score >= 30) return 'D';
    return 'E';
}



/**
 * [UPDATED] 指定されたブロックのアニメーションを再生する
 * (★チーム数に応じてラウンド数を動的に調整)
 */
async function playBlockAnimation(blockId) {
    // タブUIの更新
    document.querySelectorAll('.analysis-block-tab-btn').forEach(btn => {
        const isActive = btn.dataset.block === blockId;
        btn.classList.toggle('bg-cyan-500', isActive);
        btn.classList.toggle('text-white', isActive);
        btn.classList.toggle('bg-gray-700', !isActive);
        btn.classList.toggle('text-gray-400', !isActive);
    });

    const stage = document.getElementById('analysis-stage');
    const narrationTextEl = document.getElementById('analysis-narration-text');
    const analysisData = tournamentState.blockAnalysisData;

    if (!analysisData || !analysisData[blockId]) {
        stage.innerHTML = `<p class="text-center text-gray-500">分析データを読み込めませんでした。</p>`;
        narrationTextEl.textContent = '';
        return;
    }
    const narration = analysisData[blockId];
    
    // ★★★ 修正箇所: ブロックサイズとチーム抽出 ★★★
    const numBlocks = 4;
    const blockSize = Math.ceil(tournamentState.teams.length / numBlocks); // 128->32, 64->16
    const blockIndex = blockId.charCodeAt(0) - 65; // A=0, B=1...
    const blockTeams = tournamentState.teams.slice(
        blockIndex * blockSize, 
        (blockIndex + 1) * blockSize
    );
    // ★★★ 修正ここまで ★★★

    stage.innerHTML = '';
    narrationTextEl.textContent = '';
    
    // ★★★ 修正箇所: ラウンドカラムの生成 ★★★
    const numRoundsInBlock = Math.log2(blockSize); // 32->5, 16->4
    
    for (let i = 1; i <= numRoundsInBlock; i++) {
        const col = document.createElement('div');
        col.id = `r${i}-col`;
        col.className = 'round-column';
        stage.appendChild(col);
    }
    // ★★★ 修正ここまで ★★★

    // 1回戦の描画 (チームペア)
    const numMatchupsR1 = blockSize / 2;
    for(let i = 0; i < numMatchupsR1; i++) { 
        const matchupEl = document.createElement('div');
        matchupEl.className = 'analysis-matchup';
        // チーム名がある場合のみ表示、足りない場合は???
        const t1 = blockTeams[i*2] || '???';
        const t2 = blockTeams[i*2+1] || '???';
        
        matchupEl.innerHTML = `
            <div class="analysis-team" data-team-name="${t1}">${t1}</div>
            <div class="analysis-team" data-team-name="${t2}">${t2}</div>
            <div class="matchup-connector"></div>
        `;
        stage.querySelector('#r1-col').appendChild(matchupEl);
    }
    
    // 2回戦以降の描画 (空の箱)
    for (let r = 2; r <= numRoundsInBlock; r++) {
        const col = stage.querySelector(`#r${r}-col`);
        const numMatchups = blockSize / Math.pow(2, r);
        for(let i = 0; i < numMatchups; i++) {
            const isLast = r === numRoundsInBlock;
            col.innerHTML += `<div class="analysis-matchup"><div class="analysis-team">???</div>${isLast ? '' : '<div class="analysis-team">???</div><div class="matchup-connector"></div>'}<div class="round-connector"></div></div>`; 
        }
    }

    await new Promise(r => setTimeout(r, 100));
    document.querySelectorAll('.analysis-team').forEach((el, i) => {
        setTimeout(() => el.classList.add('show'), i * 30);
    });

    // ナレーションのタイプライター表示
    for (let i = 0; i < narration.length; i++) {
        narrationTextEl.textContent += narration[i];
        await new Promise(r => setTimeout(r, 30));
    }
    
    // 注目チームのハイライト
    blockTeams.forEach(team => {
        if (narration.includes(team)) {
            document.querySelectorAll(`.analysis-team[data-team-name="${team}"]`).forEach(el => {
                el.classList.add('highlight');
            });
        }
    });
}

// ▲▲▲ 置き換えここまで ▲▲▲
// ▼▼▼ この関数をまるごと追加してください ▼▼▼
/**
 * [UPDATED] AIに各ブロックの勢力図を分析させ、ナレーション原稿を生成させる
 * (★チーム数に応じてブロックサイズを動的に計算)
 */
async function generateBlockAnalysisArticle(state) {
    const { teams, seeds } = state;
    const blocks = { A: [], B: [], C: [], D: [] };

    // ★★★ 修正箇所: ブロックサイズ ★★★
    const numBlocks = 4;
    const blockSize = Math.ceil(teams.length / numBlocks); 
    // ★★★ 修正ここまで ★★★

    teams.forEach((team, i) => {
        if (i < blockSize) blocks.A.push(team); 
        else if (i < blockSize * 2) blocks.B.push(team); 
        else if (i < blockSize * 3) blocks.C.push(team); 
        else blocks.D.push(team); 
    });

    // (以下、既存のプロンプト生成ロジックは変更なし)
    const blockAnalysisData = {};
    for (const blockId in blocks) {
        const blockTeams = blocks[blockId];
        const teamDetails = blockTeams.map(teamName => {
            const rank = calculateRank(teamName, state);
            const isSeed = seeds.some(s => s.team === teamName);
            const teamData = TEAM_DATA[teamName];
            if (isSeed || ['A', 'B'].includes(rank)) {
                const info = teamData?.info || '';
                return `${teamName}(${rank}${isSeed ? 'S' : ''}) [背景: ${info.substring(0, 40)}...]`;
            } else {
                return `${teamName}(${rank})`;
            }
        }).join(', ');
        blockAnalysisData[blockId] = teamDetails;
    }

    const prompt = `あなたは高校野球の解説者です。以下の各ブロックのチームリストを分析し、それぞれの見どころを**150字程度**のナレーション原稿にまとめてください。

### 分析対象ブロック (チーム名とランク、Sはシード校、[]内は注目校の背景情報)
- **Aブロック:** ${blockAnalysisData.A}
- **Bブロック:** ${blockAnalysisData.B}
- **Cブロック:** ${blockAnalysisData.C}
- **Dブロック:** ${blockAnalysisData.D}

### 指示
- **物語を重視:** [背景]情報が提供されている注目校を中心に、そのチームが持つ物語や背景に触れながら解説してください。
- **簡潔に:** 全体のナレーションは150字程度に収めてください。
- 最も激戦区だと思われる「死のブロック」を特定してください。

### 出力形式 (JSON)
{
  "A": "（Aブロックのナレーション）",
  "B": "（Bブロックのナレーション）",
  "C": "（Cブロックのナレーション）",
  "D": "（Dブロックのナレーション）"
}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        return parseJsonFromText(result.candidates[0].content.parts[0].text);
    } catch (error) {
        console.error("AIブロック分析記事の生成に失敗:", error);
        return null;
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲
   

// ▼▼▼ この関数を「新規追加」(10400行目あたり、createNewTournament の直前) ▼▼▼

/**
 * [NEW] 128チーム制トーナメントの「(BYE)」(不戦勝)を自動処理する
 */
function processByes(state) {
    const r1MatchIds = Object.keys(state.matches).filter(id => id.includes('-R1-'));
    let byesProcessed = 0;

    r1MatchIds.forEach(matchId => {
        const match = state.matches[matchId];
        if (match.winner) return; // 既に処理済み

        const team1 = match.team1;
        const team2 = match.team2;
        let winnerName = null;

        if (team1 === '(BYE)' && team2 !== '(BYE)') {
            winnerName = team2;
        } else if (team2 === '(BYE)' && team1 !== '(BYE)') {
            winnerName = team1;
        } else if (team1 === '(BYE)' && team2 === '(BYE)') {
            // 両方BYE (ありえないはずだが、念のため)
            match.winner = '(BYE)'; // 勝者もBYE
            winnerName = '(BYE)';
        }

        if (winnerName) {
            byesProcessed++;
            match.winner = winnerName;
            match.summary = "不戦勝";
            
            // 次のラウンドに進める
            const idParts = matchId.split('-');
            const side = idParts[0]; // 'L' or 'R'
            const matchNum = parseInt(idParts[2].slice(1)); // 1-32
            
            const nextRoundNum = 2; // R2
            const nextMatchId = `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
            const nextMatch = state.matches[nextMatchId];
            
            if (nextMatch) {
                const slot = (matchNum % 2 !== 0 ? 1 : 2); // 奇数ならteam1, 偶数ならteam2
                nextMatch[`team${slot}`] = winnerName;
            }
        }
    });

    if (byesProcessed > 0) {
        console.log(`${byesProcessed}件の不戦勝(BYE)を自動処理しました。`);
        // BYE処理後にトーナメント表を再描画
        renderTournament(state);
        saveState();
    }
}
// ▲▲▲ 新規追加ここまで ▲▲▲

/**
 * 新しいトーナメントを開始するメイン関数
 * (★BYE 16枠固定配置、★R2-R4球場シャッフル に対応した最終版)
 */
async function createNewTournament(isNext = false, nextTournamentType = 'summer', predeterminedTeams = null) {
    setupEl.classList.add('hidden');
    tournamentDisplayEl.classList.remove('hidden');

    if (tournamentState.teamRecords) {
        for (const teamName in tournamentState.teamRecords) {
            const record = tournamentState.teamRecords[teamName];
            record.tournamentStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, r: 0, so: 0 };
        }
    }
    
    autumnControls.classList.add('hidden');
    startMainTournamentBtn.classList.add('hidden');
    startRankingPlayoffsBtn.classList.add('hidden');

    if (isNext && tournamentState.teamRecords) {
        for (const teamName in tournamentState.teamRecords) {
            if (tournamentState.teamRecords.hasOwnProperty(teamName)) {
                const record = tournamentState.teamRecords[teamName];
                record.previousRank = record.lastFinish;
                record.wins = 0;
                record.losses = 0;
            }
        }
    }
    
    mainBracketWrapper.classList.remove('hidden');
    tournamentState.is16team = false;
    tournamentState.currentTournament = nextTournamentType;
    
    const numTeamsInTournament = 128;
    const finalRound = 7;

    if (isNext) { 
        if (nextTournamentType === 'summer') {
            tournamentState.tournamentYear++;
        }
    }
    
    if (!isNext) { 
        tournamentState.tournamentYear = 2025;
        tournamentState.teamRecords = {};
        const initialAiEnabled = document.getElementById('initial-ai-generation-toggle').checked;
        tournamentState.settings = { 
            enableArticleGeneration: initialAiEnabled, 
            enableBbsGeneration: initialAiEnabled 
        };
        tournamentState.homepageNews = []; 
        INITIAL_TEAM_POOL.forEach(t => {
            const historicalRank = getRankFromHistoryString(TEAM_DATA[t].last);
            tournamentState.teamRecords[t] = { 
                wins: 0, losses: 0, best: null, history: [],
                lastFinish: historicalRank, 
                previousRank: null,
                teamTraits: [], 
                previousStarters: null,
                roster: null,
                playerStats: { batting: {}, pitching: {} },
                tournamentStats: { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, r: 0, so: 0 } 
            };
        });
    }
    
    let teams;
    let seeds = [];

    // (シード校の決定ロジックは変更なし)
    if (isNext) { 
        const lastTournamentTeams = Object.keys(tournamentState.teamRecords)
            .map(teamName => ({ name: teamName, ...tournamentState.teamRecords[teamName] }))
            .sort((a, b) => a.lastFinish - b.lastFinish); 
        seeds = lastTournamentTeams.slice(0, 8).map((t, i) => ({ team: t.name, rank: i + 1 })); 
    } else { 
        const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
        const setInitialSeedRank = (teamName) => {
            if (teamName === '283学園') return 1; if (teamName === '常葉菊川') return 2;
            if (teamName === '静岡') return 3; if (teamName === '掛川西') return 4;
            const rank = historicalRanks.find(hr => hr.name === teamName)?.rank || 128;
            if (rank === 8) return 8; return rank;
        };
        const adjustedHistoricalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: setInitialSeedRank(teamName) }));
        adjustedHistoricalRanks.sort((a, b) => a.rank - b.rank);
        seeds = adjustedHistoricalRanks.slice(0, 8).map((t, i) => ({ team: t.name, rank: i + 1 }));
    }
    
    // (組み合わせの決定)
    if (predeterminedTeams) {
        teams = predeterminedTeams;
    } else {
        const seedTeamsList = seeds.map(s => s.team);
        
        // ★★★ [NEW] 112校選抜 + 16BYE固定配置ロジック ★★★
        
        // 1. 全チーム(112校)からシード(8校)を除く
        let nonSeeds = INITIAL_TEAM_POOL.filter(t => !seedTeamsList.includes(t)); // 104校
        nonSeeds = shuffleArray(nonSeeds);
        
        teams = Array(numTeamsInTournament).fill(null); // 128スロット
        
        // 2. シード校（8校）を固定配置 (各16チームブロックの先頭)
        const seedPositions = [0, 16, 32, 48, 64, 80, 96, 112]; 
        
        const seedPlacements = {};
        const rank1_4 = seeds.filter(s => s.rank <= 4).sort((a, b) => a.rank - b.rank);
        seedPlacements[seedPositions[0]] = rank1_4.find(s => s.rank === 1).team; // A (0)
        seedPlacements[seedPositions[4]] = rank1_4.find(s => s.rank === 2).team; // C (64)
        seedPlacements[seedPositions[2]] = rank1_4.find(s => s.rank === 4).team; // B (32)
        seedPlacements[seedPositions[6]] = rank1_4.find(s => s.rank === 3).team; // D (96)
        const rank5_8 = shuffleArray(seeds.filter(s => s.rank > 4));
        const remainingSeedSlots = [16, 80, 48, 112]; // 残りのシード枠
        rank5_8.forEach((seed, i) => { seedPlacements[remainingSeedSlots[i]] = seed.team; });
        for (const position in seedPlacements) { teams[position] = seedPlacements[position]; }

        // 3. BYE（16校）を固定配置
        // (各16チームブロックのシード校がいない山に2つずつ)
        const byePositions = [
            4, 12,  // 1シード (0) の山
            20, 28, // 5-8シード (16) の山
            36, 44, // 4シード (32) の山
            52, 60, // 5-8シード (48) の山
            68, 76, // 2シード (64) の山
            84, 92, // 5-8シード (80) の山
            100, 108, // 3シード (96) の山
            116, 124  // 5-8シード (112) の山
        ];
        byePositions.forEach(slot => { teams[slot] = '(BYE)'; });
        
        // 4. ノーシード校（104校）を、残りの 104 スロットに配置
        const teamsToPlace = shuffleArray(nonSeeds); // 104校
        
        let nonSeedIndex = 0;
        for (let i = 0; i < numTeamsInTournament; i++) {
            if (teams[i] === null) { // スロットが空（シードでもBYEでもない）
                if(nonSeedIndex < teamsToPlace.length) {
                    teams[i] = teamsToPlace[nonSeedIndex];
                    nonSeedIndex++;
                }
            }
        }
        
        if (nonSeedIndex !== 104) {
             console.error(`抽選ロジックエラー: 104校を配置する予定でしたが、${nonSeedIndex}校しか配置されませんでした。`);
        }
    }
    
    // (トーナメントstateの初期化 ... 変更なし)
    tournamentState.teams = teams;
    tournamentState.matches = {};
    tournamentState.news = [];
    tournamentState.documentary = { target: null, type: null };
    tournamentState.activeScandal = null;
    tournamentState.seeds = seeds; 
    tournamentState.bbsComments = [];
    tournamentState.daiyaBbsComments = [];
    tournamentState.tickerHeadlines = []; 
    tournamentState.rivalries = RIVALRIES;
    tournamentState.feuds = tournamentState.feuds || []; 
    tournamentState.namcoNews = null;
    tournamentState.preGameComments = {};
    tournamentState.matomeThreads = {}; 
    tournamentState.userThreads = [];
    tournamentState.autumnData = { regions: {} };
    tournamentState.springData = { regions: {} };

    // (R1の試合オブジェクトを作成 ... 変更なし)
    const round1Setup = teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);
    round1Setup.forEach((match, index) => {
        const side = index < 32 ? 'L' : 'R';
        const matchNum = index < 32 ? index + 1 : index - 31;
        const matchId = `${side}-R1-M${matchNum}`;
        const rivalryType = checkRivalry(match.team1, match.team2);
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '', rivalryType: rivalryType };
    });

    // (R2〜R6, Fの空の箱を作成 ... 変更なし)
    for (let r = 2; r < finalRound; r++) {
        const numMatchesInRound = numTeamsInTournament / Math.pow(2, r);
        for (let m = 1; m <= numMatchesInRound / 2; m++) {
            const matchIdL = `L-R${r}-M${m}`;
            tournamentState.matches[matchIdL] = { id: matchIdL, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '', prevMatch1Id: `L-R${r-1}-M${(m*2)-1}`, prevMatch2Id: `L-R${r-1}-M${(m*2)}` };
            const matchIdR = `R-R${r}-M${m}`;
            tournamentState.matches[matchIdR] = { id: matchIdR, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '', prevMatch1Id: `R-R${r-1}-M${(m*2)-1}`, prevMatch2Id: `R-R${r-1}-M${(m*2)}` };
        }
    }
    tournamentState.matches['F-R1-M1'] = { id: 'F-R1-M1', team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '', prevMatch1Id: `L-R${finalRound-1}-M1`, prevMatch2Id: `R-R${finalRound-1}-M1` };
    
    // --- 3. スケジュール割り当て (★R2-R4の球場をシャッフル) ---
    let datesR1, datesR2, datesR3, datesR4, datesR5, datesR6, dateFinal;
    if (nextTournamentType === 'autumn') {
        datesR1 = ["9/10", "9/11", "9/12", "9/13"];
        datesR2 = ["9/15", "9/16"];
        datesR3 = ["9/18", "9/19"];
        datesR4 = ["9/21"];
        datesR5 = ["9/23"];
        datesR6 = ["9/25"];
        dateFinal = ["9/27"];
    } else if (nextTournamentType === 'spring') {
        datesR1 = ["4/10", "4/11", "4/12", "4/13"];
        datesR2 = ["4/15", "4/16"];
        datesR3 = ["4/18", "4/19"];
        datesR4 = ["4/21"];
        datesR5 = ["4/23"];
        datesR6 = ["4/25"];
        dateFinal = ["4/27"];
    } else {
        datesR1 = ["7/10", "7/11", "7/12", "7/13"];
        datesR2 = ["7/15", "7/16"];
        datesR3 = ["7/18", "7/19"];
        datesR4 = ["7/21"];
        datesR5 = ["7/23"];
        datesR6 = ["7/25"];
        dateFinal = ["7/27"];
    }
    
    // (R1のスケジュール割り当て ... 変更なし)
    const matchIdsR1 = Object.keys(tournamentState.matches).filter(id => id.includes('-R1-'));
    let fullScheduleQueueR1 = [];
    for (const date of datesR1) {
        for (const stadium of STADIUM_DATA) { 
            for (let i = 1; i <= 2; i++) { fullScheduleQueueR1.push({ date: date, stadium: stadium.abbr, stadiumFull: stadium.name, region: stadium.region, gameNum: i }); }
        }
    }
    fullScheduleQueueR1 = shuffleArray(fullScheduleQueueR1);
    const seedMatchIds = [];
    const normalMatchIds = [];
    const seedTeamsList = tournamentState.seeds.map(s => s.team); 
    matchIdsR1.forEach(matchId => {
        const match = findMatchById(matchId);
        if (match && (seedTeamsList.includes(match.team1) || seedTeamsList.includes(match.team2))) { seedMatchIds.push(matchId); } 
        else { normalMatchIds.push(matchId); }
    });
    seedMatchIds.forEach(matchId => {
        const match = findMatchById(matchId); if (!match) return;
        let targetRegion = null; let preferredStadiumAbbr = null;
        if (match.team1 === "静岡" || match.team2 === "静岡") { preferredStadiumAbbr = STADIUM_DATA[0].abbr; targetRegion = STADIUM_DATA[0].region; }
        else if (match.team1 === "掛川西" || match.team2 === "掛川西") { preferredStadiumAbbr = STADIUM_DATA[6].abbr; targetRegion = STADIUM_DATA[6].region; }
        else {
            const seedTeamName = seedTeamsList.includes(match.team1) ? match.team1 : match.team2;
            const seedTeamData = TEAM_DATA[seedTeamName];
            if (seedTeamData) { targetRegion = seedTeamData.region; if (targetRegion === '伊豆') targetRegion = '東部'; }
        }
        let schedule; let foundSlotIndex = -1;
        if (preferredStadiumAbbr) { foundSlotIndex = fullScheduleQueueR1.findIndex(s => s.stadium === preferredStadiumAbbr); }
        if (foundSlotIndex === -1 && targetRegion) { foundSlotIndex = fullScheduleQueueR1.findIndex(s => s.region === targetRegion); }
        if (foundSlotIndex === -1 && (preferredStadiumAbbr === STADIUM_DATA[0].abbr || preferredStadiumAbbr === STADIUM_DATA[6].abbr)) {
             let fallbackSlotIndex = fullScheduleQueueR1.findIndex(s => s.region === '東部');
             if (fallbackSlotIndex !== -1) { schedule = fullScheduleQueueR1.splice(fallbackSlotIndex, 1)[0]; }
             else { schedule = fullScheduleQueueR1.shift(); }
        } else if (foundSlotIndex !== -1) { schedule = fullScheduleQueueR1.splice(foundSlotIndex, 1)[0]; }
        else { schedule = fullScheduleQueueR1.shift(); }
        if (schedule) { match.schedule = { date: schedule.date, stadium: schedule.stadium, stadiumFull: schedule.stadiumFull, game: schedule.gameNum }; }
    });
    normalMatchIds.forEach(matchId => {
        const match = findMatchById(matchId); if (!match) return;
        const data1 = TEAM_DATA[match.team1]; const data2 = TEAM_DATA[match.team2];
        let targetRegion = '中部'; 
        if (data1 && data2) {
            const region1 = data1.region; const region2 = data2.region;
            if (region1 === region2) targetRegion = region1;
            else if ((region1 === '東部' && region2 === '西部') || (region1 === '西部' && region2 === '東部')) targetRegion = '中部';
            else if ((region1 === '東部' && region2 === '中部') || (region1 === '中部' && region2 === '東部')) targetRegion = '中部';
            else if ((region1 === '西部' && region2 === '中部') || (region1 === '中部' && region2 === '西部')) targetRegion = '西部';
            else if (region1 === '伊豆' || region2 === '伊豆') targetRegion = '東部';
            if (targetRegion === '伊豆') targetRegion = '東部';
        }
        let foundSlotIndex = fullScheduleQueueR1.findIndex(s => s.region === targetRegion);
        let schedule;
        if (foundSlotIndex === -1) { schedule = fullScheduleQueueR1.shift(); }
        else { schedule = fullScheduleQueueR1.splice(foundSlotIndex, 1)[0]; }
        if (schedule) { match.schedule = { date: schedule.date, stadium: schedule.stadium, stadiumFull: schedule.stadiumFull, game: schedule.gameNum }; }
    });
    
    // (R2以降の割り当て ... ★球場リストをシャッフル)
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R2-')), 
        datesR2, shuffleArray(STADIUM_DATA), 2 // R2 (32試合) -> 全10球場 (シャッフル)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R3-')), 
        datesR3, shuffleArray(ROUND_3_STADIUMS), 2 // R3 (16試合) -> 主要4球場 (シャッフル)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R4-')), 
        datesR4, shuffleArray(ROUND_3_STADIUMS), 2 // R4 (8試合) -> 主要4球場 (シャッフル)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R5-')), 
        datesR5, shuffleArray(QUARTER_FINAL_STADIUMS), 4 // R5 (準々 4試合) -> 2球場 (シャッフル)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R6-')), 
        datesR6, FINAL_STAGE_STADIUMS, 2 // R6 (準決 2試合) -> メイン球場
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.startsWith('F-R1-')), 
        dateFinal, FINAL_STAGE_STADIUMS, 1 // 決勝 (1試合) -> メイン球場
    );
// ▲▲▲ 置き換えここまで ▲▲▲
    
    // 4. 画面とAIの初期化
    renderTournament(tournamentState); 
    
    // 5. 不戦勝(BYE)の自動処理
    processByes(tournamentState);
    
    // 6. AI生成 (変更なし)
    if (tournamentState.settings.enableArticleGeneration) {
        (async () => {
            const newFeuds = await generateDynamicFeuds(tournamentState);
            if (newFeuds && newFeuds.length > 0) {
                tournamentState.feuds.push(...newFeuds);
                saveState(); 
                renderTournament(tournamentState); 
                const feudTitles = newFeuds.map(f => `「${f.teams[0]} vs ${f.teams[1]} (${f.type})」`).join('、');
                tournamentState.news.push({
                    title: "【速報】今大会の「因縁の対決」が決定！",
                    body: `大会本部は、AI解説者の分析に基づき、今大会の注目すべき「因縁の対決」を発表した。\n${feudTitles}など、1回戦から目が離せない戦いが続く。`,
                    timestamp: Date.now()
                });
                renderNews(tournamentState.news);
            }
        })();

        saveState(); 
        renderTournament(tournamentState); 
        const currentTournamentName = tournamentNameMap[tournamentState.currentTournament];
        newsContainer.innerHTML = `<div class="loader">AI記者が${currentTournamentName}の組み合わせと展望を分析中...</div>`;
        bbsCommentsContainer.innerHTML = `<div class="loader">AIが組み合わせを分析中...</div>`;
        namcoNewsSection.classList.remove('hidden');
        namcoNewsContent.innerHTML = `<div class="loader">ナムコグループからのお知らせを確認中...</div>`;
        let analysisArticlePromise = generateBracketAnalysisNewsArticle(tournamentState);
        let bracketBbsPromise = generateBracketBbsThread(tournamentState); 
        try {
            const topicArticles = await generateTopicSchoolArticles(tournamentState); 
            if (topicArticles && topicArticles.length > 0) {
                tournamentState.news.push(...topicArticles); 
            }
        } catch (e) { console.error("話題校紹介記事の生成中にエラーが発生しました:", e); }
        const [namcoNews, analysisArticle, bracketBbsResult] = await Promise.all([
            generateNamcoNews(tournamentState, 'bracket'),
            analysisArticlePromise,
            bracketBbsPromise
        ]);
        if (analysisArticle && !analysisArticle.error) { tournamentState.news.unshift(analysisArticle); }
        else if (analysisArticle && analysisArticle.error) { tournamentState.news.unshift(analysisArticle); }
        if (bracketBbsResult && !bracketBbsResult.error) { tournamentState.bbsComments.push(bracketBbsResult); }
        else if (bracketBbsResult && bracketBbsResult.error) { tournamentState.bbsComments.push({ ...bracketBbsResult, context: { isBracketThread: true } }); }
        if (namcoNews) tournamentState.namcoNews = namcoNews;
        renderNews(tournamentState.news);
        renderBbsComments(tournamentState.bbsComments); 
        renderNamcoNews(tournamentState.namcoNews);
        saveState();
    } else {
        saveState(); 
        renderTournament(tournamentState); 
        newsContainer.innerHTML = `<p class="text-gray-500 text-center">（AIによる自動記事生成は現在オフです。設定 ⚙️ からオンにできます）</p>`;
        bbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">（AIによる掲示板生成は現在オフです。設定 ⚙️ からオンにできます）</p>`;
        namcoNewsSection.classList.add('hidden');
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * AIに組み合わせ抽選時に「話題校紹介」の記事を数本生成させる
 * (★E, D, C, B, Aランクから各1校ずつ、計5校ピックアップ)
 * (★★AI生成失敗時に「エラー記事」として描画し、再生成を可能にする最終版★★)
 * @param {object} state - tournamentState
 * @returns {Promise<Array<object>>} - 生成された記事オブジェクト（またはエラー記事オブジェクト）の配列
 */
async function generateTopicSchoolArticles(state) {
    const { teams, seeds } = state;
    if (!teams || teams.length === 0) return [];

    const articles = [];
    const getTeamRank = (teamName) => calculateRank(teamName, state);
    
    // チームをシャッフル (同じランクからランダムに選ぶため)
    const shuffledTeams = shuffleArray(teams); 

    // ランク別にチームを分類
    const teamsByRank = { 'A': [], 'B': [], 'C': [], 'D': [], 'E': [] };
    shuffledTeams.forEach(team => {
        const rank = getTeamRank(team);
        teamsByRank[rank].push(team);
    });

    // --- 各ランクから1校ずつ選んで記事を生成 ---

    // 1. Eランク校の記事 (テーマ: 悲願の初戦突破へ)
    const teamE = teamsByRank['E'][0];
    if (teamE) {
        const article = await createTopicArticle(teamE, getTeamRank(teamE), 'E');
        if (article) {
            articles.push(article);
        } else {
            // ▼▼▼ ユーザーの要望: 失敗した場合、エラー記事オブジェクトを作成 ▼▼▼
            articles.push({
                title: `記事生成エラー (${teamE})`,
                body: "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                isTopicArticle: true, // これも話題校記事であることを示す
                context: { teamName: teamE, theme: 'E' } // ★再生成用のコンテキスト
            });
            // ▲▲▲
        }
    }

    // 2. Dランク校の記事 (テーマ: 躍進のベスト8へ)
    const teamD = teamsByRank['D'][0];
    if (teamD) {
        const article = await createTopicArticle(teamD, getTeamRank(teamD), 'D');
        if (article) {
            articles.push(article);
        } else {
            articles.push({
                title: `記事生成エラー (${teamD})`,
                body: "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                isTopicArticle: true, 
                context: { teamName: teamD, theme: 'D' } 
            });
        }
    }

    // 3. Cランク校の記事 (テーマ: 甲子園出場という悲願へ)
    const teamC = teamsByRank['C'][0];
    if (teamC) {
        const article = await createTopicArticle(teamC, getTeamRank(teamC), 'C');
        if (article) {
            articles.push(article);
        } else {
            articles.push({
                title: `記事生成エラー (${teamC})`,
                body: "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                isTopicArticle: true, 
                context: { teamName: teamC, theme: 'C' } 
            });
        }
    }

    // 4. Bランク校の記事 (テーマ: 打倒Aランクへ)
    const teamB = teamsByRank['B'][0];
    if (teamB) {
        const article = await createTopicArticle(teamB, getTeamRank(teamB), 'B');
        if (article) {
            articles.push(article);
        } else {
            articles.push({
                title: `記事生成エラー (${teamB})`,
                body: "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                isTopicArticle: true, 
                context: { teamName: teamB, theme: 'B' } 
            });
        }
    }

    // 5. Aランク校の記事 (テーマ: 王者の道)
    const teamA = teamsByRank['A'][0];
    if (teamA) {
        const article = await createTopicArticle(teamA, getTeamRank(teamA), 'A');
        if (article) {
            articles.push(article);
        } else {
            articles.push({
                title: `記事生成エラー (${teamA})`,
                body: "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                isTopicArticle: true, 
                context: { teamName: teamA, theme: 'A' } 
            });
        }
    }

    // 失敗した記事(エラーオブジェクト)もそのまま返すため、.filter(Boolean) は削除
    return articles;
}

/**
 * generateTopicSchoolArticles のヘルパー関数。
 * 1校を選び、ランクに応じたテーマで記事を生成する。
 * (★BYEの場合は「2回戦から登場」と紹介する修正版)
 * @param {string} teamName - 選ばれたチーム名
 * @param {string} rank - チームランク (A, B, C, D, E)
 * @param {'E' | 'D' | 'C' | 'B' | 'A'} theme - 記事のテーマ
 * @returns {Promise<object|null>} - 生成された記事オブジェクト
 */
async function createTopicArticle(teamName, rank, theme) {
    const teamData = TEAM_DATA[teamName];
    const teamRecord = tournamentState.teamRecords[teamName];
    const detailedData = DETAILED_TEAM_DATA[teamName];
    const lore = PREFECTURE_LORE; 

    // 1. ランク記号を日本語の説明に変換
    const rankDescription = getRankDescription(rank); 
    
    // 2. シード校か判定
    const isSeed = tournamentState.seeds.some(s => s.team === teamName);
    const seedRankString = isSeed ? getSeedRankString(teamName, tournamentState.seeds) : '';

    // 3. 基本情報を作成
    let contextInfo = `
- **チーム名:** ${teamName} ${seedRankString} (${rankDescription})
- **チーム背景(info):** ${teamData.info || '情報なし'}
- **監督:** ${teamData.coach.name} (${teamData.coach.style})
- **昨年の成績:** ${getRankString(teamRecord.lastFinish)}
`;
    if (detailedData) {
        contextInfo += `- **注目選手:** ${detailedData.players.map(p => `${p.name}(${p.year}年, ${p.pos}) - ${p.desc}`).join('、 ')}\n`;
    }

    // 4. ★★★ 初戦情報の判定（修正箇所） ★★★
    const firstMatch = Object.values(tournamentState.matches).find(m => 
        m.id.includes('-R1-') && (m.team1 === teamName || m.team2 === teamName)
    );
    
    let firstMatchInfo = '';
    let isByeStart = false; // 2回戦から登場フラグ

    if (firstMatch) {
        const opponentName = firstMatch.team1 === teamName ? firstMatch.team2 : firstMatch.team1;
        
        // ▼▼▼ BYE（不戦勝）の判定 ▼▼▼
        if (opponentName === '(BYE)') {
            isByeStart = true;
            firstMatchInfo = `
- **初戦情報:**
  - **対戦相手:** (BYE) 不戦勝
  - **状況:** 規定により1回戦は免除され、**「2回戦からの登場」**となります。他チームより日程に余裕があり、調整面で有利です。
`;
        } else {
            // 通常の対戦相手
            const opponentRankDesc = getRankDescription(calculateRank(opponentName, tournamentState)); 
            const opponentSeedRank = getSeedRankString(opponentName, tournamentState.seeds);
            let scheduleInfo = '日程・球場未定';
            if (firstMatch.schedule) {
                const gameNumIcon = ['①', '②', '③', '④'][firstMatch.schedule.game - 1] || `(第${firstMatch.schedule.game}試合)`;
                scheduleInfo = `${firstMatch.schedule.date} ${firstMatch.schedule.stadiumFull} ${gameNumIcon}`;
            }
            firstMatchInfo = `
- **初戦情報:**
  - **対戦相手:** ${opponentName} ${opponentSeedRank} (${opponentRankDesc})
  - **日程:** ${scheduleInfo}
`;
        }
        // ▲▲▲ 修正ここまで ▲▲▲
    }
    contextInfo += firstMatchInfo;

    // テーマに応じたプロンプトを作成
    let prompt = `あなたは「スポーツ報知」の高校野球担当記者です。
夏の静岡大会の組み合わせが決定しました。
あなたは今、ピックアップした「話題校」の紹介記事を執筆しています。
以下の【取材データ】と【執筆テーマ】に基づき、情景や選手の背景（物語）が目に浮かぶようなリアルな紹介記事を生成してください。

### 取材データ
${contextInfo}

### 静岡県の常識（あなたの知識）
${lore}

`;

    // 各テーマの指示文
    if (theme === 'E') {
        prompt += `
### 執筆テーマ：「悲願の初戦突破へ」
- このチーム（${rankDescription}）の目標は、まず「夏に1勝」することです。
- そのチームが抱える**特有の事情**（例：浜松特支の創部背景、新居の0勝32敗、川根の最後の夏、虎府島の離島ハンデなど）を**記事の中心**に据えてください。
`;
    } else if (theme === 'D') {
        prompt += `
### 執筆テーマ：「躍進のベスト8を目指して」
- このチーム（${rankDescription}）の目標は、強豪を倒して「ベスト8」に進出し、大会のダークホースになることです。
- チームの**歴史**や、注目選手（いなければ架空の注目選手を創作）の**成長物語**に焦点を当ててください。
- 監督や主将の「今年こそは」という、**下剋上（ジャイアントキリング）**にかける意気込みを描写してください。
`;
    } else if (theme === 'C') {
        prompt += `
### 執筆テーマ：「甲子園出場という悲願へ」
- このチーム（${rankDescription}）の目標は、静岡県の「戦国時代」を勝ち抜き、甲子園に出場することです。
- チームの中心となる**エースや主軸選手**に焦点を当て、その選手の**苦悩、成長、そして決意**を深く掘り下げてください。
`;
    } else if (theme === 'B') {
        if (isSeed) {
            prompt += `
### 執筆テーマ：「悲願の甲子園出場へ！そして聖地１勝を」
- このチーム（${rankDescription}, ${seedRankString}）は、優勝候補に次ぐ「強豪シード校」です。最大の目標は、Aランク校を倒し、まずは「甲子園出場」の切符を掴むことです。`;
        } else {
            prompt += `
### 執筆テーマ：「ノーシードの強豪、下剋上なるか」
- このチーム（${rankDescription}）は、Bランクの力を持つにも関わらず、「ノーシード」で今大会に臨みます。
- 序盤からシード校と激突する可能性があり、大会の「ダークホース」または「波乱要因」として注目されています。`;
        }
        prompt += `
- チームの強み（例：強力打線）に焦点を当て、それが甲子園出場にどう繋がるかを分析してください。
- チームのキーマン（例：4番、エース）を取り上げ、彼/彼女の決意を語らせてください。`;
    
    } else if (theme === 'A') {
        if (isSeed) {
            prompt += `
### 執筆テーマ：「全国制覇へ、王者のプレッシャー」
- このチーム（${rankDescription}, ${seedRankString}）は、今大会の「優勝候補筆頭」です。最終目標は「全国制覇」ですが、そのためにはまず「甲子園出場」という最大の関門を突破しなければなりません。`;
        } else {
            prompt += `
### 執筆テーマ：「最強のノーシード、死のブロックの主役」
- このチーム（${rankDescription}）は、Aランクの力を持つにも関わらず、「ノーシード」で今大会に臨みます。
- 彼らが入ったブロックは、自動的に「死のブロック」となります。彼らがどのシード校を倒して勝ち上がってくるのか、その「下剋上」の軌跡に焦点を当ててください。`;
        }
        prompt += `
- **「勝って当たり前」というプレッシャー**とどう戦っているか、主将や監督のコメントを通じて描写してください。
- チームの圧倒的な戦力（例：プロ注目選手）を紹介してください。`;
    }

    prompt += `
### 追加指示：初戦の情報【最重要】
- 記事の最後（締めくくり）に、**【取材データ】にある「初戦情報」**について必ず言及してください。
${isByeStart ? '- **特に「1回戦は不戦勝であり、2回戦からの登場となる」こと、そしてそれが「調整面で有利（または試合勘で不利）」であること**に触れ、次戦への準備万端な様子を描写してください。' : '- 対戦相手、日程、球場に触れ、大会への期待感を高めてください。'}

### 出力形式【厳守】
- **【最重要】** あなたの応答は、必ず単一のJSONオブジェクト"のみ"でなければなりません。
{"title": "（例：【高校野球】${teamName}、${isByeStart ? '2回戦から登場！万全の調整で夏に挑む' : '初戦はXXと激突'}）", "body": "（ここにスポーツ報知風の記事本文）"}
`;

    // --- AIへのリクエスト ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
            const rawTextFromAi = result.candidates[0].content?.parts[0]?.text;
            const article = parseJsonFromText(rawTextFromAi);
            
            if (article && article.title && article.body) {
                article.body += "\n\n　（スポーツ報知 記者）"; 
                return { 
                    ...article, 
                    timestamp: Date.now(),
                    isTopicArticle: true, 
                    context: { teamName: teamName, theme: theme, isTopicArticle: true } 
                };
            } else {
                 console.error("parseJsonFromText failed for TopicArticle:", rawTextFromAi);
                 throw new Error("AI response format error after parsing (TopicArticle).");
            }
        } else {
             console.error("Unexpected AI response structure (TopicArticle):", result);
             throw new Error("AI response structure is missing expected parts (TopicArticle).");
        }
    } catch (error) {
        console.error(`話題校紹介記事（${teamName}）の生成に失敗しました:`, error);
        return null; 
    }
}

/**
 * [UPDATED] AIに組み合わせ抽選結果の詳細分析に基づいた展望ニュース記事を生成させる
 * (★チーム数に応じてブロックサイズを動的に計算)
 */
async function generateBracketAnalysisNewsArticle(state) {
    const { teams, seeds, currentTournament, tournamentYear } = state;
    const tournamentName = tournamentNameMap[currentTournament] || '大会';
    if (!teams || teams.length === 0) return null;

    // ★★★ 修正箇所: ブロックサイズを動的に計算 ★★★
    const numBlocks = 4;
    const blockSize = Math.ceil(teams.length / numBlocks); // 128->32, 64->16
    // ★★★ 修正ここまで ★★★

    let tournamentContextPrompt = "";
    let seedContext = "前大会ベスト8";
    if (currentTournament === 'summer') {
        tournamentContextPrompt = "3年生にとっては最後の夏であり、甲子園出場をかけた最も熱い戦いです。";
    } else if (currentTournament === 'summer_koshien') {
        tournamentContextPrompt = "全国の代表校が集う夏の甲子園。負ければ終わりの一発勝負です。";
        seedContext = "注目校";
    } else if (currentTournament === 'autumn') {
        tournamentContextPrompt = "1,2年生による新チームが始動する最初の公式戦です。";
    } else if (currentTournament === 'spring') {
        tournamentContextPrompt = "夏のシード権をかけた前哨戦です。";
    }

    const blockData = [];
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    const getTeamRank = (teamName) => calculateRank(teamName, state);
    let crushR1 = []; 
    let goodCardsR5 = []; 
    let blockSummary = "";

    for (let i = 0; i < numBlocks; i++) {
        const blockName = String.fromCharCode(65 + i);
        const startIdx = i * blockSize;
        const endIdx = (i + 1) * blockSize;
        const blockTeams = teams.slice(startIdx, endIdx);
        if (blockTeams.length === 0) continue;
        
        const strongTeamsInBlock = blockTeams.filter(team => {
            const rank = getTeamRank(team);
            return seeds.some(s => s.team === team) || ['A', 'B'].includes(rank); 
        });
        const matchupsR1 = [];
        const potentialR5 = [];
        for (let j = 0; j < blockTeams.length; j += 2) {
            const team1 = blockTeams[j]; const team2 = blockTeams[j + 1];
            if (!team1 || !team2) continue;
            const rank1 = getTeamRank(team1); const rank2 = getTeamRank(team2);
            const matchup = { team1, rank1, team2, rank2 };
            matchupsR1.push(matchup);
            if ((seeds.some(s => s.team === team1) || ['A', 'B'].includes(rank1)) && (seeds.some(s => s.team === team2) || ['A', 'B'].includes(rank2))) {
                matchup.isCrush = true;
            }
        }
        // (簡易シミュレーション: R1勝者 -> R2勝者 -> R3勝者 -> R4進出者)
        // ※64チーム制の場合、R4は準々決勝ではないが、ベスト8決めの重要なラウンドとして扱う
        let winners = [];
        matchupsR1.forEach(m => { winners.push(rankValues[m.rank1] >= rankValues[m.rank2] ? m.team1 : m.team2); });
        
        // シミュレーションの段数をチーム数に合わせて調整するのは複雑なので、
        // ここでは「ブロック内の有力校同士の対決予想」として、単純に有力校リストを使う形に留めるか、
        // 既存ロジックが動く範囲でよしとする（数合わせで動くため）
        
        blockData.push({ name: blockName, strongTeams: strongTeamsInBlock, matchupsR1: matchupsR1, potentialR5: potentialR5 });
    }

    blockData.forEach(block => {
        const strongTeamNames = block.strongTeams.map(team => `${team} ${getSeedRankString(team, state.seeds)}`).join(', ');
        blockSummary += `- ${block.name}ブロック: 有力校 ${block.strongTeams.length} (${strongTeamNames || 'なし'})\n`;
        block.matchupsR1.forEach(m => {
            if (m.isCrush) {
                const team1Info = `${m.team1}${getSeedRankString(m.team1, state.seeds)}(${m.rank1})`;
                const team2Info = `${m.team2}${getSeedRankString(m.team2, state.seeds)}(${m.rank2})`;
                crushR1.push(`${block.name}: ${team1Info} vs ${team2Info}`);
            }
        });
    });
    
    blockData.sort((a, b) => b.strongTeams.length - a.strongTeams.length);
    const deathBlock = blockData[0];
    const blessedBlock = blockData[blockData.length - 1];
    
    let analysisText = `各ブロックの有力校:\n${blockSummary}`;
    analysisText += `死のブロック: ${deathBlock.name} (${deathBlock.strongTeams.length}校)\n`;
    analysisText += `恵まれたブロック: ${blessedBlock.name} (${blessedBlock.strongTeams.length}校)\n`;
    if (crushR1.length > 0) analysisText += `1回戦での有力校潰し合い:\n  - ${crushR1.join('\n  - ')}\n`;

    const prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。
${tournamentYear}年度 ${tournamentName}の組み合わせ抽選会が終了しました。
以下の詳細な分析結果に基づき、読者の期待感を高めるような展望記事を作成してください。

### 大会の文脈 (最重要)
${tournamentContextPrompt}

### 参考情報：静岡県高校野球の「常識」（勢力図）
${PREFECTURE_LORE}
---
### 組み合わせ分析結果 (★シードランク付き)
${analysisText}

### 執筆指示
- 【大会の文脈を反映】: 記事全体で、${tournamentName}ならではの視点（甲子園なら「全国の頂点」など）を反映させてください。
- タイトル: 「${tournamentName} 組み合わせ決定！${deathBlock.name}ブロックは激戦区か？」のように、大会名と抽選結果のポイントが伝わるものにしてください。
- 本文構成:
    1. 組み合わせが決定したことを伝える導入。
    2. 各ブロックの有力校に触れつつ、特に「死のブロック (${deathBlock.name})」と「恵まれたブロック (${blessedBlock.name})」について解説してください。
    3. 勝ち上がりを予想し、注目カードについても触れてください。
    4. 【AI記者の注目株】: あなたが「今大会の一押しチーム（推し）」を1校選び、そのチームの魅力を熱く語るコラム欄を設けてください。
    5. 最後に、大会への期待を述べて締めくくってください。

### 出力形式
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article && article.title && article.body) {
                return { ...article, timestamp: Date.now(), context: { isBracketAnalysis: true } }; 
            }
        }
        throw new Error("AIからの応答が、正しい記事形式ではありません。");
    } catch (error) {
        console.error("AI組み合わせ分析記事の生成に失敗しました:", error);
        return {
            title: "組み合わせ分析記事 生成エラー",
            body: "AI記者との通信に失敗し、記事を生成できませんでした。",
            timestamp: Date.now(),
            error: true,
            errorId: `bracket-analysis-${Date.now()}`,
            context: { isBracketAnalysis: true }
        };
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲


// --- Tournament Animation Logic ---

let currentAnimation = null; // 再生中のアニメーションの種類 (null, 'autumn', 'spring')
let currentStep = -1;       // 現在のステップ番号
let animationSteps = [];    // 現在のアニメーションの全ステップ関数

const stage = document.getElementById('animation-stage');
const narrationEl = document.getElementById('animation-narration');
const prevBtn = document.getElementById('prev-step-btn');
const nextBtn = document.getElementById('next-step-btn');
const animPlaceholder = document.getElementById('anim-placeholder');
const showAutumnBtn = document.getElementById('show-autumn-anim-btn');
const showSpringBtn = document.getElementById('show-spring-anim-btn');

/**
 * アニメーション要素を作成するヘルパー
 */
function createAnimElement(type, text, options = {}) {
    const el = document.createElement('div');
    el.className = `anim-${type}`;
    el.textContent = text;
    if (options.id) el.id = options.id;
    if (options.children) options.children.forEach(child => el.appendChild(child));
    if (options.style) Object.assign(el.style, options.style);
    return el;
}

/**
 * 要素を表示（フェードイン）させるヘルパー
 */
async function showElement(element, delay = 50) {
    if (!element) return;
    await sleep(delay);
    element.classList.add('show');
}

/**
 * 要素を非表示（フェードアウト）させるヘルパー
 */
async function hideElement(element, delay = 0) {
    if (!element) return;
    await sleep(delay);
    element.classList.remove('show', 'anim-highlight');
    await sleep(500); // Wait for fade out
}

/**
 * 要素をハイライトするヘルパー
 */
function highlightElement(element, clearOthers = true) {
    if (clearOthers) {
        stage.querySelectorAll('.anim-highlight').forEach(el => el.classList.remove('anim-highlight'));
    }
    if (element) {
        element.classList.add('anim-highlight');
    }
}

/**
 * ナレーションを設定し、タイプライター風に表示するヘルパー
 */
async function setNarration(text) {
    narrationEl.textContent = '';
    for (const char of text) {
        narrationEl.textContent += char;
        await sleep(30); // 文字間のウェイト
    }
}

/**
 * ステップ実行とボタン制御
 */
async function runStep(stepIndex) {
    if (stepIndex < 0 || stepIndex >= animationSteps.length) return;
    currentStep = stepIndex;
    stage.innerHTML = ''; // ステージをクリア
    animPlaceholder.classList.add('hidden'); // プレースホルダー非表示
    await animationSteps[currentStep](); // 現在のステップ関数を実行
    updateButtons();
}

function updateButtons() {
    prevBtn.disabled = currentStep <= 0;
    nextBtn.disabled = currentStep >= animationSteps.length - 1;
}

// --- 秋季大会アニメーションステップ ---
const autumnAnimation = [
    // Step 0: Introduction
    async () => {
        await setNarration("🍂 秋季大会は新チーム最初の公式戦！センバツ甲子園出場に繋がります。");
        const title = createAnimElement('bracket', '秋季大会システム', { style: { fontSize: '1.2rem', fontWeight: 'bold' } });
        stage.appendChild(title);
        await showElement(title);
    },
    // Step 1: Regional Qualifiers Overview
    async () => {
        await setNarration("まず、県内を4地区（東部・中部・西部・伊豆）に分けて地区予選を行います。");
        const regions = ['東部(20)', '中部(20)', '西部(20)', '伊豆(4)'].map(r => createAnimElement('region', r));
        const container = createAnimElement('bracket', '', { children: regions, style: { display: 'flex', justifyContent: 'center' } });
        stage.appendChild(container);
        for (const region of regions) await showElement(region);
    },
    // Step 2: Main 3 Regions - Blocks
    async () => {
        await setNarration("東・中・西地区では、20チームが4ブロックに分かれ、各ブロック優勝を目指します。");
        const region = createAnimElement('region', '東部地区 (20チーム)', { id: 'main-region', style: { width: '80%' } });
        const blocks = ['A (5)', 'B (5)', 'C (5)', 'D (5)'].map(b => createAnimElement('block', `ブロック ${b}`));
        region.append(...blocks);
        stage.appendChild(region);
        await showElement(region);
        for (const block of blocks) await showElement(block, 100);
        highlightElement(region);
    },
    // Step 3: Block Winner
    async () => {
        await setNarration("各ブロックの優勝チーム (計4チーム) は県大会へ進出決定！🏆");
        const region = document.getElementById('main-region');
        if (!region) { // 要素がなければ再生成 (Prevボタン対策)
            await autumnAnimation[2](); // 前のステップを再実行
            await sleep(500);
        }
        const blockA = stage.querySelector('.anim-block'); // 例としてAブロック
        const winner = createAnimElement('team', 'A優勝', { classList: ['winner'] });
        blockA.appendChild(winner);
        await showElement(winner, 200);
        highlightElement(winner);
        // TODO: 矢印で「県大会へ」を示す
    },
    // Step 4: Block Runner-up & Repechage
    async () => {
        await setNarration("各ブロックの準優勝チーム (計4チーム) は、最後の1枠を賭けた敗者復活戦へ。");
        await autumnAnimation[3](); // 前のステップの表示をベースにする
        const blocks = stage.querySelectorAll('.anim-block');
        const runnersUp = [];
        blocks.forEach((block, i) => {
            const runnerUp = createAnimElement('team', `${String.fromCharCode(65 + i)}準優勝`, { classList: ['loser'] });
            block.appendChild(runnerUp);
            runnersUp.push(runnerUp);
        });
        for (const ru of runnersUp) await showElement(ru, 100);

        const repechage = createAnimElement('bracket', '第5代表決定戦 (敗者復活)', { id: 'repechage', style: { marginTop: '15px' } });
        stage.appendChild(repechage);
        await showElement(repechage);
        highlightElement(repechage);
        // TODO: 準優勝チームから敗者復活戦への矢印
    },
    // Step 5: Repechage Winner
    async () => {
        await setNarration("敗者復活戦の勝者 (1チーム) も県大会へ進出！これで各地区5チーム。");
        await autumnAnimation[4]();
        const repechage = document.getElementById('repechage');
        const repWinner = createAnimElement('team', '復活優勝', { classList: ['winner'] });
        repechage.appendChild(repWinner);
        await showElement(repWinner, 200);
        highlightElement(repWinner);
        // TODO: 矢印で「県大会へ」を示す
    },
    // Step 6: Izu Region
    async () => {
        await setNarration("伊豆地区は4チームのトーナメント。優勝した1チームのみ県大会へ。");
        const region = createAnimElement('region', '伊豆地区 (4チーム)', { id: 'izu-region' });
        const winner = createAnimElement('team', '伊豆優勝', { classList: ['winner'] });
        region.appendChild(winner);
        stage.appendChild(region);
        await showElement(region);
        await showElement(winner, 200);
        highlightElement(region);
    },
    // Step 7: Prefectural Tournament
    async () => {
        await setNarration("全代表16チーム (東5+中5+西5+伊豆1) が集結し、県大会本戦 (トーナメント)！");
        const bracket = createAnimElement('bracket', '県大会本戦 (16チーム)', { id: 'main-bracket' });
        const teams = ['東1', '中1', '西1', '伊1', '東2', '中2', '...', '西5(敗復)'].map(t => createAnimElement('team', t));
        bracket.append(...teams);
        stage.appendChild(bracket);
        await showElement(bracket);
        for (const team of teams) await showElement(team, 30);
        highlightElement(bracket);
    },
    // Step 8: Rewards
    async () => {
        await setNarration("県大会の優勝・準優勝はセンバツ有力！ベスト8以上で春季大会のシード権獲得！✨");
        await autumnAnimation[7]();
        const bracket = document.getElementById('main-bracket');
        const rewards = createAnimElement('bracket', '🏆優勝/準優勝 → センバツへ<br>🏅ベスト8 → 春シード権', { style: { marginTop: '15px', borderColor: 'gold' } });
        stage.appendChild(rewards);
        await showElement(rewards, 200);
        highlightElement(rewards);
    }
];

// --- 春季大会アニメーションステップ ---
const springAnimation = [
    // Step 0: Introduction
    async () => {
        await setNarration("🌸 春季大会は夏の大会の前哨戦！夏のシード権獲得を目指します。");
        const title = createAnimElement('bracket', '春季大会システム', { style: { fontSize: '1.2rem', fontWeight: 'bold' } });
        stage.appendChild(title);
        await showElement(title);
    },
    // Step 1: Seed Teams
    async () => {
        await setNarration("秋季大会ベスト8のチームはシード校となり、県大会2回戦から登場します。");
        const seeds = Array.from({ length: 8 }).map((_, i) => createAnimElement('team', `秋Best8-${i+1}`, { classList: ['seed'] }));
        const container = createAnimElement('bracket', 'シード校 (8チーム)', { children: seeds, id: 'seeds', style: { borderColor: 'orange' } });
        stage.appendChild(container);
        await showElement(container);
        for (const seed of seeds) await showElement(seed, 50);
        highlightElement(container);
    },
    // Step 2: Regional Qualifiers (Non-seeds)
    async () => {
        await setNarration("シード校以外のチームは、再び地区予選へ。秋と同様に代表枠を争います。");
        const others = createAnimElement('region', 'シード以外の全チーム (56チーム)', { id: 'others' });
        const qualifiers = createAnimElement('bracket', '地区予選 (秋と同じ形式)', { id: 'qualifiers' });
        stage.appendChild(others);
        stage.appendChild(qualifiers);
        await showElement(others);
        await showElement(qualifiers, 200);
        highlightElement(qualifiers);
        // TODO: othersからqualifiersへの矢印
    },
    // Step 3: Qualifier Winners
    async () => {
        await setNarration("地区予選を突破した16チームが県大会1回戦へ進出します。");
        await springAnimation[2](); // 前のステップ表示
        const qualifiers = document.getElementById('qualifiers');
        const winners = Array.from({ length: 16 }).map((_, i) => createAnimElement('team', `予選突破-${i+1}`, { classList: ['winner'] }));
        const winnerContainer = createAnimElement('bracket', '予選突破 (16チーム)', { children: winners, id: 'q-winners' });
        qualifiers.appendChild(winnerContainer);
        await showElement(winnerContainer, 200);
        highlightElement(winnerContainer);
    },
    // Step 4: Prefectural Round 1
    async () => {
        await setNarration("県大会1回戦は、予選突破校同士の対決です。");
        await springAnimation[3]();
        const qWinners = document.getElementById('q-winners');
        const r1Bracket = createAnimElement('bracket', '県大会1回戦 (8試合)', { id: 'r1-bracket', style: { marginTop: '15px' } });
        // 代表として4チーム表示
        const teamsR1 = ['予選A', '予選B', '予選C', '予選D'].map(t => createAnimElement('team', t));
        r1Bracket.append(...teamsR1);
        stage.appendChild(r1Bracket);
        await showElement(r1Bracket, 200);
        highlightElement(r1Bracket);
        // TODO: q-winnersからr1-bracketへの矢印
    },
    // Step 5: Prefectural Round 2 (Seeds Join)
    async () => {
        await setNarration("1回戦の勝者8チームが、シード校8チームと2回戦で激突！ここから本戦！");
        const seeds = Array.from({ length: 8 }).map((_, i) => createAnimElement('team', `秋Best8-${i+1}`, { classList: ['seed'] }));
        const seedContainer = createAnimElement('bracket', 'シード校 (8チーム)', { children: seeds, id: 'seeds', style: { borderColor: 'orange' } });

        const r1Winners = Array.from({ length: 8 }).map((_, i) => createAnimElement('team', `1回戦勝者-${i+1}`, { classList: ['winner'] }));
        const r1WinnerContainer = createAnimElement('bracket', '1回戦勝者 (8チーム)', { children: r1Winners, id: 'r1-winners' });

        const r2Bracket = createAnimElement('bracket', '県大会2回戦 (16チーム)', { id: 'r2-bracket', style: { borderColor: 'red' } });

        stage.append(seedContainer, r1WinnerContainer, r2Bracket);
        await showElement(seedContainer);
        await showElement(r1WinnerContainer);
        await showElement(r2Bracket, 200);
        highlightElement(r2Bracket);
        // TODO: seedContainerとr1WinnerContainerからr2Bracketへの矢印
    },
    // Step 6: Reward (Summer Seed)
    async () => {
        await setNarration("この大会でベスト8以上に入ると、夏の選手権大会のシード権獲得！🔥");
        await springAnimation[5]();
        const r2Bracket = document.getElementById('r2-bracket');
        const reward = createAnimElement('bracket', '🏅ベスト8 → 夏のシード権', { style: { marginTop: '15px', borderColor: 'gold' } });
        stage.appendChild(reward);
        await showElement(reward, 200);
        highlightElement(reward);
    }
];

// --- Event Listeners for Animation Control ---

showAutumnBtn.addEventListener('click', () => {
    currentAnimation = 'autumn';
    animationSteps = autumnAnimation;
    runStep(0);
});

showSpringBtn.addEventListener('click', () => {
    currentAnimation = 'spring';
    animationSteps = springAnimation;
    runStep(0);
});

prevBtn.addEventListener('click', () => {
    if (currentStep > 0) {
        runStep(currentStep - 1);
    }
});

nextBtn.addEventListener('click', () => {
    if (currentStep < animationSteps.length - 1) {
        runStep(currentStep + 1);
    }
});

// Helper for delays
// function sleep(ms) { // 既存のsleep関数があれば不要
//     return new Promise(resolve => setTimeout(resolve, ms));
// }

/**
 * [UPDATED] AIに組み合わせ抽選結果に基づいた、なんJ風の掲示板スレッドを生成させる
 * (★Cランク校への「ダークホース」反応を強化した修正版)
 */
async function generateBracketBbsThread(state) {
    const { teams, seeds, currentTournament, tournamentYear } = state;
    const tournamentName = tournamentNameMap[currentTournament] || '大会';
    if (!teams || teams.length === 0) return null; 

    // ブロックサイズ計算
    const numBlocks = 4;
    const blockSize = Math.ceil(teams.length / numBlocks); 

    const blockData = [];
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 }; 
    const getTeamRank = (teamName) => calculateRank(teamName, state); 
    
    let nicheMatchups = []; // ★Cランク等の注目カード
    let crushR1 = [];       // 潰し合い
    let blockSummary = "";
    
    for (let i = 0; i < numBlocks; i++) {
        const blockName = String.fromCharCode(65 + i);
        const startIdx = i * blockSize; const endIdx = (i + 1) * blockSize;
        const blockTeams = teams.slice(startIdx, endIdx); if (blockTeams.length === 0) continue;
        const strongTeamsInBlock = blockTeams.filter(team => { const rank = getTeamRank(team); return seeds.some(s => s.team === team) || ['A', 'B'].includes(rank); });
        const matchupsR1 = [];
        
        for (let j = 0; j < blockTeams.length; j += 2) {
            const team1 = blockTeams[j]; const team2 = blockTeams[j + 1];
            if (!team1 || !team2) continue;
            const rank1 = getTeamRank(team1); const rank2 = getTeamRank(team2);
            const matchup = { team1, rank1, team2, rank2 }; 
            matchupsR1.push(matchup);
            
            // 強豪同士の潰し合い判定
            if ((seeds.some(s => s.team === team1) || ['A', 'B'].includes(rank1)) && (seeds.some(s => s.team === team2) || ['A', 'B'].includes(rank2))) { 
                matchup.isCrush = true; 
            }

            // ★★★ Cランク(中堅) vs A/Bランク(強豪) の「ジャイアントキリング予備軍」を抽出 ★★★
            // 条件: まだ注目カード枠(5つ)に空きがあり、潰し合いではなく、片方が強豪・片方がCランクの場合
            if (nicheMatchups.length < 5 && !matchup.isCrush) {
                 // 強豪(4以上) vs C(3)
                 if ((rankValues[rank1] >= 4 && rankValues[rank2] === 3) || (rankValues[rank1] === 3 && rankValues[rank2] >= 4)) {
                    const cRankTeam = rankValues[rank1] === 3 ? team1 : team2;
                    const strongTeam = rankValues[rank1] === 3 ? team2 : team1;
                    nicheMatchups.push({ 
                        block: blockName, 
                        match: `${strongTeam}(${getTeamRank(strongTeam)}) vs ${cRankTeam}(C)`, 
                        reason: `★波乱の予感★ Cランクの不気味な存在・${cRankTeam}が強豪に挑む` 
                    });
                 } 
                 // Cランク同士の好カード
                 else if (rank1 === 'C' && rank2 === 'C') {
                    nicheMatchups.push({ 
                        block: blockName, 
                        match: `${team1}(C) vs ${team2}(C)`, 
                        reason: `実力伯仲！Cランク同士の玄人好みな好カード` 
                    });
                 }
            }
        }
        blockData.push({ name: blockName, strongTeams: strongTeamsInBlock, matchupsR1: matchupsR1 });
    }
    
    blockData.forEach(block => {
        const strongTeamNames = block.strongTeams.map(team => `${team} ${getSeedRankString(team, state.seeds)}`).join(', ');
        blockSummary += `- ${block.name}ブロック: 有力校 ${block.strongTeams.length} (${strongTeamNames || 'なし'})\n`;
        block.matchupsR1.forEach(m => {
            if (m.isCrush) {
                crushR1.push(`${block.name}: ${m.team1}(${m.rank1}) vs ${m.team2}(${m.rank2})`);
            }
        });
    });
    blockData.sort((a, b) => b.strongTeams.length - a.strongTeams.length);
    const deathBlock = blockData[0]; 
    const blessedBlock = blockData[blockData.length - 1]; 
    
    let analysisText = `各ブロックの有力校:\n${blockSummary}`;
    analysisText += `死のブロック: ${deathBlock.name}\n`;
    analysisText += `恵まれたブロック: ${blessedBlock.name}\n`;
    if (crushR1.length > 0) analysisText += `1回戦での有力校潰し合い:\n  - ${crushR1.join('\n  - ')}\n`;
    // ★ダークホース情報を追加
    if (nicheMatchups.length > 0) analysisText += `その他の注目カード（ダークホース・波乱枠）:\n${nicheMatchups.map(nm => `  - ${nm.block}ブロック: ${nm.match} (${nm.reason})`).join('\n')}\n`;

    let tournamentContextPrompt = "";
    if (currentTournament === 'summer') {
        tournamentContextPrompt = "3年生にとってはガチで最後の夏や。";
    } else if (currentTournament === 'summer_koshien') {
        tournamentContextPrompt = "全国の猛者が集う甲子園や。負けたら終わり。";
    } else if (currentTournament === 'autumn') {
        tournamentContextPrompt = "新チームの初陣やな。";
    } else if (currentTournament === 'spring') {
        tournamentContextPrompt = "夏のシード権がかかった前哨戦や。";
    }

    // ★★★ プロンプトに「Cランクへの反応」を具体的に追加 ★★★
    const prompt = `あなたは、匿名掲示板「なんでも実況J（なんJ）」の住民です。
${tournamentYear}年度 ${tournamentName}の組み合わせ抽選会が終わりました。
以下の詳細な分析結果を基に、**なんJらしいスレッドタイトル**と、そのスレッド内での**リアルタイムな反応コメントを20〜25個**生成してください。

### 大会の文脈
${tournamentContextPrompt}

### 組み合わせ分析結果
${analysisText}

### コメントの方向性 (重要)
- **全体感:** 「死のブロック」や「恵まれたブロック」の格差にツッコミを入れてください。
- **強豪:** 「1回戦の潰し合い」には、「もったいない」「いきなりクライマックス」と嘆いてください。
- **【★最重要：Cランク(中堅校)への反応】:** - 「その他の注目カード」に含まれる**Cランクチーム**に対しては、単なる弱小扱いではなく、**「こいつら地味に強いぞ」「シード校も油断したら喰われる」「今年のダークホース枠」**といった、**不気味さや波乱を期待するリアクション**を必ず複数含めてください。
  - 「Cランクをナメてると痛い目見るで」「〇〇（Cランク）はワンチャンある」といった、通好みの玄人コメントを混ぜてください。

### 出力形式 (JSON)
{
  "threadTitle": "（${tournamentName}組み合わせ決定www 死のブロックは〇〇！）",
  "comments": [
    {"personality": "1: 風吹けば名無し", "comment": "（スレ主のコメント）"},
    {"personality": "2: 風吹けば名無し", "comment": "（住民2のコメント）"}
    // ... (合計20〜25個のコメント) ...
  ]
}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const bbsJson = parseJsonFromText(rawText);
            
            if (bbsJson && bbsJson.threadTitle && Array.isArray(bbsJson.comments)) {
                return {
                    id: `bracket-thread-${Date.now()}`, 
                    title: bbsJson.threadTitle,
                    matchId: 'bracket', 
                    comments: bbsJson.comments.map((c, index) => ({ 
                        id: crypto.randomUUID(),
                        personality: c.personality || `${index + 1}: 風吹けば名無し`, 
                        text: c.comment,
                        timestamp: Date.now() + index * 10, 
                        replies: [] 
                    })),
                    timestamp: Date.now() 
                };
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI組み合わせ反応スレッドの生成に失敗しました:", error);
        return {
            error: true,
            title: "組み合わせスレッド生成エラー",
            body: "AIによるスレッド生成に失敗しました。", 
            timestamp: Date.now(),
            errorId: `bracket-thread-error-${Date.now()}` 
        };
    }
}// ▲▲▲ 置き換えここまで ▲▲▲

// ▼▼▼ 【新規追加】CPUチームの架空成績自動生成システム ▼▼▼

/**
 * [FIXED] チームにロスター（選手名簿）がなければ生成する
 * (★ランダム生成チームにもキャプテンを割り当てる修正版)
 */
function ensureCpuRoster(teamName) {
    const record = tournamentState.teamRecords[teamName];
    if (!record) return null;

    // 既にロスターが存在すれば、それを返す
    if (record.roster && record.roster.length > 0) {
        return record.roster;
    }

    let newRoster = [];

    // --- パターンA: マスタデータがある場合 (283学園など) ---
    if (TEAM_ROSTER_MASTER[teamName]) {
        const master = TEAM_ROSTER_MASTER[teamName];
        
        newRoster = master.map((p, index) => {
            const order = (index < 9) ? (index + 1).toString() : null;
            
            let posShort = p.position ? p.position.charAt(0) : '控';
            if (p.position && p.position.includes("外")) posShort = "中";
            if (p.position && p.position.includes("右")) posShort = "右";
            if (p.position && p.position.includes("左")) posShort = "左";
            if (p.position && p.position.includes("中")) posShort = "中";

            return {
                order: order,
                name: p.name,
                number: p.number,
                pos: posShort,
                throwBat: p.throwBat || 'R/R',
                sub_type: null,
                isCaptain: p.isCaptain || false // マスタ指定のキャプテンを反映
            };
        });
        
    } 
    // --- パターンB: マスタデータがない場合 (CPUランダム生成) ---
    else {
        // 1. 守備位置と背番号のペアを作成
        const positionSlots = [
            { pos: '投', num: 1 }, { pos: '捕', num: 2 }, { pos: '一', num: 3 },
            { pos: '二', num: 4 }, { pos: '三', num: 5 }, { pos: '遊', num: 6 },
            { pos: '左', num: 7 }, { pos: '中', num: 8 }, { pos: '右', num: 9 }
        ];

        // 2. 打順をランダムに決定
        const shuffledSlots = shuffleArray([...positionSlots]);

        // 3. 固定選手データの取得
        const detailedData = DETAILED_TEAM_DATA[teamName];
        let predefinedPlayers = [];
        if (detailedData && detailedData.players) {
            predefinedPlayers = [...detailedData.players];
        }

        // 4. スタメン生成
        for (let i = 1; i <= 9; i++) {
            let assignedSlot = null;
            let playerEntry;
            
            if (predefinedPlayers.length > 0) {
                const p = predefinedPlayers.shift();
                let posShort = p.position ? p.position.charAt(0) : '控';
                if (p.position && p.position.includes("外")) posShort = "中";
                
                const slotIndex = shuffledSlots.findIndex(s => s.pos === posShort);
                if (slotIndex !== -1) {
                    assignedSlot = shuffledSlots.splice(slotIndex, 1)[0];
                } else {
                    assignedSlot = shuffledSlots.shift();
                }

                playerEntry = {
                    order: i.toString(),
                    name: p.name,
                    number: assignedSlot ? assignedSlot.num : i, 
                    pos: posShort,
                    throwBat: 'R/R',
                    sub_type: null,
                    isCaptain: false // 後で設定
                };
            } else {
                assignedSlot = shuffledSlots.shift();
                playerEntry = {
                    order: i.toString(),
                    name: JAPANESE_SURNAMES[Math.floor(Math.random() * JAPANESE_SURNAMES.length)],
                    number: assignedSlot.num,
                    pos: assignedSlot.pos,
                    throwBat: Math.random() > 0.3 ? 'R/R' : 'L/L',
                    sub_type: null,
                    isCaptain: false // 後で設定
                };
            }
            newRoster.push(playerEntry);
        }
        
        // 5. 控え選手生成
        const benchPositions = [
            { pos: '投', num: 10 }, { pos: '投', num: 11 }, { pos: '捕', num: 12 },
            { pos: '一', num: 13 }, { pos: '二', num: 14 }, { pos: '三', num: 15 },
            { pos: '遊', num: 16 }, { pos: '左', num: 17 }, { pos: '中', num: 18 }
        ];

        for (const benchSlot of benchPositions) {
            let playerEntry;
            if (predefinedPlayers.length > 0) {
                const p = predefinedPlayers.shift();
                playerEntry = { 
                    order: null, name: p.name, number: benchSlot.num, pos: benchSlot.pos, 
                    throwBat: 'R/R', sub_type: null, isCaptain: false 
                };
            } else {
                playerEntry = { 
                    order: null, 
                    name: JAPANESE_SURNAMES[Math.floor(Math.random() * JAPANESE_SURNAMES.length)], 
                    number: benchSlot.num, pos: benchSlot.pos, 
                    throwBat: 'R/R', sub_type: null, isCaptain: false 
                };
            }
            newRoster.push(playerEntry);
        }

        // ★★★ 追加: スタメンの中からランダムに1人をキャプテンに任命 ★★★
        // (0〜8番目のインデックス = 打順1〜9番)
        const captainIndex = Math.floor(Math.random() * 9);
        if (newRoster[captainIndex]) {
            newRoster[captainIndex].isCaptain = true;
        }
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
    }

    // 保存して返す
    record.roster = newRoster;
    return newRoster;
}
/**
 * 【修正版】チームの過去試合（スキップ含む）の成績を自動生成する
 * ★四球(bb)や塁打数(tb)もシミュレートし、分析グラフを面白くする
 */
function backfillCpuStats(teamName) {
    const record = tournamentState.teamRecords[teamName];
    if (!record) return;

    // ロスター取得（なければ生成）
    const roster = ensureCpuRoster(teamName);
    
    // エース特定
    let acePitcher = roster.find(p => p.number === 1) || roster.find(p => p.pos === '投') || roster[0];

    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    Object.keys(allMatches).forEach(matchId => {
        const match = allMatches[matchId];
        
        // このチームが関わっていて、かつ勝敗が決まっている試合のみ
        if (match.winner && (match.team1 === teamName || match.team2 === teamName)) {

            // ★二重計上防止（詳細入力がある場合はスキップ）
            if (match.details && (match.details.batting?.team1?.length > 0 || match.details.batting?.team2?.length > 0)) {
                return; 
            }

            // ★二重計上防止（既にログがある場合はスキップ）
            let alreadyHasStats = false;
            if (record.playerStats?.batting) {
                for (const pName in record.playerStats.batting) {
                    if (record.playerStats.batting[pName].gamelogs?.some(l => l.matchId === matchId)) {
                        alreadyHasStats = true; break;
                    }
                }
            }
            if (alreadyHasStats) return;

            // --- 自動生成開始 ---
            if (!record.playerStats) record.playerStats = { batting: {}, pitching: {} };
            if (!record.tournamentStats) {
                record.tournamentStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0 };
            }
            
            // 投手用コンテナ初期化
            if (!record.playerStats.pitching[acePitcher.name]) {
                record.playerStats.pitching[acePitcher.name] = { 
                    career: { games:0, w:0, l:0, ip:0, so:0, er:0, h:0, bb:0 }, 
                    gamelogs: [], narrative_flag: 'normal' 
                };
            }

            const isWin = match.winner === teamName;
            const oppScore = parseInt(match.team1 === teamName ? match.score2 : match.score1) || 0;
            const myScore = parseInt(match.team1 === teamName ? match.score1 : match.score2) || 0;
            const opponentName = match.team1 === teamName ? match.team2 : match.team1;
            const roundName = getRoundNameFromMatchId(matchId);

            // A. 投手成績シミュレーション
            const ip = 9;
            const er = Math.max(0, oppScore - Math.floor(Math.random() * 2)); // 自責点は失点より少し少ない
            const hitsAllowed = Math.max(3, oppScore * 2 + Math.floor(Math.random() * 4));
            const so = Math.floor(Math.random() * 8) + 2;
            const bbAllowed = Math.floor(Math.random() * 5);
            
            const pLog = {
                matchId: matchId, date: match.schedule?.date || '日付不明', round: roundName,
                opponent: opponentName, opponentRank: calculateRank(opponentName, tournamentState),
                result: isWin ? 'W' : 'L', ip: ip, h: hitsAllowed, bb: bbAllowed, so: so, r: oppScore, er: er
            };
            
            record.playerStats.pitching[acePitcher.name].gamelogs.push(pLog);
            const pCareer = record.playerStats.pitching[acePitcher.name].career;
            pCareer.games = (pCareer.games || 0) + 1;
            if (isWin) pCareer.w++; else pCareer.l++;
            pCareer.ip = (pCareer.ip || 0) + ip;
            pCareer.er = (pCareer.er || 0) + er;
            pCareer.so = (pCareer.so || 0) + so;
            pCareer.h = (pCareer.h || 0) + hitsAllowed;
            pCareer.bb = (pCareer.bb || 0) + bbAllowed;

            // B. 打撃成績シミュレーション (★ここを強化)
            roster.forEach(batter => {
                if (batter.pos === '投') return; // 投手は省略(簡易化)
                
                if (!record.playerStats.batting[batter.name]) {
                    record.playerStats.batting[batter.name] = { games:0, pa:0, ab:0, h:0, hr:0, rbi:0, sb:0, bb:0, tb:0, gamelogs: [] };
                }
                
                const orderNum = parseInt(batter.order);
                const isCleanup = orderNum >= 3 && orderNum <= 5;
                const isLeadOff = orderNum === 1;

                // 打率設定 (勝利チームやクリーンナップは打つ)
                let hitProb = isWin ? 0.30 : 0.20;
                if (isCleanup) hitProb += 0.05;

                // ★四球率設定
                let walkProb = 0.08; 
                if (isLeadOff || isCleanup) walkProb += 0.05; // 1番とクリーンナップは選ぶ

                const pa = Math.floor(Math.random() * 2) + 3; // 3~5打席
                let h = 0, bb = 0, hr = 0, tb = 0, rbi = 0, sb = 0;

                for(let k=0; k < pa; k++) {
                    const rand = Math.random();
                    if (rand < hitProb) {
                        // ヒットの内訳抽選 (単打:70%, 二塁打:20%, 三塁打:2%, 本塁打:8%)
                        h++;
                        const hitType = Math.random();
                        if (hitType < 0.70) { tb += 1; } // Single
                        else if (hitType < 0.90) { tb += 2; } // Double
                        else if (hitType < 0.92) { tb += 3; } // Triple
                        else { tb += 4; hr++; } // HR
                    } else if (rand < hitProb + walkProb) {
                        bb++; // 四球
                    }
                }
                
                // 打点 (HRなら必ず入る + ランダム)
                if (hr > 0) rbi += hr + Math.floor(Math.random() * 2);
                else if (h > 0 && isCleanup && myScore > 0) rbi += Math.floor(Math.random() * 2);

                // 盗塁 (1番・2番は走りやすい)
                if ((h > 0 || bb > 0) && (orderNum <= 2 || Math.random() < 0.1)) {
                    if (Math.random() < 0.3) sb++;
                }

                const ab = pa - bb; // 打数 = 打席 - 四球

                const bLog = {
                    matchId: matchId, date: match.schedule?.date || '日付不明', round: roundName,
                    opponent: opponentName, opponentRank: calculateRank(opponentName, tournamentState),
                    order: batter.order, 
                    stats: { ab, h, hr, rbi, sb, bb, tb } // ★詳細データを保存
                };

                record.playerStats.batting[batter.name].gamelogs.push(bLog);
                
                const bCareer = record.playerStats.batting[batter.name];
                bCareer.games = (bCareer.games || 0) + 1;
                bCareer.pa = (bCareer.pa || 0) + pa;
                bCareer.ab = (bCareer.ab || 0) + ab;
                bCareer.h += h;
                bCareer.hr += hr;
                bCareer.rbi += rbi;
                bCareer.sb += sb;
                bCareer.bb = (bCareer.bb || 0) + bb; // ★四球を加算
                bCareer.tb = (bCareer.tb || 0) + tb; // ★塁打を加算

                // チーム合計にも加算
                record.tournamentStats.pa += pa;
                record.tournamentStats.ab += ab;
                record.tournamentStats.h += h;
                record.tournamentStats.hr += hr;
                record.tournamentStats.rbi += rbi;
                record.tournamentStats.sb += sb;
                record.tournamentStats.bb += bb;
                record.tournamentStats.tb += tb;
            });
        }
    });
}

/**
 * [UPDATED] 大会終了時に、全チームの最終順位を記録する
 * (★甲子園の場合はマイナスの値を記録して区別する)
 */
function updateTournamentFinishRecords() {
    const { matches, teams, currentTournament } = tournamentState;
    if (!teams || teams.length === 0) return;

    const numTeams = teams.length; 
    const finalRound = Math.log2(numTeams);
    
    // ★ 甲子園モードかどうか判定
    const isKoshien = (currentTournament === 'summer_koshien');

    // 敗者を特定するヘルパー
    const getRoundLosers = (round, side) => {
        const losers = [];
        const numMatches = (numTeams / 2) / Math.pow(2, round - 1); 
        for (let m = 1; m <= numMatches; m++) {
            const match = matches[`${side}-R${round}-M${m}`];
            if (match && match.winner) {
                const loser = match.winner === match.team1 ? match.team2 : match.team1;
                if (loser && loser !== '(BYE)') losers.push(loser);
            }
        }
        return losers;
    };

    const finalMatch = matches['F-R1-M1'];
    if (finalMatch && finalMatch.winner) {
        const winner = finalMatch.winner;
        const runnerUp = finalMatch.winner === finalMatch.team1 ? finalMatch.team2 : finalMatch.team1;
        
        // ★ 甲子園なら -1(優勝), -2(準優勝)。通常なら 1, 2
        if (winner && tournamentState.teamRecords[winner]) {
            tournamentState.teamRecords[winner].lastFinish = isKoshien ? -1 : 1;
        }
        if (runnerUp && tournamentState.teamRecords[runnerUp]) {
            tournamentState.teamRecords[runnerUp].lastFinish = isKoshien ? -2 : 2;
        }
    }

    // 準決勝以前の敗退順位を記録
    for (let r = finalRound - 1; r >= 1; r--) { 
        const finishRank = Math.pow(2, finalRound - r); // 4, 8, 16...
        
        // ★ 甲子園ならマイナスにする (例: -4, -8, -16...)
        const recordRank = isKoshien ? -finishRank : finishRank;
        
        getRoundLosers(r, 'L').concat(getRoundLosers(r, 'R')).forEach(t => {
            if (t && tournamentState.teamRecords[t]) {
                tournamentState.teamRecords[t].lastFinish = recordRank;
            }
        });
    }

    // 履歴(history)と最高成績(best)の更新
    Object.keys(tournamentState.teamRecords).forEach(team => {
        const record = tournamentState.teamRecords[team];
        if(!record.lastFinish) return;

        const newHistoryRecord = {
            year: tournamentState.tournamentYear,
            tournament: currentTournament,
            rank: record.lastFinish
        };

        if (!record.history) record.history = [];
        record.history.unshift(newHistoryRecord);

        // 最高成績の更新ロジック (マイナスの方が強い)
        if (!record.best) {
            record.best = newHistoryRecord;
        } else {
            const currentBestIsKoshien = record.best.rank < 0;
            const newIsKoshien = newHistoryRecord.rank < 0;

            if (newIsKoshien) {
                // 今回が甲子園記録の場合
                if (!currentBestIsKoshien) {
                    // 過去が県大会記録なら、問答無用で更新 (甲子園 > 県大会)
                    record.best = newHistoryRecord;
                } else {
                    // 過去も甲子園なら、数字が大きい方（絶対値が小さい方）が上 (-1 > -8)
                    if (newHistoryRecord.rank > record.best.rank) {
                        record.best = newHistoryRecord;
                    }
                }
            } else {
                // 今回が県大会記録の場合
                if (!currentBestIsKoshien) {
                    // 過去も県大会なら、数字が小さい方が上 (1 < 8)
                    if (newHistoryRecord.rank < record.best.rank) {
                        record.best = newHistoryRecord;
                    }
                }
                // 過去が甲子園なら更新しない
            }
        }
    });
}

/**
 * [NEW] ランク分布ピラミッドを描画する関数
 * チーム数に応じて幅が変わる「お腹の出たピラミッド」を生成します
 */
function renderRankPyramid() {
    const container = document.getElementById('rank-pyramid-container');
    if (!container) {
        console.warn("Rank pyramid container not found.");
        return;
    }

    // 1. 全チームのランクを集計
    const counts = { A: 0, B: 0, C: 0, D: 0, E: 0 };
    // TEAM_DATA が定義されていることを前提とします
    const allTeams = Object.keys(TEAM_DATA);
    
    allTeams.forEach(teamName => {
        // 現在のロジックでランクを判定 (tournamentStateが必要)
        const rank = calculateRank(teamName, tournamentState);
        if (counts[rank] !== undefined) {
            counts[rank]++;
        } else {
            // 万が一想定外のランクが返ってきた場合
            if (!counts['E']) counts['E'] = 0;
            counts['E']++; 
        }
    });

    // 2. 最大数を取得（グラフの横幅100%の基準にするため）
    const maxCount = Math.max(...Object.values(counts));

    // 3. HTML生成
    const ranks = ['A', 'B', 'C', 'D', 'E'];
    const labels = {
        A: 'A:名門', B: 'B:強豪', C: 'C:中堅', D: 'D:発展', E: 'E:挑戦'
    };
    // Tailwind CSSの色クラス
    const colors = {
        A: 'bg-red-500',     // 赤
        B: 'bg-orange-400',  // オレンジ
        C: 'bg-yellow-400',  // 黄色
        D: 'bg-blue-400',    // 青
        E: 'bg-gray-400'     // グレー
    };

    let html = '<div class="flex flex-col items-center w-full space-y-2">';

    ranks.forEach(rank => {
        const count = counts[rank];
        // 横幅の計算 (最大値を100%とし、最低でも10%は確保して見やすくする)
        // countが0の場合は幅0にする
        const widthPct = count > 0 ? Math.max(10, (count / maxCount) * 100) : 0;
        
        html += `
            <div class="w-full flex items-center justify-center text-xs group">
                <div class="w-16 text-right mr-2 font-semibold text-gray-600">${labels[rank]}</div>
                
                <div class="flex-grow flex justify-center h-6">
                    <div class="${colors[rank]} text-white font-bold rounded-sm flex items-center justify-center shadow-sm transition-all duration-500 relative" 
                         style="width: ${widthPct}%; height: 100%;">
                        ${count > 0 ? count : ''}
                        
                        <span class="absolute -top-8 left-1/2 transform -translate-x-1/2 bg-black text-white text-xs py-1 px-2 rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap z-10">
                            ${count}チーム
                        </span>
                    </div>
                </div>
                
                <div class="w-16 ml-2"></div>
            </div>
        `;
    });

    html += '</div>';
    
    // 合計チーム数
    html += `<div class="text-center text-xs text-gray-400 mt-3 border-t pt-2">総チーム数: ${allTeams.length}校</div>`;

    container.innerHTML = html;
}

// ▼▼▼ リアルタイム学校検索機能 (オートコンプリート) - 再整理版 ▼▼▼

const searchInput = document.getElementById('school-search-input');
const suggestionsList = document.getElementById('search-suggestions');

// 1. 文字入力時のイベント (リアルタイム検索)
searchInput.addEventListener('input', () => {
    const query = searchInput.value.trim().toLowerCase();
    
    if (!query) {
        suggestionsList.classList.add('hidden');
        suggestionsList.innerHTML = '';
        return;
    }

    const allTeams = [...new Set([...INITIAL_TEAM_POOL, ...Object.keys(TEAM_DATA)])];

    const matches = allTeams.filter(teamName => {
        const data = TEAM_DATA[teamName] || {};
        // 既存のフィルタリングロジック
        return (
            teamName.includes(query) || 
            (data.name_yomi && data.name_yomi.includes(query)) ||
            (data.region && data.region.includes(query)) ||
            (data.coach && data.coach.name && data.coach.name.includes(query)) 
        );
    }).slice(0, 10);

    // リストの描画 (この関数がメイン検索の表示専用となります)
    renderSchoolSearchSuggestions(matches, query);
});

// 2. 【メイン検索専用】候補リストを描画する関数
function renderSchoolSearchSuggestions(teams, query) {
    suggestionsList.innerHTML = '';

    if (teams.length === 0) {
        suggestionsList.classList.add('hidden');
        return;
    }

    teams.forEach(teamName => {
        const data = TEAM_DATA[teamName] || {};
        const region = data.region || '不明';
        const coach = data.coach ? data.coach.name : '';
        
        const li = document.createElement('li');
        li.className = 'suggestion-item';
        li.innerHTML = `
            <div>
                <span class="text-gray-800 font-medium">${highlightMatch(teamName, query)}</span>
                <span class="text-xs text-gray-500 ml-2">(${region})</span>
            </div>
            <div class="suggestion-meta">
                ${coach ? `監督: ${coach}` : ''}
            </div>
        `;

        // クリック時の動作 (★アーカイブモーダルを開く動作に固定)
        li.addEventListener('click', () => {
            searchInput.value = teamName;
            suggestionsList.classList.add('hidden');
            renderSchoolArchiveModal(teamName); 
        });

        suggestionsList.appendChild(li);
    });

    suggestionsList.classList.remove('hidden');
}


// 3. 検索キーワードをハイライト表示するヘルパー (定義が重複しないよう、グローバルに残す)

// 4. 外側をクリックしたらリストを閉じる
document.addEventListener('click', (e) => {
    if (!searchInput.contains(e.target) && !suggestionsList.contains(e.target)) {
        suggestionsList.classList.add('hidden');
    }
});

// 5. (既存) 検索ボタンクリック時の動作 (オートコンプリートを呼び出す)
document.getElementById('school-search-btn').addEventListener('click', () => {
    const query = searchInput.value.trim();
    if (!query) return;
    
    // 入力イベントを発火させてリアルタイム検索ロジックを呼び出す
    searchInput.dispatchEvent(new Event('input'));

    // 完全一致があればそれを優先 (既存ロジックを簡略化)
    const allTeams = [...new Set([...INITIAL_TEAM_POOL, ...Object.keys(TEAM_DATA)])];
    const match = allTeams.find(t => t === query); 
    if (match) {
         renderSchoolArchiveModal(match);
         suggestionsList.classList.add('hidden');
    }
});
// ▲▲▲ オートコンプリート機能 ここまで ▲▲▲



/**
 * 検索結果が複数の場合にリストを表示する関数
 */
function showSearchResultsList(teams, query) {
    const contentEl = document.getElementById('school-archive-content');
    const modal = document.getElementById('school-archive-modal');
    
    let html = `
        <div class="archive-header">
            <span class="archive-school-name">検索結果: "${query}"</span>
            <span class="archive-pref">${teams.length}件 ヒット</span>
        </div>
        <div class="mt-4">
            <ul class="search-result-list">
    `;

    teams.forEach(teamName => {
        const data = TEAM_DATA[teamName];
        const region = data.region || '不明';
        const rank = calculateRank(teamName, tournamentState);
        const coach = data.coach ? data.coach.name : '不明';

        // リストアイテムをクリックすると、その学校の詳細モーダルを開く
        // (onclick属性で関数を呼ぶ形にします)
        html += `
            <li class="search-result-item" onclick="document.getElementById('school-search-input').value='${teamName}'; document.getElementById('school-search-btn').click();">
                <div>
                    <span class="search-result-name">${teamName}</span>
                    <span class="search-result-tag">${region}</span>
                    <span class="search-result-tag bg-gray-100 text-gray-800">ランク${rank}</span>
                </div>
                <div class="search-result-info">
                    監督: ${coach} / 最高成績: ${data.best || '-'}
                </div>
            </li>
        `;
    });

    html += `
            </ul>
        </div>
    `;

    contentEl.innerHTML = html;
    modal.classList.remove('hidden');
    modal.classList.add('flex');
}
// ▲▲▲ 学校検索機能ここまで ▲▲▲

/**
 * [FIXED] チームの過去の試合結果から「勝ちパターン」と「チームカラー」を分析する
 * (★打率とOPSの両方を評価指標として計算する修正版)
 */
function analyzeTeamColor(teamName) {
    const record = tournamentState.teamRecords[teamName];
    if (!record || record.wins + (record.losses || 0) === 0) {
        return { primary: '不明', secondary: '不明', comment: '試合経験不足のため分析できません。' };
    }
    
    const analysis = {
        totalWins: record.wins || 0,
        comebackWins: 0,
        wireToWireWins: 0,
        totalTeamIP: 0,
        aceIP: 0,
        topRCShare: 0,
        offenseScore: 0,
        pitchingScore: 0,
        teamOPS: 0,
        teamAvg: 0 // ★追加
    };
    
    // --- 1. 依存度分析 (RCシェア) の計算 ---
    const aceName = record.roster?.find(p => p.number === 1)?.name || 'エース';
    let teamTotalRC = 0;
    
    const players = Object.keys(record.playerStats?.batting || {}).map(name => {
        const s = record.playerStats.batting[name];
        const h = s.h || 0; const bb = (s.bb || 0) + (s.hbp || 0);
        const ab = s.ab || 0; const hr = s.hr || 0;
        const tb = (s.tb || h) + (hr * 3);
        const times = ab + bb;
        let rc = times > 0 ? ((h + bb) * tb) / times : 0;
        rc = isNaN(rc) ? 0 : rc;
        teamTotalRC += rc;
        return { name, rc };
    }).sort((a, b) => b.rc - a.rc);

    if (players.length > 0 && teamTotalRC > 0) {
        analysis.topRCShare = (players[0].rc / teamTotalRC) * 100;
    }
    
    // 投手データの集計
    const pitchingStats = record.playerStats?.pitching || {};
    for (const name in pitchingStats) {
        const pStats = pitchingStats[name].career;
        if (pStats) {
            analysis.totalTeamIP += pStats.ip || 0;
            if (name === aceName) {
                analysis.aceIP = pStats.ip || 0;
            }
        }
    }
    
    // --- 2. 試合フロー分析 (変更なし) ---
    const allMatches = { ...tournamentState.matches, ...(tournamentState.autumnData?.allMatches || {}), ...(tournamentState.springData?.allMatches || {}) };
    Object.values(allMatches).forEach(match => {
        if (match.winner === teamName && match.details?.inningScore) {
            const inningScores = match.details.inningScore;
            const teamKey = match.team1 === teamName ? 'team1' : 'team2';
            const oppKey = teamKey === 'team1' ? 'team2' : 'team1';
            let scoreSelf = 0; let scoreOpp = 0;
            const inningsToCheck = Math.min(5, inningScores[teamKey].length);
            for (let i = 0; i < inningsToCheck; i++) {
                scoreSelf += parseInt(inningScores[teamKey][i] || 0);
                scoreOpp += parseInt(inningScores[oppKey][i] || 0);
            }
            if (scoreSelf < scoreOpp) analysis.comebackWins++;
            else if (scoreSelf > scoreOpp || inningsToCheck === 0) analysis.wireToWireWins++;
        }
    });

    // --- 3. ドミナンス分析 (打率とOPSの計算) ---
    const ts = record.tournamentStats || {};
    const tab = ts.ab || 0;
    const th = ts.h || 0; 
    const tbb = (ts.bb || 0) + (ts.hbp || 0); 
    const tsf = ts.sf || 0;
    
    // 打率
    analysis.teamAvg = tab > 0 ? th / tab : 0;

    // OPS
    const tpa = tab + tbb + tsf;
    const tobp = tpa > 0 ? (th + tbb) / tpa : 0;
    const safeTB = ts.tb || (th + (ts.hr || 0) * 3);
    const safeSLG = tab > 0 ? safeTB / tab : 0;
    analysis.teamOPS = tobp + safeSLG;

    const teamERA = calculateTeamPitchingStats(teamName).era === "----" ? 9.99 : parseFloat(calculateTeamPitchingStats(teamName).era);
    
    // 攻撃スコア (OPSと打率の両方を加味)
    analysis.offenseScore = (analysis.teamOPS * 70) + (analysis.teamAvg * 30); 
    analysis.pitchingScore = (10 - teamERA) * 10; 

    // 4. 分類とコメント生成
    let color = { primary: '', secondary: '' };
    let narrative = { primary: '', secondary: '' };
    
    if (analysis.pitchingScore > 70 && analysis.teamOPS < 0.700) {
        color.primary = '守備勝利型';
        narrative.primary = `防御率${teamERA.toFixed(2)}を誇る投手力を軸に、少ない得点を守り切るスタイルです。`;
    } else if (analysis.teamOPS >= 0.850) {
        color.primary = '破壊的打撃型';
        narrative.primary = `チームOPS ${analysis.teamOPS.toFixed(3)} という圧倒的な破壊力を持ち、長打で相手を粉砕します。`;
    } else if (analysis.teamAvg >= 0.350) { // ★高打率チームの判定を追加
        color.primary = '安打製造機型';
        narrative.primary = `チーム打率 ${analysis.teamAvg.toFixed(3)} という高確率なコンタクト能力で、連打を重ねて得点します。`;
    } else if (analysis.aceIP / analysis.totalTeamIP >= 0.70 && analysis.totalTeamIP > 5) {
        color.primary = 'エース依存型';
        narrative.primary = `エースの投球回が全体の7割以上を占めています。`;
    } else {
        color.primary = '総合力型';
        narrative.primary = `投打に大きな偏りがなく、バランスの取れたチームです。`;
    }
    
    // (Secondary Colorのロジックはそのまま)
    const comebackPct = analysis.comebackWins / analysis.totalWins;
    if (analysis.totalWins === 0) { color.secondary = '不明'; narrative.secondary = 'まだ勝利経験がありません。'; }
    else if (comebackPct >= 0.30) { color.secondary = '終盤追い上げ型'; narrative.secondary = `勝利の約${Math.round(comebackPct * 100)}%が逆転劇。粘り強さが強みです。`; }
    else if (analysis.wireToWireWins / analysis.totalWins >= 0.70) { color.secondary = '先行逃げ切り型'; narrative.secondary = `勝利の7割が先行逃げ切り。序盤のリードを守り切る展開が得意です。`; }
    else { color.secondary = '試合展開不定'; narrative.secondary = `対戦相手によって柔軟に試合展開を変えることができます。`; }
    
    return {
        id: teamName,
        classification: color,
        stats: { ops: analysis.teamOPS, avg: analysis.teamAvg, era: teamERA }, // ★両方返す
        narrative: {
            primary: narrative.primary,
            secondary: narrative.secondary,
            comment: `【チームカラー】: 主に「${color.primary}」であり、「${color.secondary}」の勝ちパターンを持ちます。`
        }
    };
}

/**
 * [UPDUPDATED] 学校アーカイブモーダルを描画するメイン関数 (AI分析実行ボタンを追加)
 */
async function renderSchoolArchiveModal(teamName) {
    const contentEl = document.getElementById('school-archive-content');
    const teamData = TEAM_DATA[teamName];
    const teamRecord = tournamentState.teamRecords[teamName];
    
    if (!teamData || !teamRecord) return;

    // --- HTML初期構築 ---
    let html = `
        <div class="archive-header">
            <span class="archive-school-name">${teamName}</span>
            <span class="archive-pref">(${teamData.region}地区)</span>
        </div>

        <div class="archive-section-title">概要</div>
        <div class="result-summary-box">
            <div class="result-summary-row">
                <dt class="result-summary-dt">最高成績</dt>
                <dd class="result-summary-dd">${teamRecord.best ? formatRecordToString(teamRecord.best) : "なし"}</dd>
            </div>
            <div class="result-summary-row">
                <dt class="result-summary-dt">通算勝敗</dt>
                <dd class="result-summary-dd">${teamRecord.wins || 0}勝 ${teamRecord.losses || 0}敗</dd>
            </div>
            <div class="result-summary-row">
                <dt class="result-summary-dt">チーム特徴</dt>
                <dd class="result-summary-dd">${teamData.info || '情報なし'}</dd>
            </div>
            <div class="result-summary-row">
                <dt class="result-summary-dt">監督</dt>
                <dd class="result-summary-dd">${teamData.coach?.name || '不明'} (${teamData.coach?.style || ''})</dd>
            </div>
        </div>

        <div class="archive-section-title">今大会のチーム分析</div>
        <div id="archive-ai-analysis-container" class="p-3 border rounded-lg bg-gray-50 text-gray-700 leading-relaxed">
            <div id="archive-ai-analysis" class="text-sm">
                <p class="text-center text-gray-500">ボタンを押して、最新の戦況をAIに分析させます。</p>
            </div>
            <button id="run-archive-analysis-btn" 
                    data-team-name="${teamName}"
                    class="mt-2 w-full bg-blue-600 text-white font-bold py-1 px-3 rounded text-sm hover:bg-blue-700">
                AI分析を実行
            </button>
        </div>
        <div class="archive-section-title">直近3大会の成績</div>
        <ul class="history-list">
            ${(teamRecord.history || []).slice(0, 3).map(h => `
                <li class="history-item">
                    <span class="history-year">${h.year}年 ${tournamentNameMap[h.tournament] || h.tournament}</span>
                    <span class="history-rank">${getRankString(h.rank)}</span>
                </li>
            `).join('')}
        </ul>

        <div class="archive-section-title">全試合結果一覧</div>
        <div class="archive-sub-title">
            <h3>最新の試合結果</h3>
            <ul class="flex space-x-4 text-sm font-normal ml-4 mt-1">
                <li><span class="text-red-600 font-bold">🔴</span> 勝ち</li>
                <li><span class="text-blue-600 font-bold">🔵</span> 負け</li>
            </ul>
        </div>

        <div class="overflow-x-auto">
            <table class="record-table">
                <thead>
                    <tr>
                        <th>年</th>
                        <th>大会</th>
                        <th>回戦</th>
                        <th>対戦校</th>
                        <th>スコア</th>
                        <th>勝敗</th>
                    </tr>
                </thead>
                <tbody>
    `;

    // 試合履歴のテーブル行の生成
    const allMatches = getRecentMatchesForTeam(teamName, 1000); 
    if (allMatches.length > 0) {
        allMatches.forEach(match => {
            const resultClass = match.isWin ? 'result-win' : 'result-lose';
            const resultText = match.isWin ? '勝ち' : '負け';
            const resultIcon = match.isWin ? '🔴' : '🔵'; 

            html += `
                <tr>
                    <td>${match.year}</td>
                    <td>${match.tournamentName}</td>
                    <td>${match.roundName}</td>
                    <td class="opponent-cell clickable-team-name cursor-pointer text-blue-600 hover:underline" data-team-name="${match.opponent}">
                        ${match.opponent}
                    </td>
                    <td class="score-cell">${match.scoreResult}</td>
                    <td class="${resultClass}">${resultIcon} ${resultText}</td>
                </tr>
            `;
        });
    } else {
        html += `<tr><td colspan="6" class="text-gray-500">試合データがありません</td></tr>`;
    }

    html += `
                </tbody>
            </table>
        </div>
    `;

    contentEl.innerHTML = html;
    
    // モーダル表示
    const modal = document.getElementById('school-archive-modal');
    modal.classList.remove('hidden');
    modal.classList.add('flex');
}
    // ★★★ 【重要修正】リスナー登録は、DOMに要素が追加された後、setTimeoutの外で行う ★★★
    
    
    
/**
 * [NEW] AI分析を実際に実行し、結果をモーダルに挿入する関数
 */
async function runArchiveAnalysis(teamName) {
    const container = document.getElementById('archive-ai-analysis-container');
    const analysisEl = document.getElementById('archive-ai-analysis');
    const runBtn = document.getElementById('run-archive-analysis-btn');

    if (!analysisEl || !runBtn || !container) return;
    
    analysisEl.innerHTML = '<div class="loader">AIが今大会の状況を分析中...</div>';
    container.classList.remove('bg-gray-50', 'bg-red-100');
    container.classList.add('bg-white'); 
    runBtn.disabled = true;

    try {
        const analysisResult = await generateArchiveAnalysis(teamName);

        if (analysisResult.includes('AIによる分析に失敗') || analysisResult.includes('コンテキスト情報が不足')) {
             analysisEl.innerHTML = `
                <p class="text-red-700 font-bold">分析失敗: データ不足</p>
                <p class="text-sm text-gray-700 mt-2">理由：**注目選手が不足**しています。分析には**最低10打席以上**の打者が必要です。</p>
                <p class="text-xs text-gray-600 mt-2">💡 数試合スキップした後、手動で**「詳細入力（🎲）」**を使い、選手の打席数を増やしてから再実行してください。</p>
                `;
             container.classList.remove('bg-white');
             container.classList.add('bg-red-100');
        } else {
            analysisEl.innerHTML = analysisResult.replace(/\n/g, '<br>'); // 改行を反映
             container.classList.remove('bg-white');
             container.classList.add('bg-green-50');
        }
    } catch (error) {
        console.error("Archive Analysis Runtime Error:", error);
        analysisEl.innerHTML = `<p class="text-red-700">分析中に致命的なエラーが発生しました。</p>`;
        container.classList.remove('bg-white');
        container.classList.add('bg-red-100');
    } finally {
        runBtn.disabled = false;
    }
}
/**
 * [FIXED] AIが現在のチームのトーナメント状況を分析し、次戦の勝敗予想を含めたレポートを生成する
 * (★自チームと敵チームの「5大指標（打率・HR・打点・盗塁・OPS）」と打順を網羅して比較する完全版)
 */
async function generateArchiveAnalysis(teamName) {
    const record = tournamentState.teamRecords[teamName];
    // データチェック
    if (!record || !record.tournamentStats || (record.tournamentStats.pa || 0) < 1) {
        return 'チームの成績データが不足しています。（試合数が少ないか、詳細入力が行われていません）';
    }
    
    // ★★★ 重要：teamDataの定義 ★★★
    const teamData = TEAM_DATA[teamName];
    if (!teamData) return 'チームデータが見つかりません。';

    // --- 1. ヘルパー：チームの詳細データを収集する関数 ---
    const getDetailedTeamInfo = (targetName) => {
        const tr = tournamentState.teamRecords[targetName];
        if (!tr || !tr.tournamentStats) return null;
        const td = TEAM_DATA[targetName];

        // (A) チーム攻撃力 (5大指標)
        const ts = tr.tournamentStats;
        const tab = ts.ab || 0;
        const tavg = tab > 0 ? (ts.h / tab).toFixed(3) : '.000';
        
        const t_h = ts.h || 0; const t_bb = (ts.bb || 0) + (ts.hbp || 0); const t_sf = ts.sf || 0;
        const t_tb = ts.tb || (t_h + (ts.hr || 0) * 3);
        const tpa = tab + t_bb + t_sf;
        const tobp = tpa > 0 ? (t_h + t_bb) / tpa : 0;
        const tslg = tab > 0 ? t_tb / tab : 0;
        const tops = (tobp + tslg).toFixed(3);
        
        const t_hr = ts.hr || 0;
        const t_rbi = ts.rbi || 0;
        const t_sb = ts.sb || 0;

        // ARC/G (相手ランク補正付き得点力)
        let totalRC = 0;
        let players = []; // スタメン候補リスト

        if (tr.playerStats?.batting) {
            Object.entries(tr.playerStats.batting).forEach(([name, s]) => {
                // スタメン回数集計
                let startCount = 0;
                let typicalOrder = 99;
                if (s.gamelogs) {
                    const orderCounts = {};
                    s.gamelogs.forEach(log => {
                        if (log.order && !log.order.toString().includes('sub')) {
                            const ord = parseInt(log.order);
                            if (!isNaN(ord)) { orderCounts[ord] = (orderCounts[ord] || 0) + 1; startCount++; }
                        }
                    });
                    let maxCount = -1;
                    for (const [ord, count] of Object.entries(orderCounts)) {
                        if (count > maxCount) { maxCount = count; typicalOrder = parseInt(ord); }
                    }
                }

                // スタメン経験あり or 1打席以上
                if (startCount > 0 || (s.pa || 0) >= 1) {
                    const p_h = s.h||0; const p_bb=(s.bb||0)+(s.hbp||0); const p_ab=s.ab||0;
                    const p_tb = (s.tb||p_h) + (s.hr||0)*3;
                    const p_times = p_ab + p_bb;
                    let p_rc = p_times > 0 ? ((p_h + p_bb) * p_tb) / p_times : 0;
                    p_rc = isNaN(p_rc) ? 0 : p_rc;
                    totalRC += p_rc;
                    
                    // ★ 個人成績リスト作成 (5大指標を含む)
                    players.push({ 
                        name, typicalOrder,
                        ops: parseFloat(calculateOps(s)), 
                        rc: p_rc, 
                        hr: s.hr || 0, 
                        rbi: s.rbi || 0, 
                        sb: s.sb || 0, 
                        avg: (s.ab > 0 ? s.h/s.ab : 0).toFixed(3) 
                    });
                }
            });
        }
        
        const totalGames = players.length > 0 ? Math.max(1, tr.wins + tr.losses) : 1;
        const rawRCG = totalGames > 0 ? totalRC / totalGames : 0;
        const arcg = calculateAdjustedRCG(targetName, rawRCG).toFixed(2);

        // (B) 投手力
        const tp = calculateTeamPitchingStats(targetName);

        // (C) チームカラー
        const tc = analyzeTeamColor(targetName);
        
        // (D) 打順リスト生成 (打順順にソート)
        players.sort((a, b) => a.typicalOrder - b.typicalOrder);
        
        // ★ 打順付きの詳細リスト (上位だけでなくスタメン全員分)
        const lineupList = players.filter(p => p.typicalOrder <= 9).map(p => 
            `- 【${p.typicalOrder}番】${p.name}: 打率${p.avg}, ${p.hr}本, ${p.rbi}打点, ${p.sb}盗塁, OPS${p.ops.toFixed(3)}`
        ).join('\n  ') || "（スタメンデータなし）";
        
        // 構造分析
        const topBatter = players.reduce((prev, cur) => (prev.rc > cur.rc) ? prev : cur, {rc: 0, name: 'なし'});
        const share = (topBatter.rc > 0 && totalRC > 0) ? (topBatter.rc / totalRC) * 100 : 0;
        let structure = share >= 35 ? `ワンマン型(${topBatter.name}依存${share.toFixed(0)}%)` : `分散型(トップ依存${share.toFixed(0)}%)`;

        // (E) 投手陣詳細
        let pDetails = [];
        if (tr.playerStats?.pitching) {
            Object.entries(tr.playerStats.pitching).forEach(([name, ps]) => {
                const logs = ps.gamelogs || [];
                if(logs.length > 0) {
                    const stats = logs.reduce((a, l) => { 
                        a.ip += parseFloat(l.ip||0); a.er+=parseInt(l.er||0); a.so+=parseInt(l.so||0); 
                        if(l.result === 'W') a.wins++; if(l.result === 'L') a.losses++;
                        return a; 
                    }, {ip:0, er:0, so:0, wins:0, losses:0});
                    if(stats.ip >= 5) { // 5回以上
                        const era = stats.ip>0 ? ((stats.er*9)/stats.ip).toFixed(2) : "0.00";
                        const k9 = stats.ip>0 ? ((stats.so*9)/stats.ip).toFixed(2) : "0.00";
                        pDetails.push({ name, ...stats, era, k9 });
                    }
                }
            });
        }
        pDetails.sort((a, b) => b.ip - a.ip);
        const pDetailsText = pDetails.map(p => 
            `- ${p.name}: 防御率${p.era}, ${p.wins}勝${p.losses}敗, ${p.ip.toFixed(1)}回, ${p.so}奪三振 (K/9 ${p.k9})`
        ).join('\n  ') || "（詳細データなし）";

        // (F) 軌跡
        const journey = getCurrentTournamentPerformance(targetName, 'analysis') || '初戦';

        return {
            name: targetName,
            rank: calculateRank(targetName, tournamentState),
            style: td?.coach?.style || '不明',
            avg: tavg, ops: tops, arcg: arcg, 
            hr: t_hr, rbi: t_rbi, sb: t_sb, // ★ チーム合計値
            era: tp.era,
            color: `${tc.classification.primary}`,
            structure: structure,
            lineup: lineupList, // ★ 打順リスト (5大指標付き)
            pitchers: pDetailsText,
            journey: journey
        };
    };

    // --- 2. 自チームのデータ取得 ---
    const myData = getDetailedTeamInfo(teamName);

    // --- 3. 対戦相手の特定とデータ取得 ---
    let targetMatchId = null;
    let nextOpponentName = null;
    
    const allMatches = { ...tournamentState.matches, ...(tournamentState.autumnData?.allMatches || {}), ...(tournamentState.springData?.allMatches || {}) };
    // 未消化の試合を探す
    const nextMatch = Object.values(allMatches).find(m => !m.winner && (m.team1 === teamName || m.team2 === teamName));

    if (nextMatch) {
        targetMatchId = nextMatch.id;
        nextOpponentName = (nextMatch.team1 === teamName) ? nextMatch.team2 : nextMatch.team1;
    }

    let opponentData = null;
    let isMatchDecided = false;
    let opponentName = nextOpponentName;

    // 相手が決まっていて、かつダミーでない場合
    if (opponentName && opponentName !== '（未定）' && opponentName !== '(BYE)' && opponentName !== '優勝' && opponentName !== '大会終了') {
        // 相手チームのデータがない場合は自動生成して埋める
        backfillCpuStats(opponentName);
        opponentData = getDetailedTeamInfo(opponentName);
        isMatchDecided = true;
    }

    // --- 4. プロンプトの作成 ---
    let prompt = `あなたは高校野球のデータアナリストです。
チーム「${teamName}」の現状分析${isMatchDecided ? `と、次戦の相手「${opponentName}」との徹底的な戦力比較` : ''}を行ってください。

### 【自チーム】${myData.name} (${myData.rank}ランク)
- **チーム攻撃力**: 打率${myData.avg}, 本塁打${myData.hr}, 打点${myData.rbi}, 盗塁${myData.sb}, OPS${myData.ops}, ARC/G(補正得点力)${myData.arcg}
- **チーム守備力**: 防御率${myData.era}
- **チームカラー**: ${myData.color} (${myData.structure})
- **軌跡**: ${myData.journey}
#### スタメン打順データ (5大指標)
  ${myData.lineup}
#### 投手陣詳細
  ${myData.pitchers}
`;

    if (isMatchDecided && opponentData) {
        prompt += `
### 【次戦の相手】${opponentData.name} (${opponentData.rank}ランク)
- **チーム攻撃力**: 打率${opponentData.avg}, 本塁打${opponentData.hr}, 打点${opponentData.rbi}, 盗塁${opponentData.sb}, OPS${opponentData.ops}, ARC/G(補正得点力)${opponentData.arcg}
- **チーム守備力**: 防御率${opponentData.era}
- **チームカラー**: ${opponentData.color} (${opponentData.structure})
- **軌跡**: ${opponentData.journey}
#### スタメン打順データ (5大指標)
  ${opponentData.lineup}
#### 投手陣詳細
  ${opponentData.pitchers}
`;
    } else {
        prompt += `\n### 次戦の相手\nまだ決定していません（${opponentName || '未定'}）。\n`;
    }

    prompt += `
### 指示
1.  **現状分析**: 自チームの「5大指標（打率・本塁打・打点・盗塁・OPS）」に基づき、攻撃の特色（長打力重視か、機動力重視かなど）を評価してください。打順ごとの役割機能（1番の出塁、クリーンナップの決定力）にも触れてください。
`;

    if (isMatchDecided) {
        prompt += `2.  **【最重要】戦力比較シミュレーション**:
    - **打線 vs 投手**: 「${myData.name}打線 vs ${opponentData.name}投手陣」の相性を分析してください。相手エースの攻略難易度は？
    - **打順比較**: 両チームの「1番打者」や「4番打者」や全体的な打線の成績（OPS, 打点など）を比較し、どちらが攻撃の起点・決定として優秀か論じてください。
    - **攻略法**: 相手のデータ（防御率、打順の穴、盗塁数など）に基づき、具体的な攻略プランを提案してください。
3.  **【勝敗予想】**:
    - ズバリ、**${teamName}の勝率（％）**を予想し、その根拠を述べてください。
    - 「有利（60%以上）」「五分（45-55%）」「劣勢（40%以下）」のいずれかを明言してください。
`;
    } else {
        const currentRank = calculateRank(teamName, tournamentState);
        let goalQuestion = "上位進出";
        if(currentRank === 'A') goalQuestion = "全国制覇";
        else if(currentRank === 'B') goalQuestion = "県制覇";
        else if(currentRank === 'C') goalQuestion = "ベスト8";
        else goalQuestion = "トーナメント勝ち上がり";
        
        prompt += `2.  **目標達成度**: ランク(${currentRank})に基づき、現在のチーム状況で「${goalQuestion}」が可能か評価してください。\n`;
    }

    prompt += `### 出力形式: JSON {"body": "（分析コラム本文）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        const aiData = parseJsonFromText(result.candidates[0].content.parts[0].text);
        
        return aiData?.body || 'AIによる分析に失敗しました。';
    } catch (error) {
        console.error("AI archive analysis failed:", error);
        return '分析エラーが発生しました。';
    }
}

/**
 * [NEW] チームのセイバーメトリクス指標を計算し、ダッシュボードHTMLを生成する
 */
function generateSabermetricsHTML(teamName) {
    const record = tournamentState.teamRecords[teamName];
    if (!record || !record.playerStats) return '<p class="text-xs text-center text-gray-400">データ不足のため分析できません</p>';

    // --- 1. データ集計 ---
    let totalAB = 0, totalTB = 0, totalH = 0, totalBB_Bat = 0, totalSO_Bat = 0; // 打撃
    let totalIP = 0, totalH_Pit = 0, totalBB_Pit = 0, totalRunsAllowed = 0; // 投手
    let totalRunsScored = record.tournamentStats?.r || 0; // 得点はtournamentStatsから取得 (簡易)

    // 打撃集計 (IsoP, BB/K用)
    if (record.playerStats.batting) {
        Object.values(record.playerStats.batting).forEach(s => {
            totalAB += s.ab || 0;
            totalH += s.h || 0;
            const hr = s.hr || 0;
            // TB(塁打)がない場合は簡易計算
            totalTB += (s.tb || (s.h + hr * 3)); 
            totalBB_Bat += (s.bb || 0) + (s.hbp || 0);
            totalSO_Bat += s.so || 0;
            // もしtournamentStatsの得点が0なら、個人の打点合計で代用（簡易）
            if(totalRunsScored === 0) totalRunsScored += (s.rbi || 0);
        });
    }

    // 投手集計 (WHIP, Pythagenpat用)
    if (record.playerStats.pitching) {
        Object.values(record.playerStats.pitching).forEach(s => {
            if (s.career) {
                totalIP += s.career.ip || 0;
                totalH_Pit += s.career.h || 0;
                totalBB_Pit += s.career.bb || 0;
                totalRunsAllowed += s.career.r || s.career.er || 0; // 失点
            }
        });
    }

    // --- 2. 指標計算 ---

    // A. IsoP (Isolated Power) = 長打率 - 打率
    // 「純粋な長打力」を示す。0.200超えれば優秀。
    const avg = totalAB > 0 ? totalH / totalAB : 0;
    const slg = totalAB > 0 ? totalTB / totalAB : 0;
    const isoP = slg - avg;

    // B. BB/K (Walks per Strikeout) = 四球 / 三振
    // 「選球眼とアプローチ」を示す。1.00超えれば優秀。
    const bbK = totalSO_Bat > 0 ? totalBB_Bat / totalSO_Bat : 0;

    // C. WHIP (Walks plus Hits per Inning Pitched) = (被安打 + 与四球) / 投球回
    // 「投手の安定感」を示す。1.20未満なら優秀。
    const whip = totalIP > 0 ? (totalH_Pit + totalBB_Pit) / totalIP : 0;

    // D. Pythagorean Expectation (ピタゴラス勝率) = 得点^2 / (得点^2 + 失点^2)
    // 「得失点差から見た本来の実力」。実際の勝率より高ければ「不運」、低ければ「幸運」。
    // ※高校野球用に指数を1.83ではなく2.0（古典的）または少し調整して計算
    const exponent = 1.83; 
    const pythWinPct = (totalRunsScored === 0 && totalRunsAllowed === 0) ? 0 
        : (Math.pow(totalRunsScored, exponent)) / (Math.pow(totalRunsScored, exponent) + Math.pow(totalRunsAllowed, exponent));
    
    // 実際の勝率
    const totalGames = (record.wins + record.losses) || 1;
    const actualWinPct = record.wins / totalGames;
    const luckDiff = actualWinPct - pythWinPct; // 正なら運が良い、負なら実力以下

    // --- 3. 表示用ヘルパー ---
    const getColor = (val, type) => {
        if (type === 'isop') return val >= 0.2 ? 'val-excellent' : val >= 0.15 ? 'val-good' : 'val-poor';
        if (type === 'bbk') return val >= 1.0 ? 'val-excellent' : val >= 0.7 ? 'val-good' : 'val-poor';
        if (type === 'whip') return val > 0 && val < 1.10 ? 'val-excellent' : val < 1.30 ? 'val-good' : 'val-poor';
        if (type === 'pyth') return Math.abs(val) >= 0.2 ? 'val-excellent' : 'val-poor'; // 乖離が大きいかどうか
        return 'val-poor';
    };

    // HTML生成
    return `
        <div class="saber-grid">
            <div class="saber-card">
                <div class="saber-title">IsoP (純粋長打力)</div>
                <div class="saber-value ${getColor(isoP, 'isop')}">${isoP.toFixed(3)}</div>
                <div class="saber-desc">打率を除いた長打の割合。<br>0.200超でスラッガー級。</div>
            </div>
            
            <div class="saber-card">
                <div class="saber-title">BB/K (選球眼)</div>
                <div class="saber-value ${getColor(bbK, 'bbk')}">${bbK.toFixed(2)}</div>
                <div class="saber-desc">四球÷三振。<br>1.00超で極めて優秀。</div>
            </div>
            
            <div class="saber-card">
                <div class="saber-title">WHIP (投手安定感)</div>
                <div class="saber-value ${getColor(whip, 'whip')}">${whip.toFixed(2)}</div>
                <div class="saber-desc">1回あたりに出す走者数。<br>1.20未満でエース級。</div>
            </div>
            
            <div class="saber-card">
                <div class="saber-title">ピタゴラス勝率</div>
                <div class="saber-value">${(pythWinPct * 100).toFixed(1)}%</div>
                <div class="saber-desc" style="color: ${luckDiff > 0 ? '#f59e0b' : '#3b82f6'};">
                    実際勝率: ${(actualWinPct*100).toFixed(1)}%<br>
                    (${luckDiff > 0 ? '運で勝利 +' : '実力以下 '}${(Math.abs(luckDiff)*100).toFixed(1)}%)
                </div>
            </div>
        </div>
        <div class="text-right mt-1">
            <span class="text-xs text-gray-400">※得失点: ${totalRunsScored}得点 / ${totalRunsAllowed}失点</span>
        </div>
    `;
}

/**
 * チームの直近N試合の履歴を取得する
 * @param {string} teamName - チーム名
 * @param {number} limit - 取得数 (デフォルト5, アーカイブ表示時は大きく設定)
 * @returns {Array} - フォーマット済みの試合データ配列
 */
function getRecentMatchesForTeam(teamName, limit = 5) {
    const history = [];
    const state = tournamentState;
    const currentYear = state.tournamentYear;

    // 1. データソースの定義 (優先度順: 現在 > 春 > 秋)
    // ※実際の時系列は 秋(前年) -> 春 -> 夏 ですが、表示上は新しい順に並べたいのでこの順序で走査します
    const sources = [
        { label: tournamentNameMap[state.currentTournament], year: currentYear, matches: state.matches, weight: 300 },
        { label: '春季大会', year: currentYear, matches: state.springData?.allMatches, weight: 200 },
        { label: '秋季大会', year: currentYear - 1, matches: state.autumnData?.allMatches, weight: 100 }
    ];

    sources.forEach(source => {
        if (!source.matches) return;
        
        Object.values(source.matches).forEach(match => {
            // 勝敗が決まっており、かつ対象チームが関わっている試合
            if (match.winner && (match.team1 === teamName || match.team2 === teamName)) {
                
                // BYE(不戦勝)は除外する
                if (match.team1 === '(BYE)' || match.team2 === '(BYE)') return;

                const isTeam1 = match.team1 === teamName;
                const opponent = isTeam1 ? match.team2 : match.team1;
                const myScore = isTeam1 ? match.score1 : match.score2;
                const oppScore = isTeam1 ? match.score2 : match.score1;
                const isWin = match.winner === teamName;
                
                // ラウンド名の数値化 (ソート用)
                let roundVal = 0;
                if (match.id.startsWith('F-')) roundVal = 100; // 決勝
                else if (match.id.includes('-R')) {
                    roundVal = parseInt(match.id.split('-R')[1].split('-')[0]);
                }

                // 試合オブジェクトを作成
                history.push({
                    matchId: match.id,
                    tournamentName: source.label,
                    year: source.year,
                    roundName: getRoundNameFromMatchId(match.id),
                    opponent: opponent,
                    scoreResult: `${myScore}-${oppScore}`,
                    result: isWin ? '○' : '●',
                    isWin: isWin,
                    // ソート用スコア: (大会の重み * 1000) + ラウンド番号
                    sortKey: (source.weight * 1000) + roundVal
                });
            }
        });
    });

    // 2. ソート (新しい順 = sortKeyの降順)
    history.sort((a, b) => b.sortKey - a.sortKey);

    // 3. 最新N件を返す
    return history.slice(0, limit);
}

// ▼▼▼ アーカイブモーダル関連のイベントリスナー ▼▼▼

// 1. モーダルを閉じるボタン
document.getElementById('school-archive-close-btn').addEventListener('click', () => {
    document.getElementById('school-archive-modal').classList.add('hidden');
    document.getElementById('school-archive-modal').classList.remove('flex');
});

// 2. アーカイブ内の対戦校リンクをクリックした時の処理（再帰的にモーダルを更新）
document.getElementById('school-archive-content').addEventListener('click', (e) => {
    if (e.target.classList.contains('clickable-team-name')) {
        const teamName = e.target.dataset.teamName;
        renderSchoolArchiveModal(teamName);
    }
});


// ▼▼▼ ラウンドスキップ新聞生成用の関数群 (ここから追加) ▼▼▼

/**
 * [UPDATED] スキップしたラウンドの結果を基に、新聞モーダルを生成・表示・保存する
 * (★チーム数に応じてラウンド名を動的に判定)
 */
async function generateSkipRoundNewspaper(roundNumber, results) {
    const modal = document.getElementById('skip-newspaper-modal');
    const bodyEl = document.getElementById('skip-newspaper-body');
    const dateEl = document.getElementById('skip-newspaper-date');
    const topTitleEl = document.getElementById('skip-newspaper-top-title');
    const resultsTitleEl = document.getElementById('skip-newspaper-results-title');
    
    if (!modal || !bodyEl || !dateEl || !topTitleEl || !resultsTitleEl) return;

    // ★★★ 修正箇所: ラウンド名の動的マッピング ★★★
    const numTeams = tournamentState.teams.length; 
    const finalRound = Math.log2(numTeams); // 128->7, 64->6
    
    const roundNameMap = { 
        [finalRound]: '決勝', 
        [finalRound-1]: '準決勝', 
        [finalRound-2]: '準々決勝', 
        [finalRound-3]: '4回戦' 
    };
    const roundName = roundNameMap[roundNumber] || `${roundNumber}回戦`;
    // ★★★ 修正ここまで ★★★
    
    let today;
    if (results.length > 0) {
        const lastMatchId = results[results.length - 1].matchId;
        const lastMatch = findMatchById(lastMatchId);
        if (lastMatch?.schedule?.date) today = lastMatch.schedule.date;
    }
    if (!today) {
        const d = new Date();
        today = `${d.getMonth() + 1}/${d.getDate()}`;
    }
    
    const dateString = `${tournamentState.tournamentYear}年 ${today} 発行`;
    dateEl.textContent = dateString;
    topTitleEl.textContent = `熱戦の${roundName}、${tournamentState.currentTournament === 'summer_koshien' ? '甲子園' : '静岡'}を席巻`;
    resultsTitleEl.textContent = `${roundName} 全試合結果`;

    // AIに記事生成を依頼
    bodyEl.querySelector('.skip-newspaper-main-headline').textContent = '取材中...';
    bodyEl.querySelector('.skip-newspaper-main-body').innerHTML = '<p>AI記者が記事を執筆しています...</p>';
    const articleData = await generateSkipRoundArticleContent(roundName, results);

    let resultsBoxHtml = '';
    results.forEach(match => {
        resultsBoxHtml += `
            <div class="skip-newspaper-match">
                <div><span class="winner">${match.winnerName}</span></div>
                <div><span class="score">${match.winnerScore}</span>-<span class="score">${match.loserScore}</span></div>
                <div><span class="loser">${match.loserName}</span></div>
            </div>
        `;
    });

    bodyEl.innerHTML = `
        <div class="skip-newspaper-main-headline">${articleData.mainHeadline}</div>
        <div class="skip-newspaper-main-article">
            <div class="skip-newspaper-main-image">写真：${articleData.mainImageCaption}</div>
            <p class="skip-newspaper-image-caption">${articleData.mainImageCaption}</p>
            <div class="skip-newspaper-main-body">
                <h4>${articleData.mainArticleSubHeadline}</h4>
                <p>${articleData.mainArticleBody.replace(/\n/g, '<br><br>')}</p>
            </div>
        </div>
        <div class="skip-newspaper-side-article right">
            <h3 class="skip-newspaper-side-headline">${articleData.sideArticle1Headline}</h3>
            <div class="skip-newspaper-side-body"><p>${articleData.sideArticle1Body.replace(/\n/g, '<br><br>')}</p></div>
        </div>
        <div class="skip-newspaper-side-article left">
            <h3 class="skip-newspaper-side-headline">${articleData.sideArticle2Headline}</h3>
            <div class="skip-newspaper-side-body"><p>${articleData.sideArticle2Body.replace(/\n/g, '<br><br>')}</p></div>
        </div>
        <div class="skip-newspaper-results-section">
            <h2 id="skip-newspaper-results-title">${roundName} 全試合結果</h2>
            <div id="skip-newspaper-match-grid" class="skip-newspaper-match-grid">${resultsBoxHtml}</div>
        </div>
    `;

    // ニュース欄に保存
    const articleObject = {
        title: `【熱闘新聞】${roundName}特集号（スキップ発行）`,
        body: articleData.mainArticleSubHeadline,
        timestamp: Date.now(),
        isSkipNewspaper: true,
        roundNumber: roundNumber,
        articleData: articleData,
        resultsBoxHtml: resultsBoxHtml,
        dateString: dateString,
        context: { isSkipNewspaper: true, roundNumber: roundNumber, results: results }
    };
    tournamentState.news.push(articleObject);
    renderNews(tournamentState.news);
    saveState();

    modal.classList.remove('hidden');
}

/**
 * [NEW] 日付オブジェクトを "MM/DD" 形式の文字列にフォーマットするヘルパー
 */
function formatDate(date) {
    if (!date) return "日付不明";
    return `${date.getMonth() + 1}/${date.getDate()}`;
}

/**
 * [修正版] ラウンドスキップ新聞を閉じる
 */
function closeSkipNewspaper() {
    document.getElementById('skip-newspaper-modal').classList.add('hidden');
}

/**
 * [修正版] AIにスキップしたラウンドの記事内容を生成させる（新聞用）
 */
async function generateSkipRoundArticleContent(roundName, results) {
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    
    // 1. 最大の番狂わせを特定
    // rankDiffが最も小さい（マイナスが大きい）ものが番狂わせ
    const biggestUpset = [...results].sort((a, b) => a.rankDiff - b.rankDiff)[0];

    let upsetText = null;
    let mainHeadlineCandidate = `白熱の${roundName}`;
    let mainImageCaptionCandidate = `熱戦の瞬間`;

    if (biggestUpset && biggestUpset.rankDiff <= -2) { // ランク差2以上を大きな番狂わせとする
        upsetText = `最大の波乱は、${biggestUpset.winnerRank}ランクの「${biggestUpset.winnerName}」が、${biggestUpset.loserRank}ランクの強豪「${biggestUpset.loserName}」を ${biggestUpset.winnerScore}-${biggestUpset.loserScore} で破った一戦だ。`;
        mainHeadlineCandidate = `まさか！ ${biggestUpset.loserName}散る`;
        mainImageCaptionCandidate = `${biggestUpset.winnerName}の歓喜`;
    } else if (biggestUpset && biggestUpset.rankDiff < 0) { // 小さな番狂わせ
        upsetText = `一筋縄ではいかない試合も。${biggestUpset.winnerRank}ランクの「${biggestUpset.winnerName}」が、${biggestUpset.loserRank}ランクの「${biggestUpset.loserName}」を ${biggestUpset.winnerScore}-${biggestUpset.loserScore} で破る番狂わせがあった。`;
    }

    // 2. シード校の動向を分析
    const seeds = tournamentState.seeds.map(s => s.team);
    let seedSurvivedCount = 0;
    let seedEliminated = [];
    let seedEliminatedDetails = []; // どのラウンドで誰に敗れたか
    
    for (const r of results) {
        if (seeds.includes(r.winnerName)) {
            seedSurvivedCount++;
        }
        if (seeds.includes(r.loserName)) { // シード校が敗退した場合
            seedEliminated.push(r.loserName);
            seedEliminatedDetails.push(`シード校「${r.loserName}」が「${r.winnerName}」に敗れ、${roundName}で姿を消した。`);
            mainHeadlineCandidate = `${r.loserName}まさかの敗退`;
            mainImageCaptionCandidate = `${r.winnerName}、金星`;
        }
    }
    
    let seedStatusText;
    if (seedEliminated.length > 0) {
        seedStatusText = `シード校の動向にも注目が集まった${roundName}では、${seedEliminated.join('、')}が敗退。${seedEliminatedDetails.join('')}`;
        if (!upsetText) mainHeadlineCandidate = `強豪、涙を飲む`;
    } else {
        seedStatusText = 'シード校は順当に勝ち進み、その実力を見せつけた。';
        if (!upsetText) mainHeadlineCandidate = `強豪、盤石の戦い`;
    }

    // 決勝戦の特別な描写
    if (roundName === '決勝') {
        const finalMatch = results[0];
        mainHeadlineCandidate = `${finalMatch.winnerName}、栄冠！`;
        mainImageCaptionCandidate = `${finalMatch.winnerName}、歓喜の胴上げ`;
        
        // 決勝専用のプロンプト
        const finalPrompt = `あなたは「静岡 熱闘新聞」の編集長です。
高校野球 ${tournamentNameMap[tournamentState.currentTournament]}の「決勝戦」が終了しました。
以下の分析データに基づき、新聞の一面を飾る「縦書きの大見出し」「メイン記事の小見出し」「メイン記事本文」「サイド記事1の見出し」「サイド記事1本文」「サイド記事2の見出し」「サイド記事2本文」「メイン画像キャプション」を生成してください。

### 決勝戦 分析データ
- **優勝校:** ${finalMatch.winnerName}
- **準優勝校:** ${finalMatch.loserName}
- **試合結果:** ${finalMatch.winnerScore}-${finalMatch.loserScore}
- **優勝校のランク:** ${finalMatch.winnerRank}
- **準優勝校のランク:** ${finalMatch.loserRank}

### 指示
1.  **mainHeadline (縦書きの大見出し):**
    - 5～8文字程度で、優勝校と感動を伝える。
    - 例：「〇〇優勝！」「歓喜の初V」
2.  **mainArticleSubHeadline (メイン記事の小見出し):**
    - 20～30文字程度で、決勝戦のドラマを表現する。
    - 例：「激闘の末、〇〇が悲願達成！粘りの野球で頂点へ」
3.  **mainArticleBody (メイン記事本文):**
    - 150～200文字程度で、決勝戦の展開、両チームの奮闘、勝利の感動を詳細に描写する。
    - 優勝校の強さや、準優勝校の健闘も称えること。
4.  **sideArticle1Headline (サイド記事1の見出し):**
    - 15文字程度で、優勝校の監督や選手のコメントなど。
    - 例：「監督『夢のようだ』」「エース、支えに感謝」
5.  **sideArticle1Body (サイド記事1本文):**
    - 80～120文字程度で、上記の見出しに関連する内容。
6.  **sideArticle2Headline (サイド記事2の見出し):**
    - 15文字程度で、準優勝校の健闘や、大会全体の総括など。
    - 例：「準Vも胸張る」「夏を彩る熱戦」
7.  **sideArticle2Body (サイド記事2本文):**
    - 80～120文字程度で、上記の見出しに関連する内容。
8.  **mainImageCaption (メイン画像キャプション):**
    - 10～20文字程度で、メイン画像の状況を説明。
    - 例：「歓喜の胴上げ」「渾身の一球」

### 出力形式 (JSON)
{"mainHeadline": "...", "mainArticleSubHeadline": "...", "mainArticleBody": "...", "sideArticle1Headline": "...", "sideArticle1Body": "...", "sideArticle2Headline": "...", "sideArticle2Body": "...", "mainImageCaption": "..."}`;
        
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: finalPrompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
                if (article && article.mainHeadline && article.mainArticleSubHeadline && article.mainArticleBody) {
                    return article;
                }
            }
            throw new Error("AI final article response format error.");
        } catch (error) {
            console.error("AI final article generation failed:", error);
            // フォールバック（デフォルト）の記事を返す
            return {
                mainHeadline: "激闘の末",
                mainArticleSubHeadline: `${finalMatch.winnerName}、栄冠！ 粘りの野球で悲願達成`,
                mainArticleBody: `本日行われた決勝戦は、両チーム一歩も譲らない白熱の展開となった。${finalMatch.winnerName}は得意の集中打でチャンスをものにし、${finalMatch.loserName}は堅い守備で応戦。最終盤までもつれ込む大接戦となったが、${finalMatch.winnerName}が持ち前の勝負強さを発揮し、${finalMatch.winnerScore}-${finalMatch.loserScore}で勝利をもぎ取った。悲願の優勝に選手たちは歓喜の涙を流し、スタンドからは惜しみない拍手が送られた。敗れた${finalMatch.loserName}も、その堂々たる戦いぶりは多くの感動を呼んだ。`,
                sideArticle1Headline: `監督「夢の舞台」`,
                sideArticle1Body: `優勝監督は「選手たちが本当によく頑張ってくれた。夢の舞台で最高の野球ができた」と、感極まった様子で語った。エースも「仲間を信じて投げた」と胸を張った。`,
                sideArticle2Headline: `準Vも胸張る`,
                sideArticle2Body: `惜しくも準優勝に終わった${finalMatch.loserName}の選手たちは「悔しいが、全力を尽くせた」と、すがすがしい表情で球場を後にした。夏を彩る熱戦に感謝の意を表した。`,
                mainImageCaption: `${finalMatch.winnerName}、歓喜の瞬間`
            };
        }
    }


    // 通常ラウンドのプロンプト
    const prompt = `あなたは「静岡 熱闘新聞」の編集長です。
高校野球 ${tournamentNameMap[tournamentState.currentTournament]}の「${roundName}」が全試合終了しました。
以下の分析データに基づき、新聞の一面を飾る「縦書きの大見出し」「メイン記事の小見出し」「メイン記事本文」「サイド記事1の見出し」「サイド記事1本文」「サイド記事2の見出し」「サイド記事2本文」「メイン画像キャプション」を生成してください。

### ${roundName} 分析データ
- **試合数:** ${results.length}試合
- **最大の波乱:** ${upsetText || '特に大きな波乱はなかった。'}
- **シード校の動向:** ${seedStatusText}
- **注目チーム:** 強豪校の名前をいくつか挙げることも可能。

### 指示
1.  **mainHeadline (縦書きの大見出し):**
    - 5～8文字程度で、最も衝撃的または重要な事実を伝える。
    - 例：「シード散る」「大波乱の〇回戦」「強豪、順当勝ち」
2.  **mainArticleSubHeadline (メイン記事の小見出し):**
    - 20～30文字程度で、大見出しを補足し、ラウンド全体の概況を表現する。
    - 例：「激戦を制し、次なる舞台へ！波乱含みの展開に熱気」
3.  **mainArticleBody (メイン記事本文):**
    - 150～200文字程度で、${roundName}全体を総括する。
    - 必ず「最大の波乱」と「シード校の動向」に触れること。
    - 読者の期待を煽るような、熱意のある文体で書くこと。
    - 2段落以上に分けること。
4.  **sideArticle1Headline (サイド記事1の見出し):**
    - 15文字程度で、番狂わせを起こしたチームや選手の活躍など、特定のトピックを切り取る。
    - 例：「〇〇高校、金星！」「若きエースの躍動」
5.  **sideArticle1Body (サイド記事1本文):**
    - 80～120文字程度で、上記の見出しに関連する内容。
6.  **sideArticle2Headline (サイド記事2の見出し):**
    - 15文字程度で、惜敗したチームの健闘や、次のラウンドへの展望など。
    - 例：「強豪、涙を飲む」「ベスト8出揃う」
7.  **sideArticle2Body (サイド記事2本文):**
    - 80～120文字程度で、上記の見出しに関連する内容。
8.  **mainImageCaption (メイン画像キャプション):**
    - 10～20文字程度で、メイン画像の状況を説明。
    - 例：「熱戦の瞬間」「渾身の投球」

### 出力形式 (JSON)
{"mainHeadline": "...", "mainArticleSubHeadline": "...", "mainArticleBody": "...", "sideArticle1Headline": "...", "sideArticle1Body": "...", "sideArticle2Headline": "...", "sideArticle2Body": "...", "mainImageCaption": "..."}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article && article.mainHeadline && article.mainArticleSubHeadline && article.mainArticleBody) {
                return article;
            }
        }
        throw new Error("AI article response format error.");
    } catch (error) {
        console.error("AI skip round article generation failed:", error);
        // フォールバック（デフォルト）の記事を返す
        return {
            mainHeadline: mainHeadlineCandidate,
            mainArticleSubHeadline: "激戦を制し、次なる舞台へ",
            mainArticleBody: `本日行われた${roundName}では、各地で手に汗握る激戦が繰り広げられた。${upsetText || seedStatusText} 選手たちの熱い思いが詰まったプレーに、観衆は惜しみない拍手を送った。\n\nこの結果、次ラウンドへの進出を決めたチームは、さらなる高みを目指すことになる。敗れたチームもまた、その健闘を称えられ、来年への雪辱を誓った。夏の甲子園を目指す戦いは、ますます熱気を帯びてきている。`,
            sideArticle1Headline: `注目校の戦い`,
            sideArticle1Body: `〇〇高校のエース、田中選手は本日も圧巻のピッチングを披露。粘る相手打線を完璧に抑え込み、チームを勝利に導いた。`,
            sideArticle2Headline: `敗者の弁`,
            sideArticle2Body: `惜しくも敗れた△△高校の主将は「悔しいが、全力を尽くせた。この経験をバネにしたい」と涙をこらえながら語った。`,
            mainImageCaption: mainImageCaptionCandidate
        };
    }
}


// ... (既存の initializeApp(); の呼び出し) ...

 /**
     * 現在のトーナメント状態に基づいてUI全体を再描画する
     * (★夏・秋・春 すべて128チーム制のメインブラケットを描画するよう統一)
     */
    function renderTournament(data) {
        let tournamentNameString = tournamentNameMap[data.currentTournament] || '大会';

        // UI要素を一度すべて非表示に初期化
        mainBracketWrapper.classList.add('hidden');
        autumnRegionalContainer.classList.add('hidden');
        autumnRankingContainer.classList.add('hidden');
        autumnControls.classList.add('hidden');
        [skipAutumnBlocksBtn, skipAutumnRankingBtn, skipAutumnMainBtn, skipSpringQualifiersBtn, skipSpringRound1Btn, skipSpringMainBtn, startRankingPlayoffsBtn, startMainTournamentBtn].forEach(btn => btn?.classList.add('hidden'));
        
        // ★★★ ここからが新ロジック ★★★
        // 大会の種類に関わらず、常にメインブラケットを描画
        mainBracketWrapper.classList.remove('hidden');
        renderMainBracket(data);
        // ★★★ 新ロジックここまで ★★★

        // --- 共通の描画処理 (変更なし) ---
        tournamentYearDisplay.textContent = `${data.tournamentYear}年度 ${tournamentNameString}`;
        renderRegionMap(data);
        renderNews(data.news || []);
        renderBbsComments(data.bbsComments || []);
        renderDaiyaBbsComments(data.daiyaBbsComments || []);
        renderNamcoNews(data.namcoNews);
        checkTournamentProgress(); // 夏・秋・春 共通のスキップボタン表示制御
        updateTicker();
    }
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * [秋季大会] 地区ブロック予選をスキップする
 */
async function skipAutumnRegionalBlocks() {
    skipAutumnBlocksBtn.disabled = true;
    skipAutumnBlocksBtn.textContent = '進行中...';

    // 全ての地区の全ブロックの試合を処理
    for (const region of ['東部', '中部', '西部', '伊豆']) {
        const regionData = tournamentState.autumnData.regions[region];
        
        const blocks = regionData.izuBracket ? [regionData.izuBracket] : regionData.blocks;

        for (const block of blocks) {
            // ブロック内の全試合IDを取得
            const matchIds = Object.keys(block.matches);
            for (const matchId of matchIds) {
                const match = block.matches[matchId];
                // チームがセットされていて、まだ勝者が決まっていない試合を処理
                if (match.team1 && match.team2 && !match.winner) {
                    const { team1, team2 } = match;
                    const rank1 = calculateRank(team1, tournamentState);
                    const rank2 = calculateRank(team2, tournamentState);
                    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                    
                    const winnerName = (rankValues[rank1] >= rankValues[rank2]) ? team1 : team2;
                    const loserName = winnerName === team1 ? team2 : team1;

                    const [winnerScore, loserScore] = generateAutoScore(rank1, rank2);
                    match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
                    match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;
                    
                    // processMatchWinを呼び出して勝者を次に進める
                    await processMatchWin(matchId, winnerName);
                }
            }
        }
    }
    
    // 全て終わったら、自動で次のステージへ
    await setupAutumnRankingTournaments();
    skipAutumnBlocksBtn.disabled = false;
    skipAutumnBlocksBtn.textContent = '地区ブロック予選をスキップ';
}

/**
 * [秋季大会] 地区順位決定戦（敗者復活戦）をスキップする
 */
async function skipAutumnRankingTournaments() {
    skipAutumnRankingBtn.disabled = true;
    skipAutumnRankingBtn.textContent = '進行中...';

    for (const region of ['東部', '中部', '西部']) {
        const repBracket = tournamentState.autumnData.regions[region].repechageBracket;
        if (!repBracket) continue;
        
        const matchIds = Object.keys(repBracket.matches);
        for (const matchId of matchIds) {
            const match = repBracket.matches[matchId];
            if (match.team1 && match.team2 && !match.winner) {
                const { team1, team2 } = match;
                const rank1 = calculateRank(team1, tournamentState);
                const rank2 = calculateRank(team2, tournamentState);
                const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
                
                const winnerName = (rankValues[rank1] >= rankValues[rank2]) ? team1 : team2;
                
                const [winnerScore, loserScore] = generateAutoScore(rank1, rank2);
                match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
                match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;

                await processMatchWin(matchId, winnerName);
            }
        }
    }

    // 自動で県大会本戦へ
    await setupAutumnMainTournament();
    skipAutumnRankingBtn.disabled = false;
    skipAutumnRankingBtn.textContent = '地区順位決定戦をスキップ';
}

/**
 * [秋季大会] 県大会本戦をスキップする
 */
async function skipAutumnMainTournament() {
    skipAutumnMainBtn.disabled = true;
    skipAutumnMainBtn.textContent = '進行中...';

    // 秋季県大会は16チームトーナメント（4ラウンド）
    await skipRound(1); // 1回戦 (ベスト8決定)
    await skipRound(2); // 準々決勝 (ベスト4決定)
    await skipRound(3); // 準決勝 (決勝進出決定)
    await skipFinal();  // 決勝

    skipAutumnMainBtn.disabled = false;
    skipAutumnMainBtn.textContent = '県大会本戦をスキップ';
}

/**
 * [春季大会] 地区予選をスキップする
 */
async function skipSpringQualifiers() {
    skipSpringQualifiersBtn.disabled = true;
    skipSpringQualifiersBtn.textContent = '進行中...';

    const allQualifierMatches = Object.values(tournamentState.springData.allMatches);

    // 予選の全試合をループ処理
    for (const match of allQualifierMatches) {
        // チームがまだセットされていない試合はスキップ
        if (!match.team1 || !match.team2 || match.winner) continue;
        
        const { team1, team2 } = match;
        const rank1 = calculateRank(team1, tournamentState);
        const rank2 = calculateRank(team2, tournamentState);
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        
        const winnerName = (rankValues[rank1] >= rankValues[rank2]) ? team1 : team2;
        
        const [winnerScore, loserScore] = generateAutoScore(rank1, rank2);
        match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
        match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;

        await processMatchWin(match.id, winnerName);
    }

    // 自動で県大会1回戦へ
    await setupSpringMainTournament_Round1();
    skipSpringQualifiersBtn.disabled = false;
    skipSpringQualifiersBtn.textContent = '春季地区予選をスキップ';
}

/**
 * [春季大会] 県大会1回戦をスキップする
 */
async function skipSpringMainRound1() {
    skipSpringRound1Btn.disabled = true;
    skipSpringRound1Btn.textContent = '進行中...';

    // 1回戦は8試合
    await skipRound(1); 
    
    // 自動で県大会2回戦へ
    await setupSpringMainTournament_Round2();
    skipSpringRound1Btn.disabled = false;
    skipSpringRound1Btn.textContent = '春季県大会1回戦をスキップ';
}

/**
 * [春季大会] 県大会2回戦以降をスキップする
 */
async function skipSpringMainTournament() {
    skipSpringMainBtn.disabled = true;
    skipSpringMainBtn.textContent = '進行中...';

    // 2回戦以降はベスト16トーナメントと同じ
    await skipRound(1); // 2回戦 (ベスト8決定)
    await skipRound(2); // 準々決勝 (ベスト4決定)
    await skipRound(3); // 準決勝 (決勝進出決定)
    await skipFinal();  // 決勝

    skipSpringMainBtn.disabled = false;
    skipSpringMainBtn.textContent = '春季県大会2回戦以降をスキップ';
}

   /**
     * メインのトーナメント表（128, 32, 16チーム制に対応）を描画する
     * (★32チーム制＝左右8試合ずつに振り分けるよう修正)
     */
    function renderMainBracket(data) {
        if (!data.teams || data.teams.length === 0) {
             mainBracketContainer.innerHTML = '';
             return;
        };

        const { matches, teams, seeds } = data;
        const numTeams = teams.length; // 128 (夏), 32 (秋), 16 (春)

        const bracketContentWrapper = document.createElement('div');
        bracketContentWrapper.className = 'flex flex-row';

        const leftBracketEl = document.createElement('div');
        leftBracketEl.className = 'bracket-half left';

        const rightBracketEl = document.createElement('div');
        rightBracketEl.className = 'bracket-half right';
        
        const finalRound = Math.log2(numTeams); // 128->7, 32->5, 16->4
        const semiFinalRound = finalRound - 1; // 準決勝のラウンド番号 (R6, R4, R3)
        
        const leftChampion = data.matches[`L-R${semiFinalRound}-M1`]?.winner ?? null;
        const rightChampion = data.matches[`R-R${semiFinalRound}-M1`]?.winner ?? null;
        
        const finalMatch = data.matches['F-R1-M1'] || {};
        const finalTeam1 = finalMatch.team1 ?? leftChampion;
        const finalTeam2 = finalMatch.team2 ?? rightChampion;

        const finalEl = document.createElement('div');
        finalEl.className = 'bracket-final';
        finalEl.innerHTML = `<div class="final-title">決勝</div><div class="final-matchup" data-match-id="F-R1-M1">${createMatchHTML('F-R1-M1', finalTeam1, finalTeam2, finalMatch, seeds)}</div><div class="winner-box" id="tournament-winner">${finalMatch.winner ? `🏆 ${finalMatch.winner} 🏆` : '🏆'}</div>`;

        // 1回戦の全試合を生成 (128->64試合, 32->16試合, 16->8試合)
        const round1Setup = teams.reduce((acc, team, i) => {
            if (i % 2 === 0) acc.push({ team1: team, team2: null });
            else acc[acc.length - 1].team2 = team;
            return acc;
        }, []);
        
        // ★★★ ここからが修正箇所 (全試合を半分に分割) ★★★
        const halfMatches = round1Setup.length / 2; // 64->32, 16->8, 8->4
        
        const leftHalfSetup = round1Setup.slice(0, halfMatches);
        const rightHalfSetup = round1Setup.slice(halfMatches);
        // ★★★ 修正ここまで ★★★

        generateHalf(leftBracketEl, leftHalfSetup, 'L', matches, seeds);
        generateHalf(rightBracketEl, rightHalfSetup, 'R', matches, seeds);

        mainBracketContainer.innerHTML = '';
        bracketContentWrapper.append(leftBracketEl, finalEl, rightBracketEl);
        mainBracketContainer.appendChild(bracketContentWrapper);

        if (finalMatch.winner) {
            nextTournamentBtn.classList.remove('hidden');
        } else {
            nextTournamentBtn.classList.add('hidden');
        }
    }
// ▲▲▲ 置き換えここまで ▲▲▲

   /**
     * トーナメント表の片側（レフトまたはライト）を描画するヘルパー関数
     * (★128チーム制＝7ラウンド制のラウンド名に固定)
     */
    function generateHalf(containerEl, setup, side, allMatches, seeds) {
        containerEl.innerHTML = '';
        const numMatchesInFirstRound = setup.length; // 32
        const numTeamsOnSide = numMatchesInFirstRound * 2; // 64
        const numRounds = Math.log2(numTeamsOnSide); // 6 (R1...R6)

        // ★★★ ここからが修正箇所 (128チーム制のラウンド名に固定) ★★★
        const roundNameMap = { 1: "1回戦", 2: "2回戦", 3: "3回戦", 4: "4回戦", 5: "準々決勝", 6: "準決勝" };
        // ★★★ 修正ここまで ★★★

        const roundElements = [];
        for (let i = 0; i < numRounds; i++) {
            const roundEl = document.createElement('div');
            roundEl.className = 'round';
            if (i > 0) roundEl.classList.add('subsequent-round');

            const roundTitle = document.createElement('h3');
            roundTitle.className = 'text-center font-bold mb-2';
            roundTitle.textContent = roundNameMap[i + 1] || `${i + 1}回戦`;
            roundEl.appendChild(roundTitle);

            containerEl.appendChild(roundEl);
            roundElements.push(roundEl);
        }

        // (以降の描画ロジックは変更なし)
        setup.forEach((matchSetup, index) => {
            const matchId = `${side}-R1-M${index + 1}`;
            let dbMatch = allMatches[matchId] || {};
            const team1 = dbMatch.team1 || matchSetup.team1;
            const team2 = dbMatch.team2 || matchSetup.team2;
            roundElements[0].insertAdjacentHTML('beforeend', createMatchHTML(matchId, team1, team2, dbMatch, seeds));
        });
        
        for (let r = 2; r <= numRounds; r++) {
            const numMatchesInRound = numMatchesInFirstRound / Math.pow(2, r - 1);
            for (let m = 1; m <= numMatchesInRound; m++) {
                const matchId = `${side}-R${r}-M${m}`;
                const dbMatch = allMatches[matchId] || {};
                const prevMatch1Id = `${side}-R${r - 1}-M${(m * 2) - 1}`;
                const prevMatch2Id = `${side}-R${r - 1}-M${m * 2}`;
                const prevWinner1 = allMatches[prevMatch1Id]?.winner || null;
                const prevWinner2 = allMatches[prevMatch2Id]?.winner || null;
                const team1 = dbMatch.team1 || prevWinner1;
                const team2 = dbMatch.team2 || prevWinner2;
                roundElements[r - 1].insertAdjacentHTML('beforeend', createMatchHTML(matchId, team1, team2, dbMatch, seeds));
            }
        }
    }
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 熱狂度グラフを描画する
 */
function renderExcitementChart(ctx, dataObj) {
    // 既存のチャートがあれば破棄
    const existingChart = Chart.getChart(ctx);
    if (existingChart) existingChart.destroy();

    // グラデーション作成 (赤くなるほど熱い)
    const gradient = ctx.createLinearGradient(0, 200, 0, 0);
    gradient.addColorStop(0, 'rgba(59, 130, 246, 0.2)'); // 青 (冷)
    gradient.addColorStop(1, 'rgba(239, 68, 68, 0.6)');  // 赤 (熱)

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: dataObj.labels,
            datasets: [{
                label: '試合熱狂度 (Excitement)',
                data: dataObj.dataPoints,
                borderColor: '#f59e0b', // Amber
                backgroundColor: gradient,
                borderWidth: 3,
                pointBackgroundColor: '#fff',
                pointBorderColor: '#f59e0b',
                pointRadius: 4,
                tension: 0.4, // 滑らかな曲線
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: '盛り上がり度' },
                    suggestedMax: 50
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (ctx) => `熱狂度: ${ctx.raw.toFixed(1)}`
                    }
                },
                annotation: {
                    annotations: {
                        line1: {
                            type: 'line', yMin: 20, yMax: 20, borderColor: 'red', borderDash: [2, 2], 
                            label: { content: '激熱ゾーン', enabled: true, position: 'end', color: 'red', font: {size: 10} }
                        }
                    }
                }
            }
        }
    });
}
// ▲▲▲ 熱狂度グラフ機能 ここまで ▲▲▲

/**
 * [UPDATED] 試合の「熱狂度」推移データを計算する
 * (★ランク差による「番狂わせ補正」を追加した修正版)
 */
function calculateExcitementData(dbMatch) {
    if (!dbMatch || !dbMatch.details) return null;

    // ★ 1. ランク情報の取得と差分の計算
    const rank1 = calculateRank(dbMatch.team1, tournamentState);
    const rank2 = calculateRank(dbMatch.team2, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    const val1 = rankValues[rank1] || 3;
    const val2 = rankValues[rank2] || 3;
    
    const rankDiff = val1 - val2; 

    const inningScores1 = dbMatch.details.inningScore.team1 || [];
    const inningScores2 = dbMatch.details.inningScore.team2 || [];
    
    // ▼▼▼ 【修正】コールドゲームなら、その回数を上限にする ▼▼▼
    let numInnings = Math.max(inningScores1.length, inningScores2.length);
    if (dbMatch.calledGame && dbMatch.calledInning) {
        numInnings = dbMatch.calledInning;
    }
    // ▲▲▲ 修正ここまで ▲▲▲

    let dataPoints = [];
    let labels = [];
    let totalExcitement = 0;

    let currentScore1 = 0;
    let currentScore2 = 0;

    for (let i = 0; i < numInnings; i++) {
        const inningNum = i + 1;
        
        const runsTop = parseInt(inningScores1[i] || 0);
        const prevScore1 = currentScore1;
        currentScore1 += runsTop;
        
        const runsBottom = parseInt(inningScores2[i] || 0);
        const prevScore2 = currentScore2;
        currentScore2 += runsBottom;

        // --- 熱狂度計算ロジック (変更なし) ---
        const scoreDiff = currentScore1 - currentScore2;
        const absDiff = Math.abs(scoreDiff);

        let scoreFactor = 1.0;
        if (absDiff === 0) scoreFactor = 3.0;
        else if (absDiff === 1) scoreFactor = 2.0;
        else if (absDiff <= 3) scoreFactor = 1.2;
        else scoreFactor = 0.5;

        let upsetFactor = 1.0;
        if (rankDiff > 0 && scoreDiff <= 0) {
            upsetFactor = 1.0 + (rankDiff * 0.2); 
            if (scoreDiff < 0) upsetFactor += 0.5; 
        }
        else if (rankDiff < 0 && scoreDiff >= 0) {
            upsetFactor = 1.0 + (Math.abs(rankDiff) * 0.2);
            if (scoreDiff > 0) upsetFactor += 0.5;
        }
        else if ((rankDiff > 0 && scoreDiff >= 5) || (rankDiff < 0 && scoreDiff <= -5)) {
            upsetFactor = 0.6;
        }

        let inningFactor = 1.0;
        if (inningNum >= 9) inningFactor = 2.5; 
        else if (inningNum >= 7) inningFactor = 1.5;

        let eventBonus = 0;
        const wasLeading1 = prevScore1 > prevScore2;
        const isLeading1 = currentScore1 > currentScore2;
        const wasTied = prevScore1 === prevScore2;
        
        if (wasLeading1 !== isLeading1 && !wasTied && absDiff !== 0) eventBonus += 5.0 * upsetFactor;
        if (!wasTied && absDiff === 0) eventBonus += 3.0 * upsetFactor;
        
        if (i === numInnings - 1 && dbMatch.winner === dbMatch.team2 && runsBottom > 0 && prevScore2 <= currentScore1) {
            eventBonus += 20.0; 
            scoreFactor = 5.0;
        }

        const runsFactor = (runsTop + runsBottom) * 0.5;
        let excitement = (10 * scoreFactor * inningFactor * upsetFactor) + (runsFactor * 2) + eventBonus;
        
        dataPoints.push(excitement);
        labels.push(`${inningNum}回`);
        totalExcitement += excitement;
    }

    let rank = 'C';
    const avgExcitement = numInnings > 0 ? totalExcitement / numInnings : 0; // 0除算対策
    
    if (avgExcitement >= 35) rank = 'S (伝説の名勝負)';
    else if (avgExcitement >= 25) rank = 'A (激熱)';
    else if (avgExcitement >= 15) rank = 'B (好ゲーム)';
    else rank = 'C (凡戦・一方的)';

    return { labels, dataPoints, rank, totalExcitement };
}

 // ▼▼▼ 既存の「createMatchHTML」関数 (12489行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * 1試合分のHTMLを生成する
 * (★選手の「調子」アイコン表示を追加した最終版)
 */
function createMatchHTML(matchId, team1, team2, dbMatch, seeds = []) {
    // --- (内部ヘルパー関数 createSpecialButtons は変更なし) ---
    const createSpecialButtons = (teamName) => {
        if (!teamName || (tournamentState.documentary && tournamentState.documentary.target)) return '';
        let buttonHTML = '';
        if (UNDERDOG_TEAMS.includes(teamName)) {
            buttonHTML += `<button class="underdog-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の逆境に密着取材する">📹</button>`;
        }
        if (POWERHOUSE_TEAMS.includes(teamName)) {
            buttonHTML += `<button class="powerhouse-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の王者の苦悩に密着取材する">👑</button>`;
        }
        if (POWERHOUSE_REVIVAL_TEAMS.includes(teamName)) {
            buttonHTML += `<button class="powerhouse-revival-doc-btn text-lg ml-2" data-team-name="${teamName}" title="${teamName}の古豪復活に密着取材する">🏰</button>`;
        }
        if (ONE_MAN_TEAMS.includes(teamName)) {
            buttonHTML += `<button class="one-man-team-doc-btn text-lg ml-2" data-team-name="${teamName}" title="絶対的エースとその仲間たちに密着取材する">🌟</button>`;
        }
        return buttonHTML;
    };
    
    const t1Empty = !team1;
    const t2Empty = !team2;

    let specialMatchClass = '';
    if (dbMatch.rivalryType) {
        specialMatchClass = 'rivalry-match';
    } 
    else if (!t1Empty && !t2Empty) {
        const feud = tournamentState.feuds?.find(f => f.teams.includes(team1) && f.teams.includes(team2));
        if (feud) {
            specialMatchClass = 'feud-match';
        } else {
            const rivalry = tournamentState.rivalries?.find(r => r.teams.includes(team1) && r.teams.includes(team2));
            if (rivalry) {
                specialMatchClass = 'rivalry-match';
            }
        }
    }
    const rank1 = calculateRank(team1, tournamentState);
    const rank2 = calculateRank(team2, tournamentState);
    const rankColor = (rank) => {
        switch (rank) {
            case 'A': return 'rank-A'; case 'B': return 'rank-B'; case 'C': return 'rank-C';
            case 'D': return 'rank-D'; case 'E': return 'rank-E'; default: return '';
        }
    };

    const seedInfo1 = seeds.find(s => s.team === team1);
    const seedInfo2 = seeds.find(s => s.team === team2);
    const isSeed1 = !!seedInfo1;
    const isSeed2 = !!seedInfo2;

    const showInputs = !t1Empty && !t2Empty;

    let atmosphereInputs = '';
    if (showInputs) {
        atmosphereInputs = `
        <div class="team-atmosphere-container mt-1">
            <input type-="text" class="team-atmosphere-input w-full text-xs p-1 border rounded-t" data-match-id="${matchId}" data-team-key="team1" placeholder="[${team1}] 試合前の雰囲気/公約 (任意)" value="${dbMatch.atmosphere_team1 || ''}">
            <input type-="text" class="team-atmosphere-input w-full text-xs p-1 border rounded-b border-t-0" data-match-id="${matchId}" data-team-key="team2" placeholder="[${team2}] 試合前の雰囲気/公約 (任意)" value="${dbMatch.atmosphere_team2 || ''}">
        </div>
        `;
    }

    let scheduleInfo = '';
    if (dbMatch.schedule) { 
        const gameNumIcon = ['①', '②', '③', '④'][dbMatch.schedule.game - 1] || `(${dbMatch.schedule.game})`;
        scheduleInfo = `
        <div class="match-schedule" title="${dbMatch.schedule.stadiumFull}球場 ${dbMatch.schedule.date} 第${dbMatch.schedule.game}試合">
            ${dbMatch.schedule.date}・${dbMatch.schedule.stadium}${gameNumIcon}
        </div>
        `;
    }

    // ★★★ ここからが修正箇所 ★★★
    // 選手の調子アイコンを取得するヘルパー
    const getConditionIconForTeam = (teamName) => {
        // (注: この関数は「試合前」に描画されます。アイコンは「前の試合」の結果です)
        if (!teamName) return ""; 
        
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord || !teamRecord.playerStats) return "";

        let icons = [];

        // 1. 打者の調子
        if (teamRecord.playerStats.batting) {
            for (const playerName in teamRecord.playerStats.batting) {
                const flag = teamRecord.playerStats.batting[playerName].narrative_flag;
                const icon = getPlayerConditionIcon(flag);
                if (icon) icons.push(icon);
            }
        }
        // 2. 投手の調子
        if (teamRecord.playerStats.pitching) {
            for (const playerName in teamRecord.playerStats.pitching) {
                const flag = teamRecord.playerStats.pitching[playerName].narrative_flag;
                const icon = getPlayerConditionIcon(flag);
                if (icon) icons.push(icon);
            }
        }
        
        // 重複を除去して返す (例: 姫川が打者/投手両方で🔥でも1つだけ表示)
        return [...new Set(icons)].join('');
    };

    const team1ConditionIcons = getConditionIconForTeam(team1);
    const team2ConditionIcons = getConditionIconForTeam(team2);
    // ★★★ 修正ここまで ★★★

    // ▼▼▼ チームスロットのHTMLを差し替え ▼▼▼
    const content = `
        <div class="team-slot ${t1Empty ? 'empty' : ''} ${dbMatch.winner === team1 && !t1Empty ? 'winner' : ''} ${dbMatch.winner && dbMatch.winner !== team1 && dbMatch.winner !== null ? 'loser' : ''}" data-team-name="${team1 || ''}">
            <span class="team-name clickable-team-name ${isSeed1 ? 'seed' : ''}" title="${team1 || ''}" data-team-name="${team1 || ''}">
                ${team1 ? `<span class="rank ${rankColor(rank1)}">[${rank1}]</span>` : ''}
                ${isSeed1 ? `[${seedInfo1.rank}] ` : ''}${team1 || '---'}
                ${team1ConditionIcons}
            </span>
            ${createSpecialButtons(team1)} 
            ${!t1Empty ? `<button class="show-team-stats-btn text-lg p-1 text-blue-600 hover:bg-blue-100 rounded" data-team-name="${team1}" title="${team1} の通算成績を見る">📊</button>` : ''}
            
            <input type="text" class="score-input ${showInputs ? '' : 'hidden'}" value="${dbMatch.score1 ?? ''}" data-team-pos="1">
            <button class="win-btn ${showInputs ? '' : 'hidden'}">▶</button>
            ${!showInputs ? `<span class="score-input font-bold">${dbMatch.score1 ?? ''}</span>` : ''}
        </div>
        
        <div class="team-slot ${t2Empty ? 'empty' : ''} ${dbMatch.winner === team2 && !t2Empty ? 'winner' : ''} ${dbMatch.winner && dbMatch.winner !== team2 && dbMatch.winner !== null ? 'loser' : ''}" data-team-name="${team2 || ''}">
            <span class="team-name clickable-team-name ${isSeed2 ? 'seed' : ''}" title="${team2 || ''}" data-team-name="${team2 || ''}">
                ${team2 ? `<span class="rank ${rankColor(rank2)}">[${rank2}]</span>` : ''}
                ${isSeed2 ? `[${seedInfo2.rank}] ` : ''}${team2 || '---'}
                ${team2ConditionIcons}
            </span>
            ${createSpecialButtons(team2)}
            ${!t2Empty ? `<button class="show-team-stats-btn text-lg p-1 text-blue-600 hover:bg-blue-100 rounded" data-team-name="${team2}" title="${team2} の通算成績を見る">📊</button>` : ''}
            
            <input type="text" class="score-input ${showInputs ? '' : 'hidden'}" value="${dbMatch.score2 ?? ''}" data-team-pos="2">
            <button class="win-btn ${showInputs ? '' : 'hidden'}">▶</button>
            ${!showInputs ? `<span class="score-input font-bold">${dbMatch.score2 ?? ''}</span>` : ''}
        </div>
        ${scheduleInfo} 
        ${atmosphereInputs}
        <div class="match-summary-container ${showInputs ? '' : 'hidden'}">
            <textarea class="match-summary-input w-full text-xs p-1 mt-1 border rounded" data-match-id="${matchId}" placeholder="試合の決め手（任意）">${dbMatch.summary || ''}</textarea>
        </div>
    `;

    // ▲▲▲ 差し替えここまで ▲▲▲

    let calledGameInfo = '';
    if (dbMatch.calledGame) {
        calledGameInfo = `<div class="text-center text-xs text-red-600 font-bold mt-1">(${dbMatch.calledInning}回コールド)</div>`;
    }

    let footer = '';
    if (dbMatch.winner && dbMatch.boxScoreHtml) {
        footer = `<div class="matchup-footer">
                    <button class="boxscore-btn text-sm bg-blue-600 text-white font-bold px-4 py-1 rounded hover:bg-blue-700" data-match-id="${matchId}">
                        一球速報
                    </button>
                    <button class="details-btn text-xs bg-gray-500 text-white px-2 py-1 rounded hover:bg-gray-600" data-match-id="${matchId}" title="詳細入力（修正）">
                        詳細
                    </button>
                  </div>`;
    }
     else if (!t1Empty && !t2Empty && !dbMatch.winner) {
        footer = `<div class="matchup-footer">
                    <button class="details-btn" data-match-id="${matchId}">詳細入力</button>
                    <button class="scorecard-open-btn text-sm bg-green-600 text-white font-bold px-3 py-1 rounded hover:bg-green-700" data-match-id="${matchId}">
                        🎮 簡易入力
                    </button>
                    <button class="quick-sim-btn text-lg" data-match-id="${matchId}" title="このスコアでおまかせ入力">🎲</button>
                    <button class="pre-game-cheer-btn text-xs bg-green-500 text-white px-2 py-1 rounded hover:bg-green-600" data-match-id="${matchId}">応援</button>
                  </div>`;
    }
        
    return `<div class="matchup ${specialMatchClass}" data-match-id="${matchId}">
                ${content}
                ${calledGameInfo} 
                ${footer}
            </div>`;
}
// ▲▲▲ 置き換えここまで ▲▲▲

    
/**
 * [修正版] UIの各種コンテンツエリア（ニュース）を描画する
 * (★スキップ新聞の「読み返しボタン」に対応)
 */
function renderNews(news) {
    if (!news || news.length === 0) {
        newsContainer.innerHTML = `<p class="text-gray-500 text-center">まだニュースはありません。</p>`;
        return;
    }
    newsContainer.innerHTML = '';
    
    news.slice().reverse().forEach((article, reversedIndex) => {
        const articleEl = document.createElement('div');
        const originalIndex = news.length - 1 - reversedIndex;

        if (article.isScandalRumor) {
            // ... (スキャンダル記事のロジックは変更なし) ...
            articleEl.className = 'bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-lg shadow';
            articleEl.innerHTML = `
                <h3 class="font-bold">${article.title}</h3>
                <p class="text-sm mt-2">${article.body}</p>
                <div class="mt-4 border-t pt-3 text-center">
                    <p class="text-sm font-bold mb-2">あなたはこの疑惑をどうしますか？</p>
                    <button class="report-scandal-btn bg-red-600 text-white px-4 py-1 rounded text-sm hover:bg-red-700">大会運営に報告する</button>
                    <button class="ignore-scandal-btn bg-gray-500 text-white px-4 py-1 rounded text-sm hover:bg-gray-600 ml-2">見て見ぬふりをする</button>
                </div>
            `;
// ▼▼▼ 追加箇所: スカウティングレポートの表示 ▼▼▼
     }   else if (article.isScoutReport) {
            articleEl.className = 'scout-report-card p-4 rounded-lg shadow mb-4';
            articleEl.innerHTML = `
                <h3 class="scout-report-title text-lg">⚾ ${article.title}</h3>
                <div class="scout-report-body">
                    ${article.body.replace(/\n/g, '<br>')}
                </div>
            `;
        }
        // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

         else if (article.error) {
            // ... (エラー記事のロジックは変更なし) ...
            articleEl.className = 'article-error';
            const regenerateButtonHTML = article.context ? `<button class="regenerate-btn" data-index="${originalIndex}">再生成</button>` : '';
            articleEl.innerHTML = `<span>${article.title}</span>${regenerateButtonHTML}`;
        } else {
            // --- 通常記事、新聞記事、スキップ新聞記事 ---
            articleEl.className = 'bg-white p-4 rounded-lg shadow';
            let buttonsHTML = '';

            if (article.isAnalysisArticle) {
                // ... (勢力図アニメーションボタンは変更なし) ...
                buttonsHTML = `<button class="text-sm bg-cyan-500 text-white font-bold px-4 py-2 rounded hover:bg-cyan-600 view-analysis-btn">勢力図をアニメーションで見る</button>`;
            
            // ★★★ ここからが修正箇所 ★★★
            } else if (article.isSkipNewspaper) {
                // --- スキップ新聞の場合 ---
                buttonsHTML = `<button class="text-sm bg-gray-700 text-white font-bold px-4 py-2 rounded hover:bg-gray-800 skip-newspaper-view-btn" data-index="${originalIndex}">スキップ新聞を読む</button>`;
            
            } else {
                // --- 通常の試合記事の場合 ---
                const regenerateButtonHTML = article.context ? `<button class="text-sm bg-yellow-100 text-yellow-800 px-3 py-1 rounded hover:bg-yellow-200 ml-2 regenerate-btn" data-index="${originalIndex}">再生成</button>` : '';
                const newspaperButtonHTML = article.isNewspaper ? `<button class="text-sm bg-red-100 text-red-700 px-3 py-1 rounded hover:bg-red-200 ml-2 newspaper-view-btn" data-index="${originalIndex}">新聞を読む</button>` : '';
                buttonsHTML = `
                    <button class="text-sm bg-gray-200 px-3 py-1 rounded hover:bg-gray-300 news-article-btn" data-index="${originalIndex}">本文</button>
                    ${newspaperButtonHTML}
                    ${regenerateButtonHTML}
                `;
            }
            // ★★★ 修正ここまで ★★★

            articleEl.innerHTML = `
                <div class="flex justify-between items-center">
                    <div>
                        <h3 class="font-bold text-lg text-blue-600">${article.title}</h3>
                        <p class="text-xs text-gray-400 mt-1">${new Date(article.timestamp).toLocaleDateString('ja-JP')}</p>
                    </div>
                    <div class="flex items-center space-x-2">
                        ${buttonsHTML}
                    </div>
                </div>
            `;
        }
        newsContainer.appendChild(articleEl);
    });
}    



/**
 * 掲示板のコメント（スレッド形式と個別コメント形式の両方に対応）を描画する
 */
function renderBbsComments(items) { // 引数名を items に変更
    if (!items || items.length === 0) {
        bbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">まだ反応はありません。</p>`;
        return;
    }
    bbsCommentsContainer.innerHTML = ''; // コンテナをクリア

    // 新しいアイテムが上に来るように逆順で処理
    items.slice().reverse().forEach((item, reversedIndex) => {
        const originalIndex = items.length - 1 - reversedIndex;

        // A. エラーオブジェクトの場合
        if (item.error && item.title) {
            const errorEl = document.createElement('div');
            errorEl.className = 'article-error mb-4'; // マージン追加, ニュース記事のエラースタイルを流用
            // ★★★ 再生成ボタンのdata属性を修正 ★★★
            const regenerateButtonHTML = item.context ? `<button class="retry-bbs-btn bg-red-600 text-white px-3 py-1 rounded text-sm hover:bg-red-700" data-index="${originalIndex}" data-type="${item.context.isBracketThread ? 'bracket-thread' : 'match-comments'}">再生成</button>` : '';
            errorEl.innerHTML = `<span>${item.title}</span>${regenerateButtonHTML}`;
            bbsCommentsContainer.appendChild(errorEl);
        }
        // B. スレッドオブジェクトの場合 (組み合わせ決定スレなど title と comments を持つ)
        else if (item.comments && Array.isArray(item.comments) && item.title) {
            const threadWrapper = document.createElement('div');
            threadWrapper.className = 'mb-6 p-4 border rounded-lg bg-white shadow';

            const titleEl = document.createElement('h3');
            titleEl.className = 'text-lg font-bold text-gray-800 mb-3 border-b pb-2';
            titleEl.textContent = `【${item.matchId === 'bracket' ? '組み合わせ決定' : '試合結果'}】${item.title}`;
            threadWrapper.appendChild(titleEl);

            const commentsContainer = document.createElement('div');
            commentsContainer.className = 'space-y-3';

            // スレッド内のコメントを描画
            item.comments.forEach(comment => {
                renderCommentThread(comment, commentsContainer, 'general');
            });

            threadWrapper.appendChild(commentsContainer);
            bbsCommentsContainer.appendChild(threadWrapper);
        }
        // C. 個別のコメントオブジェクトの場合 (試合後の反応など personality と text を持つ)
        else if (item.personality && item.text) {
            // 個別コメントはスレッド枠なしで直接描画
            renderCommentThread(item, bbsCommentsContainer, 'general');
            // 個別コメント間に区切り線などを入れても良いかも
            const hr = document.createElement('hr');
            hr.className = 'my-3 border-gray-200';
            bbsCommentsContainer.appendChild(hr);
        }
        // D. その他の予期せぬデータ
        else {
             console.warn("Unknown item type in bbsComments:", item);
             const unknownEl = document.createElement('div');
             unknownEl.className = 'text-red-500 text-sm my-2';
             unknownEl.textContent = '[不明な掲示板データ]';
             bbsCommentsContainer.appendChild(unknownEl);
        }
    });

     // 最後の区切り線を削除 (個別コメントが最後だった場合)
     const lastElement = bbsCommentsContainer.lastElementChild;
     if (lastElement && lastElement.tagName === 'HR') {
         bbsCommentsContainer.removeChild(lastElement);
     }
}

// renderCommentThread 関数は個別のコメントを描画するため、基本変更不要
// function renderCommentThread(comment, container, bbsType) { ... }

    function renderDaiyaBbsComments(comments) {
        if (!comments || comments.length === 0) {
            daiyaBbsCommentsContainer.innerHTML = `<p class="text-gray-500 text-center">まだ反応はありません。</p>`;
            return;
        }
        daiyaBbsCommentsContainer.innerHTML = '';
        comments.slice().reverse().forEach(comment => {
            renderCommentThread(comment, daiyaBbsCommentsContainer, 'daiya');
        });
    }

    function renderNamcoNews(news) {
        if (!news) {
            namcoNewsSection.classList.add('hidden');
            return;
        }
        namcoNewsSection.classList.remove('hidden');
        namcoNewsContent.innerHTML = '';
        const newsItem = document.createElement('div');
        newsItem.className = 'namco-news-item p-2 hover:bg-orange-50 rounded';
        newsItem.innerHTML = `<p class="font-semibold text-gray-700">${news.title}<span class="namco-news-tag">野球部</span></p>`;
        newsItem.addEventListener('click', () => {
            document.getElementById('modal-title').textContent = news.title;
            document.getElementById('modal-body').textContent = news.body;
            document.getElementById('modal-meta').innerHTML = `<p>${new Date(news.timestamp).toLocaleDateString('ja-JP')}</p><p class="font-bold text-gray-500">野球部</p>`;
            newsModal.classList.remove('hidden');
            newsModal.classList.add('flex');
        });
        namcoNewsContent.appendChild(newsItem);
    }

    function renderCommentThread(comment, container, bbsType) {
        const threadContainer = document.createElement('div');
        if (container.id === `replies-to-${comment.id}` || (container.id.includes('bbs-comments') && container.children.length > 0)) {
            threadContainer.className = 'ml-4 border-l-2 pl-4 mt-2';
        } else {
            threadContainer.className = 'mt-2';
        }

        const personalityClass = comment.personality === 'あなた' ? 'text-blue-600 font-bold' : 'text-gray-600';
        const commentEl = document.createElement('div');
        commentEl.className = 'bbs-comment';
        commentEl.innerHTML = `
            <div class="flex justify-between items-center">
                <p class="font-semibold ${personalityClass} text-sm">${comment.personality || '名無しさん'}</p>
                <button class="reply-btn text-xs text-blue-500 hover:underline" data-comment-id="${comment.id}" data-bbs-type="${bbsType}">返信する</button>
            </div>
            <p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>
            <p class="text-xs text-gray-400 text-right">${new Date(comment.timestamp).toLocaleString('ja-JP')}</p>
            <div id="reply-form-container-${comment.id}" class="hidden mt-2">
                <form class="reply-form" data-comment-id="${comment.id}" data-bbs-type="${bbsType}">
                    <textarea class="w-full p-2 border rounded text-sm" placeholder="返信を入力..." required></textarea>
                    <button type="submit" class="mt-1 bg-blue-500 text-white px-3 py-1 text-xs rounded hover:bg-blue-600">送信</button>
                </form>
            </div>
        `;
        threadContainer.appendChild(commentEl);

        const repliesContainer = document.createElement('div');
        repliesContainer.id = `replies-to-${comment.id}`;
        threadContainer.appendChild(repliesContainer);

        container.appendChild(threadContainer);

        if (comment.replies && comment.replies.length > 0) {
            comment.replies.slice().reverse().forEach(reply => {
                renderCommentThread(reply, repliesContainer, bbsType);
            });
        }
    }

   // ▼▼▼ 既存の「renderRegionMap」関数 (8459行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * [UPDATED] 地域別勝ち残り状況を描画する
 * (★参加チームの地域(region)を動的に収集して表示する汎用版)
 */
function renderRegionMap(data) {
    const regionMapSection = document.getElementById('region-map-section');
    const finalMatch = data.matches['F-R1-M1'];
    
    // 試合データがない場合は非表示
    if ((!data.matches || Object.keys(data.matches).length === 0) && !finalMatch) {
        regionMapSection.classList.add('hidden');
        return;
    }
    regionMapSection.classList.remove('hidden');

    const container = document.getElementById('region-map-container');
    
    // ★★★ 修正箇所: 地域を動的に収集 ★★★
    const teamsByRegion = {};
    const targetTeams = data.teams || INITIAL_TEAM_POOL; // 現在の大会参加チーム、なければ全チーム

    targetTeams.forEach(teamName => {
        if (teamName === '(BYE)') return;
        const region = TEAM_DATA[teamName]?.region || 'その他';
        if (!teamsByRegion[region]) {
            teamsByRegion[region] = [];
        }
        teamsByRegion[region].push(teamName);
    });
    
    // 表示順序を定義 (甲子園用と県大会用)
    let regionOrder = [];
    if (data.currentTournament === 'summer_koshien') {
        regionOrder = ['北海道', '東北', '関東', '北信越', '東海', '近畿', '中国', '四国', '九州', '全国', 'その他'];
    } else {
        regionOrder = ['東部', '中部', '西部', '伊豆', 'その他'];
    }
    // ★★★ 修正ここまで ★★★

    const eliminatedTeams = new Set();
    const allMatches = data.matches; 

    Object.values(allMatches).filter(match => match.winner).forEach(match => {
        const loser = match.team1 === match.winner ? match.team2 : match.team1;
        if (loser && loser !== '(BYE)') eliminatedTeams.add(loser); 
    });

    if (finalMatch?.winner) {
        const tournamentWinner = finalMatch.winner;
        // 優勝チームは敗退リストから除外（念のため）
        if (eliminatedTeams.has(tournamentWinner)) eliminatedTeams.delete(tournamentWinner);
    }
    
    let html = '<div class="region-map-scroll-container">';
    
    // 定義順に並べ替え、定義にない地域は末尾に追加
    const sortedRegions = Object.keys(teamsByRegion).sort((a, b) => {
        const indexA = regionOrder.indexOf(a);
        const indexB = regionOrder.indexOf(b);
        if (indexA !== -1 && indexB !== -1) return indexA - indexB;
        if (indexA !== -1) return -1;
        if (indexB !== -1) return 1;
        return a.localeCompare(b, 'ja');
    });

    for (const region of sortedRegions) {
        const teams = teamsByRegion[region];
        if (!teams || teams.length === 0) continue;
        
        const survivingCount = teams.filter(team => !eliminatedTeams.has(team)).length;

        html += `
        <div class="region-column">
            <div class="region-header">
                <h3 class="region-title">${region}</h3>
                <p class="region-stats">${survivingCount} / ${teams.length} 校生存</p>
            </div>
            <ul class="region-team-list">
                ${teams.sort((a, b) => {
                    const aElim = eliminatedTeams.has(a);
                    const bElim = eliminatedTeams.has(b);
                    if (aElim === bElim) return a.localeCompare(b, 'ja');
                    return aElim ? 1 : -1;
                }).map(team => `
                    <li class="region-team ${eliminatedTeams.has(team) ? 'team-eliminated' : 'team-surviving'}">
                        ${team}
                    </li>
                `).join('')}
            </ul>
        </div>
        `;
    }
    html += '</div>';
    container.innerHTML = html;
}
// ▲▲▲ 置き換えここまで ▲▲▲
    
    /**
     * スキップボタンの表示・非表示を制御する
     * (★変数宣言を削除し、グローバル変数を参照するよう修正)
     */
    function checkTournamentProgress() {
        // ★★★ 修正箇所 (const をすべて削除) ★★★
        skipR1Btn = document.getElementById('skip-r1-btn');
        skipR2Btn = document.getElementById('skip-r2-btn');
        skipR3Btn = document.getElementById('skip-r3-btn');
        skipR4Btn = document.getElementById('skip-r4-btn');
        skipR5Btn = document.getElementById('skip-r5-btn');
        skipR6Btn = document.getElementById('skip-r6-btn'); 
        skipFinalBtn = document.getElementById('skip-final-btn');
        generateSummaryBtn = document.getElementById('generate-summary-btn');
        // ★★★ 修正ここまで ★★★
        
        const allSkipButtons = [skipR1Btn, skipR2Btn, skipR3Btn, skipR4Btn, skipR5Btn, skipR6Btn, skipFinalBtn, generateSummaryBtn];

        if (!tournamentState.matches || Object.keys(tournamentState.matches).length === 0) {
            allSkipButtons.forEach(btn => btn?.classList.add('hidden'));
            return;
        }

        const matchIds = Object.keys(tournamentState.matches);
        const numTeams = tournamentState.teams.length; // 128
        const finalRound = Math.log2(numTeams); // 7

        const getRoundStatus = (roundNumber) => {
            const played = matchIds.filter(id => id.includes(`-R${roundNumber}-M`) && tournamentState.matches[id]?.winner).length;
            const total = numTeams / Math.pow(2, roundNumber); // R1=64, R2=32...
            return { total, played };
        };
        
        const r1_status = getRoundStatus(1);
        const r2_status = getRoundStatus(2);
        const r3_status = getRoundStatus(3);
        const r4_status = getRoundStatus(4);
        const r5_status = getRoundStatus(5);
        const r6_status = getRoundStatus(6);
        const finalMatch = tournamentState.matches['F-R1-M1'];

        skipR1Btn.classList.toggle('hidden', r1_status.played === r1_status.total);
        skipR2Btn.classList.toggle('hidden', !(r1_status.played === r1_status.total && r2_status.played !== r2_status.total));
        skipR3Btn.classList.toggle('hidden', !(r2_status.played === r2_status.total && r3_status.played !== r3_status.total));
        skipR4Btn.classList.toggle('hidden', !(r3_status.played === r3_status.total && r4_status.played !== r4_status.total));
        skipR5Btn.classList.toggle('hidden', !(r4_status.played === r4_status.total && r5_status.played !== r5_status.total));
        skipR6Btn.classList.toggle('hidden', !(r5_status.played === r5_status.total && r6_status.played !== r6_status.total));
        skipFinalBtn.classList.toggle('hidden', !(r6_status.played === r6_status.total && (!finalMatch || !finalMatch.winner)));
        
        const summaryGenerated = tournamentState.news.some(n => n.summaryType === 'best8');
        generateSummaryBtn.classList.toggle('hidden', !(r4_status.played === r4_status.total && r5_status.played === 0 && !summaryGenerated));
    }
// ▲▲▲ 置き換えここまで ▲▲▲

/**
     * 【修正版】決勝戦を自動でスキップする
     * (★新聞生成フックを追加)
     */
    async function skipFinal() {
        const finalMatch = tournamentState.matches['F-R1-M1'];
        if (!finalMatch || !finalMatch.team1 || !finalMatch.team2 || finalMatch.winner) return;

        const btn = document.getElementById('skip-final-btn');
        if(btn) btn.disabled = true;
        
        const { team1, team2 } = finalMatch;
        const rank1 = calculateRank(team1, tournamentState);
        const rank2 = calculateRank(team2, tournamentState);
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        
        let winnerName, loserName;
        // ランク差が2以上ある場合、95%の確率でランク上位が勝利
        const upsetChance = Math.abs(rankValues[rank1] - rankValues[rank2]) >= 2 ? 0.05 : 0.45;

        if (Math.random() < upsetChance) { // 番狂わせ
            winnerName = rankValues[rank1] < rankValues[rank2] ? team1 : team2;
        } else { // 順当
            winnerName = rankValues[rank1] >= rankValues[rank2] ? team1 : team2;
        }
        loserName = winnerName === team1 ? team2 : team1;

        const winnerRank = calculateRank(winnerName, tournamentState);
        const loserRank = calculateRank(loserName, tournamentState);
        const [winnerScore, loserScore] = generateAutoScore(winnerRank, loserRank);

        finalMatch.score1 = (finalMatch.team1 === winnerName) ? winnerScore : loserScore;
        finalMatch.score2 = (finalMatch.team2 === winnerName) ? winnerScore : loserScore;

        // ★ 結果を収集 (決勝は1試合のみ)
        const roundResults = [{
            matchId: 'F-R1-M1', winnerName, loserName, winnerScore, loserScore,
            winnerRank, loserRank, rankDiff: rankValues[winnerRank] - rankValues[loserRank]
        }];

        await processMatchWin('F-R1-M1', winnerName);

        // ★★★ ステップ2：新聞を生成・表示 ★★★
        const finalRoundNum = Math.log2(tournamentState.teams.length); // 128チームなら 7
        await generateSkipRoundNewspaper(finalRoundNum, roundResults);
        // ★★★ 新聞生成フックここまで ★★★

        if(btn) btn.classList.add('hidden');
    }

    function checkBest8Decided(){} // checkTournamentProgressに統合
// --- 試合詳細モーダル関連の関数（高機能版） ---

   /**
 * [修正版] イニングスコアのテーブルHTMLを生成する
 * (★コールド回数や実際のイニング数に合わせて列数を調整)
 */
function createInningScoreTable(team1Name, team2Name, details, isCalledGame, calledInning) {
    const inningData = details.inningScore || { team1: [], team2: [] };
    
    // 表示するイニング数を決定
    // データ上の最大イニング、コールド回、または最低9回
    const maxDataLen = Math.max(inningData.team1.length, inningData.team2.length);
    let numInnings = Math.max(9, maxDataLen);

    // コールドゲームの場合は、指定された回数で切る
    if (isCalledGame && calledInning) {
        numInnings = calledInning;
    }

    let header = '';
    for (let i = 1; i <= numInnings; i++) {
        header += `<th class="col-inning-score">${i}</th>`;
    }

    const createRow = (teamKey, teamName) => {
        let cells = '';
        for (let i = 0; i < numInnings; i++) {
            const scoreValue = inningData[teamKey]?.[i] ?? ''; 
            cells += `<td class="col-inning-score"><input type="number" value="${scoreValue}"></td>`;
        }
        return `<tr>
                    <th class="col-team text-left font-semibold pl-2">${teamName}</th>
                    ${cells}
                    <td class="total-score col-total"></td>
                </tr>`;
    };

    return `
        <div class="mb-6 overflow-x-auto">
            <h4 class="font-bold mb-2">イニングスコア</h4>
            <table class="details-table" id="inning-score-table">
                <thead>
                    <tr>
                        <th class="col-team">チーム</th>${header}<th class="col-total">計</th><th class="col-add-inning"><button id="add-inning-score-btn" class="text-xs font-bold">+</button></th>
                    </tr>
                </thead>
                <tbody>${createRow('team1', team1Name)}${createRow('team2', team2Name)}</tbody>
            </table>
        </div>`;
}


// ▼▼▼ 既存の「openDetailsModal」関数 (10563行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * 新しい試合詳細モーダルを開き、各種テーブルを生成する
 * (★コールドゲーム対応・イニング数動的調整版)
 */
function openDetailsModal(matchId) {
    currentMatchIdForDetails = matchId;
    const match = findMatchById(matchId);
    if (!match) {
        console.error(`[openDetailsModal] エラー: ID ${matchId} の試合が見つかりません。`);
        return;
    }

    console.log("--- [モーダル表示 開始] ---", { matchId: matchId, 既存データ: match.details });

    let details = JSON.parse(JSON.stringify(match.details || {}));

    // --- 前回のロスター情報を引き継ぐ ---
    if ((!details.batting || !details.batting.team1 || details.batting.team1.length === 0)) {
        console.log("[ロスター引継] この試合の詳細は空です。前回のロスターを探します...");
        
        // battingオブジェクトがない場合は初期化
        details.batting = details.batting || { team1: [], team2: [] };

        for (const teamKey of ['team1', 'team2']) {
            const teamName = match[teamKey];
            const teamRecord = tournamentState.teamRecords[teamName];
            
            // パターンA: 保存されたロスターがある場合 (2回戦以降)
            if (teamRecord && teamRecord.roster && teamRecord.roster.length > 0) {
                console.log(`[ロスター引継] ${teamRecord.roster.length}名のロスターデータを読み込みます。`);
                details.batting[teamKey] = teamRecord.roster
                    .filter(playerData => playerData.order && !playerData.order.toString().includes('sub'))
                    .map(playerData => ({
                        ...playerData, 
                        sub_type: null,
                        results: []     
                    }));
            }
            // パターンB: 過去のスタメン履歴がある場合 (旧データ互換性)
            else if (teamRecord && teamRecord.previousStarters && teamRecord.previousStarters.length > 0) {
                 details.batting[teamKey] = teamRecord.previousStarters.map(playerData => ({
                    ...playerData,
                    results: [] 
                }));
            }
            // パターンC: 【新規】マスタデータがある場合 (1回戦・初回)
            else if (TEAM_ROSTER_MASTER[teamName]) {
                 console.log(`[ロスター引継] ${teamName} のデフォルトスタメンをロードします。`);
                 const masterRoster = TEAM_ROSTER_MASTER[teamName];
                 
                 // マスタデータをスタメン形式に変換
                 details.batting[teamKey] = masterRoster.map((p, index) => {
                     // 9番目まではスタメン(order:1-9)、それ以降は控え(order:null)
                     // ※TEAM_ROSTER_MASTERがスタメン順に並んでいる前提
                     const order = (index < 9) ? (index + 1).toString() : null;
                     
                     // 守備位置の短縮形 (例: "遊撃手" -> "遊")
                     const posShort = p.position ? p.position.charAt(0) : '';

                     return {
                         order: order,
                         name: p.name,
                         number: p.number,
                         pos: posShort,
                         throwBat: p.throwBat,
                         isCaptain: p.isCaptain || false, // キャプテン情報も反映
                         sub_type: null,
                         results: [] 
                     };
                 });
            }
        }
    }

    // ▼▼▼ 修正箇所1：表示するイニング数の計算ロジックを変更 ▼▼▼
    let numInnings = 9;
    const currentMaxLen = Math.max(
        details.inningScore?.team1?.length || 0,
        details.inningScore?.team2?.length || 0,
        details.batting?.team1?.[0]?.results?.length || 0
    );
    
    if (match.calledGame && match.calledInning) {
        // コールドゲームなら、その回数に合わせる
        numInnings = match.calledInning;
    } else {
        // 通常なら最低9回、延長があればそれに合わせる
        numInnings = Math.max(9, currentMaxLen);
    }
    console.log(`[モーダル表示] イニング数を ${numInnings} 回として描画します`);
    // ▲▲▲ 修正ここまで ▲▲▲

    // データ構造の初期化（配列長を numInnings に合わせる）
    details.inningScore = details.inningScore || { team1: [], team2: [] };
    details.batting = details.batting || { team1: [], team2: [] };
    details.pitching = details.pitching || { team1: [], team2: [] };
    details.fielding = details.fielding || { team1: [], team2: [] };
    details.inningEvents = details.inningEvents || { team1: [], team2: [] };
    details.positionChanges = details.positionChanges || [];

    // --- 守備交代の履歴生成 ---
    const allChanges = details.positionChanges || [];
    const sortedChanges = allChanges.sort((a, b) => {
        const inningA = parseInt(a.inning) || 0;
        const inningB = parseInt(b.inning) || 0;
        if (inningA !== inningB) return inningA - inningB;
        return (a.topBottom === '裏' ? 1 : 0) - (b.topBottom === '裏' ? 1 : 0);
    });

    for (const teamKey of ['team1', 'team2']) {
        const teamBattingData = details.batting[teamKey];
        if (teamBattingData) {
            teamBattingData.forEach(player => {
                if (!player.name) {
                    player.posHistoryDisplay = ''; 
                    player.currentPos = ''; 
                    return;
                }
                let history = [];
                if (player.pos) {
                    let initialTiming = "スタメン";
                    // ▼▼▼ 修正: orderが存在する場合のみチェックするよう変更 ▼▼▼
                    if (player.order && player.order.toString().includes('sub')) {
                    // ▲▲▲ 修正ここまで ▲▲▲
                        if (player.sub_type === 'PH') initialTiming = "代打出場";
                        else if (player.sub_type === 'PR') initialTiming = "代走出場";
                        else initialTiming = "途中出場";
                    }
                    history.push({ pos: player.pos, timing: initialTiming });
                }
                sortedChanges.forEach(change => {
                    if (change.teamKey === teamKey && change.playerName === player.name) {
                        let timingStr = `${change.inning || '?'}回${change.topBottom || ''}`;
                        if (change.timing === 'mid') timingStr += ` ${change.outs || '0'}死`;
                        else timingStr += ` 0死`;
                        history.push({ pos: change.newPos, timing: timingStr });
                    }
                });
                const uniqueHistory = history.filter((entry, index) => {
                    return entry.pos && (index === 0 || entry.pos !== history[index - 1].pos);
                });
                if (uniqueHistory.length > 1) {
                    player.posHistoryDisplay = uniqueHistory.map((entry, index) => {
                        if (index === 0) return entry.pos;
                        return `→ (${entry.timing}) ${entry.pos}`;
                    }).join(' ');
                    player.currentPos = uniqueHistory[uniqueHistory.length - 1].pos;
                } else if (uniqueHistory.length === 1) {
                    player.posHistoryDisplay = uniqueHistory[0].pos;
                    player.currentPos = uniqueHistory[0].pos;
                } else {
                    player.posHistoryDisplay = '';
                    player.currentPos = player.pos || '';
                }
            });
        }
    }

    for(const teamKey of ['team1', 'team2']) {
        if (!details.inningEvents[teamKey]) details.inningEvents[teamKey] = [];
        while (details.inningScore[teamKey].length < numInnings) details.inningScore[teamKey].push('');
        while (details.inningEvents[teamKey].length < numInnings) details.inningEvents[teamKey].push('');
        if (details.batting[teamKey]) {
            details.batting[teamKey].forEach(player => {
                if (!player.results) player.results = [];
                while (player.results.length < numInnings) player.results.push('');
            });
        }
    }

    // 選手名簿読み込み
    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (details.batting[teamKey].length === 0 && teamRecord && teamRecord.roster) {
            details.batting[teamKey] = teamRecord.roster.map(p => ({ ...p, results: Array(numInnings).fill('') }));
        }
    }
    
    const playersTeam1 = details.batting.team1.filter(p => p.name).map(p => ({name: p.name}));
    const playersTeam2 = details.batting.team2.filter(p => p.name).map(p => ({name: p.name}));

    const detailsBody = document.getElementById('details-modal-body');
    detailsBody.innerHTML = `
        <div class="space-y-4">
            ${createInningScoreTable(match.team1, match.team2, details, match.calledGame, match.calledInning)}
            
            <div class="flex items-center justify-center space-x-4 bg-gray-100 p-2 rounded border border-gray-300">
                <label class="inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="called-game-checkbox" class="form-checkbox h-5 w-5 text-blue-600" ${match.calledGame ? 'checked' : ''}>
                    <span class="ml-2 text-gray-700 font-bold">この試合をコールドゲームとして記録する</span>
                </label>
            </div>
            <div class="text-center py-2 border-t border-b">
                <button id="swap-teams-btn" data-match-id="${matchId}" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded">先攻・後攻を入れ替え</button>
            </div>
            
            <div class="space-y-4">
                <h4 class="font-bold text-lg">${match.team1} 打撃成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPlayerBattingTable(match.team1, 'team1', details)}</div>
                <h4 class="font-bold text-lg mt-4">${match.team2} 打撃成績</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPlayerBattingTable(match.team2, 'team2', details)}</div>
            </div>
            
            <div class="space-y-4 mt-4">
                <h4 class="font-bold text-lg flex justify-between items-center">
                    <span>${match.team1} 投手成績</span>
                    <button class="calc-pitcher-stats-btn text-xs bg-purple-100 text-purple-700 px-2 py-1 rounded hover:bg-purple-200 ml-2"
                            data-pitching-team="team1" data-batting-team="team2">
                        ${match.team2}の打撃から自動計算
                    </button>
                    <button class="copy-pitchers-from-batting-btn text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded hover:bg-blue-200 ml-2" data-team-key="team1">
                        打順からコピー
                    </button>
                </h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPitchingStatsTable('team1', details)}</div>
                
                <h4 class="font-bold text-lg flex justify-between items-center mt-4">
                    <span>${match.team2} 投手成績</span>
                    <button class="calc-pitcher-stats-btn text-xs bg-purple-100 text-purple-700 px-2 py-1 rounded hover:bg-purple-200 ml-2"
                            data-pitching-team="team2" data-batting-team="team1">
                        ${match.team1}の打撃から自動計算
                    </button>
                    <button class="copy-pitchers-from-batting-btn text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded hover:bg-blue-200 ml-2" data-team-key="team2">
                        打順からコピー
                    </button>
                </h4>
                <div class="overflow-x-auto border rounded-lg bg-white">${createPitchingStatsTable('team2', details)}</div>
            </div>

            <div class="space-y-4 mt-4">
                <h4 class="font-bold text-lg">${match.team1} 守備ハイライト</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">
                    ${createFieldingTable('team1', details, playersTeam1)}
                </div>
                 <h4 class="font-bold text-lg mt-4">${match.team2} 守備ハイライト</h4>
                <div class="overflow-x-auto border rounded-lg bg-white">
                    ${createFieldingTable('team2', details, playersTeam2)}
                </div>
            </div>
        </div>
    `;

    // 283学園用 datalist
    const roster283 = TEAM_ROSTER_MASTER["283学園"];
    if (roster283) {
        const rosterOptionsHTML = roster283.map(p => `<option value="${p.name}"></option>`).join('');
        if (match.team1 === "283学園") {
            const datalistId = "roster-datalist-team1";
            const datalist = document.createElement('datalist');
            datalist.id = datalistId;
            datalist.innerHTML = rosterOptionsHTML;
            detailsBody.appendChild(datalist);
            document.querySelectorAll('#batting-table-team1 .player-name').forEach(input => input.setAttribute('list', datalistId));
        }
        if (match.team2 === "283学園") {
            const datalistId = "roster-datalist-team2";
            const datalist = document.createElement('datalist');
            datalist.id = datalistId;
            datalist.innerHTML = rosterOptionsHTML;
            detailsBody.appendChild(datalist);
            document.querySelectorAll('#batting-table-team2 .player-name').forEach(input => input.setAttribute('list', datalistId));
        }
    }

    detailsModal.classList.remove('hidden');
    updateTotalScores();
}

// ▲▲▲ 置き換えここまで ▲▲▲ 

/**
 * 投手成績のテーブルHTMLを生成する
 * (★全クラス名を付与した最終修正版★)
 * @param {string} teamKey - 'team1' または 'team2'
 * @param {object} details - 試合の詳細データ
 * @returns {string} - 生成されたHTML
 */
function createPitchingStatsTable(teamKey, details) {
    const pitchingData = details.pitching[teamKey] || [];
    
    // プルダウン選択肢の定義 (変更なし)
    const throwStyleOptions = [
        { val: "over", label: "オーバー" }, { val: "three_quarter", label: "スリークォーター" },
        { val: "side", label: "サイド" }, { val: "under", label: "アンダー" }
    ];
    const pitcherTypeOptions = [
        { val: "honkaku", label: "本格派" }, { val: "sokkyu", label: "速球派" },
        { val: "giko", label: "技巧派" }, { val: "nanto", label: "軟投派" }
    ];
    const velocityOptions = [];
    for (let v = 120; v <= 165; v += 5) {
        velocityOptions.push({ val: `${v}km`, label: `${v}km帯` });
    }
    const throwBatOptions = [
        { val: "R/R", label: "右/右" }, { val: "R/L", label: "右/左" }, { val: "R/S", label: "右/両" },
        { val: "L/L", label: "左/左" }, { val: "L/R", label: "左/右" }, { val: "L/S", label: "左/両" }
    ];

    let bodyRows = pitchingData.map((player, index) => {
        const tbOptionsHtml = throwBatOptions.map(opt => `<option value="${opt.val}" ${player.throwBat === opt.val ? 'selected' : ''}>${opt.label}</option>`).join('');
        const styleOptionsHtml = throwStyleOptions.map(opt => `<option value="${opt.val}" ${player.throwStyle === opt.val ? 'selected' : ''}>${opt.label}</option>`).join('');
        const typeOptionsHtml = pitcherTypeOptions.map(opt => `<option value="${opt.val}" ${player.pitcherType === opt.val ? 'selected' : ''}>${opt.label}</option>`).join('');
        const velocityOptionsHtml = velocityOptions.map(opt => `<option value="${opt.val}" ${player.velocity === opt.val ? 'selected' : ''}>${opt.label}</option>`).join('');

        // ▼▼▼ この行全体を修正（全要素にクラスを追加） ▼▼▼
        return `
        <tr data-pitcher-index="${index}">
            <td class="col-pitcher-result">
                <select class="pitcher-result"> 
                    <option value="" ${!player.result ? 'selected' : ''}>-</option>
                    <option value="W" ${player.result === 'W' ? 'selected' : ''}>○</option>
                    <option value="L" ${player.result === 'L' ? 'selected' : ''}>●</option>
                    <option value="S" ${player.result === 'S' ? 'selected' : ''}>S</option>
                    <option value="H" ${player.result === 'H' ? 'selected' : ''}>H</option>
                </select>
            </td>
            <td class="col-pitcher-name"><input type="text" class="pitcher-name" value="${player.name || ''}"></td> 
            <td class="col-pitcher-throw-bat"><select class="pitcher-throw-bat w-full bg-transparent"><option value="">-投/打-</option>${tbOptionsHtml}</select></td>
            <td class="col-pitcher-style"><select class="pitcher-throw-style w-full bg-transparent"><option value="">-投げ方-</option>${styleOptionsHtml}</select></td>
            <td class="col-pitcher-type"><select class="pitcher-type w-full bg-transparent"><option value="">-タイプ-</option>${typeOptionsHtml}</select></td>
            <td class="col-pitcher-velocity"><select class="pitcher-velocity w-full bg-transparent"><option value="">-球速帯-</option>${velocityOptionsHtml}</select></td>
            <td class="col-stat"><input type="text" class="pitcher-innings" value="${player.innings || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-batters" value="${player.battersFaced || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-pitches" value="${player.pitches || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-hits" value="${player.hits || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-so" value="${player.strikeouts || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-walks" value="${player.walks || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-runs" value="${player.runs || ''}"></td> 
            <td class="col-stat"><input type="number" class="pitcher-er" value="${player.earnedRuns || ''}"></td> 
        </tr>
        `;
        // ▲▲▲ 修正ここまで ▲▲▲
    }).join('');

    // もし投手が一人もいなければ、空の行を1つ追加しておく
    if (pitchingData.length === 0) {
        const tbOptionsHtml = throwBatOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const styleOptionsHtml = throwStyleOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const typeOptionsHtml = pitcherTypeOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const velocityOptionsHtml = velocityOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        // ▼▼▼ 空行にも全クラスを追加 ▼▼▼
        bodyRows = `
            <tr data-pitcher-index="0">
                <td class="col-pitcher-result"><select class="pitcher-result"><option value="" selected>-</option><option value="W">○</option><option value="L">●</option><option value="S">S</option><option value="H">H</option></select></td>
                <td class="col-pitcher-name"><input type="text" class="pitcher-name" value=""></td>
                <td class="col-pitcher-throw-bat"><select class="pitcher-throw-bat w-full bg-transparent"><option value="">-投/打-</option>${tbOptionsHtml}</select></td>
                <td class="col-pitcher-style"><select class="pitcher-throw-style w-full bg-transparent"><option value="">-投げ方-</option>${styleOptionsHtml}</select></td>
                <td class="col-pitcher-type"><select class="pitcher-type w-full bg-transparent"><option value="">-タイプ-</option>${typeOptionsHtml}</select></td>
                <td class="col-pitcher-velocity"><select class="pitcher-velocity w-full bg-transparent"><option value="">-球速帯-</option>${velocityOptionsHtml}</select></td>
                <td class="col-stat"><input type="text" class="pitcher-innings" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-batters" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-pitches" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-hits" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-so" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-walks" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-runs" value=""></td>
                <td class="col-stat"><input type="number" class="pitcher-er" value=""></td>
            </tr>
        `;
        // ▲▲▲ 修正ここまで ▲▲▲
    }

    return `
        <div class="overflow-x-auto">
            <table class="details-table" id="pitching-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="col-pitcher-result">勝敗</th>
                        <th class="col-pitcher-name">選手名</th>
                        <th class="col-pitcher-throw-bat">投/打</th>
                        <th class="col-pitcher-style">投げ方</th>
                        <th class="col-pitcher-type">タイプ</th>
                        <th class="col-pitcher-velocity">球速帯</th>
                        <th class="col-stat">回数</th>
                        <th class="col-stat">打者</th><th class="col-stat">球数</th><th class="col-stat">被安打</th>
                        <th class="col-stat">奪三振</th><th class="col-stat">与四球</th><th class="col-stat">失点</th>
                        <th class="col-stat">自責点</th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            <button class="add-row-btn text-xs mt-2" data-table-id="pitching-table-${teamKey}">+ 投手を追加</button>
        </div>
    `;
}

function createFieldingTable(teamKey, details, playersOnField) {
    const fieldingData = details.fielding?.[teamKey] || [];
    
    // 選手名を選択するための <option> タグを生成
    const playerOptions = playersOnField.map(p => `<option value="${p.name}">${p.name}</option>`).join('');

    let bodyRows = fieldingData.map((play, index) => `
        <tr data-fielding-index="${index}">
            <td class="w-16"><input type="number" class="fielding-inning" value="${play.inning || ''}" min="1"></td>
            <td>
                <select class="player-name w-full">
                    <option value="">- 選手 -</option>
                    ${playersOnField.map(p => `<option value="${p.name}" ${p.name === play.player ? 'selected' : ''}>${p.name}</option>`).join('')}
                </select>
            </td>
            <td><input type="text" class="fielding-play" value="${play.play || ''}" placeholder="例: ダイビングキャッチ、レーザービームで補殺"></td>
            <td class="w-12 text-center">
                <button class="remove-fielding-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </td>
        </tr>
    `).join('');
    
    return `
        <div class="overflow-x-auto">
            <table class="details-table" id="fielding-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="w-16">イニング</th>
                        <th>選手名</th>
                        <th>ファインプレーの内容</th>
                        <th class="w-12">削除</th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            <button class="add-fielding-play-btn text-xs mt-2" data-team-key="${teamKey}">+ ファインプレーを追加</button>
        </div>
    `;
}

// ▼▼▼ 整理済み：貢献度・打順分析機能のイベント処理 (最終版) ▼▼▼

// --- 1. グローバル変数の再取得 ---
const contribInput = document.getElementById('contribution-team-input');
const contribList = document.getElementById('contribution-suggestions');
// ※ activeAnalysisMode はグローバルで定義済みとします


// --- 2. 汎用ヘルパー関数 (変更なし) ---

/**
 * 貢献度モーダルを開く前の初期化処理
 */
function initContributionModal() {
    // 画面リセット
    document.getElementById('contribution-content').classList.add('hidden');
    
    // 入力欄とリストをクリア
    contribInput.value = '';
    contribList.classList.add('hidden');
    
    // モーダルを表示
    document.getElementById('contribution-modal').classList.remove('hidden');
    document.getElementById('contribution-modal').classList.add('flex');
}

/**
 * 検索キーワードをハイライト表示するヘルパー (グローバル化)
 */
function highlightMatch(text, query) {
    // 単純な置換だとHTMLが壊れる可能性があるため、テキストとして処理
    if (!query) return text;
    const regex = new RegExp(`(${query})`, 'gi');
    return text.replace(regex, '<span class="suggestion-match">$1</span>');
}


// --- 3. イベントリスナー定義 ---

// A. 【ボタン】貢献度・天体観測 (フラグ設定)
document.getElementById('show-contribution-btn').addEventListener('click', () => {
    initContributionModal();
    activeAnalysisMode = 'CONTRIBUTION'; 
    document.getElementById('contribution-modal').querySelector('h3').textContent = "🌌 チーム貢献度シェア & 天体観測";
    contribInput.placeholder = "分析するチーム名を入力...";
});

// B. 【ボタン】適正打順分析 (フラグ設定)
document.getElementById('show-lineup-analysis-btn').addEventListener('click', () => {
    initContributionModal();
    activeAnalysisMode = 'LINEUP_ANALYSIS'; 
    document.getElementById('contribution-modal').querySelector('h3').textContent = "⚾ 適正打順・役割分析";
    contribInput.placeholder = "分析したいチーム名を入力...";
});

// C. 【入力時】リアルタイム検索 (共通ロジック)
contribInput.addEventListener('input', () => {
    const query = contribInput.value.trim().toLowerCase();
    
    if (!query) {
        contribList.classList.add('hidden');
        return;
    }

    // 成績データがあるチームのみを検索対象にする
    const validTeams = Object.keys(tournamentState.teamRecords).filter(t => {
        const r = tournamentState.teamRecords[t];
        return r.wins > 0 || r.losses > 0; // 1試合以上したチーム
    });

    // フィルタリング
    const matches = validTeams.filter(teamName => {
        const data = TEAM_DATA[teamName] || {};
        return (
            teamName.includes(query) || 
            (data.name_yomi && data.name_yomi.includes(query)) ||
            (data.region && data.region.includes(query))
        );
    }).slice(0, 10);

    renderContribSuggestions(matches, query);
});

// D. 【クリック/Enter】実行ロジック (フラグに従って実行)
function executeAnalysis(teamName) {
    if (activeAnalysisMode === 'LINEUP_ANALYSIS') {
        const optimalLineup = generateOptimalLineup(teamName);
        if (optimalLineup) {
            renderOptimalLineupModal(teamName, optimalLineup);
        } else {
            alert(`「${teamName}」はデータ不足のため、打順を組めません。最低5打席以上の選手が9人必要です。`);
        }
    } else {
        // CONTRIBUTION モード
        renderContributionAnalysis(teamName);
    }
    document.getElementById('contribution-content').classList.remove('hidden');
}

// E. 【候補リスト】の描画 (クリックアクションを含む)
function renderContribSuggestions(teams, query) {
    contribList.innerHTML = '';
    if (teams.length === 0) {
        contribList.classList.add('hidden');
        return;
    }

    teams.forEach(teamName => {
        const data = TEAM_DATA[teamName] || {};
        const region = data.region || '不明';
        
        const li = document.createElement('li');
        li.className = 'suggestion-item';
        li.innerHTML = `
            <div>
                <span class="text-gray-800 font-medium">${highlightMatch(teamName, query)}</span>
                <span class="text-xs text-gray-500 ml-2">(${region})</span>
            </div>
        `;

        // ★★★ 【重要修正】クリック時の動作を executeAnalysis に一本化 ★★★
        li.addEventListener('click', () => {
            contribInput.value = teamName;
            contribList.classList.add('hidden');
            // グローバルフラグを参照して、適切な分析を実行
            executeAnalysis(teamName); 
        });

        contribList.appendChild(li);
    });

    contribList.classList.remove('hidden');
}

// F. 【Enterキー】実行リスナーを追加 (シンプルな処理に戻す)
contribInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        const teamName = contribInput.value.trim();
        // 候補リストを隠し、そのまま実行ロジックを呼び出す
        contribList.classList.add('hidden');
        if (teamName) {
            executeAnalysis(teamName);
        }
    }
});


// G. 【外側クリック】でリストを閉じる (変更なし)
document.addEventListener('click', (e) => {
    if (!contribInput.contains(e.target) && !contribList.contains(e.target)) {
        contribList.classList.add('hidden');
    }
});

// ▲▲▲ 整理済みコードここまで ▲▲▲
/**
 * RC貢献度ランキングを棒グラフで描画する (Chart.js)
 * ★ RC/G (試合あたり貢献度) に変更
 */
function renderRcBarChart(ctx, players) {
    const existingChart = Chart.getChart(ctx);
    if (existingChart) existingChart.destroy();

    // 1. RC/Gの値を計算して格納
    const playersWithRCG = players.map(p => {
        // gamesが未定義の場合があるため、0を代入
        const games = p.games || 0; 
        return {
            ...p,
            // RC/Gを計算: RC合計 / 試合数 (games)
            rcg: games > 0 ? p.rc / games : 0
        };
    }).filter(p => p.rcg > 0); // RC/Gが0より大きい選手のみ表示

    // データがなければ描画しない
    if (playersWithRCG.length === 0) {
        // Canvasを空にする処理（今回はCanvas自体にメッセージは書かない）
        return; 
    }

    // 2. RC/Gが高い順にソート（トップ10に制限）
    const sortedPlayers = playersWithRCG.sort((a, b) => b.rcg - a.rcg).slice(0, 10);

    const labels = sortedPlayers.map(p => p.name);
    const data = sortedPlayers.map(p => p.rcg);
    const colors = sortedPlayers.map(p => p.color);

    // 3. Chart.jsによる描画
    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Runs Created per Game (RC/G)',
                data: data,
                backgroundColor: colors,
                // 枠線を少し濃く (colors配列が空でないことを前提)
                borderColor: colors.map(c => c.replace('0.8', '1')), 
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y', // 横棒グラフ
            scales: {
                x: {
                    title: { display: true, text: 'Runs Created per Game (RC/G)' }, 
                    beginAtZero: true
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            // 小数点第2位まで表示
                            return `${context.label}: ${context.raw.toFixed(2)}点/試合`;
                        }
                    }
                }
            }
        }
    });
}

/**
 * [NEW] チームの対戦相手ランクを考慮した補正済み RC/G (ARC/G) を計算する
 */
function calculateAdjustedRCG(teamName, teamAvgRCG) {
    if (teamAvgRCG === 0) return 0;
    
    const record = tournamentState.teamRecords[teamName];
    if (!record || !record.playerStats) return teamAvgRCG;

    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    let totalOpponentRankScore = 0;
    let totalGames = 0;

    // 全ての打者のGamelogを走査し、試合ごとの対戦相手ランクを収集
    const processedMatchIds = new Set();
    
    // チーム全員の打撃Gamelogsを統合して処理
    for (const playerName in record.playerStats.batting) {
        const stats = record.playerStats.batting[playerName];
        if (stats.gamelogs) {
            stats.gamelogs.forEach(log => {
                // 試合IDが未処理、かつ相手ランク情報がある試合のみ
                if (!processedMatchIds.has(log.matchId) && log.opponentRank) {
                    totalOpponentRankScore += rankValues[log.opponentRank] || 3; // ランク値を加算
                    totalGames++;
                    processedMatchIds.add(log.matchId);
                }
            });
        }
    }
    
    if (totalGames === 0) return teamAvgRCG;

    // 補正係数の計算
    const averageOpponentRankValue = totalOpponentRankScore / totalGames;
    const neutralRank = 3.0; // Cランクを中立点とする
    
    // 補正係数: 平均ランクが中立点より高ければブースト、低ければ減衰
    const adjustmentFactor = averageOpponentRankValue / neutralRank;
    
    // ARC/G = RC/G * 補正係数
    const arcg = teamAvgRCG * adjustmentFactor;

    return arcg;
}

// ▼▼▼ renderContributionAnalysis 関数全体（ARC/G 挿入ロジック分離版）▼▼▼
/**
 * 選択されたチームの分析を描画
 */
function renderContributionAnalysis(teamName) {
    const record = tournamentState.teamRecords[teamName];
    if (!record || !record.playerStats || !record.playerStats.batting) return;

    // --- 0. Canvas要素の復元とコンテンツ定義 ---
    const contentArea = document.getElementById('contribution-content'); 
    if (!contentArea) return;

    // Canvas要素がない場合に再作成するロジックを統合 (打順分析から戻った場合)
    if (!document.getElementById('rc-pie-chart')) {
        // ★★★ HTML再構築処理 ★★★
        contentArea.innerHTML = `
            <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-gray-400">
                <h4 class="text-lg font-bold text-gray-800 mb-4 flex items-center">
                    <span class="text-xl mr-2">💡</span> 指標の目安と評価基準
                </h4>
                <div id="rc-guidelines" class="space-y-3"></div>
            </div>

            <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-purple-500">
                <h4 class="text-lg font-bold text-gray-800 mb-4">📊 得点創出シェア (Runs Created Share)</h4>
                <div class="flex flex-col md:flex-row items-center gap-8">
                    <div class="w-full md:w-1/2 h-64">
                        <canvas id="rc-pie-chart"></canvas>
                    </div>
                    <div class="w-full md:w-1/2">
                        <p class="text-sm text-gray-600 mb-2">
                            ※ <strong>RC (Runs Created)</strong>: その選手が「一人で何点生み出したか」を推定する指標。
                        </p>
                        <div id="rc-analysis-text" class="text-md font-bold text-purple-800 p-3 bg-purple-50 rounded"></div>
                    </div>
                </div>

                <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-yellow-500">
                    <h4 class="text-lg font-bold text-gray-800 mb-4">棒グラフ：RC/G（試合あたり貢献度）ランキング (Top 10)</h4>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="rc-bar-chart"></canvas>
                    </div>
                </div>
                
                <div class="bg-white p-6 rounded-lg shadow-md border-l-4 border-indigo-500">
                    <h4 class="text-lg font-bold text-gray-800 mb-4">⚾ 打者タイプ・マップ (OPS分析)</h4>
                    <div style="height: 400px; width: 100%;">
                        <canvas id="stellar-scatter-chart"></canvas>
                    </div>
                    <div class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-2 text-xs text-center">
                        <div class="p-2 bg-red-50 border border-red-200 rounded"><span class="text-lg">💣 爆発型</span><br>長打力特化 (OPS高)</div>
                        <div class="p-2 bg-blue-50 border border-blue-200 rounded"><span class="text-lg">🎯 理想型</span><br>打率とOPSのバランス型</div>
                        <div class="p-2 bg-orange-50 border border-orange-200 rounded"><span class="text-lg">🏹 職人型</span><br>高打率・確実性型 (AVG高)</div>
                        <div class="p-2 bg-gray-100 border border-gray-300 rounded"><span class="text-lg">📈 成長株</span><br>規定打席未到達/育成枠</div>
                    </div>
                </div>
            `;
        // グラフエリアを再表示
        const graphAreas = contentArea.querySelectorAll('.bg-white.p-6.rounded-lg.shadow-md');
        graphAreas.forEach(el => el.classList.remove('hidden'));

        // 打順表を非表示にする（打順分析から戻ってきた場合）
        const lineupTable = document.getElementById('optimal-lineup-table');
        if (lineupTable) {
            lineupTable.remove(); // 完全にDOMから削除
            contentArea.querySelector('.archive-header')?.remove(); 
        }
    } else {
         // グラフ要素が残っている場合は、単に非表示クラスを解除する
        const graphAreas = contentArea.querySelectorAll('.bg-white.p-6.rounded-lg.shadow-md');
        graphAreas.forEach(el => el.classList.remove('hidden'));
    }

    const players = [];
    let teamTotalRC = 0;

    // 1. データ計算
    // ... (データ計算ロジックは変更なし) ...
    Object.entries(record.playerStats.batting).forEach(([name, s]) => {
        if ((s.pa || 0) > 0) { 
            const h = s.h || 0;
            const bb = (s.bb || 0) + (s.hbp || 0);
            const ab = s.ab || 0;
            const hr = s.hr || 0;
            const tb = (s.tb || h) + (hr * 3); 

            const ob = h + bb; 
            const times = ab + bb; 
            
            let rc = times > 0 ? ((ob * tb) / times) : 0;
            rc = parseFloat(rc.toFixed(2));
            
            if (isNaN(rc)) { rc = 0; }
            
            const ops = parseFloat(calculateOps(s));
            const avg = ab > 0 ? h / ab : 0;
            
            // 天体分類
            let stellarType = '原始星'; 
            let color = '#94a3b8'; 

            if (ops >= 1.200 || hr >= 3) {
                stellarType = '超新星'; 
                color = '#ef4444'; 
            } else if (ops >= 0.850) {
                stellarType = '主系列星'; 
                color = '#facc15'; 
            } else if (s.games >= 3 && ops >= 0.700) {
                stellarType = '赤色巨星'; 
                color = '#f97316'; 
            }

            players.push({ name, rc, ops, avg: avg, hr: hr, type: stellarType, color, games: s.games });
            teamTotalRC += rc;
        }
    });

    // --- 1.5. 【新規】ARC/Gの計算 ---
    const totalGamesPlayed = players.reduce((max, p) => Math.max(max, p.games || 0), 0) || 1;
    const teamAvgRCG = teamTotalRC / totalGamesPlayed;
    const teamArcg = calculateAdjustedRCG(teamName, teamAvgRCG);

    // ★★★ 【修正ポイント】ARC/G表示を contentAreaの直下に挿入 ★★★
    const isPowerful = teamArcg >= 7.0;
    
    // ARC/GのHTMLを生成
    const arcgHtml = `
        <div id="arcg-score-box" class="mt-4 p-3 rounded-lg ${isPowerful ? 'bg-red-50 border-red-200' : 'bg-blue-50 border-blue-200'}">
            <p class="font-bold text-sm text-gray-800">🎯 チーム平均 ARC/G <span class="text-gray-500">(対戦相手補正済)</span></p>
            <p class="text-xl font-extrabold ${isPowerful ? 'text-red-600' : 'text-blue-600'}">${teamArcg.toFixed(2)}</p>
            <p class="text-xs text-gray-600">※試合あたり約 ${teamArcg.toFixed(1)} 点の貢献ペース (補正前RC/G: ${teamAvgRCG.toFixed(2)})</p>
        </div>
    `;

    // 既存の ARC/G ボックスを削除
    const oldArcgBox = document.getElementById('arcg-score-box');
    if (oldArcgBox) oldArcgBox.remove();
    
    // contentAreaの直下（一番最初の要素の前）に挿入
    contentArea.insertAdjacentHTML('afterbegin', arcgHtml);
    // ★★★ 修正完了 ★★★


    // 2. 円グラフ (RCシェア) 描画
    players.sort((a, b) => b.rc - a.rc); // RC高い順
    const topPlayers = players.slice(0, 6); // 上位6名
    const othersRC = players.slice(6).reduce((sum, p) => sum + p.rc, 0);
    
    const pieLabels = topPlayers.map(p => p.name);
    const pieData = topPlayers.map(p => p.rc);
    const pieColors = topPlayers.map(p => p.color);
    
    if (othersRC > 0) {
        pieLabels.push("その他");
        pieData.push(othersRC);
        pieColors.push("#cbd5e1");
    }

    // テキスト分析
    const analysisEl = document.getElementById('rc-analysis-text');
    // ... (既存のテキスト分析ロジックは変更なし) ...
    if (players.length > 0 && teamTotalRC > 0 && analysisEl) {
        const topShare = (players[0].rc / teamTotalRC) * 100;
        
        let analysisText = ""; 
        if (topShare >= 50) {
            analysisText = `🚨 **独裁型（超依存リスク）**：トップ選手の貢献度が${topShare.toFixed(1)}%と極端に高く、機能停止のリスクが最大です。彼が抑えられるとチームは崩壊します。`;
        } else if (topShare >= 35) {
            analysisText = `⚠️ **ワンマン型（高リスク）**：依存度が高く、特定の主軸（例：4番）が抑えられると、チーム全体の生産力が急落する高リスクな構造です。`;
        } else if (topShare >= 25) {
            analysisText = `⚖️ **主軸集中型（標準）**：上位打線に生産力が集中しており、健全な主軸構造を保っています。打線のバランスは良好です。`;
        } else if (topShare >= 15) {
            analysisText = `✨ **分散型（理想）**：貢献度がレギュラー全体に広く分散しており、切れ目のない打線として機能しています。誰からでも得点が生まれます。`;
        } else {
            analysisText = `📉 **超均等型（低火力リスク）**：全員の貢献度が非常に均等です。安定性は高い反面、試合を決める一打や絶対的な破壊力が不足するリスクがあります。`;
        }
        
        analysisEl.innerHTML = analysisText; 
    } else if (analysisEl) {
        analysisEl.textContent = "データ不足のため分析できません。";
    }

    // Chart.jsで円グラフ描画
    const pieCanvas = document.getElementById('rc-pie-chart');
    if (pieCanvas) {
        const pieCtx = pieCanvas.getContext('2d');
        const existingPie = Chart.getChart(pieCtx);
        if (existingPie) existingPie.destroy();
        
        new Chart(pieCtx, {
            type: 'doughnut',
            data: {
                labels: pieLabels,
                datasets: [{
                    data: pieData,
                    backgroundColor: pieColors,
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { 
                        position: 'right' 
                    },
                    title: { 
                        display: true, 
                        text: '得点創出シェア (Runs Created Score)' 
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const label = context.label || '';
                                const rcValue = context.raw;
                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                const percentage = (rcValue / total * 100).toFixed(1);
                                
                                return `${label}: ${rcValue.toFixed(2)}点分の貢献 (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }

    // 3. 散布図 (打者タイプ・マップ) 描画
    const scatterCanvas = document.getElementById('stellar-scatter-chart');
    if (scatterCanvas) {
        // 描画前に、データが空でないか、または全てが無効でないかチェック
        if (players.length === 0) {
            if (Chart.getChart(scatterCanvas)) Chart.getChart(scatterCanvas).destroy();
            return; // データがなければ描画しない
        }
        
        const scatterCtx = scatterCanvas.getContext('2d');
        const existingScatter = Chart.getChart(scatterCtx);
        if (existingScatter) existingScatter.destroy();

        // --- 安全なデータ整形ヘルパー ---
        const getSafeValue = (value, fallback = 0) => {
            const v = parseFloat(value);
            if (isNaN(v) || !isFinite(v)) return fallback;
            return v;
        };

        // グラフの凡例データを再定義
        const datasets = [{
            label: '選手分布',
            data: players.map(p => ({ 
                x: getSafeValue(p.avg, 0), 
                y: getSafeValue(p.ops, 0.3)
            })),
            backgroundColor: players.map(p => {
                const ops = getSafeValue(p.ops);
                const avg = getSafeValue(p.avg);
                // OPSが高い選手は赤系、打率が高い選手は黄系で色分け
                if (ops >= 1.000) return '#ef4444'; // 超攻撃型
                if (avg >= 0.400) return '#f97316'; // 高打率型
                if (ops >= 0.750) return '#3b82f6'; // バランス型
                return '#9ca3af'; // その他
            }),
            pointRadius: players.map(p => Math.max(5, (p.hr || 0) * 2 + 4)), // HRが null の場合のフォールバック
            pointHoverRadius: 10
        }];

        new Chart(scatterCtx, {
            type: 'scatter',
            data: {
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { 
                        title: { display: true, text: '確実性 (打率 AVG)' }, 
                        min: 0.200, 
                        max: 0.500, // 範囲修正: 0.500で十分
                        ticks: { callback: (v) => getSafeValue(v).toFixed(3) }
                    },
                    y: { 
                        title: { display: true, text: '破壊力 (OPS)' }, 
                        min: 0.300, 
                        max: 1.500, // 範囲を1.500まで広げ、超攻撃型も描画可能に
                        ticks: { callback: (v) => getSafeValue(v).toFixed(3) }
                    }
                },
                plugins: {
                    legend: { display: false },
                    title: { display: true, text: '打者タイプ・マップ (OPS vs AVG)' },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const p = players[context.dataIndex];
                                
                                const type = (() => {
                                    if (p.type === '超新星') return '💣 爆発型';
                                    if (p.type === '主系列星') return '🎯 理想型';
                                    if (p.type === '赤色巨星') return '🏹 職人型';
                                    return '📈 育成枠';
                                })();
                                
                                // ★★★ ツールチップ表示の安全化 ★★★
                                const safeOps = getSafeValue(p.ops).toFixed(3);
                                const safeAvg = getSafeValue(p.avg).toFixed(3);
                                
                                return `${p.name} (${type}): OPS ${safeOps}, 打率 ${safeAvg}, HR ${p.hr || 0}`;
                            }
                        }
                    }
                },
                annotation: {
                    annotations: {
                        opsLine: { type: 'line', scaleID: 'y', value: 0.850, borderColor: '#facc15', borderWidth: 1, borderDash: [5, 5], label: { content: '主軸レベル', enabled: true, position: 'start' } },
                        avgLine: { type: 'line', scaleID: 'x', value: 0.350, borderColor: '#3b82f6', borderWidth: 1, borderDash: [5, 5], label: { content: '高打率レベル', enabled: true, position: 'end' } }
                    }
                }
            }
        });
    }

    // 2.5. 棒グラフ (RCランキング) の描画
    const barCtx = document.getElementById('rc-bar-chart');
    if (barCtx) {
        renderRcBarChart(barCtx.getContext('2d'), players);
    }

    const guidelinesEl = document.getElementById('rc-guidelines');
    if (guidelinesEl) {
        // RC/Gなどのテキストガイドラインを挿入
        guidelinesEl.innerHTML = getGuidelineText(teamTotalRC, players, teamName);
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 【FIXED】選手データに基づき、最適な打順（1番〜9番）を推奨する
 * (OPS、出塁率、長打力、貢献度(RC/G)を役割別に評価)
 * @param {string} teamName - チーム名
 * @returns {Array<object> | null} - 最適な打順 (1番から9番) の選手オブジェクトの配列
 */
function generateOptimalLineup(teamName) {
    const record = tournamentState.teamRecords[teamName];
    // データがない、または打者が3人未満の場合は処理しない
    if (!record || !record.playerStats || !record.playerStats.batting || Object.keys(record.playerStats.batting).length < 3) {
        return null;
    }

    const MIN_PA_FOR_RANKING = 5; // 最低打席数

    // 1. 選手のデータと評価指標を計算
    const allPlayers = Object.keys(record.playerStats.batting).map(playerName => {
        const stats = record.playerStats.batting[playerName];
        const { ab = 0, h = 0, hr = 0, rbi = 0, pa = 0, games = 0, tb = 0, bb = 0, hbp = 0, sf = 0 } = stats;
        
        // 規定打席未満、または打席機会がなければ除外
        if (pa < MIN_PA_FOR_RANKING) return null;

        const obp_den = ab + bb + hbp + sf;
        const obp = obp_den > 0 ? (h + bb + hbp) / obp_den : 0;
        const slg = ab > 0 ? tb / ab : 0;
        const ops = obp + slg;
        
        // --- ★★★ RC/G 計算の安全化 ★★★ ---
        const rcCalc = (obp * tb) / (ab + bb);
        const safeRc = isNaN(rcCalc) ? 0 : rcCalc; // RCのNaNチェック
        const rcg = games > 0 ? safeRc / games : 0; 
        
        // 役割スコアの計算
        return {
            name: playerName,
            rcg: rcg, // ★ RC/Gをデータに含める
            // 1番スコア (出塁率 + 盗塁重視)
            leadOff: (obp * 2.0) + (stats.sb * 0.2) + (rcg * 0.5), 
            // 2番スコア (RC/G + 安定性)
            rcgScore: (rcg * 2.5) + (obp * 1.0),
            // 3番スコア (OPS + 確実性)
            consistency: (ops * 1.5) + (obp * 1.0),
            // 4/5番スコア (長打 + 打点重視)
            power: (slg * 1.5) + (rbi * 0.2) + (hr * 0.5) + (ops * 0.5),
            // 俊足 (盗塁が多いか)
            isFast: stats.sb >= 3,
            // 長打力 (OPSが高いか)
            isSlugger: ops >= 1.000,
            // 確実性 (打率が高いか)
            isHighAvg: (ab > 0 && h / ab >= 0.400)
        };
    }).filter(p => p !== null).sort((a, b) => b.power - a.power); // 初期はパワー順にソート

    if (allPlayers.length < 9) {
        console.warn(`[Lineup] データが不足しています。規定打席 (${MIN_PA_FOR_RANKING}) を満たす選手が9人未満です。`);
        return null;
    }

    let remainingPlayers = [...allPlayers];
    const lineup = Array(9).fill(null);

    // 2. 役割別割り当て (高校野球/セイバーメトリクス理論に基づく)
    
    // A. 4番 (絶対的パワーヒッター) - Powerスコア最高
    const p4 = remainingPlayers.shift();
    lineup[3] = p4;

    // B. 3番 (確実性 + OPS) - 4番の次に高いConsistencyを持つ選手
    const p3 = remainingPlayers.sort((a, b) => b.consistency - a.consistency).shift();
    lineup[2] = p3;

    // C. 1番 (出塁 + 俊足) - LeadOffスコア最高
    remainingPlayers.sort((a, b) => b.leadOff - a.leadOff);
    const p1 = remainingPlayers.shift();
    lineup[0] = p1;

    // D. 2番 (RC/G + 安定性) - 1番と3番をつなぐ最も効率的な打者
    remainingPlayers.sort((a, b) => b.rcgScore - a.rcgScore);
    const p2 = remainingPlayers.shift();
    lineup[1] = p2;

    // E. 5番 (後続の打点役) - 4番の次に高いPowerスコア (残りの選手をソート)
    remainingPlayers.sort((a, b) => b.power - a.power);
    const p5 = remainingPlayers.shift();
    lineup[4] = p5;
    
    // F. 6番 (残りの中で最もPowerが高い選手)
    remainingPlayers.sort((a, b) => b.power - a.power);
    lineup[5] = remainingPlayers.shift();
    
    // G. 9番 (下位のリードオフ) - 残りの中でObpが高い選手
    remainingPlayers.sort((a, b) => b.leadOff - a.leadOff);
    lineup[8] = remainingPlayers.shift();
    
    // H. 7番/8番 (残りをRC/G順に割り当て)
    remainingPlayers.sort((a, b) => b.rcgScore - a.rcgScore);
    lineup[6] = remainingPlayers.shift(); // 7番
    lineup[7] = remainingPlayers.shift(); // 8番

    // 3. 打順番号を付与して返す
    return lineup.map((p, i) => ({
        ...p,
        order: i + 1,
        recommendation: i + 1
    }));
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * [FIXED] RC、OPSなどの評価基準と、トップ貢献者を分析するテキストを生成
 * (★グラフの読み方解説を追加)
 * @param {number} teamTotalRC - チームの総 Runs Created
 * @param {Array} players - 選手のRCデータリスト
 * @param {string} teamName - 分析対象のチーム名 (通算試合数取得用)
 */
function getGuidelineText(teamTotalRC, players, teamName) {
    // プレイヤーがいない、または総RCがゼロなら分析しない
    if (players.length === 0 || teamTotalRC === 0) {
        return "<p class='text-gray-500'>まだ打者の成績データが不足しています。</p>";
    }
    
    const sortedPlayers = [...players].sort((a, b) => b.rc - a.rc);
    const topRcPlayer = sortedPlayers[0];
    const teamRecord = tournamentState.teamRecords[teamName];

    let html = '';

    // --- 0. グラフの読み方解説 (新規追加) ---
    html += `
        <div class="border-b pb-2">
            <p class="font-bold text-base text-gray-800">📊 打者タイプ・マップの読み方</p>
            <ul class="list-disc list-inside ml-4 text-sm text-gray-700 space-y-1">
                <li><strong>OPS（縦軸: 破壊力）:</strong> 高いほど長打力と出塁能力がある。</li>
                <li><strong>打率（横軸: 確実性）:</strong> 高いほどボールにバットが当たる安定性がある。</li>
                <li><strong>バブルの大きさ:</strong> その選手の**本塁打数**に比例します。</li>
            </ul>
        </div>`;
        
    // --- 1. 評価基準とグラフの位置による分類 ---
    if (topRcPlayer) {
        // RC/Gの計算
        const gamesPlayed = topRcPlayer.games || 1;
        const rcPerGame = topRcPlayer.rc / gamesPlayed;
        const topShare = (topRcPlayer.rc / teamTotalRC) * 100;

        html += `
            <div class="border-b pb-2">
                <p class="font-bold text-base text-indigo-700">評価基準と選手の役割</p>
                <ul class="list-disc list-inside ml-4 text-sm text-gray-700 space-y-1">
                    <li><strong>OPS 1.000以上:</strong> 怪物級。プロ注目。</li>
                    <li><strong class="text-red-600">OPS 0.850以上:</strong> 強豪校の主軸として非常に優秀な水準。</li>
                    <li><strong>打率 .400以上:</strong> 驚異的。</li>
                </ul>
                <div class="mt-3 p-2 bg-yellow-50 rounded">
                    <p class="font-bold text-xs">グラフ位置による分類:</p>
                    <ul class="list-none ml-2 text-xs">
                        <li>- **右上の選手 (理想):** 打率もOPSも高い、最も優秀な打者。</li>
                        <li>- **左上の選手 (破壊者):** OPSは高いが打率が低い長距離砲。</li>
                        <li>- **右下の選手 (職人):** 打率は高いが長打力は低いアベレージヒッター。</li>
                    </ul>
                </div>
            </div>`;
            
        // --- 2. トップ貢献者の情報 (RC/Gの絶対値を含む) ---
        html += `
            <div class="p-2 bg-gray-50 rounded">
                <p class="font-bold text-sm text-gray-800">🔥 現在の最高貢献者</p>
                <p class="text-lg font-extrabold text-red-600">${topRcPlayer.name}</p>
                <p class="text-sm text-gray-700">RC/試合 (RC/G): <strong>${rcPerGame.toFixed(2)}</strong></p>
                <p class="text-xs text-gray-600">RC/G 2.0以上で「エース級」のペースです。</p>
            </div>`;
    }
    
    return html;
}


/**
 * 個人別打席結果のテーブルHTMLを生成する
 * (★「個人成績モーダル」ボタンを追加)
 * (★★「調子」アイコンを追加★★)
 */
function createPlayerBattingTable(teamName, teamKey, details) {
    const battingData = details.batting[teamKey] || [];
    const numInnings = details.inningScore?.[teamKey]?.length || 9;
    
    // 選手リスト（代走/守備固めも含む）
    const playersOnField = battingData.filter(p => p.name).map(p => ({name: p.name}));

    // 「投/打」プルダウン用の選択肢
    const throwBatOptionsList = [
        { val: "R/R", label: "右/右" }, { val: "R/L", label: "右/左" }, { val: "R/S", label: "右/両" },
        { val: "L/L", label: "左/左" }, { val: "L/R", label: "左/右" }, { val: "L/S", label: "左/両" }
    ];
    const createThrowBatOptions = (selectedVal) => {
        return throwBatOptionsList.map(opt => 
            `<option value="${opt.val}" ${selectedVal === opt.val ? 'selected' : ''}>${opt.label}</option>`
        ).join('');
    };

    // 背番号と守備位置の選択肢
    let numberOptions = '<option value=""></option>';
    for (let i = 1; i <= 20; i++) { numberOptions += `<option value="${i}">${i}</option>`; }
    const posOptions = ['投', '捕', '一', '二', '三', '遊', '左', '中', '右'].map(p => `<option value="${p}">${p}</option>`).join('');
    
    // イニングヘッダー
    let inningsHeader = '';
    for (let i = 1; i <= numInnings; i++) {
        inningsHeader += `<th class="col-inning">${i}</th>`;
    }

    let bodyRows = '';
    const teamRecord = tournamentState.teamRecords[teamName]; // ★調子取得用

    // --- 1. スタメン (1〜9番) の行を生成 ---
    for (let i = 1; i <= 9; i++) {
        let starterData = battingData.find(p => p.order && parseInt(p.order) === i) || { order: i, results: Array(numInnings).fill('') };
        if (!starterData.results) starterData.results = Array(numInnings).fill('');
        const pName = starterData.name || ''; 
const isCaptain = starterData.isCaptain ? 'active' : '';

        // ★★★ ここからが修正箇所 ★★★
        let conditionIcon = '';
        if (pName && teamRecord?.playerStats?.batting[pName]) {
            const flag = teamRecord.playerStats.batting[pName].narrative_flag;
            conditionIcon = getPlayerConditionIcon(flag);
        }
        // ★★★ 修正ここまで ★★★

        const starterNumberSelect = `<select class="player-number w-full bg-transparent">${numberOptions.replace(`value="${starterData.number}"`, `value="${starterData.number}" selected`)}</select>`;
        const starterThrowBatSelect = `<select class="player-throw-bat w-full bg-transparent"><option value="">-投/打-</option>${createThrowBatOptions(starterData.throwBat)}</select>`;
        const starterPosSelect = `<select class="player-pos w-full bg-transparent"><option value=""></option>${posOptions.replace(`value="${starterData.currentPos || starterData.pos}"`, `value="${starterData.currentPos || starterData.pos}" selected`)}</select>`;
        const posHistoryHtml = `<span class="text-xs text-gray-500 truncate" title="${starterData.posHistoryDisplay || ''}">${starterData.posHistoryDisplay || ''}</span>`;
        
        let resultInputs = '';
        for (let j = 0; j < numInnings; j++) {
            const resultString = starterData.results[j] || '';
            const atBats = (resultString && resultString.split('、').length > 0) ? resultString.split('、') : [''];
            const atBatBlocksHTML = atBats.map(atBatString => createBattingResultDropdowns(playersOnField, atBatString)).join('');
            
            const changeBtnHTML = `
                <button class="inning-add-sub-btn text-xs mt-1 bg-gray-200 px-2 py-1 rounded hover:bg-gray-300 w-auto font-semibold" 
                        data-team-key="${teamKey}" 
                        data-order="${starterData.order}"
                        data-inning="${j}" 
                        title="${j + 1}回に代打を送る">
                    代打
                </button>`;

            resultInputs += `
                <td class="col-inning batting-result-cell align-top p-1">
                    ${atBatBlocksHTML}
                    <div class="flex justify-between items-center mt-1 pt-1 border-t">
                        <button class="add-at-bat-btn text-xs bg-blue-100 px-2 py-1 rounded hover:bg-blue-200 font-semibold">＋ 2打席</button>
                        ${changeBtnHTML}
                    </div>
                 </td>`;
        }
        
       bodyRows += `
            <tr data-order="${starterData.order}">
                <td class="col-order">${i}</td>
                <td class="col-number">${starterNumberSelect}</td>
                <td class="col-throw-bat">${starterThrowBatSelect}</td>
                <td class="col-player">
                    <div class="flex items-center gap-1">
                        <input type="text" class="player-name w-full" value="${pName}" list="roster-datalist-${teamKey}">
                        
                        <button class="captain-btn ${isCaptain}" title="主将に設定">C</button>
                        ${conditionIcon} 
                        <button class="show-player-stats-btn text-lg p-1 text-blue-600 hover:bg-blue-100 rounded" 
                                data-team-name="${teamName}" 
                                data-player-order-key="${starterData.order}" 
                                title="通算成績を表示">📊</button>
                    </div>
                </td>
                <td class="col-pos">
                    <div class="flex items-center justify-between">${starterPosSelect}<button class="text-xs bg-gray-200 px-1 ml-1 rounded pos-change-btn" data-team-key="${teamKey}">変更</button></div>
                    ${posHistoryHtml}
                </td>
                <td class="col-sub-type align-middle">
                    <button class="add-sub-row-btn text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300 w-full" data-order="${starterData.order}" data-team-key="${teamKey}">
                        + 交代
                    </button>
                </td>
                ${resultInputs}
            </tr>
        `;
        
        // --- 2. 交代選手 (スタメンの直下) の行を生成 ---
        const substitutes = battingData.filter(p => p.order && p.order.toString().startsWith(`${i}-sub`));
        substitutes.forEach(subData => {
            if (!subData.results) subData.results = Array(numInnings).fill('');
            const subName = subData.name || '';

            // キャプテン状態
            const isSubCaptain = subData.isCaptain ? 'active' : '';

            // 調子アイコン
            let subConditionIcon = '';
            if (subName && teamRecord?.playerStats?.batting[subName]) {
                const flag = teamRecord.playerStats.batting[subName].narrative_flag;
                subConditionIcon = getPlayerConditionIcon(flag);
            }

            // 各種セレクトボックスのHTML生成
            const subNumberSelect = `<select class="player-number w-full bg-transparent">${numberOptions.replace(`value="${subData.number}"`, `value="${subData.number}" selected`)}</select>`;
            const subThrowBatSelect = `<select class="player-throw-bat w-full bg-transparent"><option value="">-投/打-</option>${createThrowBatOptions(subData.throwBat)}</select>`;
            const subPosSelect = `<select class="player-pos w-full bg-transparent"><option value=""></option>${posOptions.replace(`value="${subData.currentPos || subData.pos}"`, `value="${subData.currentPos || subData.pos}" selected`)}</select>`;
            const subPosHistoryHtml = `<span class="text-xs text-gray-500 truncate" title="${subData.posHistoryDisplay || ''}">${subData.posHistoryDisplay || ''}</span>`;

            // イニング入力欄の生成
            let subResultInputs = '';
            for (let j = 0; j < numInnings; j++) {
                const resultString = subData.results[j] || '';
                const atBats = (resultString && resultString.split('、').length > 0) ? resultString.split('、') : [''];
                const atBatBlocksHTML = atBats.map(atBatString => createBattingResultDropdowns(playersOnField, atBatString)).join('');

                const changeBtnHTML = `
                    <button class="inning-add-sub-btn text-xs mt-1 bg-gray-200 px-2 py-1 rounded hover:bg-gray-300 w-auto font-semibold" 
                            data-team-key="${teamKey}" 
                            data-order="${subData.order}"
                            data-inning="${j}"
                            title="${j + 1}回に代打を送る">
                        代打
                    </button>`;
                
                subResultInputs += `
                    <td class="col-inning batting-result-cell align-top p-1">
                        ${atBatBlocksHTML}
                        <div class="flex justify-between items-center mt-1 pt-1 border-t">
                            <button class="add-at-bat-btn text-xs bg-blue-100 px-2 py-1 rounded hover:bg-blue-200 font-semibold">＋ 2打席</button>
                            ${changeBtnHTML}
                        </div>
                     </td>`;
            }
            
            // ▼▼▼ 修正: ここで足りなかった最初の3列を復活させました ▼▼▼
            bodyRows += `
                <tr data-order="${subData.order}">
                    <td class="col-order"></td> <td class="col-number">${subNumberSelect}</td> <td class="col-throw-bat">${subThrowBatSelect}</td> <td class="col-player pl-4"> <div class="flex items-center gap-1">
                            <input type="text" class="player-name w-full" value="${subName}" list="roster-datalist-${teamKey}">
                            
                            <button class="captain-btn ${isSubCaptain}" title="主将に設定">C</button>

                            ${subConditionIcon} 
                            <button class="show-player-stats-btn text-lg p-1 text-blue-600 hover:bg-blue-100 rounded" 
                                    data-team-name="${teamName}" 
                                    data-player-order-key="${subData.order}" 
                                    title="通算成績を表示">📊</button>
                        </div>
                    </td>
                    <td class="col-pos"> <div class="flex items-center justify-between">${subPosSelect}<button class="text-xs bg-gray-200 px-1 ml-1 rounded pos-change-btn" data-team-key="${teamKey}">変更</button></div>
                        ${subPosHistoryHtml}
                    </td>
                    <td class="col-sub-type align-top"> <select class="sub-type-select w-full bg-transparent mb-1">
                            <option value="" ${!subData.sub_type ? 'selected' : ''}>-</option>
                            <option value="PH" ${subData.sub_type === 'PH' ? 'selected' : ''}>代打</option>
                            <option value="PR" ${subData.sub_type === 'PR' ? 'selected' : ''}>代走</option>
                            <option value="DEF" ${subData.sub_type === 'DEF' ? 'selected' : ''}>守備</option>
                            <option value="PITCHER" ${subData.sub_type === 'PITCHER' ? 'selected' : ''}>投手</option>
                        </select>
                        <button class="add-sub-row-btn text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300 w-full" data-order="${subData.order}" data-team-key="${teamKey}">
                            + 交代
                        </button>
                    </td>
                    ${subResultInputs} </tr>
            `;
        });
    }

    return `
        <div class="overflow-x-auto">
            <table class="details-table batting-table" id="batting-table-${teamKey}">
                <thead>
                    <tr>
                        <th class="col-order">打順</th>
                        <th class="col-number">#</th>
                        <th class="col-throw-bat">投/打</th>
                        <th class="col-player">選手名</th>
                        <th class="col-pos">守備</th>
                        <th class="col-sub-type">出場</th>
                        ${inningsHeader}
                        <th class="w-10"><button class="add-inning-btn text-xs" data-team-key="${teamKey}">+ 回</button></th>
                    </tr>
                </thead>
                <tbody>${bodyRows}</tbody>
            </table>
            </div>
    `;
}
// ▲▲▲ 置き換えここまで ▲▲▲



/**
 * [修正・完全版] 詳細データを保存し、通算成績を更新する
 * (★コールド処理後に自動で0埋めを行うが、Xになるべき箇所は空欄のままにするスマート機能付き)
 */
function saveDetailedStats() {
    if (!currentMatchIdForDetails) return;
    const match = findMatchById(currentMatchIdForDetails);
    if (!match) return;

    // --- 起用ブロック (変更なし) ---
    let injuredPlayerFound = null;
    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord || !teamRecord.playerStats) continue;
        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (battingTable) {
            battingTable.querySelectorAll('tbody tr').forEach(row => {
                const nameInput = row.querySelector('.player-name');
                if (nameInput && nameInput.value.trim() !== '') {
                    const playerName = nameInput.value.trim();
                    const bStats = teamRecord.playerStats.batting[playerName];
                    if (bStats && (bStats.narrative_flag === 'injured' || bStats.narrative_flag === 'sick' || bStats.narrative_flag === 'minor_injury')) {
                        injuredPlayerFound = playerName;
                    }
                }
            });
        }
        if (injuredPlayerFound) break;
        const pitchingTable = document.getElementById(`pitching-table-${teamKey}`);
        if (pitchingTable) {
            pitchingTable.querySelectorAll('tbody tr').forEach(row => {
                const nameInput = row.querySelector('.pitcher-name');
                if (nameInput && nameInput.value.trim() !== '') {
                    const playerName = nameInput.value.trim();
                    const pStats = teamRecord.playerStats.pitching[playerName];
                    if (pStats && (pStats.narrative_flag === 'injured' || pStats.narrative_flag === 'sick' || pStats.narrative_flag === 'minor_injury')) {
                        injuredPlayerFound = playerName;
                    }
                }
            });
        }
        if (injuredPlayerFound) break;
    }
    if (injuredPlayerFound) {
        alert(`[起用不可] 選手が起用できません。\n\n選手名: ${injuredPlayerFound}\n理由: 故障(🏥)・軽傷(🩹)・体調不良のため、試合に出場させられません。`);
        return;
    }
    // --- 起用ブロックここまで ---

    // --- 1. 成績リセット処理 (既存コードのまま) ---
    if (match.details && match.details.playerGameStats) {
        for (const teamKey of ['team1', 'team2']) {
            const teamName = match[teamKey];
            const teamRecord = tournamentState.teamRecords[teamName];
            if (!teamRecord || !teamRecord.playerStats) continue;
            const previousBattingStats = match.details.playerGameStats[teamKey];
            if (previousBattingStats) {
                for (const playerName in previousBattingStats) {
                    const careerStats = teamRecord.playerStats.batting[playerName];
                    const prevGameStats = previousBattingStats[playerName]; 
                    if (careerStats && prevGameStats) {
                        if(prevGameStats.played) careerStats.games = (careerStats.games || 1) - 1;
                        for (const key of ['pa', 'ab', 'h', 'hr', 'rbi', 'sb', 'bb', 'hbp', 'sf', 'tb', 'r', 'so']) {
                            careerStats[key] = (careerStats[key] || 0) - (prevGameStats[key] || 0);
                        }
                        careerStats.narrative_flag = null;
                    }
                } 
            } 
            const previousBattingData = match.details.batting?.[teamKey];
            if (previousBattingData) {
                previousBattingData.forEach(prevPlayerData => {
                    const playerName = prevPlayerData.name;
                    if (!playerName || !teamRecord.playerStats.batting[playerName]) return;
                    const bStats = teamRecord.playerStats.batting[playerName];
                    if (bStats.gamelogs) {
                        bStats.gamelogs = bStats.gamelogs.filter(log => log.matchId !== currentMatchIdForDetails);
                    }
                });
            }
            if (teamRecord.tournamentStats && previousBattingStats) {
                let totals = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0 };
                for (const playerName in previousBattingStats) {
                    const prevGameStats = previousBattingStats[playerName]; 
                    if (prevGameStats) {
                        for (const key in totals) { totals[key] += prevGameStats[key] || 0; }
                    }
                }
                for (const key in totals) {
                     teamRecord.tournamentStats[key] = (teamRecord.tournamentStats[key] || 0) - totals[key];
                }
            } 
            const previousPitchingStats = match.details.pitching?.[teamKey];
            if (previousPitchingStats) {
                previousPitchingStats.forEach(prevGameStats => { 
                    const playerName = prevGameStats.name;
                    if (!playerName || !teamRecord.playerStats.pitching[playerName]) return;
                    const pStats = teamRecord.playerStats.pitching[playerName];
                    const careerStats = pStats.career;
                    if (careerStats && prevGameStats) {
                        careerStats.games = (careerStats.games || 1) - 1;
                        if (parseInt(prevGameStats.battersFaced || 0) > 0) {
                            if (prevGameStats.result === 'W') careerStats.w--;
                            if (prevGameStats.result === 'L') careerStats.l--;
                            careerStats.ip -= parseFloat(prevGameStats.innings || 0);
                            careerStats.so -= parseInt(prevGameStats.strikeouts || 0);
                            careerStats.er -= parseInt(prevGameStats.earnedRuns || 0);
                            careerStats.h = (careerStats.h || 0) - parseInt(prevGameStats.hits || 0);
                            careerStats.bb = (careerStats.bb || 0) - parseInt(prevGameStats.walks || 0);
                        }
                    }
                    if (pStats.gamelogs) {
                        pStats.gamelogs = pStats.gamelogs.filter(log => log.matchId !== currentMatchIdForDetails);
                    }
                    pStats.narrative_flag = null;
                });
            }
        }
    }

    // --- 2. 新しい詳細データを構築 ---
    const details = { 
        inningScore: { team1: [], team2: [] }, 
        batting: { team1: [], team2: [] }, 
        pitching: { team1: [], team2: [] }, 
        fielding: { team1: [], team2: [] },
        playerGameStats: { team1: {}, team2: {} },
        positionChanges: match.details?.positionChanges || []
    };

    // --- ★★★ イニングスコア読み取り処理 (0埋め前の生データ取得) ★★★ ---
    const scoreTable = document.getElementById('inning-score-table');
    let lastInningWithScore = 0;

    if (scoreTable) {
        const rows = scoreTable.querySelectorAll('tbody tr');
        
        // team1 (先攻)
        const team1Row = Array.from(rows).find(row => row.querySelector('th')?.textContent.trim() === match.team1);
        if (team1Row) {
            const inputs = Array.from(team1Row.querySelectorAll('input'));
            details.inningScore.team1 = inputs.map((input, index) => {
                const val = input.value;
                if (val !== '') {
                    lastInningWithScore = Math.max(lastInningWithScore, index + 1);
                    return parseInt(val);
                }
                return null; // ★空欄はnullのまま保持
            });
        }

        // team2 (後攻)
        const team2Row = Array.from(rows).find(row => row.querySelector('th')?.textContent.trim() === match.team2);
        if (team2Row) {
            const inputs = Array.from(team2Row.querySelectorAll('input'));
            details.inningScore.team2 = inputs.map((input, index) => {
                const val = input.value;
                if (val !== '') {
                    lastInningWithScore = Math.max(lastInningWithScore, index + 1);
                    return parseInt(val);
                }
                return null; // ★空欄はnullのまま保持
            });
        }
    }
    
    // --- ★★★ コールド設定とイニング数の確定 ★★★ ---
    const calledGameCheckbox = document.getElementById('called-game-checkbox');
    let finalGameLength = 9; // デフォルトは9回
    
    if (calledGameCheckbox) {
        match.calledGame = calledGameCheckbox.checked;
        if (match.calledGame) {
            // チェックあり：入力がある最終回までで切る (最低5回)
            finalGameLength = Math.max(lastInningWithScore, 5);
            match.calledInning = finalGameLength;
        } else {
            // チェックなし：通常 (9回またはそれ以上)
            finalGameLength = Math.max(lastInningWithScore, 9);
            match.calledInning = null;
        }
    }

    // --- ★★★ スマート0埋め処理 ★★★ ---
    // 確定したイニング数までの範囲で、nullを0に変換する。
    // ただし、「後攻がリードしている最終回裏」は null (X) のままにする。

    // イニング配列を finalGameLength の長さに調整（切り詰め or 拡張）
    // (拡張部分は undefined になるので、map処理内で対応)
    for (const teamKey of ['team1', 'team2']) {
        // 指定長さにスライス（足りない場合は維持、あとでループ処理）
        details.inningScore[teamKey] = details.inningScore[teamKey].slice(0, finalGameLength);
    }

    let currentScore1 = 0;
    let currentScore2 = 0;

    for (let i = 0; i < finalGameLength; i++) {
        // 先攻: 常に0埋め
        if (details.inningScore.team1[i] == null) {
            details.inningScore.team1[i] = 0;
        }
        currentScore1 += details.inningScore.team1[i];

        // 後攻: 状況判断
        if (details.inningScore.team2[i] != null) {
            // 入力があればそれを加算
            currentScore2 += details.inningScore.team2[i];
        } else {
            // 入力がない(null)場合
            if (i === finalGameLength - 1 && currentScore2 > currentScore1) {
                // 最終回かつ後攻リード中なら、nullのまま (X扱い)
                details.inningScore.team2[i] = null;
            } else {
                // それ以外は0埋め
                details.inningScore.team2[i] = 0;
                currentScore2 += 0;
            }
        }
    }

    // 合計スコア計算 (nullは0として計算)
    match.score1 = details.inningScore.team1.reduce((sum, score) => sum + (score || 0), 0);
    match.score2 = details.inningScore.team2.reduce((sum, score) => sum + (score || 0), 0);


    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord) continue;
        if (!teamRecord.playerStats) teamRecord.playerStats = { batting: {}, pitching: {} };
        if (!teamRecord.tournamentStats) teamRecord.tournamentStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0 }; 
        const playersAppearedThisGame = new Set();
        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (battingTable) {
            battingTable.querySelectorAll('tbody tr').forEach(row => {
                const nameInput = row.querySelector('.player-name');
                if (nameInput && nameInput.value.trim() !== '') {
                    const playerName = nameInput.value.trim();
                    const resultCells = Array.from(row.querySelectorAll('td.col-inning'));
                    const results = resultCells.map(cell => {
                        const atBatBlocks = Array.from(cell.querySelectorAll('.at-bat-block'));
                        const atBatsString = atBatBlocks.map(block => {
                            const container = block.querySelector('.batting-result-container');
                            if (!container) return ''; 
                            const batterPlay = [
                                (block.querySelector('.mark-at-bat-btn')?.dataset.marked === 'true') ? '★:' : '',
                                container.querySelector('.result-strength').value,
                                container.querySelector('.result-direction').value,
                                container.querySelector('.result-type').value,
                                container.querySelector('.result-rbi').value,
                                container.querySelector('.result-runner-play').value
                            ].filter(Boolean).join('');
                            const runnerPlays = Array.from(block.querySelectorAll('.runner-play-input')).map(rpContainer => {
                                const name = rpContainer.querySelector('.runner-name').value;
                                const play = rpContainer.querySelector('.runner-play').value;
                                const base = rpContainer.querySelector('.runner-base').value;
                                if (!name || !play) return '';
                                return [name, play, base].filter(Boolean).join(' ');
                            }).filter(Boolean).join(','); 
                            return [batterPlay, runnerPlays].filter(Boolean).join(';');
                        }).join('、');
                        return atBatsString;
                    });
                    const playerData = {
                        order: row.dataset.order, name: playerName,
                        number: row.querySelector('.player-number').value,
                        throwBat: row.querySelector('.player-throw-bat')?.value,
                        pos: row.querySelector('.player-pos').value,
                        currentPos: row.querySelector('.player-pos').value, // ★ currentPos を保存
                        posHistoryDisplay: row.querySelector('.text-xs.text-gray-500')?.title || '', // ★ 履歴表示を保存
                        sub_type: row.querySelector('.sub-type-select') ? row.querySelector('.sub-type-select').value : null,
isCaptain: row.querySelector('.captain-btn')?.classList.contains('active') || false,
                        results: results
                    };
                    details.batting[teamKey].push(playerData);
                    if (!teamRecord.playerStats.batting[playerName]) {
                        teamRecord.playerStats.batting[playerName] = { games: 0, pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0 };
                    }
                    const careerStats = teamRecord.playerStats.batting[playerName];
                    const isNonBattingSub = playerData.sub_type === 'DEF' || playerData.sub_type === 'PR';
                    const gameStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0, played: false, strongHits: 0, weakHits: 0, strongOuts: 0, weakOuts: 0 };
                    playerData.results.forEach(inningResultString => {
                        (inningResultString || '').split('、').forEach(atBatString => {
                            if (!atBatString) return;
                            const [batterPlay, runnerPlaysString] = atBatString.split(';');
                            if (batterPlay && batterPlay.trim() !== '') {
                                let cleanBatterPlay = batterPlay.trim().replace(/^★:/, '');
                                const isHit = BATTING_RESULTS.hits.some(h => cleanBatterPlay.includes(h));
                                const isOut = BATTING_RESULTS.outs.some(o => cleanBatterPlay.includes(o)) || BATTING_RESULTS.sacrifices.some(s => cleanBatterPlay.includes(s));
                                if (cleanBatterPlay.startsWith('S:')) {
                                    if (isHit) gameStats.strongHits++; if (isOut) gameStats.strongOuts++;
                                    cleanBatterPlay = cleanBatterPlay.substring(2);
                                } else if (cleanBatterPlay.startsWith('W:')) {
                                    if (isHit) gameStats.weakHits++; if (isOut) gameStats.weakOuts++;
                                    cleanBatterPlay = cleanBatterPlay.substring(2);
                                }
                                gameStats.played = true; gameStats.pa++;
                                const isWalk = ['四球', '死球', '敬遠'].some(w => cleanBatterPlay.includes(w));
                                const isSac = ['犠飛', '犠打', '犠失'].some(w => cleanBatterPlay.includes(w));
                                if (!isWalk && !isSac && !cleanBatterPlay.includes('妨害')) { gameStats.ab++; }
                                if (cleanBatterPlay.includes('四球') || cleanBatterPlay.includes('敬遠')) gameStats.bb++;
                                if (cleanBatterPlay.includes('死球')) gameStats.hbp++;
                                if (cleanBatterPlay.includes('犠飛')) gameStats.sf++;
                                if (cleanBatterPlay.includes('本塁打')) { gameStats.h++; gameStats.tb += 4; gameStats.hr++; }
                                else if (cleanBatterPlay.includes('三塁打')) { gameStats.h++; gameStats.tb += 3; }
                                else if (cleanBatterPlay.includes('二塁打')) { gameStats.h++; gameStats.tb += 2; }
                                else if (cleanBatterPlay.includes('安')) { gameStats.h++; gameStats.tb += 1; }
                                if (cleanBatterPlay.includes('点')) { 
                                    const rbiValue = (cleanBatterPlay.match(/(\d+)点/) || [0, 0])[1];
                                    gameStats.rbi += parseInt(rbiValue, 10);
                                }
                                if (cleanBatterPlay.includes('三振')) gameStats.so++;
                            }
                            (runnerPlaysString || '').split(',').forEach(runnerPlay => {
                                const parts = runnerPlay.split(' ');
                                if (parts[0] === playerName && parts[1] === '盗塁') { gameStats.sb++; }
                                if (parts[0] === playerName && (parts[1] === '生還' || (parts[1] === '進塁' && parts[2] === '本塁へ(生還)'))) {
                                    gameStats.r++;
                                }
                            });
                        });
                    });
                    if((gameStats.played || isNonBattingSub) && !playersAppearedThisGame.has(playerName)) { 
                        careerStats.games++; 
                        playersAppearedThisGame.add(playerName);
                    }
                    for (const key of ['pa', 'ab', 'h', 'hr', 'rbi', 'sb', 'bb', 'hbp', 'sf', 'tb', 'r', 'so']) {
                        careerStats[key] = (careerStats[key] || 0) + gameStats[key];
                        if (teamRecord.tournamentStats) {
                            teamRecord.tournamentStats[key] = (teamRecord.tournamentStats[key] || 0) + gameStats[key];
                        }
                    }
                    details.playerGameStats[teamKey][playerName] = gameStats;
                    if (!careerStats.gamelogs) careerStats.gamelogs = [];
                    const opponentName = teamKey === 'team1' ? match.team2 : match.team1;
                    const opponentRank = opponentName ? calculateRank(opponentName, tournamentState) : 'E';
                    careerStats.gamelogs.push({
                        matchId: currentMatchIdForDetails,
                        date: match.schedule?.date || '不明',
                        round: getRoundNameFromMatchId(currentMatchIdForDetails),
                        opponent: opponentName,
                        opponentRank: opponentRank,
                        order: playerData.order, 
                        sub_type: playerData.sub_type,
                        stats: gameStats 
                    });
                }
            });
        }
        const pitchingTable = document.getElementById(`pitching-table-${teamKey}`);
        if (pitchingTable) {
            pitchingTable.querySelectorAll('tbody tr').forEach(row => {
                const pitcherName = row.querySelector('.pitcher-name')?.value.trim(); 
                if (pitcherName && pitcherName !== '') {
                    const pitcherData = {
                        result: row.querySelector('.pitcher-result').value,
                        name: pitcherName, 
                        throwBat: row.querySelector('.pitcher-throw-bat').value,
                        throwStyle: row.querySelector('.pitcher-throw-style').value,
                        pitcherType: row.querySelector('.pitcher-type').value,
                        velocity: row.querySelector('.pitcher-velocity').value,
                        innings: row.querySelector('.pitcher-innings').value,
                        battersFaced: row.querySelector('.pitcher-batters').value,
                        pitches: row.querySelector('.pitcher-pitches').value,
                        hits: row.querySelector('.pitcher-hits').value, 
                        strikeouts: row.querySelector('.pitcher-so').value,
                        walks: row.querySelector('.pitcher-walks').value, 
                        runs: row.querySelector('.pitcher-runs').value,
                        earnedRuns: row.querySelector('.pitcher-er').value,
                    };
                    details.pitching[teamKey].push(pitcherData);
                    if (!teamRecord.playerStats.pitching[pitcherName]) {
                        teamRecord.playerStats.pitching[pitcherName] = { 
                            career: { games: 0, w: 0, l: 0, ip: 0, so: 0, er: 0, h: 0, bb: 0 },
                            gamelogs: []
                        };
                    }
                    const pStats = teamRecord.playerStats.pitching[pitcherName];
                    const careerStats = pStats.career;
                    if (pitcherData.name && !playersAppearedThisGame.has(pitcherName)) {
                        careerStats.games = (careerStats.games || 0) + 1;
                        playersAppearedThisGame.add(pitcherName);
                    }
                    if (pitcherData.battersFaced && parseInt(pitcherData.battersFaced) > 0) {
                        if (pitcherData.result === 'W') careerStats.w++;
                        if (pitcherData.result === 'L') careerStats.l--;
                        careerStats.ip += parseFloat(pitcherData.innings) || 0;
                        careerStats.so += parseInt(pitcherData.strikeouts) || 0;
                        careerStats.er += parseInt(pitcherData.earnedRuns) || 0;
                        careerStats.h = (careerStats.h || 0) + parseInt(pitcherData.hits || 0);
                        careerStats.bb = (careerStats.bb || 0) + parseInt(pitcherData.walks || 0);
                        const opponentName = teamKey === 'team1' ? match.team2 : match.team1;
                        const opponentRank = opponentName ? calculateRank(opponentName, tournamentState) : 'E';
                        pStats.gamelogs.push({
                            matchId: currentMatchIdForDetails,
                            date: match.schedule?.date || '不明', 
                            round: getRoundNameFromMatchId(currentMatchIdForDetails),
                            opponent: opponentName,
                            opponentRank: opponentRank, 
                            result: pitcherData.result,
                            ip: pitcherData.innings,
                            h: pitcherData.hits,
                            bb: pitcherData.walks,
                            so: pitcherData.strikeouts,
                            r: pitcherData.runs,
                            er: pitcherData.earnedRuns
                        });
                    }
                }
            });
        }
    }
    for (const teamKey of ['team1', 'team2']) {
        const fieldingTable = document.getElementById(`fielding-table-${teamKey}`);
        if (fieldingTable) {
            fieldingTable.querySelectorAll('tbody tr').forEach(row => {
                const inning = row.querySelector('.fielding-inning')?.value;
                const player = row.querySelector('.player-name')?.value;
                const play = row.querySelector('.fielding-play')?.value;
                if (player && play) { 
                    details.fielding[teamKey].push({
                        inning: inning ? parseInt(inning) : null,
                        player: player,
                        play: play
                    });
                }
            });
        }
    }

    match.details = details;
    saveState();
    detailsModal.classList.add('hidden');
    renderTournament(tournamentState);
    alert('詳細を保存しました。');
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * [UPDATED] 準々決勝進出の8チームを分析し、展望記事をAIに生成させる
 * (★チーム数に応じて対象ラウンドを動的に変更)
 */
async function generateBest16PreviewArticle() {
    const state = tournamentState;
    if (!state.matches) return null;

    // ★★★ 修正箇所: 準々決勝のラウンド番号を計算 ★★★
    const numTeams = state.teams.length;
    const finalRound = Math.log2(numTeams); // 128->7, 64->6
    const roundNum = finalRound - 2; // 準々決勝 (7-2=5, 6-2=4)
    // ★★★ 修正ここまで ★★★

    const matchIdsInRound = Object.keys(state.matches).filter(id => 
        id.includes(`-R${roundNum}-M`)
    );
    
    if (matchIdsInRound.length === 0) return null;

    let matchupsText = "";
    let cinderellaTeams = [];
    
    // (以下、既存の分析ロジックは変更なし)
    for (const matchId of matchIdsInRound) {
        const match = state.matches[matchId];
        if (!match.team1 || !match.team2) continue;

        const team1 = match.team1;
        const team2 = match.team2;
        const rank1 = calculateRank(team1, state);
        const rank2 = calculateRank(team2, state);
        
        matchupsText += `\n### ${getRoundNameFromMatchId(matchId)} カード: ${team1} vs ${team2}\n`;
        
        [team1, team2].forEach(teamName => {
            const teamRecord = state.teamRecords[teamName];
            if (!teamRecord) return;
            
            const rank = calculateRank(teamName, state);
            const journey = getCurrentTournamentPerformance(teamName, matchId);
            const dynamicInfo = generateDynamicTeamInfo(teamName, TEAM_DATA[teamName], teamRecord);
            
            matchupsText += `- **${teamName}** (${rank}ランク)\n`;
            matchupsText += `  - 勝ち上がり: ${journey}\n`;
            matchupsText += `  - チーム状況: ${dynamicInfo}\n`;
            
            if (rank === 'C' || rank === 'D' || rank === 'E') {
                cinderellaTeams.push(`${teamName}(${rank})`);
            }
            
            let conditions = [];
            if (teamRecord.playerStats?.batting) {
                Object.values(teamRecord.playerStats.batting).forEach(p => {
                    if (p.narrative_flag && p.narrative_flag !== 'normal') {
                        conditions.push(`${p.name} (${getPlayerConditionIcon(p.narrative_flag)})`);
                    }
                });
            }
            if (teamRecord.playerStats?.pitching) {
                Object.values(teamRecord.playerStats.pitching).forEach(p => {
                    if (p.narrative_flag && p.narrative_flag !== 'normal') {
                        conditions.push(`${p.name} (${getPlayerConditionIcon(p.narrative_flag)})`);
                    }
                });
            }
            if (conditions.length > 0) {
                matchupsText += `  - 主な選手の調子: ${[...new Set(conditions)].join(', ')}\n`;
            }
        });
    }

    const prompt = `あなたは「静岡 熱闘スタジアム」のベテラン解説AIです。
${state.tournamentYear}年度 ${tournamentNameMap[state.currentTournament] || '大会'}はベスト8が決定しました。
以下の【準々決勝】の組み合わせデータに基づき、全4試合の見どころを解説する、ドラマチックな「展望記事」を執筆してください。

### 参考：勢力図
${PREFECTURE_LORE}

### 準々決勝 全4試合の対戦データ
${matchupsText}

### 執筆指示
1.  **タイトル:** 「ベスト8激突！準々決勝の注目カードをAIが徹底分析！」のような、期待感を煽るタイトルにしてください。
2.  **導入:** ベスト8が決定したことへの興奮と、ここからが本当の戦いであることを宣言してください。
3.  **【快進撃への言及】:**
    - もし ${cinderellaTeams.length > 0 ? `快進撃を続けるチーム（${cinderellaTeams.join(', ')}）` : '快進撃のチーム'} がいる場合、彼らの健闘を「今大会最大のサプライズ」として**必ず**称賛してください。
4.  **各カード分析:**
    - 全4試合の見どころを解説してください。
    - **データ活用:** 各チームの「今大会のチーム打率」や「選手の調子（🔥, ❄️）」を分析データとして引用してください。
5.  **締めくくり:** 準決勝に進むのはどのチームか、読者に問いかける形で記事を締めくくってください。

### 出力形式 (JSON)
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                return { 
                    ...article, 
                    timestamp: Date.now(),
                    summaryType: 'best8',
                    context: { isBracketAnalysis: true }
                };
            }
        }
        throw new Error("AI best8 preview response format error.");
    } catch (error) {
        console.error(`AI準々決勝展望記事の生成に失敗しました:`, error);
        return { 
            title: "準々決勝 展望記事生成エラー", body: "AI記者との通信に失敗しました。", 
            timestamp: Date.now(), error: true, errorId: `best8-preview-${Date.now()}`,
            summaryType: 'best8',
            context: { isBracketAnalysis: true }
        };
    }
}

/**
 * [修正版] 相手チームの打撃成績テーブルをスキャンし、
 * 味方チームの投手テーブルの「イニング数」に基づき、成績を自動で振り分ける
 * (★被安打・与四死球がカウントされないバグを修正)
 */
async function fillPitcherStatsFromBatting(pitchingTeamKey, battingTeamKey) {
    const battingTable = document.getElementById(`batting-table-${battingTeamKey}`);
    const pitchingTable = document.getElementById(`pitching-table-${pitchingTeamKey}`);
    const pitchingTableBody = pitchingTable?.querySelector('tbody');
    
    if (!battingTable || !pitchingTableBody) {
        alert("エラー: 必要なテーブルが見つかりません。");
        return;
    }

    // --- 1. 投手テーブルから「全投手」の「イニング数」を取得 ---
    const pitcherRows = Array.from(pitchingTableBody.querySelectorAll('tr'));
    const pitchersData = pitcherRows.map(row => {
        const name = row.querySelector('.pitcher-name')?.value.trim();
        const inningsStr = row.querySelector('.pitcher-innings')?.value.trim();
        const innings = parseFloat(inningsStr) || 0;
        
        // 6.1回 -> 19アウト, 6.2回 -> 20アウト, 6.0回 -> 18アウト
        const totalOuts = Math.floor(innings) * 3 + (innings % 1) * 10;
        
        return { rowElement: row, name, innings, totalOuts, stats: { bf: 0, h: 0, so: 0, walks: 0, r: 0 } };
    }).filter(p => p.name && p.innings); 

    if (pitchersData.length === 0) {
        alert("先に投手テーブルに「選手名」と「回数」（例: 6.1 や 9）を正確に入力してください。");
        return;
    }

    let cumulativeOuts = 0;
    pitchersData.forEach(p => {
        cumulativeOuts += p.totalOuts;
        p.cumulativeOuts = cumulativeOuts;
    });

    // --- 2. 相手打撃テーブルの全打席を「時系列順」に並べ替える ---
    const tempBattingData = [];
    battingTable.querySelectorAll('tbody tr').forEach(row => {
        const nameInput = row.querySelector('.player-name');
        if (nameInput && nameInput.value.trim() !== '') {
            tempBattingData.push({
                order: row.dataset.order,
                name: nameInput.value.trim(),
                results: Array.from(row.querySelectorAll('td.col-inning')).map(cell => {
                    return Array.from(cell.querySelectorAll('.at-bat-block')).map(block => {
                        const container = block.querySelector('.batting-result-container');
                        if (!container) return '';
                        return [
                            (block.querySelector('.mark-at-bat-btn')?.dataset.marked === 'true') ? '★:' : '',
                            container.querySelector('.result-strength').value,
                            container.querySelector('.result-direction').value,
                            container.querySelector('.result-type').value,
                            container.querySelector('.result-rbi').value,
                            container.querySelector('.result-runner-play').value
                        ].filter(Boolean).join('');
                    }).filter(Boolean).join('、');
                })
            });
        }
    });

    const sortedBattingOrder = tempBattingData.sort((a,b) => parseFloat(a.order.replace('-sub','.')) - parseFloat(b.order.replace('-sub','.')));
    const numInnings = battingTable.querySelector('thead tr').children.length - 7;
    let batterIndices = {}; 
    const allChronologicalPlays = []; 
    
    sortedBattingOrder.forEach((player, index) => {
        batterIndices[player.order] = index;
    });

    for (let i = 0; i < numInnings; i++) { 
        const startingBatterIndex = batterIndices[battingTeamKey] || 0;
        let currentBatterIndex = startingBatterIndex;
        let outsThisInning = 0;

        const playsInHalfInning = [];
        sortedBattingOrder.forEach(player => {
            const resultString = player.results?.[i];
            if (resultString) {
                resultString.split('、').forEach(atBat => {
                    if(atBat) playsInHalfInning.push({ player, atBat });
                });
            }
        });
        if (playsInHalfInning.length === 0) continue;

        const orderedPlays = [];
        let playsCount = 0;
        const atBatsTempCount = {};
        const processedFlags = new Array(playsInHalfInning.length).fill(false);
        while (orderedPlays.length < playsInHalfInning.length && playsCount < playsInHalfInning.length * 2) {
             const currentPlayer = sortedBattingOrder[currentBatterIndex];
             const playerOrderKey = currentPlayer.order;
             const currentAtBatOrdinal = atBatsTempCount[playerOrderKey] || 0;
             let foundPlayIndex = -1;
             let searchCount = 0;
             for(let k=0; k < playsInHalfInning.length; k++){
                 if(playsInHalfInning[k].player.order === playerOrderKey && !processedFlags[k]) {
                     if(searchCount === currentAtBatOrdinal) {
                         foundPlayIndex = k;
                         break;
                     }
                     searchCount++;
                 }
             }
             if (foundPlayIndex !== -1) {
                 orderedPlays.push(playsInHalfInning[foundPlayIndex]);
                 processedFlags[foundPlayIndex] = true;
                 atBatsTempCount[playerOrderKey] = currentAtBatOrdinal + 1;
                 currentBatterIndex = (currentBatterIndex + 1) % sortedBattingOrder.length;
             } else {
                 currentBatterIndex = (currentBatterIndex + 1) % sortedBattingOrder.length;
             }
             playsCount++;
        }
        const finalOrderedPlays = orderedPlays.length === playsInHalfInning.length ? orderedPlays : playsInHalfInning;
        
        finalOrderedPlays.forEach(play => {
            allChronologicalPlays.push(play);
            const [batterPlay] = play.atBat.split(';');
            const result = translatePlay(batterPlay);
            if (result.out) outsThisInning++;
            if (result.type === 'dp') outsThisInning++;
        });

        if (outsThisInning < 3 && finalOrderedPlays.length > 0) {
            const lastPlayer = finalOrderedPlays[finalOrderedPlays.length - 1].player;
            const lastBatterIndexInLineup = sortedBattingOrder.findIndex(p => p.order === lastPlayer.order);
            if (lastBatterIndexInLineup !== -1) {
                batterIndices[battingTeamKey] = (lastBatterIndexInLineup + 1) % sortedBattingOrder.length;
            }
        } else {
             batterIndices[battingTeamKey] = currentBatterIndex; 
        }
    }

    // --- 3. 時系列リストを処理し、成績を振り分ける ---
    let currentOuts = 0;
    
    allChronologicalPlays.forEach(play => {
        const [batterPlay, runnerPlaysString] = play.atBat.split(';');
        
        // (A) この打席を担当した投手を見つける
        let currentPitcher = pitchersData.find(p => currentOuts < p.cumulativeOuts);
        if (!currentPitcher) {
            currentPitcher = pitchersData[pitchersData.length - 1]; 
        }
        
        const stats = currentPitcher.stats;
        stats.bf++; // 打者 +1
        
        if (batterPlay && batterPlay.trim() !== '') {
            let cleanBatterPlay = batterPlay.trim().replace(/^★:/, '').replace(/^[SW]:/, '');
            
            // アウトカウント更新
            const result = translatePlay(batterPlay);
            if (result.out) currentOuts++;
            if (result.type === 'dp') currentOuts++;

            // ▼▼▼ 【修正】 被安打・与四死球のカウントロジックを修正 ▼▼▼
            // translatePlayの結果(英語タイプ)ではなく、日本語文字列(cleanBatterPlay)を直接チェックする
            
            // 被安打
            const isHit = BATTING_RESULTS.hits.some(h => cleanBatterPlay.includes(h));
            if (isHit) stats.h++;

            // 与四死球
            const isWalk = BATTING_RESULTS.walks.some(w => cleanBatterPlay.includes(w));
            if (isWalk) stats.walks++;
            
            // 奪三振 (translatePlayの結果を使用)
            if (result.type === 'so') stats.so++;
            
            // ▲▲▲ 修正ここまで ▲▲▲

            // 失点 (打点から)
            if (cleanBatterPlay.includes('点')) {
                const rbiValue = (cleanBatterPlay.match(/(\d+)点/) || [0, 0])[1];
                stats.r += parseInt(rbiValue, 10);
            }
        }
        
        // 失点 (走塁プレーから)
        (runnerPlaysString || '').split(',').forEach(runnerPlay => {
            const parts = runnerPlay.split(' ');
            if (parts.length < 2) return;
            const playType = parts[1];
            const base = parts[2] || '';
            
            if (playType === '生還' || (playType === '進塁' && base === '本塁へ(生還)')) {
                if (!batterPlay.includes('点') && !batterPlay.includes('本塁打') && !batterPlay.includes('犠飛')) {
                    stats.r++;
                }
            }
        });
    });

    // --- 4. 確認アラートを表示 ---
    let confirmMessage = "以下の内容で投手成績を自動入力しますか？\n\n";
    pitchersData.forEach(p => {
        confirmMessage += 
            `▼ ${p.name} (${p.innings}回)\n` +
            `  打者: ${p.stats.bf}人\n` +
            `  被安打: ${p.stats.h}本\n` +
            `  奪三振: ${p.stats.so}個\n` +
            `  与四死球: ${p.stats.walks}個\n` +
            `  失点: ${p.stats.r}点\n\n`;
    });
    confirmMessage += "（注：自責点(ER)と球数は手動で入力してください）";

    const confirmed = confirm(confirmMessage);

    // --- 5. 投手テーブルの入力欄に値を設定 ---
    if (confirmed) {
        pitchersData.forEach(p => {
            const row = p.rowElement;
            row.querySelector('.pitcher-batters').value = p.stats.bf;
            row.querySelector('.pitcher-hits').value = p.stats.h;
            row.querySelector('.pitcher-so').value = p.stats.so;
            row.querySelector('.pitcher-walks').value = p.stats.walks;
            row.querySelector('.pitcher-runs').value = p.stats.r;
            row.querySelector('.pitcher-er').value = p.stats.r; 
        });
        
        alert("投手成績を自動入力しました。\n自責点(ER)と球数は手動で確認・入力してください。");
    }
}

/**
 * [修正版] 詳細入力の打席結果文字列を、ボックススコア用の短い文字列に翻訳する
 * (★文字数順にソートして「犠飛」が「飛」に誤判定されるのを防ぐ)
 */
function translateResultForBoxScore(atBatString) {
    if (!atBatString) return "-";
    let tempRes = atBatString.trim();
    
    // 1. 注目フラグと勢いフラグを除去
    if (tempRes.startsWith('★:')) tempRes = tempRes.substring(3);
    if (tempRes.startsWith('S:')) tempRes = tempRes.substring(2);
    if (tempRes.startsWith('W:')) tempRes = tempRes.substring(2);

    // 2. 打点と走塁プレーを除去
    tempRes = tempRes.replace(/(\d+点)/, '');
    tempRes = tempRes.replace('好走塁', '');
    
    // 3. 方向+結果 (例: 中安, 遊ゴ) を抽出
    // ★★★ 修正: 文字数の多い順 (.sort((a, b) => b.length - a.length)) に並べ替えてから判定する
    const allResultTypes = [ 
        ...BATTING_RESULTS.hits, 
        ...BATTING_RESULTS.outs, 
        ...BATTING_RESULTS.walks, 
        ...BATTING_RESULTS.sacrifices, 
        ...BATTING_RESULTS.other, 
        '振り逃げ', '打撃妨害' 
    ].sort((a, b) => b.length - a.length);

    let foundResult = null;
    let foundDirection = '';

    for (const type of allResultTypes) {
        if (tempRes.includes(type)) {
            foundResult = type;
            tempRes = tempRes.replace(type, '').trim();
            break;
        }
    }
    
    if (tempRes.length > 0 && DIRECTIONS.includes(tempRes)) {
        foundDirection = tempRes;
    }

    if (foundResult) {
        if(foundResult === "安") foundResult = "安";
        return (foundDirection + foundResult).trim();
    }
    
    return "-";
}

// ▼▼▼ 勝率変動グラフ機能 ▼▼▼

/**
 * 勝率変動データを計算する
 * @param {string} team1 - チーム1の名前
 * @param {string} team2 - チーム2の名前
 * @param {Array} scores1 - チーム1のイニングスコア配列
 * @param {Array} scores2 - チーム2のイニングスコア配列
 * @param {object} state - tournamentState
 */
function calculateWinProbData(team1, team2, scores1, scores2, state, dbMatch) {
    const rank1 = calculateRank(team1, state);
    const rank2 = calculateRank(team2, state);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    
    const rankDiff = rankValues[rank1] - rankValues[rank2];
    let initialProb = 0.5 + (rankDiff * 0.05);
    initialProb = Math.max(0.2, Math.min(0.8, initialProb));

    const dataPoints = [initialProb];
    const labels = ['開始'];

    let currentScore1 = 0;
    let currentScore2 = 0;

    // ▼▼▼ 【修正】コールド回があればそこまで、なければ最低9回 ▼▼▼
    let totalInnings = Math.max(scores1.length, scores2.length, 9);
    if (dbMatch && dbMatch.calledGame && dbMatch.calledInning) {
        totalInnings = dbMatch.calledInning;
    }
    // ▲▲▲ 修正ここまで ▲▲▲

    for (let i = 0; i < totalInnings; i++) {
        currentScore1 += parseInt(scores1[i] || 0);
        currentScore2 += parseInt(scores2[i] || 0);

        const scoreDiff = currentScore1 - currentScore2;
        
        // 残りイニング計算 (コールドの場合は残り0に近づくように調整しても良いが、簡易的に9回ベースで減衰させる)
        const inningsLeft = Math.max(0, 9 - (i + 1));
        
        let timeDecay = 1 + ((9 - inningsLeft) * 0.3); 
        let probChange = (scoreDiff * 0.1 * timeDecay);
        
        let currentProb = initialProb + probChange;
        
        // 最終回（9回裏、またはコールド成立回）終了時は 0.0 or 1.0 に収束
        if (i === totalInnings - 1) {
            currentProb = currentScore1 > currentScore2 ? 1.0 : 0.0;
        }

        currentProb = Math.max(0.0, Math.min(1.0, currentProb));
        
        dataPoints.push(currentProb);
        labels.push(`${i + 1}回`);
    }

    return { labels, dataPoints };
}
/**
 * グラフを描画する (Chart.jsを使用)
 */
function renderWinProbChart(ctx, team1, team2, labels, dataPoints) {
    // 既存のチャートがあれば破棄
    const existingChart = Chart.getChart(ctx);
    if (existingChart) existingChart.destroy();

    // データセットの作成 (50%を基準に上下させる)
    const team1Data = dataPoints.map(p => p * 100); // チーム1の勝率%

    new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: `${team1}の勝率`,
                data: team1Data,
                borderColor: '#1d4ed8', // Blue
                backgroundColor: 'rgba(29, 78, 216, 0.1)',
                borderWidth: 2,
                pointRadius: 3,
                tension: 0.3, // 曲線にする
                fill: {
                    target: 'origin',
                    above: 'rgba(29, 78, 216, 0.1)',   // チーム1優勢エリア
                    below: 'rgba(220, 38, 38, 0.1)'    // チーム2優勢エリア (赤)
                }
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    min: 0,
                    max: 100,
                    grid: { color: (context) => context.tick.value === 50 ? '#000' : '#e5e7eb', lineWidth: (context) => context.tick.value === 50 ? 2 : 1 },
                    ticks: { callback: (v) => `${v}%` }
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const val = context.raw;
                            const t1Win = val.toFixed(1);
                            const t2Win = (100 - val).toFixed(1);
                            return `${team1} ${t1Win}% - ${team2} ${t2Win}%`;
                        }
                    }
                },
                annotation: { // 50%ライン
                    annotations: {
                        line1: {
                            type: 'line', yMin: 50, yMax: 50, borderColor: 'gray', borderWidth: 1, borderDash: [5, 5]
                        }
                    }
                }
            }
        }
    });
}
// ▲▲▲ 勝率グラフ機能 ここまで ▲▲▲

/**
 * [修正・完全版] 試合データから「一球速報」風のHTMLボックススコアを自動生成する
 * (★熱狂度の用途と目安の解説を追加)
 */
function generateBoxScoreHTML(dbMatch) {
    if (!dbMatch || !dbMatch.details) return "<p>詳細データがありません。</p>";
    
    const { details } = dbMatch;
    const team1Name = dbMatch.team1;
    const team2Name = dbMatch.team2;
    const score1 = parseInt(dbMatch.score1) || 0;
    const score2 = parseInt(dbMatch.score2) || 0;

    // --- 1. データ集計 ---
    let totalHits1 = 0;
    let totalHits2 = 0;
    if (details.playerGameStats) {
        Object.values(details.playerGameStats.team1 || {}).forEach(stats => totalHits1 += (stats.h || 0));
        Object.values(details.playerGameStats.team2 || {}).forEach(stats => totalHits2 += (stats.h || 0));
    }
    const totalErrors1 = 0; 
    const totalErrors2 = 0;

    const inningScores1 = details.inningScore?.team1 || [];
    const inningScores2 = details.inningScore?.team2 || [];
    
    let numInnings = Math.max(9, inningScores1.length, inningScores2.length);
    if (dbMatch.calledGame && dbMatch.calledInning) {
        numInnings = dbMatch.calledInning;
    }

    // --- 2. スコアボード生成 ---
    let inningHeaders = '';
    let inningRow1 = '';
    let inningRow2 = '';
    
    let currentS1 = 0;
    let currentS2 = 0;
    let team1LeadOnce = false;
    let team2LeadOnce = false;
    let bigInningTeam1 = false;
    let bigInningTeam2 = false;

    for (let i = 1; i <= numInnings; i++) {
        inningHeaders += `<th>${i}</th>`;
        
        const s1_val = parseInt(inningScores1[i-1] || 0);
        const score1_display = (i <= inningScores1.length && inningScores1[i-1] !== '' && inningScores1[i-1] !== null) ? s1_val : '';
        
        currentS1 += (score1_display !== '' ? s1_val : 0);
        if (s1_val >= 4) bigInningTeam1 = true;
        if (currentS1 > currentS2) team1LeadOnce = true;

        let score2_display = '';
        let s2_val = 0;
        const rawS2 = inningScores2[i-1];
        const hasBottomData = (rawS2 !== '' && rawS2 !== null && rawS2 !== undefined);

        if (hasBottomData) {
            s2_val = parseInt(rawS2);
            currentS2 += s2_val;
        }
        
        if (s2_val >= 4) bigInningTeam2 = true;
        if (currentS2 > currentS1) team2LeadOnce = true;

        if (i === numInnings) {
            if (score2 > score1) {
                if (!hasBottomData) {
                    score2_display = 'X';
                } else {
                    score2_display = `${s2_val}x`;
                }
            } else {
                score2_display = hasBottomData ? s2_val : '';
            }
        } else {
            score2_display = hasBottomData ? s2_val : '';
        }
        
        inningRow1 += `<td class="score-cell">${score1_display}</td>`;
        inningRow2 += `<td class="score-cell">${score2_display}</td>`;
    }

    const scoreBoardHtml = `
        <table class="boxscore-table">
            <thead class="inning-header">
                <tr><th></th>${inningHeaders}<th>計</th><th>H</th><th>E</th></tr>
            </thead>
            <tbody>
                <tr>
                    <td class="team-name">${team1Name}</td>
                    ${inningRow1}
                    <td class="total-score">${score1}</td>
                    <td class="total-score">${totalHits1}</td>
                    <td class="total-score">${totalErrors1}</td>
                </tr>
                <tr>
                    <td class="team-name">${team2Name}</td>
                    ${inningRow2}
                    <td class="total-score">${score2}</td>
                    <td class="total-score">${totalHits2}</td>
                    <td class="total-score">${totalErrors2}</td>
                </tr>
            </tbody>
        </table>
    `;

    // --- 3. スタッツテーブル生成 ---
    const generateStatsTables = (teamKey) => {
        const teamName = dbMatch[teamKey];
        const battingData = details.batting?.[teamKey] || [];
        const gameStats = details.playerGameStats?.[teamKey] || {};
        const pitchingData = details.pitching?.[teamKey] || [];

        const sortedBatters = battingData.sort((a, b) => {
            const orderA = parseFloat(a.order.replace('-sub', '.'));
            const orderB = parseFloat(b.order.replace('-sub', '.'));
            return orderA - orderB;
        });

        let battingRows = '';
        let totalAB = 0, totalR = 0, totalH = 0, totalRBI = 0, totalSO = 0, totalBB = 0;
        
        sortedBatters.forEach(player => {
            if (!player.name) return;
            const stats = gameStats[player.name];
            if (!stats || (!stats.played && (stats.sb || 0) === 0 && player.sub_type !== 'DEF' && player.sub_type !== 'PR')) return;

            const isSub = player.order.includes('sub');
            const rowClass = isSub ? 'sub-player' : '';
            const playerName = player.name;
            const playerPos = player.currentPos || player.pos || '?';
            
            const ab = stats.ab || 0; const r = stats.r || 0; const h = stats.h || 0;
            const rbi = stats.rbi || 0; const so = stats.so || 0;
            const bb = (stats.bb || 0) + (stats.hbp || 0);
            
            totalAB += ab; totalR += r; totalH += h; totalRBI += rbi; totalSO += so; totalBB += bb;

            const resultsText = player.results.map(inningResults => 
                inningResults.split('、').map(atBat => translateResultForBoxScore(atBat)).filter(res => res !== '-')
            ).flat().join(', ');

            let orderDisplay = isSub ? (player.sub_type === 'PH' ? '打' : (player.sub_type === 'PR' ? '走' : '守')) : player.order;

            battingRows += `
                <tr class="${rowClass}">
                    <td class="pos">${orderDisplay} ${playerPos}</td>
                    <td class="player">${playerName}</td>
                    <td class="at-bat">${ab}</td><td class="runs">${r}</td><td class="hits">${h}</td><td class="rbi">${rbi}</td>
                    <td class="so">${so}</td><td class="walks">${bb}</td><td class="results">${resultsText || '-'}</td>
                </tr>`;
        });
        
        const battingTableHtml = `
            <h3 class="text-xl font-bold mt-6 mb-2 text-gray-800">${teamName}</h3>
            <table class="batting-stats-table">
                <thead>
                    <tr>
                        <th class="pos"></th><th class="player">選手名</th>
                        <th class="at-bat">打</th><th class="runs">得</th><th class="hits">安</th><th class="rbi">点</th>
                        <th class="so">三</th><th class="walks">四</th><th class="results">打席結果</th>
                    </tr>
                </thead>
                <tbody>
                    ${battingRows}
                    <tr class="team-totals">
                        <td class="player" colspan="2">合計</td>
                        <td class="at-bat">${totalAB}</td><td class="runs">${totalR}</td><td class="hits">${totalH}</td><td class="rbi">${totalRBI}</td>
                        <td class="so">${totalSO}</td><td class="walks">${totalBB}</td><td class="results"></td>
                    </tr>
                </tbody>
            </table>
        `;

        let pitchingRows = '';
        if (pitchingData.length > 0) {
            pitchingData.forEach(p => {
                if (!p.name || !p.innings) return;
                const ip = parseFloat(p.innings) || 0;
                const er = parseInt(p.earnedRuns) || 0;
                const era = (ip > 0) ? ((er * 9) / ip).toFixed(2) : "0.00";
                const resultMark = {'W': '○', 'L': '●', 'S': 'Ｓ', 'H': 'Ｈ'}[p.result] || '';
                
                pitchingRows += `
                    <tr>
                        <td class="result">${resultMark}</td>
                        <td class="player">${p.name}</td>
                        <td class="ip">${p.innings}</td>
                        <td class="bf">${p.battersFaced || '-'}</td>
                        <td class="hits">${p.hits || '0'}</td>
                        <td class="so">${p.strikeouts || '0'}</td>
                        <td class="walks">${p.walks || '0'}</td>
                        <td class="runs">${p.runs || '0'}</td>
                        <td class="er">${p.earnedRuns || '0'}</td>
                        <td class="era">${era}</td>
                    </tr>`;
            });
        }
        
        const pitchingTableHtml = `
            <table class="pitching-stats-table">
                <thead><tr><th class="result"></th><th class="player">投手名</th><th class="ip">回</th><th class="bf">打者</th><th class="hits">安</th><th class="so">三</th><th class="walks">四</th><th class="runs">失</th><th class="er">自</th><th class="era">防御率</th></tr></thead>
                <tbody>${pitchingRows}</tbody>
            </table>
        `;
        return battingTableHtml + pitchingTableHtml;
    };

    // --- 4. グラフエリア (★解説を追加) ---
    const chartHtml = `
        <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-4">
            <div class="p-4 bg-white border rounded-lg shadow-sm">
                <h3 class="text-lg font-bold text-blue-700 mb-2">📉 勝率変動 (Win Probability)</h3>
                <div style="height: 200px; width: 100%;">
                    <canvas id="win-prob-chart"></canvas>
                </div>
                <p class="text-xs text-gray-500 mt-2">※点差、残りイニング、戦力差から算出した勝利確率の推移。</p>
            </div>
            <div class="p-4 bg-white border rounded-lg shadow-sm">
                <h3 class="text-lg font-bold text-orange-600 mb-2 flex justify-between">
                    <span>🔥 熱狂度推移 (Excitement)</span>
                    <span id="excitement-rank-badge" class="text-xs bg-orange-100 text-orange-800 px-2 py-1 rounded">集計中...</span>
                </h3>
                <div style="height: 200px; width: 100%;">
                    <canvas id="excitement-chart"></canvas>
                </div>
                
                <div class="mt-3 p-2 bg-orange-50 rounded border border-orange-100 text-xs text-gray-700">
                    <p class="font-bold mb-1 text-orange-800">📊 熱狂度とは？</p>
                    <p class="mb-2">試合の「面白さ」や「ドラマ性」を数値化した指標です。点差が縮まる、逆転、格下の善戦などで数値が上昇します。</p>
                    <div class="grid grid-cols-2 gap-1">
                        <div><span class="font-bold text-red-600">S (35~):</span> 伝説の名勝負・奇跡</div>
                        <div><span class="font-bold text-orange-600">A (25~):</span> 激熱・シーソーゲーム</div>
                        <div><span class="font-bold text-blue-600">B (15~):</span> 好ゲーム・接戦</div>
                        <div><span class="font-bold text-gray-500">C (~15):</span> 凡戦・ワンサイド</div>
                    </div>
                </div>
                </div>
        </div>
    `;

    // --- 5. AI戦評 (既存のまま) ---
    const winner = dbMatch.winner || "不明";
    const loser = dbMatch.team1 === winner ? dbMatch.team2 : dbMatch.team1;
    const wScore = parseInt(dbMatch.team1 === winner ? score1 : score2);
    const lScore = parseInt(dbMatch.team1 === winner ? score2 : score1);
    const diff = wScore - lScore;
    const totalHits = totalHits1 + totalHits2;
    const isWinnerTeam1 = (winner === team1Name);
    const wHits = isWinnerTeam1 ? totalHits1 : totalHits2;
    const lHits = isWinnerTeam1 ? totalHits2 : totalHits1;
    const isComeback = (isWinnerTeam1 && team2LeadOnce) || (!isWinnerTeam1 && team1LeadOnce);

    let commentTitle = "試合総括";
    let commentBody = "";
    let badgeColor = "bg-gray-100 text-gray-800";

    // 戦評の条件分岐
    if (numInnings >= 9 && isWinnerTeam1 === false && parseInt(inningScores2[numInnings-1]) > 0 && (score2 - parseInt(inningScores2[numInnings-1]) <= score1)) {
        commentTitle = "劇的サヨナラ";
        badgeColor = "bg-pink-100 text-pink-800 border border-pink-300";
        commentBody = `劇的な幕切れ！ ${winner}が土壇場で勝負強さを発揮し、${loser}との熱戦にサヨナラで終止符を打った。`;
    } else if (lScore === 0) {
        commentTitle = "完封勝利";
        badgeColor = "bg-blue-100 text-blue-800 border border-blue-300";
        commentBody = `${winner}投手陣が${loser}打線を散発${lHits}安打に抑え込み、見事な完封リレーを完成させた。`;
    } else if (diff >= 7) {
        commentTitle = "圧倒";
        badgeColor = "bg-red-100 text-red-800 border border-red-300";
        const attackType = (bigInningTeam1 || bigInningTeam2) ? "ビッグイニングを作るなど打線が爆発。" : "着実に加点し、";
        commentBody = `${winner}が投打に${loser}を圧倒。${attackType}相手に付け入る隙を与えなかった。`;
    } else if (isComeback) {
        commentTitle = "逆転勝利";
        badgeColor = "bg-green-100 text-green-800 border border-green-300";
        commentBody = `先制を許す苦しい展開だったが、${winner}が粘り強く反撃。中盤以降に試合をひっくり返し、見事な逆転勝利を収めた。`;
    } else if (totalHits >= 20 || (wScore + lScore) >= 13) {
        commentTitle = "乱打戦";
        badgeColor = "bg-purple-100 text-purple-800 border border-purple-300";
        commentBody = `両チーム合わせて${totalHits}安打が飛び交う激しい打ち合いとなった。取られたら取り返すシーソーゲームを制したのは${winner}。`;
    } else if ((wScore + lScore) <= 5 && totalHits <= 12) {
        commentTitle = "投手戦";
        badgeColor = "bg-gray-100 text-gray-800 border border-gray-400";
        commentBody = `互いの投手が持ち味を発揮し、スコアボードに0が並ぶ緊迫した投手戦となった。数少ないチャンスを確実にものにした${winner}が勝利。`;
    } else if (lHits > wHits) {
        commentTitle = "勝負強さ";
        badgeColor = "bg-yellow-100 text-yellow-800 border border-yellow-300";
        commentBody = `${loser}は${winner}を上回る${lHits}安打を放ちながらも、要所での一本が出ず残塁の山を築いた。対する${winner}は少ない好機を活かした。`;
    } else if (diff <= 2) {
        commentTitle = "大接戦";
        badgeColor = "bg-orange-100 text-orange-800 border border-orange-300";
        commentBody = `最後までどちらが勝つか分からない好ゲーム。${winner}が${loser}の猛追をわずかな差で振り切った。`;
    } else {
        commentTitle = "快勝";
        badgeColor = "bg-blue-50 text-blue-600 border border-blue-200";
        commentBody = `${winner}が終始試合の主導権を握り、${loser}に勝利した。投打のバランスが良く、危なげない試合運びを見せた。`;
    }

    if (dbMatch.summary) {
        commentBody += `<br><span class="text-xs text-gray-500 mt-3 block border-t pt-2">📝 <strong>監督メモ:</strong> ${dbMatch.summary}</span>`;
    }

    const aiCommentHtml = `
        <div class="mt-6 bg-white border border-gray-200 rounded-lg p-4 shadow-sm border-l-4 border-indigo-500">
            <div class="flex items-center mb-2">
                <span class="text-2xl mr-2">🤖</span>
                <h3 class="font-bold text-gray-800">AI戦評: <span class="text-sm px-2 py-0.5 rounded ${badgeColor} ml-1">${commentTitle}</span></h3>
            </div>
            <p class="text-sm text-gray-700 leading-relaxed">${commentBody}</p>
        </div>
    `;

    return scoreBoardHtml + generateStatsTables('team1') + generateStatsTables('team2') + chartHtml + aiCommentHtml;
}


/**
 * [新機能] あるチームの、指定された試合ID「以前」の
 * 全試合のスタメン履歴を時系列で取得する
 * @param {string} teamName - チーム名
 * @param {string} currentMatchId - 現在の試合ID (これより前の履歴を取得する)
 * @returns {Array<object>} - [{ matchId, roundName, starters: [...] }, ...]
 */
function getStarterHistory(teamName, currentMatchId) {
    const history = [];
    
    // 1. 全試合データをスキャン
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };
    
    const targetMatch = allMatches[currentMatchId];
    // 現在の試合のラウンドキーを取得 (例: 1, 2, 100)
    const currentRoundSortKey = targetMatch?.roundSortKey || getRoundSortKey(currentMatchId);

    // 2. チームが関わり、かつ「現在より前」の試合を収集
    for (const matchId in allMatches) {
        // 現在の試合自体は除外
        if (matchId === currentMatchId) continue;
        
        const match = allMatches[matchId];
        const teamKey = match.team1 === teamName ? 'team1' : (match.team2 === teamName ? 'team2' : null);
        
        // 条件：チームが関わっている AND 勝者が決まっている AND 詳細入力がある
        if (teamKey && match.winner && match.details && match.details.batting && match.details.batting[teamKey]) {
            
            const matchRoundSortKey = getRoundSortKey(matchId);
            
            // ★現在の試合のラウンドキーより「小さい」試合のみを履歴に追加
            if (matchRoundSortKey < currentRoundSortKey) {
                const starters = match.details.batting[teamKey]
                    .filter(p => p.order && !p.order.toString().includes('sub') && parseInt(p.order) >= 1 && parseInt(p.order) <= 9)
                    .map(p => p.name); // 名前だけの配列にする
                
                history.push({
                    matchId: matchId,
                    roundSortKey: matchRoundSortKey,
                    roundName: getRoundNameFromMatchId(matchId),
                    starters: starters
                });
            }
        }
    }
    
    // 3. ラウンド順にソートして返す
    history.sort((a, b) => a.roundSortKey - b.roundSortKey);
    return history;
}

/**
 * 試合IDからソート用の数値キーを取得する (getStarterHistoryのヘルパー)
 */
function getRoundSortKey(matchId) {
    if (!matchId) return 999;
    if (matchId.includes('-R')) {
        // 'L-R1-M1' -> 1
        return parseInt(matchId.split('-R')[1].split('-')[0]);
    }
    if (matchId.startsWith('F-')) {
        return 100; // 決勝
    }
    if (matchId.includes('-SB') || matchId.includes('-SREP') || matchId.includes('-SIZU') || matchId.includes('AUTUMN')) {
        return -1; // 地区予選は本戦より前
    }
    return 999;
}
// ▲▲▲ 貼り付けここまで ▲▲▲

/**
     * 【修正版】スキップ機能関連
     */
    function generateAutoScore(rankWinner, rankLoser) {
        const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
        const diff = rankValues[rankWinner] - rankValues[rankLoser];
        let winnerScore, loserScore;

        if (diff >= 3) { // 大差
            winnerScore = 7 + Math.floor(Math.random() * 4);
            loserScore = Math.floor(Math.random() * 3);
        } else if (diff >= 2) { // 中差
            winnerScore = 5 + Math.floor(Math.random() * 3);
            loserScore = Math.max(0, winnerScore - (3 + Math.floor(Math.random() * 2)));
        } else if (diff >= 1) { // 小差
            winnerScore = 3 + Math.floor(Math.random() * 4);
            loserScore = Math.max(0, winnerScore - (1 + Math.floor(Math.random() * 2)));
        } else { // 同ランク
            winnerScore = 2 + Math.floor(Math.random() * 5);
            loserScore = winnerScore - 1;
        }
        return [winnerScore, loserScore];
    }

   /**
     * 【修正版】ラウンドを自動でスキップする
     * (★新聞生成フック、結果収集機能、甲子園ボス必勝ロジックを統合)
     */
    async function skipRound(roundNumber) {
        const btnId = `skip-r${roundNumber}-btn`;
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.disabled = true;
            btn.textContent = `進行中...(${roundNumber}回戦)`;
        }
        skipLoader.classList.remove('hidden');

        // ★ 128チーム制に対応
        const numTeams = tournamentState.teams.length;
        const numMatchesInRoundSide = (numTeams / 2) / Math.pow(2, roundNumber - 1); // R1=32, R2=16...

        const matchIds = [];
        ['L', 'R'].forEach(side => {
            for (let i = 1; i <= numMatchesInRoundSide; i++) {
                matchIds.push(`${side}-R${roundNumber}-M${i}`);
            }
        });

        // ★★★ スキップした試合の結果を収集する配列 ★★★
        const roundResults = [];

        // --- ステップ1：ラウンドの全試合の勝敗を決定 ---
        for (const matchId of matchIds) {
            const match = tournamentState.matches[matchId];
            
            if (!match || match.winner || !match.team1 || !match.team2) {
                continue;
            }

            // ★★★ BYE(不戦勝)の処理 ★★★
            if (match.team1 === '(BYE)') {
                await processMatchWin(matchId, match.team2); // team2の不戦勝
                continue;
            }
            if (match.team2 === '(BYE)') {
                await processMatchWin(matchId, match.team1); // team1の不戦勝
                continue;
            }
            // ★★★ BYE処理ここまで ★★★

            const { team1, team2 } = match;
            const rank1 = calculateRank(team1, tournamentState);
            const rank2 = calculateRank(team2, tournamentState);
            const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
            let winnerName;

            // ★★★ 甲子園モード：ボスチーム強制勝利ロジック ★★★
            const bossTeams = ["花巻東", "横浜", "報徳学園", "浦和学院", "大阪桐蔭", "日大三"];
            const isKoshien = tournamentState.currentTournament === 'summer_koshien';
            const playerTeam = tournamentState.teams[0]; // プレイヤーはIndex 0にいる前提

            if (isKoshien) {
                // どちらかがボスで、もう片方がプレイヤー(283学園)でない場合、ボスを勝たせる
                if (bossTeams.includes(team1) && team2 !== playerTeam) {
                    winnerName = team1; // ボス1の勝ち
                } else if (bossTeams.includes(team2) && team1 !== playerTeam) {
                    winnerName = team2; // ボス2の勝ち
                } 
                // ボス同士の対決、あるいはプレイヤー対ボスの場合は通常ロジックへ（プレイヤーは自力で勝つ必要があるため）
            }
            // ★★★ ここまで ★★★
            
            // まだ勝者が決まっていない場合（通常ロジック）
            if (!winnerName) {
                const upsetChance = 0.15 - (Math.abs(rankValues[rank1] - rankValues[rank2]) * 0.03);
                
                if (Math.random() < upsetChance) { // 番狂わせ
                    winnerName = rankValues[rank1] < rankValues[rank2] ? team1 : team2;
                } else { // 順当
                    winnerName = rankValues[rank1] >= rankValues[rank2] ? team1 : team2;
                }
            }

            const loserName = winnerName === team1 ? team2 : team1;
            
            const winnerRank = calculateRank(winnerName, tournamentState);
            const loserRank = calculateRank(loserName, tournamentState);

            const [winnerScore, loserScore] = generateAutoScore(winnerRank, loserRank);

            match.score1 = (match.team1 === winnerName) ? winnerScore : loserScore;
            match.score2 = (match.team2 === winnerName) ? winnerScore : loserScore;
            
            // ★ 結果を収集
            roundResults.push({
                matchId, winnerName, loserName, winnerScore, loserScore,
                winnerRank, loserRank, rankDiff: rankValues[winnerRank] - rankValues[loserRank]
            });

            await processMatchWin(matchId, winnerName);
        }
        
        renderTournament(tournamentState);
        renderNews(tournamentState.news); 
        
        // ★★★ ステップ2：新聞を生成・表示 (設定OFFでもスキップ新聞は表示) ★★★
        if (roundResults.length > 0) {
            await generateSkipRoundNewspaper(roundNumber, roundResults);
        }
        // ★★★ 新聞生成フックここまで ★★★

        saveState();
        
        if (btn) {
            btn.classList.add('hidden');
            btn.disabled = false;
            btn.textContent = `${roundNumber}回戦スキップ`;
        }
        skipLoader.classList.add('hidden');
    }
// ▲▲▲ 置き換えここまで ▲▲▲

// --- NEW Autumn Tournament System ---

 /**
 * [秋季大会 ステージ1] 地区ブロック予選を開始する
 * (★新仕様: 3地区 大規模トーナメント + 敗者復活戦 方式)
 */
async function setupAutumnRegionalBlocks() {
    tournamentState.autumnPhase = 'regional_blocks';
    
    // 1. 全チームを地区別に振り分け
    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    INITIAL_TEAM_POOL.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region && teamsByRegion[region]) {
            teamsByRegion[region].push(teamName);
        }
    });

    // ★★★ ここからが新ロジック ★★★
    // 2. 「東部・伊豆」を「東部」に統合
    teamsByRegion['東部'] = teamsByRegion['東部'].concat(teamsByRegion['伊豆']);
    delete teamsByRegion['伊豆']; // 旧伊豆地区を削除
    tournamentState.autumnData.regions['伊豆'] = { blocks: [], finalReps: [] }; // 互換性のため空で残す

    // 3. 主要3地区（東部・中部・西部）の大規模トーナメントを生成
    for (const region of ['東部', '中部', '西部']) {
        let regionalTeams = shuffleArray(teamsByRegion[region]);
        if (regionalTeams.length === 0) continue;

        // (A) メイントーナメント (例: 43チーム -> 64枠トーナメント)
        const mainBracketId = `${region}-MAIN`;
        const mainMatches = createDynamicBracketMatches(mainBracketId, regionalTeams);
        
        // (B) 敗者復活トーナメント (8枠)
        const repechageBracketId = `${region}-REP`;
        const repechageMatches = createDynamicBracketMatches(repechageBracketId, Array(8).fill(null)); // 8チーム用の空の箱
        
        // (C) 州データに保存
        tournamentState.autumnData.regions[region] = {
            blocks: [], // 旧ブロックは廃止
            mainBracket: { // ★新設
                id: mainBracketId,
                teams: regionalTeams,
                matches: mainMatches,
                size: Math.pow(2, Math.ceil(Math.log2(regionalTeams.length))) // 64, 64, 64
            },
            repechageBracket: { // ★新設
                id: repechageBracketId,
                teams: Array(8).fill(null), // 8枠
                matches: repechageMatches
            },
            finalReps: [], // 最終的な代表 (12枠)
            best8: [], // ベスト8 (8枠)
            repechageTeams: [] // 敗者復活に進むチーム (8枠)
        };
        
        // (D) 全試合をマスターリストに追加
        if (!tournamentState.autumnData.allMatches) tournamentState.autumnData.allMatches = {};
        Object.assign(tournamentState.autumnData.allMatches, mainMatches, repechageMatches);
    }
    // ★★★ 新ロジックここまで ★★★

    renderTournament(tournamentState);
    saveState();
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * [NEW HELPER] 任意のチーム数でトーナメントの試合オブジェクトを自動生成する
 * (★prevMatchId (子試合ID) を保存し、描画と進行を可能にする修正版)
 * @param {string} bracketId - '東部-B1' や '伊豆-AUTUMN' などのプレフィックス
 * @param {Array<string>} teams - そのブロックに参加する全チームの配列
 * @returns {object} - 全試合の matches オブジェクト
 */
function createDynamicBracketMatches(bracketId, teams) {
    const numTeams = teams.length;
    if (numTeams === 0) return {};
    if (numTeams === 1) return {};

    const matches = {};
    const rounds = [];
    
    const tournamentSize = Math.pow(2, Math.ceil(Math.log2(numTeams)));
    const numRounds = Math.log2(tournamentSize);
    const numByes = tournamentSize - numTeams;
    const numFirstRoundTeams = numTeams - numByes;
    
    let teamsInNextRound = [];
    let teamIndex = 0;

    // --- 4. 1回戦 (R1) を生成 ---
    if (numFirstRoundTeams > 0) {
        const round1Matches = [];
        const numMatchesR1 = numFirstRoundTeams / 2;
        for (let i = 0; i < numMatchesR1; i++) {
            const matchId = `${bracketId}-R1-M${i + 1}`;
            const team1 = teams[teamIndex++];
            const team2 = teams[teamIndex++];
            matches[matchId] = { 
                id: matchId, team1: team1, team2: team2, winner: null, score1: '', score2: '',
                prevMatch1Id: null, prevMatch2Id: null, nextMatchId: null // R1は子なし
            };
            round1Matches.push(matchId);
            teamsInNextRound.push(`winner_of_${matchId}`);
        }
        rounds.push(round1Matches);
    }
    
    // --- 5. 1回戦免除(シード)のチームを次ラウンドに追加 ---
    for (let i = 0; i < numByes; i++) {
        teamsInNextRound.push(teams[teamIndex++]);
    }

    // --- 6. 2回戦 (R2) から決勝 (Final) までを自動生成 ---
    for (let r = 2; r <= numRounds; r++) {
        const roundMatches = [];
        const teamsInThisRound = shuffleArray(teamsInNextRound);
        teamsInNextRound = [];
        
        const numMatchesInRound = teamsInThisRound.length / 2;
        for (let i = 0; i < numMatchesInRound; i++) {
            const matchId = `${bracketId}-R${r}-M${i + 1}`;
            const team1_str = teamsInThisRound[i * 2];
            const team2_str = teamsInThisRound[i * 2 + 1];
            
            const resolvedTeam1 = team1_str.startsWith('winner_of_') ? null : team1_str;
            const resolvedTeam2 = team2_str.startsWith('winner_of_') ? null : team2_str;
            
            // ★★★ ここからが修正箇所 ★★★
            // この試合 (R2) に進出する、前の試合 (R1) のIDを保存する
            const prevMatch1Id = team1_str.startsWith('winner_of_') ? team1_str.replace('winner_of_', '') : null;
            const prevMatch2Id = team2_str.startsWith('winner_of_') ? team2_str.replace('winner_of_', '') : null;

            matches[matchId] = { 
                id: matchId, 
                team1: resolvedTeam1, 
                team2: resolvedTeam2, 
                winner: null, score1: '', score2: '', 
                prevMatch1Id: prevMatch1Id, // ★ 左の子 (team1側) のID
                prevMatch2Id: prevMatch2Id, // ★ 右の子 (team2側) のID
                nextMatchId: null // ★ この時点では「次」は不明
            };
            // ★★★ 修正ここまで ★★★

            roundMatches.push(matchId);
            teamsInNextRound.push(`winner_of_${matchId}`);
            
            // ★ 前の試合の「nextMatchId」に、今作った試合IDをリンクする
            if (prevMatch1Id) matches[prevMatch1Id].nextMatchId = matchId;
            if (prevMatch2Id) matches[prevMatch2Id].nextMatchId = matchId;
        }
        rounds.push(roundMatches);
    }
    
    return matches;
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * [秋季大会 ステージ1 UI] 地区予選を描画する
 * (★新仕様: 3地区 大規模T + 敗者復活T 方式)
 */
function renderAutumnRegionalBlocks() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">秋季大会 地区予選</h2>`;
    html += '<div class="space-y-8">';

    // 東部・中部・西部
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.mainBracket) continue;

        const quota = 12; // 各地区12枠

        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">${region}地区 (${quota}枠)</h3>
                
                <h4 class="font-bold text-center text-lg mb-2">県大会出場決定トーナメント (ベスト8が決定)</h4>
                <p class="text-sm text-center text-gray-600 mb-2">
                    ${regionData.mainBracket.teams.length}チームによるトーナメント。ベスト8 (準々決勝) に進出した8校が県大会出場決定！<br>
                    ベスト16で敗退した8校は、下の「敗者復活トーナメント」に進みます。
                </p>
                <div class="p-3 border rounded-lg bg-gray-50 overflow-x-auto">
                    <div class="flex items-center justify-start space-x-2 text-xs" style="min-width: ${regionData.mainBracket.size * 50}px;">
                        ${createDynamicBracketHTML(regionData.mainBracket.id, regionData.mainBracket.matches)}
                    </div>
                </div>

                <h4 class="font-bold text-center text-lg mb-2 mt-8">敗者復活トーナメント (残り4枠)</h4>
                <p class="text-sm text-center text-gray-600 mb-2">
                    上記のベスト16で敗退した8校が、残り4枠をかけて戦います。
                </p>
                <div class="p-3 border rounded-lg bg-gray-50 overflow-x-auto">
                    <div class="flex items-center justify-center space-x-2 text-xs">
                        ${createDynamicBracketHTML(regionData.repechageBracket.id, regionData.repechageBracket.matches)}
                    </div>
                </div>
            </div>
        `;
    }
    // (伊豆地区は東部に統合されたため描画ロジックを削除)

    html += '</div>';
    autumnRegionalContainer.innerHTML = html;
    checkAutumnRegionalBlocksComplete();
}
// ▲▲▲ 置き換えここまで ▲▲▲

  
    /**
     * [秋季大会 ステージ2] 地区内順位決定戦を開始する
     */
    async function setupAutumnRankingTournaments() {
    tournamentState.autumnPhase = 'regional_ranking';

    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        
        // 重要な変更：上位校トーナメントは廃止し、敗者復活戦のみを行う
        regionData.champBracket = null; // 不要になったのでクリア

        // ブロック準優勝したチームで、第5代表決定トーナメントを組む
        const repechageBracketId = `${region}-REP`;
        const repTeams = shuffleArray(regionData.blockRunnersUp);
        regionData.repechageBracket = {
            id: repechageBracketId,
            teams: repTeams,
            matches: {
                [`${repechageBracketId}-R1-M1`]: { id: `${repechageBracketId}-R1-M1`, team1: repTeams[0], team2: repTeams[1], winner: null, score1: '', score2: '', summary: '' },
                [`${repechageBracketId}-R1-M2`]: { id: `${repechageBracketId}-R1-M2`, team1: repTeams[2], team2: repTeams[3], winner: null, score1: '', score2: '', summary: '' },
                [`${repechageBracketId}-R2-M1`]: { id: `${repechageBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '', summary: '' } // 5位決定戦
            }
        };
    }
    
    renderTournament(tournamentState);
    saveState();
}
    /**
     * [秋季大会 ステージ2 UI] 地区内順位決定戦を描画する
     */
   // 【修正対象3】
function renderAutumnRankingTournaments() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">秋季大会 地区 第5代表決定トーナメント</h2>`;
    html += '<div class="space-y-8">';
    
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.repechageBracket) continue;

        const rep = regionData.repechageBracket;
        
        const repSemi1 = rep.matches[`${rep.id}-R1-M1`];
        const repSemi2 = rep.matches[`${rep.id}-R1-M2`];
        rep.matches[`${rep.id}-R2-M1`].team1 = repSemi1.winner;
        rep.matches[`${rep.id}-R2-M1`].team2 = repSemi2.winner;
        
        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-purple-700">${region}地区</h3>
                <div class="flex items-center justify-center space-x-4">
                    <div class="space-y-4">
                        ${createMatchHTML(repSemi1.id, repSemi1.team1, repSemi1.team2, repSemi1, [])}
                        
                        ${createMatchHTML(repSemi2.id, repSemi2.team1, repSemi2.team2, repSemi2, [])}
                        </div>
                    <div>
                        <p class="text-center font-semibold">代表決定戦</p>
                        ${createMatchHTML(rep.matches[`${rep.id}-R2-M1`].id, rep.matches[`${rep.id}-R2-M1`].team1, rep.matches[`${rep.id}-R2-M1`].team2, rep.matches[`${rep.id}-R2-M1`], [])}
                    </div>
                </div>
            </div>
        `;
    }
    html += '</div>';
    autumnRankingContainer.innerHTML = html;
    checkAutumnRankingTournamentsComplete();
}
    

/**
 * [秋季大会 ステージ3] 県大会本戦を開始する
 * (★新仕様: 36チーム制 (24 BYE + 12 R1) に対応)
 */
async function setupAutumnMainTournament() {
    tournamentState.autumnPhase = 'main';
    tournamentState.is16team = false; // 16チーム制ではない

    // --- 1. 代表チームのリストを作成 (36チーム) ---
    const best8_winners = []; // 24校 (2回戦から)
    const repechage_winners = []; // 12校 (1回戦から)

    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        
        // (A) メイントーナメントのベスト8 (8校) を集計
        const mainMatches = regionData.mainBracket.matches;
        const mainSize = regionData.mainBracket.size; // 64, 64, 64
        const quarterFinalRound = Math.log2(mainSize) - 1; // 準々決勝 (R5)
        
        const quarterFinalIds = Object.keys(mainMatches).filter(id => id.includes(`-R${quarterFinalRound}-M`)); // R5の試合
        quarterFinalIds.forEach(matchId => {
            const match = mainMatches[matchId];
            if (match.team1) best8_winners.push(match.team1);
            if (match.team2) best8_winners.push(match.team2);
        });

        // (B) 敗者復活トーナメントのベスト4 (4校) を集計
        const repMatches = regionData.repechageBracket.matches;
        const repSemiFinalRound = Math.log2(8) - 1; // 準決勝 (R2)
        
        const repSemiFinalIds = Object.keys(repMatches).filter(id => id.includes(`-R${repSemiFinalRound}-M`)); // R2の試合
        repSemiFinalIds.forEach(matchId => {
            const match = repMatches[matchId];
            if (match.team1) repechage_winners.push(match.team1);
            if (match.team2) repechage_winners.push(match.team2);
        });
    }

    // --- 2. 予選敗退チームの成績を記録 ---
    const repTeamNames = [...best8_winners, ...repechage_winners];
    INITIAL_TEAM_POOL.forEach(teamName => {
        if (TEAM_DATA[teamName]?.region && !repTeamNames.includes(teamName)) {
            if(tournamentState.teamRecords[teamName]) tournamentState.teamRecords[teamName].lastFinish = 64;
        }
    });

    // --- 3. 64チーム制トーナメントを生成 (36校 + 28 BYE) ---
    const numTeamsInTournament = 64;
    const finalRound = 6;
    tournamentState.teams = Array(numTeamsInTournament).fill(null);
    tournamentState.matches = {};
    tournamentState.seeds = []; // 秋季県大会はシードなし

    const shuffledRepechageTeams = shuffleArray(repechage_winners); // 12校
    const shuffledBest8Teams = shuffleArray(best8_winners); // 24校
    const byes = Array(28).fill('(BYE)'); // 28枠
    
    let teamsForR1 = []; // 1回戦を戦うチーム (36チーム)
    
    // (A) 敗者復活12校を、1回戦の6試合に配置
    for (let i = 0; i < 12; i++) {
        teamsForR1.push(shuffledRepechageTeams[i]);
    }
    
    // (B) ベスト8の24校と、BYEの28枠をペアリング
    // 24校 + 28BYE = 52チーム -> 26試合
    // このうち、(28-24)=4つのBYEがBYE同士で当たる (2試合)
    const combinedRest = shuffleArray([...shuffledBest8Teams, ...byes]);
    for (let i = 0; i < 52; i++) {
        teamsForR1.push(combinedRest[i]);
    }
    
    // (C) 1回戦の枠 (36チーム) がシャッフルされていないのでシャッフル
    teamsForR1 = shuffleArray(teamsForR1);
    
    // (D) 最終的な 64スロットを生成
    let r1Index = 0;
    let byeIndex = 0;
    const finalTeamsArray = [];
    
    // 12校(敗者復活)が6試合 = 12スロット
    for(let i=0; i<12; i++) {
        finalTeamsArray.push(shuffledRepechageTeams[i]);
    }
    // 24校(ベスト8) + 28BYE = 52スロット
    const rest = shuffleArray([...shuffledBest8Teams, ...byes]);
    finalTeamsArray.push(...rest);
    
    tournamentState.teams = finalTeamsArray; // 64枠にセット

    // --- 4. R1 (32試合) の試合オブジェクトを作成 ---
    const round1Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    round1Setup.forEach((match, index) => {
        const side = index < 16 ? 'L' : 'R'; // 32試合 / 2 = 16
        const matchNum = index < 16 ? index + 1 : index - 15;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

    // --- 5. R2, R3, R4, R5, F の「空の箱」を作成 ---
    for (let r = 2; r < finalRound; r++) { // R2, R3, R4, R5
        const numMatchesInRound = numTeamsInTournament / Math.pow(2, r); // 16, 8, 4, 2
        for (let m = 1; m <= numMatchesInRound / 2; m++) {
            const matchIdL = `L-R${r}-M${m}`;
            tournamentState.matches[matchIdL] = { id: matchIdL, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
            const matchIdR = `R-R${r}-M${m}`;
            tournamentState.matches[matchIdR] = { id: matchIdR, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
        }
    }
    tournamentState.matches['F-R1-M1'] = { id: 'F-R1-M1', team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
    
    // --- 6. スケジュールを割り当て (64チーム・6ラウンド制) ---
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R1-')), 
        ["9/15", "9/16", "9/17"], STADIUM_DATA, 2 // R1(32試合) -> 10球場*3日*2試合=60スロット (十分)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R2-')), 
        ["9/19", "9/20"], ROUND_3_STADIUMS, 2 // R2(16試合) -> 4球場*2日*2試合=16スロット
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R3-')), 
        ["9/22"], ROUND_3_STADIUMS, 2 // R3(8試合) -> 4球場*1日*2試合=8スロット
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R4-')), 
        ["9/24"], FINAL_STAGE_STADIUMS, 4 // R4(準々 4試合) -> 1球場*1日*4試合
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R5-')), 
        ["9/26"], FINAL_STAGE_STADIUMS, 2 // R5(準決 2試合) -> 1球場*1日*2試合
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('F-R1-')), 
        ["9/28"], FINAL_STAGE_STADIUMS, 1 // 決勝 (1試合)
    );
    
    renderTournament(tournamentState);
    saveState();
    
    // --- 7. 不戦勝(BYE)の自動処理 ---
    processByes(tournamentState);

    // --- 8. 記事生成 ---
    const currentTournamentName = "秋季県大会本戦";
    newsContainer.innerHTML = `<div class="loader">AI記者が${currentTournamentName}の展望記事を執筆中...</div>`;
    bbsCommentsContainer.innerHTML = `<div class="loader">AIが組み合わせを分析中...</div>`;

    const [previewArticle, bracketBbsResult] = await Promise.all([
        generateBracketAnalysisNewsArticle(tournamentState), // 64チーム制の分析を呼ぶ
        generateBracketBbsThread(tournamentState) // 64チーム制のBBSを呼ぶ
    ]);

    if (previewArticle && !previewArticle.error) {
         tournamentState.news.unshift(previewArticle);
    } else if (previewArticle && previewArticle.error) {
        tournamentState.news.unshift(previewArticle);
    }
    if (bracketBbsResult && !bracketBbsResult.error) {
        tournamentState.bbsComments.push(bracketBbsResult); 
    } else if (bracketBbsResult && bracketBbsResult.error) {
        tournamentState.bbsComments.push({ ...bracketBbsResult, context: { isBracketThread: true } });
    }
    
    renderNews(tournamentState.news);
    renderBbsComments(tournamentState.bbsComments);
    saveState();
}
// ▲▲▲ 置き換えここまで ▲▲▲


/**
     * 秋季地区ブロック予選がすべて終了したかチェックする
     * (★新仕様: 3地区 大規模T + 敗者復活T の終了を監視)
     */
    function checkAutumnRegionalBlocksComplete() {
    let allFinished = true;
    
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData || !regionData.mainBracket || !regionData.repechageBracket) {
            allFinished = false; break;
        }
        
        // 1. メイントーナメントの決勝戦 (優勝決定)
        const mainMatches = regionData.mainBracket.matches;
        const mainFinalId = Object.keys(mainMatches).find(id => !mainMatches[id].nextMatchId);
        if (!mainFinalId || !mainMatches[mainFinalId].winner) {
            allFinished = false; break;
        }

        // 2. 敗者復活トーナメントの決勝戦 (4試合)
        const repMatches = regionData.repechageBracket.matches;
const semi1 = repMatches[`${regionData.repechageBracket.id}-R2-M1`];
        const semi2 = repMatches[`${regionData.repechageBracket.id}-R2-M2`];
        
        if (!semi1 || !semi2 || !semi1.team1 || !semi1.team2 || !semi2.team1 || !semi2.team2) {
             allFinished = false; break;
        }
        // (敗者復活戦は準決勝まで進めばOK。決勝(R3-M1)までやる必要はない)
        // ★★★ 新ロジックここまで ★★★
    }

    if (allFinished) {
        autumnControls.classList.remove('hidden');
        startRankingPlayoffsBtn.classList.add('hidden');
        startMainTournamentBtn.classList.remove('hidden'); // ★ 県大会本戦ボタンを表示
        skipAutumnBlocksBtn.classList.add('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startRankingPlayoffsBtn.classList.add('hidden');
        startMainTournamentBtn.classList.add('hidden');
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲
 
   /**
     * 秋季地区内順位決定戦がすべて終了したかチェックする
     */
    /**
     * 【修正版】秋季地区内順位決定戦がすべて終了したかチェックする
     */
    function checkAutumnRankingTournamentsComplete() {
    let allRankingsFinished = true;
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.autumnData.regions[region];
        if (!regionData.repechageBracket) {
            allRankingsFinished = false;
            break;
        }

        const repechageFinal = regionData.repechageBracket.matches[`${region}-REP-R2-M1`]; // 5位決定戦

        // 敗者復活戦の決勝がすべて終わっているかチェック
        if (!repechageFinal.winner) {
            allRankingsFinished = false;
            break;
        }
    }
    
    if (allRankingsFinished) {
        autumnControls.classList.remove('hidden');
        startRankingPlayoffsBtn.classList.add('hidden');
        startMainTournamentBtn.classList.remove('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startMainTournamentBtn.classList.add('hidden');
    }
}
// --- NEW Spring Tournament System ---

/**
 * [春季大会 ステージ1] 地区予選を開始する（3校トーナメント対応・最終版）
 */
async function setupSpringRegionalQualifiers() {
    tournamentState.springPhase = 'regional_qualifiers';
    const { qualifierTeams } = tournamentState.springData;

    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };
    qualifierTeams.forEach(teamName => {
        const region = TEAM_DATA[teamName]?.region;
        if (region && teamsByRegion[region]) {
            teamsByRegion[region].push(teamName);
        }
    });
    
    // 東部・中部・西部地区の予選設定
    for (const region of ['東部', '中部', '西部']) {
        let regionalTeams = shuffleArray(teamsByRegion[region]);
        const blockCount = 4;
        const regionBlocks = [];
        
        for (let i = 0; i < blockCount; i++) {
            const blockTeams = regionalTeams.splice(0, Math.ceil(regionalTeams.length / (blockCount - i)));
            if(blockTeams.length === 0) continue;
            
            const blockId = `${region}-SB${i+1}`; // Spring Block
            const blockMatches = {};
            
            // チーム数に応じてトーナメント形式を決定
            if (blockTeams.length <= 4) { // 4チーム以下
                const semi1Id = `${blockId}-R1-M1`;
                const semi2Id = `${blockId}-R1-M2`;
                const finalId = `${blockId}-R2-M1`;
                Object.assign(blockMatches, {
                    [semi1Id]: { id: semi1Id, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '' },
                    [semi2Id]: { id: semi2Id, team1: blockTeams[2] || null, team2: blockTeams[3] || null, winner: null, score1: '', score2: '' },
                    [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '' }
                });
            } else { // 5チーム
                 const playInMatchId = `${blockId}-R0-M1`;
                 const semi1Id = `${blockId}-R1-M1`;
                 const semi2Id = `${blockId}-R1-M2`;
                 const finalId = `${blockId}-R2-M1`;
                 Object.assign(blockMatches, {
                    [playInMatchId]: { id: playInMatchId, team1: blockTeams[0], team2: blockTeams[1], winner: null, score1: '', score2: '' },
                    [semi1Id]: { id: semi1Id, team1: null, team2: blockTeams[2], winner: null, score1: '', score2: '' },
                    [semi2Id]: { id: semi2Id, team1: blockTeams[3], team2: blockTeams[4], winner: null, score1: '', score2: '' },
                    [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '' }
                 });
            }
            regionBlocks.push({ id: blockId, teams: blockTeams, matches: blockMatches });
            Object.assign(tournamentState.springData.allMatches, blockMatches);
        }
        tournamentState.springData.regions[region].blocks = regionBlocks;

        // 第5代表決定トーナメントの器を準備
        const repBracketId = `${region}-SREP`;
        tournamentState.springData.regions[region].repechageBracket = {
            id: repBracketId,
            teams: [], // ブロック準優勝校がここに入る
            matches: {
                [`${repBracketId}-R1-M1`]: { id: `${repBracketId}-R1-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' },
                [`${repBracketId}-R1-M2`]: { id: `${repBracketId}-R1-M2`, team1: null, team2: null, winner: null, score1: '', score2: '' },
                [`${repBracketId}-R2-M1`]: { id: `${repBracketId}-R2-M1`, team1: null, team2: null, winner: null, score1: '', score2: '' }
            }
        };
        Object.assign(tournamentState.springData.allMatches, tournamentState.springData.regions[region].repechageBracket.matches);
    }
    
    // 伊豆地区の予選設定
    const izuTeams = shuffleArray(teamsByRegion['伊豆']);
    const izuBracketId = '伊豆-SIZU'; // IDを'SIZU'に変更
    const izuBracket = { id: izuBracketId, teams: izuTeams, matches: {} };

    if (izuTeams.length === 3) {
        // --- 3校トーナメントの場合 ---
        const semiId = `${izuBracketId}-R1-M1`;
        const finalId = `${izuBracketId}-R2-M1`;
        // 1チームが不戦勝（bye）で決勝へ
        Object.assign(izuBracket.matches, {
            [semiId]: { id: semiId, team1: izuTeams[0], team2: izuTeams[1], winner: null, score1: '', score2: '' },
            [finalId]: { id: finalId, team1: null, team2: izuTeams[2], winner: null, score1: '', score2: '' }
        });
    } else if (izuTeams.length >= 2) {
        // --- 4校（または2校）トーナメントの場合 ---
        const semi1Id = `${izuBracketId}-R1-M1`;
        const semi2Id = `${izuBracketId}-R1-M2`;
        const finalId = `${izuBracketId}-R2-M1`;
        Object.assign(izuBracket.matches, {
            [semi1Id]: { id: semi1Id, team1: izuTeams[0], team2: izuTeams[1], winner: null, score1: '', score2: '' },
            [semi2Id]: { id: semi2Id, team1: izuTeams[2] || null, team2: izuTeams[3] || null, winner: null, score1: '', score2: '' },
            [finalId]: { id: finalId, team1: null, team2: null, winner: null, score1: '', score2: '' }
        });
    }
    tournamentState.springData.regions['伊豆'].izuBracket = izuBracket;
    Object.assign(tournamentState.springData.allMatches, izuBracket.matches);

    renderTournament(tournamentState);
    saveState();
}

/**
 * [春季大会 ステージ1 UI] 地区予選を描画する
 */
function renderSpringRegionalQualifiers() {
    let html = `<h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">春季大会 地区予選</h2>`;
    html += '<div class="space-y-8">';

    // 東部・中部・西部
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.springData.regions[region];
        if (!regionData.blocks) continue;

        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-green-700">${region}地区 (5枠)</h3>
                <h4 class="font-bold text-center text-lg mb-2">代表決定ブロック</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    ${regionData.blocks.map(block => `
                        <div class="p-3 border rounded-lg bg-gray-50">
                            <h4 class="font-bold text-center mb-2">ブロック ${block.id.split('-')[1].slice(1)}</h4>
                            ${block.teams.length <= 4 ? create4TeamBlockHTML(block) : create5TeamBlockHTML(block)}
                        </div>
                    `).join('')}
                </div>
                <h4 class="font-bold text-center text-lg mb-2">第5代表決定トーナメント</h4>
                <div class="flex justify-center">
                   ${create4TeamBlockHTML(regionData.repechageBracket, true)}
                </div>
            </div>
        `;
    }

    // 伊豆
    const izuData = tournamentState.springData.regions['伊豆'];
    if (izuData.izuBracket) {
        html += `
            <div class="p-4 border-2 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 border-b pb-2 text-green-700">伊豆地区 (1枠)</h3>
                <div class="flex justify-center">
                    ${create4TeamBlockHTML(izuData.izuBracket)}
                </div>
            </div>
        `;
    }
    
    html += '</div>';
    autumnRegionalContainer.innerHTML = html; // 秋のコンテナを流用
    checkSpringQualifiersComplete();
}

/**
 * [NEW HELPER] matchesオブジェクトからトーナメント表のHTMLを再帰的に生成する
 * (★「prevMatchId」を正しく辿って描画する修正版)
 * @param {string} bracketId - '東部-B1' など
 * @param {object} matches - このブロックの全試合 matches オブジェクト
 * @returns {string} - トーナメント表のHTML
 */
function createDynamicBracketHTML(bracketId, matches) {
    const finalMatchId = Object.keys(matches).find(id => !matches[id].nextMatchId);
    if (!finalMatchId) return "（試合なし）";

    // 再帰的にHTMLを構築する内部関数
    function buildMatchHTML(matchId) {
        const match = matches[matchId];
        if (!match) return "（エラー）";

        // ★★★ ここからが修正箇所 ★★★
        // 1. データベースに保存された子IDを直接参照
        const prevMatch1Id = match.prevMatch1Id;
        const prevMatch2Id = match.prevMatch2Id;
        
        // 2. （左側）前の試合がある場合は、再帰的に呼び出す
        const leftHtml = prevMatch1Id ? buildMatchHTML(prevMatch1Id) : '';
        // 3. （右側）前の試合がある場合は、再帰的に呼び出す
        const rightHtml = prevMatch2Id ? buildMatchHTML(prevMatch2Id) : '';

        // 4. チーム名を解決
        // (processMatchWinが勝者名を team1/team2 に入れるため、
        //  R1以外は prevMatch.winner を見る必要がなくなった)
        const team1 = match.team1 || (prevMatch1Id ? (matches[prevMatch1Id]?.winner || '---') : '---');
        const team2 = match.team2 || (prevMatch2Id ? (matches[prevMatch2Id]?.winner || '---') : '---');
        // ★★★ 修正ここまで ★★★
        
        // 5. この試合自身のHTMLを生成
        const currentMatchHtml = createMatchHTML(matchId, team1, team2, match, []);

        if (leftHtml || rightHtml) {
            // 前の試合(子)がある場合 (2回戦以降)
            return `
                <div class="flex items-center justify-center space-x-2">
                    <div class="flex flex-col justify-around space-y-4">
                        ${leftHtml}
                        ${rightHtml}
                    </div>
                    <div class="w-40">${currentMatchHtml}</div>
                </div>
            `;
        } else {
            // これが1回戦の場合 (子がない)
            return `<div class="w-40">${currentMatchHtml}</div>`;
        }
    }

    return buildMatchHTML(finalMatchId);
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 春季地区予選がすべて終了したかチェックする
 */
function checkSpringQualifiersComplete() {
    let allFinished = true;
    for (const match of Object.values(tournamentState.springData.allMatches)) {
        // チームがセットされていて、まだ勝者が決まっていない試合があるか
        if (match.team1 && match.team2 && !match.winner) {
            allFinished = false;
            break;
        }
    }

    if (allFinished) {
        autumnControls.classList.remove('hidden');
        startMainTournamentBtn.classList.remove('hidden'); // 県大会へ進むボタン
        startRankingPlayoffsBtn.classList.add('hidden');
    } else {
        autumnControls.classList.add('hidden');
        startMainTournamentBtn.classList.add('hidden');
    }
}/**
 * [春季大会 ステージ2-1] 県大会本戦1回戦を開始する
 */
async function setupSpringMainTournament_Round1() {
    tournamentState.springPhase = 'main_round1';
    
    // 各地区の代表校をfinalRepsから集計
    for (const region of ['東部', '中部', '西部']) {
        const regionData = tournamentState.springData.regions[region];
        // ブロック優勝校
        regionData.blocks.forEach(block => {
            const finalMatch = block.matches[`${block.id}-R2-M1`] || block.matches[`${block.id}-R1-M1`]; // 2,3チームブロック対応
            if(finalMatch && finalMatch.winner) regionData.finalReps.push(finalMatch.winner);
        });
        // 第5代表
        const repFinal = regionData.repechageBracket.matches[`${regionData.repechageBracket.id}-R2-M1`];
        if (repFinal.winner) regionData.finalReps.push(repFinal.winner);
    }
    const izuFinal = tournamentState.springData.regions['伊豆'].izuBracket.matches[`伊豆-SIZU-R2-M1`];
    if (izuFinal.winner) tournamentState.springData.regions['伊豆'].finalReps.push(izuFinal.winner);

    const qualifiedTeams = Object.values(tournamentState.springData.regions).flatMap(r => r.finalReps);
    
    // 予選敗退チームの成績を記録
    tournamentState.springData.qualifierTeams.forEach(team => {
        if (!qualifiedTeams.includes(team)) {
            tournamentState.teamRecords[team].lastFinish = 64; // 予選敗退
        }
    });

    tournamentState.teams = shuffleArray(qualifiedTeams); // 予選突破16校で1回戦
    tournamentState.matches = {};
    tournamentState.is16team = true; // 16チームトーナメントとして描画
    tournamentState.seeds = []; // 1回戦はシードなし

    const round1Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    round1Setup.forEach((match, index) => {
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });

// ▼▼▼ このブロックをまるごと追加 ▼▼▼
    // --- 1回戦のスケジュールを割り当て (16チーム) ---
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R1-')), 
        ["4/10", "4/11"], MAJOR_STADIUMS, 2 // 1回戦 (8試合) -> 4球場*2日*2試合=16スロット
    );
    // ▲▲▲ 追加ここまで ▲▲▲

    renderTournament(tournamentState);
    saveState();
    
    // 展望記事などを生成...
    newsContainer.innerHTML = `<div class="loader">AI記者が県大会1回戦の展望記事を執筆中...</div>`;
    // ★展望記事用の簡易contextを作成して渡す
    const previewContext = { matchId: 'preview' };
    const previewArticle = await generateNewsArticle(previewContext);
    if (previewArticle) tournamentState.news.unshift(previewArticle);

    renderNews(tournamentState.news);
    saveState();
}

/**
 * [春季大会 ステージ2-2] 県大会本戦2回戦を開始する
 */
async function setupSpringMainTournament_Round2() {
    tournamentState.springPhase = 'main_round2_onwards';
    
    const round1Winners = [];
    Object.values(tournamentState.matches).forEach(match => {
        if(match.id.includes('-R1-') && match.winner) {
            round1Winners.push(match.winner);
        }
    });

    const seedTeams = tournamentState.springData.seedTeams;
    const shuffledSeeds = shuffleArray(seedTeams);
    const shuffledWinners = shuffleArray(round1Winners);

    // 2回戦の組み合わせを作成 (シード vs 1回戦勝者)
    let newTeamsForRound2 = [];
    for (let i = 0; i < 8; i++) {
        newTeamsForRound2.push(shuffledSeeds[i]);
        newTeamsForRound2.push(shuffledWinners[i]);
    }
    newTeamsForRound2 = shuffleArray(newTeamsForRound2); // 組み合わせをシャッフル

    tournamentState.teams = newTeamsForRound2;
    tournamentState.matches = {};
    tournamentState.is16team = true;
    tournamentState.seeds = seedTeams; // 2回戦からシード校として表示

    const round2Setup = tournamentState.teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);

    // R1として試合IDを生成するが、これは大会の「2回戦」にあたる
    round2Setup.forEach((match, index) => {
        const side = index < 4 ? 'L' : 'R';
        const matchNum = index < 4 ? index + 1 : index - 3;
        const matchId = `${side}-R1-M${matchNum}`;
        tournamentState.matches[matchId] = { id: matchId, team1: match.team1, team2: match.team2, winner: null, score1: '', score2: '', details: null, summary: '' };
    });
    
    // 敗退チームの成績を記録
    Object.values(tournamentState.teamRecords).forEach(record => {
        if (record.lastFinish > 16 && record.lastFinish <=32) record.lastFinish = 32; // 1回戦敗退はベスト32扱い
    });
    
// ▼▼▼ このブロックをまるごと置き換え ▼▼▼
    // --- 2回戦以降のスケジュールを割り当て (16チーム・新ルール版) ---
    const finalRoundSpring = 4;
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R1-')), // (R1 = 2回戦)
        ["4/15", "4/16"], ROUND_3_STADIUMS, 2 // 2回戦 (主要4球場) ※3回戦用球場を流用
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R2-')), 
        ["4/18"], FINAL_STAGE_STADIUMS, 4 // 準々決勝 (草薙で4試合)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('-R3-')), 
        ["4/21"], FINAL_STAGE_STADIUMS, 2 // 準決勝 (草薙で2試合)
    );
    scheduleRoundMatches(
        Object.keys(tournamentState.matches).filter(id => id.includes('F-R1-')), 
        ["4/23"], FINAL_STAGE_STADIUMS, 1 // 決勝 (草薙で1試合)
    );
    // ▲▲▲ 置き換えここまで ▲▲▲
    renderTournament(tournamentState);
    saveState();

    // 2回戦の展望記事を生成
    newsContainer.innerHTML = `<div class="loader">AI記者が県大会2回戦の展望記事を執筆中...</div>`;
    // ★展望記事用の簡易contextを作成して渡す
    const previewContext = { matchId: 'preview' };
    const previewArticle = await generateNewsArticle(previewContext);
    if (previewArticle) tournamentState.news.unshift(previewArticle);
    if(previewArticle) 
        tournamentState.news.unshift(previewArticle);
    

    renderNews(tournamentState.news);
    saveState();
}


// --- AI Content Generation & Helpers (Part A: Main Generators) ---

/**
 * 試合の全情報を集約した「matchContext」オブジェクトを生成する司令塔
 * (★「故障者リスト(injuryReport)」の情報を追加)
 * (★★ 故障者リストに「軽傷(🩹)」と「選手の重要度(主力/控え)」も含めるよう修正 ★★)
 */
function createMatchContext(matchId, winnerName, team1QualityText, team2QualityText) {
    const dbMatch = findMatchById(matchId);
    if (!dbMatch) return null;

// ▼▼▼ 【追加】対戦相手の過去成績がない場合、自動生成して埋める ▼▼▼
    // 283学園が関わる試合かどうかに関わらず、勝者・敗者両方の過去ログを整備する
    // (これにより、決勝戦の相手などが「初出場」扱いされなくなる)
    backfillCpuStats(winnerName);
    backfillCpuStats(dbMatch.team1 === winnerName ? dbMatch.team2 : dbMatch.team1);
    // ▲▲▲ 追加ここまで ▲▲▲

    const loserName = dbMatch.team1 === winnerName ? dbMatch.team2 : dbMatch.team1;
    const nextOpponentInfo = findNextOpponent(winnerName, matchId);
    let nextOpponentJourney = null;
    if (nextOpponentInfo && nextOpponentInfo.opponentName && !['（未定）', '優勝'].includes(nextOpponentInfo.opponentName)) {
        nextOpponentJourney = getCurrentTournamentPerformance(nextOpponentInfo.opponentName, matchId);
    }

    const { highlights, keyPlayerNames } = createHighlightsText(dbMatch, winnerName);
    
    // (Gamelog収集ロジックは変更なし)
    let pitcherGamelogInfo = "\n### 参考情報：今大会の主な投手登板履歴 (この試合より前)\n";
    let relevantLogsFound = false;
    const parseDate = (dateStr) => {
        if (!dateStr || !dateStr.includes('/')) return null;
        const [month, day] = dateStr.split('/').map(Number);
        const year = tournamentState.tournamentYear + (month <= 3 ? 1 : 0);
        return new Date(year, month - 1, day);
    };
    const today = parseDate(dbMatch.schedule?.date);
    if (dbMatch.details && dbMatch.details.pitching) {
        for (const teamKey of ['team1', 'team2']) {
            const pitchingData = dbMatch.details.pitching[teamKey] || [];
            pitchingData.forEach(pitcher => {
                const playerName = pitcher.name;
                if (!playerName) return;
                const teamRecord = tournamentState.teamRecords[dbMatch[teamKey]];
                const pStats = teamRecord?.playerStats?.pitching[playerName];
                if (pStats && pStats.gamelogs && pStats.gamelogs.length > 0) {
                    const currentTournamentKey = tournamentState.currentTournament;
                    const previousLogs = pStats.gamelogs.filter(log => {
                        if (log.matchId === matchId) return false;
                        const logRound = log.round || '';
                        if (currentTournamentKey === 'summer') return logRound.includes('回戦') || logRound.includes('決勝');
                        if (currentTournamentKey === 'autumn') return logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                        if (currentTournamentKey === 'spring') return logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                        return false;
                    });
                    if (previousLogs.length > 0) {
                        relevantLogsFound = true;
                        pitcherGamelogInfo += `- ${playerName} (${dbMatch[teamKey]}):\n`;
                        previousLogs.sort((a, b) => (parseDate(a.date) || 0) - (parseDate(b.date) || 0));
                        previousLogs.forEach(log => {
                            let dateInfo = log.date || '日付不明';
                            if (today) {
                                const logDate = parseDate(log.date);
                                if (logDate) {
                                    const diffDays = Math.ceil(Math.abs(today - logDate) / (1000 * 60 * 60 * 24)) - 1;
                                    if (diffDays === 0) dateInfo = `${log.date} (連投)`;
                                    else if (diffDays === 1) dateInfo = `${log.date} (中1日)`;
                                    else if (diffDays > 0) dateInfo = `${log.date} (中${diffDays - 1}日)`;
                                }
                            }
                            const opponentRank = log.opponentRank || 'E';
                            const resultMark = {'W': '○', 'L': '●', 'S': 'Ｓ', 'H': 'Ｈ'}[log.result] || '';
                            pitcherGamelogInfo += `  - ${log.round} (${dateInfo}) (対 ${log.opponent} [${opponentRank}]): ${resultMark}${log.ip}回 ${log.h}被安打 ${log.bb}四球 ${log.so}奪三振 ${log.r}失点(自責${log.er})\n`;
                        });
                    }
                }
            });
        }
    }
    if (!relevantLogsFound) {
        pitcherGamelogInfo = "\n### 参考情報：今大会の主な投手登板履歴\n- この試合に出場した投手は、全員今大会これが初登板です。\n";
    }
    let batterGamelogInfo = "\n### 参考情報：今大会の主な打者成績履歴 (この試合より前)\n";
    let relevantBatterLogsFound = false;
    const today_batter = parseDate(dbMatch.schedule?.date);
    if (dbMatch.details && dbMatch.details.batting) {
        for (const teamKey of ['team1', 'team2']) {
            const battingData = dbMatch.details.batting[teamKey] || [];
            battingData.forEach(batter => {
                const playerName = batter.name;
                if (!playerName) return;
                const teamRecord = tournamentState.teamRecords[dbMatch[teamKey]];
                const bStats = teamRecord?.playerStats?.batting[playerName];
                if (bStats && bStats.gamelogs && bStats.gamelogs.length > 0) {
                    const currentTournamentKey = tournamentState.currentTournament;
                    const previousLogs = bStats.gamelogs.filter(log => {
                        if (log.matchId === matchId) return false;
                        const logRound = log.round || '';
                        if (currentTournamentKey === 'summer') return logRound.includes('回戦') || logRound.includes('決勝');
                        if (currentTournamentKey === 'autumn') return logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                        if (currentTournamentKey === 'spring') return logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                        return false;
                    });
                    if (previousLogs.length > 0) {
                        relevantBatterLogsFound = true;
                        batterGamelogInfo += `- ${playerName} (${dbMatch[teamKey]}):\n`;
                        previousLogs.sort((a, b) => (parseDate(a.date) || 0) - (parseDate(b.date) || 0));
                        previousLogs.forEach(log => {
                            let dateInfo = log.date || '日付不明';
                            const opponentRank = log.opponentRank || 'E';
                            const stats = log.stats || { ab: 0, h: 0, hr: 0, rbi: 0, sb: 0 };
                            let role = "";
                            if (log.sub_type === 'PH') role = "代打";
                            else if (log.order && log.order.includes('sub')) role = "途中出場";
                            else if (log.order) role = `${log.order}番`;
                            else role = "出場";
                            const statsLine = `${stats.ab}打数${stats.h}安打 ${stats.hr}HR ${stats.rbi}打点 ${stats.sb}盗塁`;
                            batterGamelogInfo += `  - ${log.round} (${dateInfo}) (対 ${log.opponent} [${opponentRank}]) (${role}): ${statsLine}\n`;
                        });
                    }
                }
            });
        }
    }
    if (!relevantBatterLogsFound) {
        batterGamelogInfo = "\n### 参考情報：今大会の主な打者成績履歴\n- この試合に出場した打者は、全員今大会これが初出場です。\n";
    }

// ★★★ 追加箇所: 県大会(予選)成績のテキスト化 ★★★
    let prefecturalStatsText = "";
    if (tournamentState.currentTournament === 'summer_koshien') {
        const pStats = tournamentState.teamRecords[winnerName]?.prefecturalStats;
        if (pStats) {
            const avg = pStats.ab > 0 ? (pStats.h / pStats.ab).toFixed(3) : '.---';
            prefecturalStatsText += `- **${winnerName} (静岡大会)**: 打率${avg}, 本塁打${pStats.hr}, 盗塁${pStats.sb}, 総得点${pStats.r}\n`;
        }
    }
    // ★★★ 追加ここまで ★★★

    // ★★★ ここからが修正箇所 (怪我人リストアップの強化) ★★★
    let injuryReportText = "\n### 参考情報：主な欠場者・怪我人リスト\n";
    let injuriesFound = false;

    for (const teamName of [winnerName, loserName]) {
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord || !teamRecord.playerStats) continue;

        // 静的ロスター（283学園用）と、直前のロスターを取得
        const staticRoster = TEAM_ROSTER_MASTER[teamName]; 
        const fullRoster = teamRecord.roster || []; 

        // チェック対象の選手リストを作成（静的ロスターがいればそれを優先、なければ履歴から）
        let checkList = [];
        if (staticRoster) {
            checkList = staticRoster.map(p => p.name);
        } else if (teamRecord.playerStats.batting) {
            checkList = Object.keys(teamRecord.playerStats.batting);
        }

        let injuredPlayers = []; 

        // 全リストを走査して、怪我フラグが立っている選手を探す
        checkList.forEach(playerName => {
            // 打撃・投手どちらかのレコードに怪我フラグがあるか
            const bFlag = teamRecord.playerStats.batting?.[playerName]?.narrative_flag;
            const pFlag = teamRecord.playerStats.pitching?.[playerName]?.narrative_flag;
            const flag = (bFlag === 'injured' || bFlag === 'sick' || bFlag === 'minor_injury') ? bFlag :
                         (pFlag === 'injured' || pFlag === 'sick' || pFlag === 'minor_injury') ? pFlag : null;

            if (flag) {
                // この試合に出場したかチェック
                const teamKey = dbMatch.team1 === teamName ? 'team1' : 'team2';
                const playedBatting = dbMatch.details?.batting?.[teamKey]?.some(p => p.name === playerName);
                const playedPitching = dbMatch.details?.pitching?.[teamKey]?.some(p => p.name === playerName);
                const isAbsent = !playedBatting && !playedPitching;

                // 重要度を判定
                let importance = 'Hikae';
                const staticData = staticRoster?.find(p => p.name === playerName);
                
                // 1. 静的データによる判定 (背番号1、主将、捕手)
                if (staticData && (staticData.number == 1 || staticData.isCaptain || staticData.position.includes('捕'))) {
                    importance = 'Shuryoku_Static';
                }
                // 2. 成績データによる判定 (打率4割超, 防御率1点台)
                else {
                     const tourneyStats = calculateCurrentTournamentStats(
                        teamRecord.playerStats.batting?.[playerName]?.gamelogs, 
                        teamRecord.playerStats.pitching?.[playerName]?.gamelogs, 
                        matchId
                    );
                    if ((tourneyStats.AVG > 0.400 && tourneyStats.AB >= 5) || (tourneyStats.IP >= 5.0 && tourneyStats.ERA < 2.00)) {
                        importance = 'Shuryoku_Dynamic';
                    } else if (tourneyStats.AB >= 10 || tourneyStats.IP >= 10) {
                        importance = 'Regular_Dynamic';
                    }
                }

                injuredPlayers.push({ 
                    name: playerName, 
                    flag: flag, 
                    importance: importance,
                    isAbsent: isAbsent // 欠場したかどうかのフラグ
                });
            }
        });

        // テキスト生成
        if (injuredPlayers.length > 0) {
            const playerStates = injuredPlayers.map(p => {
                let importanceLabel = '控え';
                if (p.importance.startsWith('Shuryoku')) importanceLabel = '主力';
                else if (p.importance.startsWith('Regular')) importanceLabel = 'レギュラー';
                
                let flagIcon = '🩹(軽傷)'; 
                if (p.flag === 'injured') flagIcon = '🏥(故障)';
                if (p.flag === 'sick') flagIcon = '😷(体調不良)';
                
                const status = p.isAbsent ? "**欠場**" : "強行出場";
                return `${p.name} ${flagIcon} [${importanceLabel}] -> ${status}`;
            });

            injuryReportText += `- **${teamName}**: ${playerStates.join(', ')}\n`;
            injuriesFound = true;
        }
    }

    if (!injuriesFound) {
        injuryReportText += "特筆すべき故障者・欠場者は記録されていません。\n";
    }
    // ★★★ 修正ここまで ★★★
    const context = {
        winnerName,
        loserName,
        dbMatch,
        matchId,
        winnerData: TEAM_DATA[winnerName],
        loserData: TEAM_DATA[loserName],
        winnerDetailedData: DETAILED_TEAM_DATA[winnerName],
        loserDetailedData: DETAILED_TEAM_DATA[loserName],
        playerStatsText: dbMatch.details ? formatPlayerStatsForPrompt(dbMatch) : null,
        winnerJourney: getCurrentTournamentPerformance(winnerName, matchId),
        loserJourney: getCurrentTournamentPerformance(loserName, matchId),
        winnerLineupChanges: dbMatch.details ? analyzeLineupChanges(winnerName, dbMatch) : "比較データなし",
        loserLineupChanges: dbMatch.details ? analyzeLineupChanges(loserName, dbMatch) : "比較データなし",
        nextOpponent: nextOpponentInfo,
        nextOpponentJourney: nextOpponentJourney,
        highlights: highlights,
        keyPlayerNames: keyPlayerNames,
        calledGame: dbMatch.calledGame,
        calledInning: dbMatch.calledInning,
        rivalryType: dbMatch.rivalryType || null,
        atmosphere_team1: dbMatch.atmosphere_team1 || null,
        atmosphere_team2: dbMatch.atmosphere_team2 || null,
        schedule: dbMatch.schedule || null,
        team1BallQuality: team1QualityText || "（打球品質データなし）",
        team2BallQuality: team2QualityText || "（打球品質データなし）",
        pitcherGamelogInfo: pitcherGamelogInfo,
        batterGamelogInfo: batterGamelogInfo,
        injuryReport: injuryReportText,
        prefecturalStatsText: prefecturalStatsText // ★ 修正されたテキスト
    };
    return context;
}

/**
 * [新ロジック] 前試合とのスタメンを比較し、「復帰」「初スタメン」「スタメン落ち」を分析する
 * @param {string} teamName - 分析対象のチーム名
 * @param {object} dbMatch - 現在の試合オブジェクト
 * @returns {string} - 変更点をまとめた短いテキスト (例: "鈴木がスタメン復帰、田中が今大会初スタメン")
 */
function analyzeLineupChanges(teamName, dbMatch) {
    const teamKey = dbMatch.team1 === teamName ? 'team1' : 'team2';
    if (!dbMatch.details || !dbMatch.details.batting || !dbMatch.details.batting[teamKey]) {
        return "比較データなし";
    }

    // 1. 現在のスタメンを取得
    const currentStarters = dbMatch.details.batting[teamKey]
        .filter(p => p.name && p.order && !p.order.toString().includes('sub'))
        .map(p => p.name);
    
    // 2. 「これまでの全試合」のスタメン履歴を取得
    const history = getStarterHistory(teamName, dbMatch.id);

    // 3. 履歴がない場合 (今大会初戦)
    if (history.length === 0) {
        return "今大会初スタメン。";
    }

    // 4. 履歴から「直前の試合のスタメン」と「過去に一度でもスタメンだったか」のリストを作成
    const lastGameStarters = new Set(history[history.length - 1].starters);
    const allPastStarters = new Set(history.flatMap(game => game.starters));

    const changes = [];

    // 5. 現在のスタメンを分析
    currentStarters.forEach(playerName => {
        if (!lastGameStarters.has(playerName)) {
            // 直前の試合にいなかった
            if (allPastStarters.has(playerName)) {
                // ...でも過去にはスタメンだった → 復帰
                changes.push(`${playerName}がスタメン復帰`);
            } else {
                // ...かつ過去にも一度もスタメンでない → 今大会初
                changes.push(`${playerName}が今大会初スタメン`);
            }
        }
    });

    // 6. 直前のスタメンを分析
    lastGameStarters.forEach(playerName => {
        if (!currentStarters.includes(playerName)) {
            // 直前の試合にいたのに、現在はいない → スタメン落ち
            changes.push(`${playerName}がスタメン落ち`);
        }
    });

    if (changes.length === 0) {
        return "前試合からスタメン変更なし。";
    }
    
    // 変更点を「復帰」→「初スタメン」→「落ち」の順に並べ替えて分かりやすくする
    changes.sort((a, b) => {
        if (a.includes('復帰')) return -1;
        if (b.includes('復帰')) return 1;
        if (a.includes('初スタメン')) return -1;
        if (b.includes('初スタメン')) return 1;
        return 0;
    });

    return `主な変更点: ${changes.join('、')}。`;
}
// ▲▲▲ 置き換えここまで ▲▲▲
/**
 * 打席結果の文字列を、シミュレーションで使える日本語とデータに変換する
 */
function translatePlay(atBatString) {
    if (!atBatString) return { description: "記録なし", type: "none", out: false, base: 0 };
    
    const s = atBatString;
    if (s.includes('本塁打')) return { description: `ホームラン`, type: "hr", out: false, base: 4 };
    if (s.includes('三塁打')) return { description: `三塁打`, type: "triple", out: false, base: 3 };
    if (s.includes('二塁打')) return { description: `二塁打`, type: "double", out: false, base: 2 };
    if (s.includes('安')) return { description: `ヒット`, type: "single", out: false, base: 1 };
    
    if (s.includes('四球') || s.includes('死球') || s.includes('敬遠')) return { description: `四死球`, type: "walk", out: false, base: 1 };
    if (s.includes('エラー') || s.includes('野選') || s.includes('犠失')) return { description: `エラー/野選`, type: "error", out: false, base: 1 };

    if (s.includes('犠飛')) return { description: `犠牲フライ`, type: "sac_fly", out: true, base: 0 };
    if (s.includes('犠打')) return { description: `犠牲バント`, type: "sac_bunt", out: true, base: 0 };
    if (s.includes('併殺')) return { description: `併殺打`, type: "dp", out: true, base: 0 }; // 2アウトは別途処理

    if (s.includes('三振')) return { description: `三振`, type: "so", out: true, base: 0 };

// ▼▼▼ この if ブロックをまるごと追加 ▼▼▼
    if (s.includes('邪')) return { description: `ファウルフライ`, type: "ff", out: true, base: 0 };
    // ▲▲▲ 追加ここまで ▲▲▲

    if (s.includes('ゴロ')) return { description: `ゴロ`, type: "go", out: true, base: 0 };
    if (s.includes('飛')) return { description: `フライ`, type: "fo", out: true, base: 0 };
    if (s.includes('直')) return { description: `ライナー`, type: "lo", out: true, base: 0 };
    
    return { description: `その他`, type: "other", out: false, base: 0 };
}

/**
 * 1イニング分の試合経過をシミュレートし、テキストを生成する
 */
function processHalfInning(dbMatch, teamKey, inningIndex, batterIndices) {
    let halfInningText = "";
    let outs = 0;
    let bases = [null, null, null]; // [1B, 2B, 3B]
    
    const battingOrder = dbMatch.details.batting[teamKey].filter(p => p.name).sort((a,b) => a.order - b.order);
    if (battingOrder.length === 0) return "";
    
    let batterIndex = batterIndices[teamKey];
    let atBatsInInning = 0;

    while (outs < 3) {
        const batter = battingOrder[batterIndex];
        const resultString = batter.results[inningIndex] || "";
        const atBatsForPlayer = resultString.split('、');

        // このイニングでこの打者がまだ打席に立っていない場合はループを抜ける
        if (atBatsForPlayer.length <= atBatsInInning) break; 
        
        const currentAtBatString = atBatsForPlayer[atBatsInInning];
        if(!currentAtBatString) break;

        const play = translatePlay(currentAtBatString);
        
        // 1. 打席結果をテキストに追加
        halfInningText += `${batter.order}番 ${batter.name} (${batter.pos}): ${play.description}\n`;

        // 2. アウトカウントを更新
        if(play.out) outs++;
        if(play.type === 'dp') outs++; // 併殺打

        if (outs >= 3) {
            halfInningText += `  → ${outs}アウト\n`;
            batterIndex = (batterIndex + 1) % battingOrder.length;
            break;
        }
        
        // 3. ランナーを進塁させる（簡易ロジック）
        const newBases = [null, null, null];
        let batterOnBase = false;

        // まずランナーを進める (3塁から)
        if (bases[2]) { // 3塁ランナー
            if (play.base >= 1 || play.type === 'sac_fly' || play.type === 'walk') newBases[2] = null; // 生還
            else newBases[2] = bases[2];
        }
        if (bases[1]) { // 2塁ランナー
            if (play.base >= 2) newBases[1] = null; // 生還
            else if (play.base === 1 || play.type === 'sac_bunt') newBases[2] = bases[1];
            else newBases[1] = bases[1];
        }
        if (bases[0]) { // 1塁ランナー
            if (play.base >= 3) newBases[0] = null; // 生還
            else if (play.base === 2) newBases[2] = bases[0];
            else if (play.base === 1 || play.type === 'sac_bunt' || play.type === 'walk') newBases[1] = bases[0];
            else newBases[0] = bases[0];
        }
        
        // 打者走者を塁に出す
        if (!play.out && play.base > 0) {
            newBases[play.base - 1] = batter.name;
        }

        bases = newBases;
        
        // 4. 現在の状況をテキストに追加
        const runners = [];
        if(bases[0]) runners.push("1塁");
        if(bases[1]) runners.push("2塁");
        if(bases[2]) runners.push("3塁");
        const runnerText = runners.length > 0 ? `ランナー${runners.join(', ')}` : "ランナーなし";
        halfInningText += `  → ${outs}アウト, ${runnerText}\n`;
        
        batterIndex = (batterIndex + 1) % battingOrder.length;
        atBatsInInning++;
    }

    batterIndices[teamKey] = batterIndex; // 次のイニングの先頭打者を記憶
    
    if (outs < 3) {
      halfInningText += `(${outs}アウトでイニング終了)\n`;
    }
    
    halfInningText += "チェンジ\n";
    return halfInningText;
}

/**
 * 全イニングの試合経過テキストを生成するマスター関数
 */
function generatePlayByPlayText(dbMatch) {
    if (!dbMatch || !dbMatch.details) return "詳細な試合データがありません。";

    let playByPlay = "";
    const numInnings = dbMatch.details.inningScore?.team1?.length || 9;
    // 各チームの次の先頭打者を記録するオブジェクト
    let batterIndices = { team1: 0, team2: 0 };

    for (let i = 0; i < numInnings; i++) {
        // 表の攻撃
        playByPlay += `\n【${i + 1}回表】${dbMatch.team1}の攻撃\n`;
        playByPlay += processHalfInning(dbMatch, 'team1', i, batterIndices);
        
        // サヨナラゲームの判定
        if (i >= 8) { // 9回表以降
            const score1 = (dbMatch.details.inningScore.team1 || []).slice(0, i + 1).reduce((a, b) => a + (b || 0), 0);
            const score2 = (dbMatch.details.inningScore.team2 || []).slice(0, i + 1).reduce((a, b) => a + (b || 0), 0);
            if (dbMatch.team2 === dbMatch.winner && score2 > score1) {
                 break;
            }
        }

        // 裏の攻撃
        playByPlay += `\n【${i + 1}回裏】${dbMatch.team2}の攻撃\n`;
        playByPlay += processHalfInning(dbMatch, 'team2', i, batterIndices);
    }

    playByPlay += "\n--- 試合終了 ---\n";
    return playByPlay;
}

/**
 * Finds a specific team's final result in the tournament.
 */
function getTeamFateSummary(teamName) {
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (match.winner && (match.team1 === teamName || match.team2 === teamName)) {
            if (match.winner !== teamName) {
                const opponent = match.winner;
                const score1 = match.team1 === teamName ? match.score1 : match.score2;
                const score2 = match.team1 === teamName ? match.score2 : match.score1;
                const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 1;
                return `${roundNum}回戦で${opponent}に${score1}-${score2}で敗退した。`;
            }
        }
    }
    
    // Check if the team is still in the tournament
    const isStillIn = Object.values(allMatches).some(match => !match.winner && (match.team1 === teamName || match.team2 === teamName));
    if(isStillIn) {
        return "まだ勝ち残っている。";
    }

    return "（今大会には出場していないか、情報がありません）";
}
   



/**
     * チームの紹介文を動的に生成する最終進化版。
     * TEAM_DATAの固定情報に、最新の成績情報を付け加える。
     * (★ チームの「通算」打率・盗塁数の集計を追加 ★)
     * @param {string} teamName - チーム名
     * @param {object} teamData - TEAM_DATAから取得したそのチームの基本情報
     * @param {object} teamRecord - tournamentState.teamRecordsから取得したそのチームの成績記録
     * @returns {string} - 生成された最新の紹介文
     */
    function generateDynamicTeamInfo(teamName, teamData, teamRecord) {
        if (!teamData) {
            console.error(`TEAM_DATAにチーム「${teamName}」が見つかりません。名前のタイプミスがないか確認してください。`);
            return `${teamName}のチーム情報が見つかりませんでした。`;
        }
        
        const baseInfo = teamData.info || `${teamName}の情報は不明です。`;

        // チームの成績記録がまだない（＝1年目の途中など）場合は、基本情報だけを返す
        if (!teamRecord || !teamRecord.history || teamRecord.history.length === 0) {
            return baseInfo;
        }

        const history = teamRecord.history;

        // --- ここからが追加情報の生成 ---
        let additionalNarrative = []; // 追加情報を入れる配列

        // 創部年数を計算 (2年目以降に意味を持つ情報)
        if (history.length > 0) {
            const establishedYear = history[history.length - 1].year;
            const yearsPassed = tournamentState.tournamentYear - establishedYear + 1;
            if (yearsPassed > 1) {
                additionalNarrative.push(`創部${yearsPassed}年目。`);
            }
        }
        
        // 直近の大会の成績
        const prevRankLabel = teamRecord.previousRank ? getRankString(teamRecord.previousRank) : null;
        if (prevRankLabel && prevRankLabel !== 'なし') {
            additionalNarrative.push(`前大会は${prevRankLabel}。`);
        }

        // 過去最高成績
        const bestFinishLabel = teamRecord.best?.rank ? getRankString(teamRecord.best.rank) : null;
        if (bestFinishLabel && bestFinishLabel !== 'なし') {
            additionalNarrative.push(`過去最高は${bestFinishLabel}。`);
        }

        // 称号（Traits）
        if (teamRecord.teamTraits && teamRecord.teamTraits.length > 0) {
            teamRecord.teamTraits.forEach(traitId => {
                const trait = Object.values(TITLES).find(t => t.id === traitId);
                if (trait) {
                    additionalNarrative.push(`「${trait.name}」。`);
                }
            });
        }

        // 今大会のチーム打率を追加
        const tourneyStats = teamRecord.tournamentStats;
        if (tourneyStats && tourneyStats.ab > 5) { 
            const avg = (tourneyStats.h / tourneyStats.ab).toFixed(3);
            additionalNarrative.push(`今大会のチーム打率は${avg}。`);
        }

        // ▼▼▼ このブロックをまるごと追加 ▼▼▼
        // (今大会とは別に)「通算」のチーム成績も集計
        const careerBattingStats = teamRecord.playerStats?.batting;
        if (careerBattingStats) {
            let totalCareerAb = 0;
            let totalCareerH = 0;
            let totalCareerSb = 0;
            
            for (const playerName in careerBattingStats) {
                const stats = careerBattingStats[playerName];
                totalCareerAb += stats.ab || 0;
                totalCareerH += stats.h || 0;
                totalCareerSb += stats.sb || 0; // ★通算盗塁を集計
            }

            if (totalCareerAb > 10) { // チーム通算打数がある程度ある場合
                const careerAvg = (totalCareerH / totalCareerAb).toFixed(3);
                // ★通算盗塁も情報に追加
                additionalNarrative.push(`(参考: チーム通算打率 ${careerAvg}, 通算 ${totalCareerSb} 盗塁)`); 
            }
        }
        // ▲▲▲ 追加ここまで ▲▲▲

        // --- 最終的な紹介文の組み立て ---
        if (additionalNarrative.length > 0) {
            return `${baseInfo} ${additionalNarrative.join(' ')}`;
        } 
        else {
            return baseInfo;
        }
    }
 
/**
 * 選手の出場形式コードを、記事で使える自然な日本語に変換する（翻訳機）
 * @param {object} player - 選手のデータオブジェクト
 * @returns {string} - 出場形式を説明する文章
 */
function getSubstitutionDescription(player) {
    // 交代選手でない（スタメン）場合は "スタメン出場" とする
    if (!player.sub_type) {
        return 'スタメン出場';
    }

    // sub_typeの値に応じて、返す文章を切り替える
    switch (player.sub_type) {
        case 'PH':
            return '代打で出場';
        case 'PR':
            return '代走で出場';
        case 'DEF':
            return '守備固めで出場';
        // ▼▼▼ ADD THIS CASE ▼▼▼
        case 'PITCHER': return 'リリーフとして登板';
        // ▲▲▲ END OF ADDITION ▲▲▲
        default:
            return '途中出場'; // 何らかの理由でsub_typeが上記以外の場合
    }
}

/**
 * 試合の個人成績をAIプロンプト用のテキスト形式にフォーマットする
 * (★選手の「今大会の通算成績」サマリーを追加した最終版)
 * @param {object} dbMatch - 試合オブジェクト
 * @returns {string} - フォーマットされたテキスト
 */
function formatPlayerStatsForPrompt(dbMatch) {
    if (!dbMatch || !dbMatch.details || !dbMatch.details.playerGameStats) {
        return '詳細な個人成績データはありません。';
    }

    const { details, winner } = dbMatch;

    const formatTeamStats = (teamKey) => {
        const teamName = dbMatch[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName]; 
        const isWinner = teamName === winner;
        const battingOrder = details.batting?.[teamKey] || [];
        const gameStats = details.playerGameStats?.[teamKey] || {};
        const pitchingData = details.pitching?.[teamKey] || [];

        let output = `\n**${teamName} (${isWinner ? '勝者' : '敗者'})**\n`;

        const sortedBatters = battingOrder.sort((a, b) => {
            const orderA = parseFloat(a.order.replace('-sub', '.'));
            const orderB = parseFloat(b.order.replace('-sub', '.'));
            return orderA - orderB;
        });

        sortedBatters.forEach(player => {
            if (!player.name) return;
            const stats = gameStats[player.name]; // この試合の成績
            
            // ★ (stats.played=true) だけでなく、盗塁(sb>0)や守備交代(DEF)なども含める
            const isNonBattingSub = player.sub_type === 'DEF' || player.sub_type === 'PR';
            if (!stats || (!stats.played && (stats.sb || 0) === 0 && !isNonBattingSub)) return; 

            const careerStats = teamRecord?.playerStats?.batting[player.name]; // 通算/Gamelog保持オブジェクト
            let statusText = "";
            if (careerStats && careerStats.narrative_flag) {
                const flagMap = {
                    "hot_streak": "絶好調", "powered_up": "一発警戒",
                    "clutch_hitter": "勝負強さ◎", "slumping": "不振"
                };
                statusText = ` (状態: ${flagMap[careerStats.narrative_flag] || careerStats.narrative_flag})`;
            }

            let batHandText = "";
            if (player.throwBat) {
                if (player.throwBat.endsWith('/R')) batHandText = "（右打）";
                else if (player.throwBat.endsWith('/L')) batHandText = "（左打）";
                else if (player.throwBat.endsWith('/S')) batHandText = "（両打）";
            }            

            // ★★★ ここからが修正箇所 ★★★
            // 選手の「今大会」の通算成績を Gamelog から集計する
            let tournamentTotalStatsText = "";
            if (careerStats && careerStats.gamelogs && careerStats.gamelogs.length > 0) {
                let tourneyStats = { sb: 0, hr: 0, h: 0, ab: 0 };
                const currentTournamentKey = tournamentState.currentTournament;
                
                careerStats.gamelogs.forEach(log => {
                    // このトーナメントのGamelogだけを抽出 (この試合(dbMatch.id)は除く)
                    const logRound = log.round || '';
                    let isInThisTournament = false;
                    if (currentTournamentKey === 'summer') isInThisTournament = logRound.includes('回戦') || logRound.includes('決勝');
                    else if (currentTournamentKey === 'autumn') isInThisTournament = logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                    else if (currentTournamentKey === 'spring') isInThisTournament = logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
                    
                    if (isInThisTournament && log.matchId !== dbMatch.id) { // この試合より「前」の成績
                        tourneyStats.sb += log.stats?.sb || 0;
                        tourneyStats.hr += log.stats?.hr || 0;
                        tourneyStats.h += log.stats?.h || 0;
                        tourneyStats.ab += log.stats?.ab || 0;
                    }
                });
                
                // 「この試合」の成績(stats)を加算
                const thisGameSB = stats.sb || 0;
                const thisGameHR = stats.hr || 0;
                
                const finalTourneySB = tourneyStats.sb + thisGameSB;
                const finalTourneyHR = tourneyStats.hr + thisGameHR;
                const finalTourneyH = tourneyStats.h + (stats.h || 0);
                const finalTourneyAB = tourneyStats.ab + (stats.ab || 0);
                const finalTourneyAvg = finalTourneyAB > 0 ? (finalTourneyH / finalTourneyAB).toFixed(3) : ".---";

                // AIに渡すためのテキストを作成
                tournamentTotalStatsText = ` (今大会: ${finalTourneyAvg}, ${finalTourneyHR}本, ${finalTourneySB}盗)`;
            }
            // ★★★ 修正ここまで ★★★

            const orderDisplay = player.order.includes('sub') ? `  - ${player.sub_type || '代'}` : `${player.order}.`;
            const playerIdentifier = `[#${player.number}] ${player.name}`; 
            
            const statsLine = `${stats.ab}打数${stats.h}安打 ${stats.rbi}打点` + 
                              (stats.hr > 0 ? ` ${stats.hr}本塁打` : '') + 
                              (stats.sb > 0 ? ` ${stats.sb}盗塁` : '');
            
            // ★ tournamentTotalStatsText を末尾に追加
            output += `${orderDisplay} ${playerIdentifier}${batHandText}${statusText}: ${statsLine}${tournamentTotalStatsText}\n`; 
        });
        
        pitchingData.forEach(pitcher => {
            // (投手成績のフォーマットは変更なし)
            if (!pitcher.name || !pitcher.innings) return;
            let statusText = "";
            const careerStats = teamRecord?.playerStats?.pitching[pitcher.name];
            if (careerStats && careerStats.narrative_flag) {
                 const flagMap = { "dominant": "圧巻", "seeking_redemption": "要修正", "tough_loss": "不運", "crafty_pitcher": "技巧派", "unlucky": "不運" };
                statusText = ` (状態: ${flagMap[careerStats.narrative_flag] || careerStats.narrative_flag})`;
            }
            let pitcherDesc = "";
            if (pitcher.throwBat) {
                if (pitcher.throwBat.startsWith('R')) pitcherDesc += "右";
                if (pitcher.throwBat.startsWith('L')) pitcherDesc += "左";
            }
            if (pitcher.throwStyle) {
                const styleMap = { "over": "オーバー", "three_quarter": "スリークォーター", "side": "サイド", "under": "アンダー" };
                pitcherDesc += `/${styleMap[pitcher.throwStyle] || pitcher.throwStyle}`;
            }
            if (pitcher.pitcherType) {
                const typeMap = { "honkaku": "本格派", "sokkyu": "速球派", "giko": "技巧派", "nanto": "軟投派" };
                pitcherDesc += `/${typeMap[pitcher.pitcherType] || pitcher.pitcherType}`;
            }
            if (pitcher.velocity) { pitcherDesc += `/${pitcher.velocity}`; }
            if (pitcherDesc) pitcherDesc = `（${pitcherDesc}）`;
            const pitcherData = sortedBatters.find(b => b.name === pitcher.name);
            const pitcherIdentifier = pitcherData ? `[#${pitcherData.number}] ${pitcher.name}` : pitcher.name;
            output += `- 投手: ${pitcherIdentifier}${pitcherDesc}${statusText} (${pitcher.innings}回 ${pitcher.runs}失点 ${pitcher.strikeouts}奪三振 ${pitcher.walks}四死球)\n`;
        });

        return output;
    };

    return formatTeamStats('team1') + formatTeamStats('team2');
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 試合の詳細データから、AIプロンプト用の個人成績ハイライトを生成する（★投手分析強化版）
 * @param {object} dbMatch - 試合オブジェクト
 * @returns {string} - "勝者・〇〇: 鈴木(4安打), 投手・田中(9回1失点, HQS達成). // 敗者・△△: ..."
 */
function extractKeyPerformances(dbMatch) {
    if (!dbMatch || !dbMatch.details || !dbMatch.details.playerGameStats) {
        return '詳細な個人成績データはありません。';
    }

    const { details, winner } = dbMatch;
    const winnerName = winner;
    const loserName = dbMatch.team1 === winner ? dbMatch.team2 : dbMatch.team1;

    const winnerKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
    const loserKey = dbMatch.team1 === loserName ? 'team1' : 'team2';

    const formatTeamPerformances = (teamKey) => {
        const teamName = dbMatch[teamKey];
        const performances = [];
        
        // 打撃成績の分析 (変更なし)
        const battingStats = details.playerGameStats?.[teamKey] || {};
        for (const playerName in battingStats) {
            const stats = battingStats[playerName];
            const playerHighlights = [];
            if (stats.h >= 3) playerHighlights.push(`${stats.h}安打`);
            if (stats.hr > 0) playerHighlights.push(`${stats.hr}本塁打`);
            if (stats.rbi >= 3) playerHighlights.push(`${stats.rbi}打点`);

            if (playerHighlights.length > 0) {
                const battingData = details.batting[teamKey].find(p => p.name === playerName);
                const order = battingData ? `${battingData.order}番` : '';
                performances.push(`${order}${playerName}(${playerHighlights.join(', ')})`);
            }
        }

        // ★★★ ここからが強化された投手分析ロジック ★★★
        const pitchingData = details.pitching?.[teamKey] || [];
        const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
        const opponentBattingData = details.batting?.[opponentTeamKey] || [];

        pitchingData.forEach(pitcher => {
            if (!pitcher.name) return;
            const pitcherHighlights = [];

            // 1. 基本的な投球結果を分析
            const innings = parseFloat(pitcher.innings || 0);
            const runs = parseInt(pitcher.runs || 0);
            const earnedRuns = parseInt(pitcher.earnedRuns || 0);
            const strikeouts = parseInt(pitcher.strikeouts || 0);
            const walks = parseInt(pitcher.walks || 0);
            const pitches = parseInt(pitcher.pitches || 0);

            // 従来の分析
            if (pitcher.result === 'W') {
                 if (innings >= 9 && earnedRuns === 0) pitcherHighlights.push('完封勝利');
                 else if (innings >= 9) pitcherHighlights.push('完投勝利');
            }
            if (strikeouts >= 10) pitcherHighlights.push(`${strikeouts}奪三振`);
            if (pitcher.result === 'L' && runs >= 5) pitcherHighlights.push(`${runs}失点炎上`);

            // 2. 新しい詳細分析
            if (pitches > 120) pitcherHighlights.push(`${pitches}球の熱投`);
            if (walks >= 5) pitcherHighlights.push(`与四球${walks}と制球難`);

            // 3. イニングごとの内容分析（主に先発投手を対象）
            if (innings >= 6 && opponentBattingData.length > 0) {
                let walksByInning = Array(9).fill(0);
                for (let i = 0; i < 9; i++) {
                    opponentBattingData.forEach(batter => {
                        const result = batter.results[i] || '';
                        if (result.includes('四球') || result.includes('死球')) {
                            walksByInning[i]++;
                        }
                    });
                }

                const earlyInningWalks = walksByInning.slice(0, 5).reduce((a, b) => a + b, 0);
                const lateInningWalks = walksByInning.slice(5, 9).reduce((a, b) => a + b, 0);

                if (lateInningWalks > earlyInningWalks && lateInningWalks >= 3) {
                    pitcherHighlights.push('終盤に制球を乱した');
                } else if (innings >= 7 && earnedRuns <= 2 && pitcher.result !== 'L') {
                    // 良い内容だった場合の評価
                    pitcherHighlights.push('試合を作った'); 
                }
            }
            
            if (pitcherHighlights.length > 0) {
                performances.push(`投手・${pitcher.name}(${pitcherHighlights.join(', ')})`);
            }
        });
        // ★★★ 投手分析ロジックはここまで ★★★

        return performances.length > 0 ? `${teamName}: ${performances.join(', ')}` : '';
    };

    const winnerPerf = formatTeamPerformances(winnerKey);
    const loserPerf = formatTeamPerformances(loserKey);

    return [winnerPerf, loserPerf].filter(Boolean).join(' // ');
}
/**
 * 密着取材型記者「羽田 雄平」のコラム記事を生成する
 * (★シードランク認識 最終版)
 * (★★ 故障者リスト(injuryReport)と「重要度」への言及をAIに指示するよう修正 ★★)
 */
async function generateHadaReport(matchContext) {
    // --- 1. contextから必要な情報を取り出す ---
    const { 
        winnerName, loserName, dbMatch, matchId, 
        playerStatsText, highlights, nextOpponent,
        injuryReport // ★ 故障者リスト
    } = matchContext;

    const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const winnerData = TEAM_DATA[winnerName];
    const loserData = TEAM_DATA[loserName];
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);

    const winnerSeedRank = getSeedRankString(winnerName, tournamentState.seeds);
    const loserSeedRank = getSeedRankString(loserName, tournamentState.seeds);
    
    let roundName = getRoundNameFromMatchId(matchId);

    let nextOpponentText = '次戦の相手はまだ決まっていません。';
    if (nextOpponent) {
        if (nextOpponent.opponentName === '優勝') {
            nextOpponentText = (tournamentState.currentTournament === 'summer')
                ? '夏の甲子園出場が決定しました。'
                : '今大会、見事優勝を果たしました。';
        }
        else if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            const nextOpponentSeed = getSeedRankString(nextOpponent.opponentName, tournamentState.seeds);
            const rankText = nextOpponent.opponentRank ? `(${nextOpponent.opponentRank}ランク)` : '';
            nextOpponentText = `次戦は${nextOpponent.roundName}、${nextOpponent.opponentName}${nextOpponentSeed}${rankText}と対戦します。`;
        }
        else if (nextOpponent.decidingMatch) {
            const dm = nextOpponent.decidingMatch;
            nextOpponentText = `次戦は${nextOpponent.roundName}、${dm.team1}と${dm.team2}の勝者と対戦します。`;
        }
    }
    
    const highlightsText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');

    let scheduleText = '';
    let scheduleInstruction = '';
    if (matchContext.schedule) {
        const sched = matchContext.schedule;
        const team1Region = TEAM_DATA[dbMatch.team1]?.region || '不明';
        const team2Region = TEAM_DATA[dbMatch.team2]?.region || '不明';
        
        scheduleText = `\n- **試合会場:** ${sched.stadiumFull} (${sched.region}地区)\n`;
        
        if (sched.region === team1Region && sched.region !== team2Region) {
            scheduleText += `- **地の利:** ${dbMatch.team1}にとって地元球場での試合。`;
            scheduleInstruction = `**【地の利の分析】**: ${dbMatch.team1}にとって「地元球場」であったことが、試合にどう影響したか（例：大応援団の後押し、慣れたマウンドなど）を、あなたの視点で分析してください。`;
        } else if (sched.region !== team1Region && sched.region === team2Region) {
            scheduleText += `- **地の利:** ${dbMatch.team2}にとって地元球場での試合。`;
            scheduleInstruction = `**【地の利の分析】**: ${dbMatch.team2}にとって「地元球場」であったことが、試合にどう影響したか（例：大応援団の後押し、慣れたマウンドなど）を、あなたの視点で分析してください。`;
        }
    }
    let ballQualityText = '';
    if (matchContext.team1BallQuality && matchContext.team2BallQuality) {
        ballQualityText = `\n### データ5：チーム別 打球品質レポート\n- ${matchContext.team1BallQuality}\n- ${matchContext.team2BallQuality}\n`;
    }

    // ▼▼▼ 4. AIへのプロンプト（指示書）を修正 ▼▼▼
    const prompt = `あなたは「東海スポーツ」所属のスポーツライター「羽田 雄平」です。
あなたは今、${roundName}「${winnerName} vs ${loserName}」の試合を取材し終え、興奮冷めやらぬまま署名入りのコラム記事を執筆しています。
以下のデータに基づき、あなたの主観と分析を交えた「羽田 雄平スタイル」のナラティブな記事を生成してください。

### 参考情報：静岡県高校野球の「常識」（勢力図）
${PREFECTURE_LORE}
---
### 羽田 雄平の取材メモ
- **大会:** ${tournamentState.tournamentYear}年度 ${tournamentNameMap[tournamentState.currentTournament]} ${roundName}
- **対戦カード:** ${winnerName} ${winnerSeedRank} (ランク: ${winnerRank}) vs ${loserName} ${loserSeedRank} (ランク: ${loserRank})
- **結果:** ${winnerScore} - ${loserScore} で ${winnerName} が勝利。
${scheduleText} 
- **${winnerName}の背景:** ${winnerData.info}
- **${loserName}の背景:** ${loserData.info}
- **試合の決め手(ユーザー入力):** ${dbMatch.summary || '特になし'}
- **次の試合:** ${nextOpponentText}
${injuryReport || ''}

### データ1：試合の主な出来事 (ハイライト)
${highlightsText}

### データ2：主な選手の個人成績 (ボックススコア)
${playerStatsText} 

### データ3：今大会の主な投手登板履歴 (この試合より前)
${matchContext.pitcherGamelogInfo || '今大会、これが初登板です。'}

### データ4：今大会の主な打者成績履歴 (この試合より前)
${matchContext.batterGamelogInfo || '打者の試合履歴データはありません。'}
${ballQualityText}

### 執筆指示
1.  **一人称で書く:** 必ず「私」を主語にし、個人的な感想（～驚きました、～でしょうね）を交えてください。
2.  **現場の空気感:** 試合当日の球場の雰囲気（観客の多さ、天候など）を描写してください。
    ${scheduleInstruction}
3.  **両チームの紹介:** 両チームの背景（「王者」「進学校」など）を紹介し、試合の位置づけを明確にしてください。
4.  **【★シードランク言及】**: **「第1シードの〇〇」**や**「シード校の△△が苦戦」**のように、シードランクにも具体的に言及し、試合の文脈を明確にしてください。
5.  **【★★ 欠場者への言及 (最重要) ★★】**: 取材メモの「主な欠場者」(${injuryReport})に選手名（例：〇〇 [🏥] (主力), △△ [🩹] (控え)）が記載されている場合、その選手の**重要度（主力か控えか）**に応じて、あなたの分析（深刻度）を変えてください。（例：『やはりエース姫川(主力)の不在が響いた』『〇〇(控え)が万全の状態なら...』）
6.  **【囲み取材】**: 記事の本文中に、あなたが試合後に直接取材した選手（例：ヒーローとなった〇〇くんや、敗れた△△くん）の**「生々しいコメント」**を必ず含めてください。
7.  **ターニングポイントの特定:** 試合が動いたイニング（例：3回）やプレーを特定し、そこを詳細に描写してください。
8.  **選手への言及**: 「データ2」の選手名を引用し、「〇〇くん」と呼称してください。**もしその選手の背番号（[#X]）が戦術や物語の上で重要だとあなたが判断した場合**、その背番号にも触れてください。#は背番号と言い換えてください。(例S1→背番号1)
9.  **【投手の詳細分析】**: 「データ2（ボックススコア）」に記載されている**投手の詳細属性（例：右/オーバー/本格派/150km帯）**にも注目し、その投手のタイプが試合にどう影響したかを分析してください。
10. **試合後の情報:** 試合後の選手のコメント（例：「コントロールを重視した」）を（架空で）挿入してください。
11. **次戦への言及:** 記事の最後に、次の対戦相手（${nextOpponentText}）に触れて締めくってください。
12. **【選手の背景創作】**: もし詳細な選手プロフィールがない無名の選手について書く場合、あなたが長年の取材でその選手を知っているという記者視点で、**それらしい架空の経歴や特徴を自由に付け加えてください。**
13. **【常識の反映】**: あなたが熟知している「常識」（例：ナムコグループの台頭、公立の砦・静岡の苦戦）を、目の前の試合結果と関連付けて分析してください。
14. **【打球の質の分析】**: 「データ1（ハイライト）」や「データ2（ボックススコア）」、「データ5（打球品質レポート）」にある**打球の質**（「鋭い当たり」「詰まった当たり」など）を重視し、結果と内容が一致しない（例：4タコだが全部鋭い当たり）選手の評価にも言及してください。
15. **【打順の役割】**: **打順の役割**も重視してください。4番が4番の仕事をしたのか、あるいは9番が意外な活躍でラッキーボーイとなったのか、といった戦術的な分析をコラムに含めてください。
16. **【投手の左右】**: ボックススコアに「（右腕）」「（左腕）」の表記がある場合、それを記事に反映させること。
17. **【★注目の打席（最重要）】**:
        - 「データ1（ハイライト）」に「（★注目）」というマークが付いている打席があります。これは**ユーザー（監督）が『試合の分水嶺』だと判断した**、最も重要な打席です。
        - あなたのコラムでは、**この記事の中心的なハイライト**として、この「★注目」の打席の前後を、最もドラマチックに描写してください。
18. **【★盗塁への言及 (重要)】**:
    - 「データ2（ボックススコア）」に**盗塁(SB)**が記録されている選手がいた場合、その選手の機動力（例：「〇〇が足でチャンスを広げ」）に言及してください。
    - さらに、その選手の**「今大会の通算盗塁数」**（例：(今大会: ... 4盗)）も必ず参照し、**「〇〇はこれで今大会4個目の盗塁。彼の足は本物だ」**といった具体的な数字を記事に含めてください。
    - **盗塁が0だった場合、それについて批判的な言及（例：「なぜ走らない」）は不要です。**
19.  **【★スタメン復帰】**: 「スタメン変更」情報（取材メモ外の別データとして提供）に「〇〇がスタメン復帰」とあった場合、**「監督の賭けが当たった」**という視点で、その選手の活躍（あるいは不振）をあなたの主観で分析してください。
20. **【連投・酷使の分析】**: 「データ3：登板履歴」を見て、もし投手が「連投」や「中1日」であったり、今大会で「投げすぎ（酷使）」の状態であったりした場合、それが今日の投球にどう影響したか、あなたの鋭い視点で分析してください。（例：「昨日120球を投げた腕で、今日も140km/hを計測するとは…彼の肩は一体どうなっているんだ」）
21. **【雪辱と真価】**: もし投手が「登板履歴」で「前回炎上」していた場合、今日の投球が「雪辱」のマウンドであったことに触れてください。逆に、これまで「格下相手」にしか投げていなかった場合、今日の試合が「真価を問うマウンド」であったと分析してください。
22. **【★打者の好不調の波】**: 「データ4：打者成績履歴」を熟読し、選手の**連続ヒット**や**連続無安打**の「波」に言及してください。（例：「1回戦で4タコだった〇〇くんが、今日はまるで別人のようだった」「△△くんはこれで3試合連続ヒット。完全に掴んだようだね」）
23. **【★打者の役割分析】**: もし選手が**「代打」**で結果を出し続けていたり、**「打順変更」**で調子を上げていたりする場合、その采配と選手の適応力をあなたの視点で分析してください。
### 出力形式【厳守】
- **【最重要】** あなたの応答は、必ず単一のJSONオブジェクト"のみ"でなければなりません。
- **絶対に**、JSONの前後に「はい、記事です」や「\`\`\`json」などのテキストを付け加えてはいけません。
{"title": "（例：王者283学園、圧巻のコールド発進！ 羽田雄平が見た『格の違い』）", "body": "（ここに羽田 雄平スタイルの記事本文）"}
`;

    // --- 5. AIへのリクエスト ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
            const rawTextFromAi = result.candidates[0].content.parts[0].text;
            const article = parseJsonFromText(rawTextFromAi);
            
            if (article && article.title && article.body) {
                article.body += "\n\n　東海スポーツ　羽田雄平";
                return { 
                    ...article, 
                    timestamp: Date.now(), 
                    context: matchContext, 
                    isHadaReport: true 
                };
            } else {
                 console.error("parseJsonFromText failed for HadaReport:", rawTextFromAi);
                 throw new Error("AI response format error after parsing (HadaReport).");
            }
        } else {
             console.error("Unexpected AI response structure (HadaReport):", result);
             throw new Error("AI response structure is missing expected parts (HadaReport).");
        }
    } catch (error) {
        console.error("羽田レポートの生成に失敗しました:", error);
        return { 
            title: "羽田コラム 生成エラー", body: "羽田記者が取材中に負傷したため、記事を生成できませんでした。", 
            timestamp: Date.now(), error: true, errorId: `hada-${matchId}`,
            context: matchContext 
        };
    }
}

// ▼▼▼ 因縁相関図 生成ロジック (AI解説機能付き・改) ▼▼▼

document.getElementById('show-rivalry-map-btn').addEventListener('click', async () => {
    document.getElementById('rivalry-map-modal').classList.remove('hidden');
    document.getElementById('rivalry-map-modal').classList.add('flex');
    await generateRivalryMap(); // モーダル表示後に生成開始
});

document.getElementById('rivalry-map-close-btn').addEventListener('click', () => {
    document.getElementById('rivalry-map-modal').classList.add('hidden');
    document.getElementById('rivalry-map-modal').classList.remove('flex');
});

/**
 * 現在のデータ、常識、そして「偏差値」や「系列」から相関図を生成する
 */
async function generateRivalryMap() {
    const container = document.getElementById('mermaid-container');
    const analysisContainer = document.getElementById('rivalry-analysis-content');
    
    container.innerHTML = '<div class="loader">県内の勢力図を広域スキャン中...</div>';
    analysisContainer.innerHTML = '<div class="loader">AI記者が勢力図を分析中...</div>';

    // --- 1. Mermaid記法のヘッダー ---
    let graphDef = "graph TD\n";
    
    // クラス定義 (色分け)
    graphDef += "classDef rankA fill:#fee2e2,stroke:#ef4444,stroke-width:3px,color:#000;\n"; // 赤 (Aランク)
    graphDef += "classDef rankB fill:#e0f2fe,stroke:#3b82f6,stroke-width:2px,color:#000;\n"; // 青 (Bランク)
    graphDef += "classDef rankC fill:#fef9c3,stroke:#eab308,stroke-width:2px,color:#000;\n"; // 黄 (Cランク)
    graphDef += "classDef namco fill:#f3e8ff,stroke:#9333ea,stroke-width:2px,color:#000;\n"; // 紫 (ナムコ系列)
    graphDef += "classDef normal fill:#fff,stroke:#9ca3af,stroke-width:1px,color:#000;\n";   // 白 (その他)

    // --- 2. ノードとエッジの収集 ---
    const nodes = new Set();
    const edges = [];
    const namcoSchools = ["283学園", "765総合高校", "初星学園", "美城学園", "283学園B"];

    // Helper: エッジ追加 (重複防止はMermaid側で処理されるが念のため)
    const addEdge = (t1, t2, label, style = '---') => {
        if (t1 === t2) return;
        nodes.add(t1); nodes.add(t2);
        edges.push(`${t1} ${style}|${label}| ${t2}`);
    };

    // (A) 固定ライバル関係 (RIVALRIES)
    tournamentState.rivalries.forEach(r => {
        if (r.teams.length >= 2) addEdge(r.teams[0], r.teams[1], r.type, '<-->');
    });

    // (B) 動的因縁 (feuds)
    if (tournamentState.feuds) {
        tournamentState.feuds.forEach(f => {
            if (f.teams.length >= 2) addEdge(f.teams[0], f.teams[1], f.type, '-.->');
        });
    }

    // (C) 直近の「番狂わせ」や「天敵」関係
    const strongTeams = Object.keys(tournamentState.teamRecords).filter(t => ['A', 'B'].includes(calculateRank(t, tournamentState)));
    strongTeams.forEach(teamA => {
        const history = getRecentMatchesForTeam(teamA, 10);
        history.forEach(match => {
            if (!match.isWin && ['C', 'D', 'E'].includes(calculateRank(match.opponent, tournamentState))) {
                addEdge(match.opponent, teamA, '金星', '==>');
            }
        });
    });

    // --- ★ここから拡張: まだ対戦していなくても表示する ---

    // (D) ナムコグループの結束
    // 283学園を中心に、他の系列校をつなぐ
    const mainNamco = "283学園";
    namcoSchools.forEach(school => {
        if (school !== mainNamco && tournamentState.teamRecords[school]) { // 存在確認
            addEdge(mainNamco, school, '系列', '-.-');
        }
    });

    // (E) 各地区の「3強」を強制的に表示し、ライバル線で結ぶ
    const regions = ['東部', '中部', '西部']; // 伊豆は東部に含む場合が多いが、データによっては独立
    const teamsByRegion = { '東部': [], '中部': [], '西部': [], '伊豆': [] };

    // 全チームを地区分けしてソート
    Object.keys(TEAM_DATA).forEach(teamName => {
        const data = TEAM_DATA[teamName];
        if (data.region && teamsByRegion[data.region]) {
            // ソート用スコア: ランクが高い順 > 偏差値が高い順
            const rank = calculateRank(teamName, tournamentState);
            const rankVal = {'A':5, 'B':4, 'C':3, 'D':2, 'E':1}[rank] || 0;
            const score = rankVal * 100 + (data.deviation || 50);
            
            teamsByRegion[data.region].push({ name: teamName, score: score });
        }
    });

    // 各地区の上位3校を抽出し、1位vs2位、2位vs3位をつなぐ
    Object.keys(teamsByRegion).forEach(region => {
        // スコア順にソート
        const sortedTeams = teamsByRegion[region].sort((a, b) => b.score - a.score);
        const top3 = sortedTeams.slice(0, 3).map(t => t.name);

        if (top3.length >= 2) {
            addEdge(top3[0], top3[1], `${region}の覇権`, '---');
        }
        if (top3.length >= 3) {
            addEdge(top3[1], top3[2], `上位争い`, '---');
        }
        // ノードとして追加（線がなくても重要校は表示）
        top3.forEach(t => nodes.add(t));
    });

    // (F) Aランク校は無条件で全員表示（孤立していてもOK）
    Object.keys(tournamentState.teamRecords).forEach(teamName => {
        if (calculateRank(teamName, tournamentState) === 'A') {
            nodes.add(teamName);
        }
    });

    // --- 3. ノード定義 (スタイル適用) ---
    nodes.forEach(team => {
        const rank = calculateRank(team, tournamentState);
        let styleClass = "normal";
        
        if (namcoSchools.includes(team)) styleClass = "namco";
        else if (rank === 'A') styleClass = "rankA";
        else if (rank === 'B') styleClass = "rankB";
        else if (rank === 'C') styleClass = "rankC";
        
        graphDef += `${team}((${team})):::${styleClass}\n`;
    });

    // --- 4. エッジ定義 ---
    // 重複エッジを削除するためにSetを使う
    const uniqueEdges = [...new Set(edges)];
    uniqueEdges.forEach(edge => { graphDef += `${edge}\n`; });

    if (uniqueEdges.length === 0 && nodes.size === 0) {
        container.innerHTML = "<p class='text-gray-500'>データがありません。</p>";
        analysisContainer.innerHTML = "";
        return;
    }

    // --- 5. レンダリング実行 ---
    try {
        container.innerHTML = `<div class="mermaid">${graphDef}</div>`;
        await mermaid.run({ nodes: container.querySelectorAll('.mermaid') });
    } catch (e) {
        console.error("Mermaid rendering failed:", e);
        container.innerHTML = "<p class='text-red-500'>図の描画に失敗しました。</p>";
    }

    // --- 6. AIによる分析レポート ---
    const displayedTeams = Array.from(nodes);
    const prompt = `あなたは高校野球の事情通記者です。
県内の有力校やライバル関係をまとめた「勢力図（相関図）」が完成しました。
この図に登場する主なチーム（${displayedTeams.slice(0, 10).join(', ')}など）を見て、
**「現在の県内のパワーバランス」**や**「注目すべき対立構図」**について、300文字程度のコラムを書いてください。
特に、地区ごとの覇権争いや、ナムコ系列校の存在感について触れてください。

### 出力形式 (JSON)
{"body": "（コラム本文）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const aiData = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (aiData && aiData.body) {
                analysisContainer.innerHTML = `<p>${aiData.body.replace(/\n/g, '<br>')}</p>`;
            }
        }
    } catch (error) {
        console.error("AI勢力図分析エラー:", error);
        analysisContainer.innerHTML = "<p class='text-red-500'>AI分析の生成に失敗しました。</p>";
    }
}
// ▲▲▲ 因縁相関図 生成ロジック (拡張版) ここまで ▲▲▲

/**
 * [UPDATED v3] 283学園戦専用：編集部・栗山氏風スカウティングレポートを生成する
 * (★主力、脇役、敵チームの好選手を書き分ける玄人視点版)
 */
async function generateKuriyamaReport(matchContext) {
    const { winnerName, loserName, dbMatch, matchId, nextOpponent } = matchContext;

    const myTeam = "283学園";
    const isWin = (winnerName === myTeam);
    const score = `${dbMatch.score1}-${dbMatch.score2}`;
    const roundName = getRoundNameFromMatchId(matchId);

    const winnerInfo = TEAM_DATA[winnerName]?.info || "";
    const loserInfo = TEAM_DATA[loserName]?.info || "";
    
    let nextGameText = "";
    if (isWin && nextOpponent) {
        if (nextOpponent.opponentName === '優勝') nextGameText = "優勝";
        else if (nextOpponent.opponentName) nextGameText = `次戦の相手は${nextOpponent.opponentName}`;
    }

    // 選手情報を詳細に抽出するヘルパー
    const getPlayerInfoDetailed = (teamName, teamKey) => {
        const gameStats = dbMatch.details?.playerGameStats?.[teamKey] || {};
        const battingDetails = dbMatch.details?.batting?.[teamKey] || [];
        const pitchingDetails = dbMatch.details?.pitching?.[teamKey] || [];
        const roster = TEAM_ROSTER_MASTER[teamName] || []; // 283学園用静的データ
        
        let infoList = [];

        // 出場した全選手をチェック
        for (const [name, stats] of Object.entries(gameStats)) {
            // 最低限の出場がある選手のみ
            if ((stats.pa && stats.pa > 0) || (stats.ip && parseFloat(stats.innings) > 0)) {
                
                // 打順と守備位置を取得
                const bDetail = battingDetails.find(p => p.name === name);
                const order = bDetail ? bDetail.order : "-";
                const pos = bDetail ? (bDetail.currentPos || bDetail.pos) : "-";
                
                // 出身データ (283学園のみ)
                const staticData = roster.find(p => p.name === name);
                const origin = staticData?.origin ? `(${staticData.origin})` : "";

                // 成績概要
                let perf = "";
                if (stats.h > 0) perf += `${stats.h}安打 `;
                if (stats.hr > 0) perf += `${stats.hr}HR `;
                if (stats.rbi > 0) perf += `${stats.rbi}打点 `;
                if (stats.ip) perf += `投${stats.innings}回${stats.earnedRuns}自責 `;
                
                // 属性判定 (AIへのヒント)
                let role = "脇役";
                if (pos === "投" || (order.match(/^[345]$/))) role = "主力";
                
                infoList.push(`- ${name}${origin} [${role}/打順${order}/守備${pos}]: ${perf}`);
            }
        }
        return infoList.join("\n");
    };

    const teamKey283 = (dbMatch.team1 === "283学園") ? 'team1' : 'team2';
    const teamKeyOpp = (teamKey283 === 'team1') ? 'team2' : 'team1';
    const opponentTeamName = (dbMatch.team1 === "283学園") ? dbMatch.team2 : dbMatch.team1;

    const data283 = getPlayerInfoDetailed("283学園", teamKey283);
    const dataOpp = getPlayerInfoDetailed(opponentTeamName, teamKeyOpp);

    const prompt = `あなたは高校野球雑誌「静岡高校野球」の編集部員・栗山です。
今日行われた${roundName}「${winnerName} 対 ${loserName}」の取材メモを元に、**あなた独特の文体（栗山節）**で、マニアックな視点の「スカウティングレポート（ブログ記事）」を執筆してください。

### 試合概要
- 結果: ${winnerName} ${score} ${loserName}
- チーム背景: [勝]${winnerInfo} / [負]${loserInfo}
- ${nextGameText}

### 選手データ（取材メモ）
**【283学園】**
${data283}

**【${opponentTeamName}】**
${dataOpp}

### 執筆指示（以下の3点を必ず盛り込むこと）
1.  **主力で気になった選手（283学園）**: 
    - チームの中心選手（投手やクリーンナップ）から1名選び、その活躍や成長ぶりを評価してください。
    - 「〇〇シニア時代からの成長」や「ボールの押し込みが強くなった」など、継続して見ている記者らしい表現を使ってください。
2.  **脇役だが輝いていた選手（283学園）**: 
    - **下位打線、守備職人、控え選手**などから、「いぶし銀」の活躍をした選手を1名見つけてください。
    - 派手な成績でなくても構いません。「体の軸がブレない」「守備の一歩目が速い」「スイングの軌道が良い」など、**玄人好みのポイント**を絶賛してください。
3.  **相手チームの好選手**: 
    - 相手チーム（${opponentTeamName}）から、将来性を感じた選手を1名挙げてください。
    - 負けたチームであっても、「素材は一級品」「このストレートはえぐかった」「体ができてくれば面白い」と、リスペクトを込めて評価してください。相手の出身中学などは**架空で創作**して補完してください（例：「〇〇中学時代は軟式で...」）。

### 栗山氏の文体
- 「～を見てきました。」「～が気になりました。」「～だと思いました。」という、丁寧だが熱量のある語り口。
- 選手をフルネーム（または苗字）で呼び、技術的なディテール（ヒジの使い、下半身の粘り等）に言及する。
- 最後は「（編集部・栗山）」で締める。

### 出力形式 (JSON)
{"title": "【編集部・栗山】${roundName}取材記：${winnerName}対${loserName}", "body": "（記事本文）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                return { 
                    ...article, 
                    timestamp: Date.now(),
                    isScoutReport: true,
                    context: matchContext
                };
            }
        }
        return null;
    } catch (error) {
        console.error("スカウティングレポート生成エラー:", error);
        return null;
    }
}

/**
 * AI記者にニュース記事を執筆させるメイン関数
 * (★「isNewspaperWorthy」のバグを修正し、R4以降のみ新聞ボタンを表示)
 * (★★ 故障者リスト(injuryReport)への言及をAIに指示するよう修正)
 * (★★★ 軽傷(🩹)選手と「重要度」への言及を指示するよう修正 ★★★)
 */
async function generateNewsArticle(matchContext, userFeedback = null) {
    const {
        winnerName, loserName, dbMatch, matchId,
        winnerData, loserData, winnerDetailedData, loserDetailedData,
        winnerLineupChanges, loserLineupChanges,
        winnerJourney, loserJourney,
        nextOpponent, pitcherGamelogInfo, batterGamelogInfo,
        injuryReport // ★ 故障者リスト
    } = matchContext || {};
    

// ▼▼▼ 追加: 両チームのキャプテンを特定する ▼▼▼
    const getCaptainName = (teamName) => {
        const record = tournamentState.teamRecords[teamName];
        if (!record || !record.roster) return "主将";
        const captain = record.roster.find(p => p.isCaptain);
        return captain ? captain.name : "主将";
    };

    const winnerCaptainName = getCaptainName(winnerName);
    const loserCaptainName = getCaptainName(loserName);
    // ▲▲▲ 追加ここまで ▲▲▲

    let prompt = '';
    
    const tournamentName = tournamentNameMap[tournamentState.currentTournament] || '大会';
    const tournamentYear = tournamentState.tournamentYear;
    let tournamentContextPrompt = "";
    let seedContext = "前大会ベスト8";
    if (tournamentState.currentTournament === 'summer') {
        tournamentContextPrompt = "3年生にとっては最後の夏であり、甲子園出場をかけた最も熱い戦いです。";
    } else if (tournamentState.currentTournament === 'autumn') {
        tournamentContextPrompt = "1,2年生による新チームが始動する最初の公式戦であり、来春のセンバツ出場校選考にも影響する重要な大会です。";
    } else if (tournamentState.currentTournament === 'spring') {
        tournamentContextPrompt = "春のセンバツ（選抜）出場校も決まり、夏の大会のシード権をかけた前哨戦です。";
        seedContext = "前回の秋季大会ベスト8";
    }

    // --- 1. 大会展望記事の生成ロジック ---
    if (matchId === 'preview') {
        // (展望記事ロジックは変更なし)
        const { seeds, teams } = tournamentState;
        const blockAnalyses = [];
        const numBlocks = 4; const blockSize = 32;
        const getTeamRank = (teamName) => calculateRank(teamName, tournamentState);
        for (let i = 0; i < numBlocks; i++) {
            const blockName = String.fromCharCode(65 + i);
            const start = i * blockSize; const end = (i + 1) * blockSize;
            const blockTeams = teams.slice(start, end);
            if (blockTeams.length === 0) continue;
            const promisingInBlock = blockTeams.filter(team => {
                const rank = getTeamRank(team);
                return seeds.some(s => s.team === team) || ['A', 'B'].includes(rank);
            }).map(team => `${team} ${getSeedRankString(team, seeds)}`);
            blockAnalyses.push(`- ${blockName}ブロック (${blockTeams.length}校): ${promisingInBlock.join(', ')}`);
        }
        const blockAnalysis = blockAnalyses.join('\n');
        let notablePlayersText = '';
        const promisingSchools = teams.filter(team => {
            const rank = getTeamRank(team);
            return seeds.some(s => s.team === team) || ['A', 'B'].includes(rank);
        });
        const notablePlayers = promisingSchools.filter(team => DETAILED_TEAM_DATA[team]);
        if (notablePlayers.length > 0) {
            notablePlayersText += '### 今大会の注目選手\n';
            notablePlayers.forEach(team => {
                const players = DETAILED_TEAM_DATA[team]?.players.slice(0, 2) || [];
                notablePlayersText += `- **${team}**: ${players.map(p => `${p.name}(${p.year}年)`).join(', ')}\n`;
            });
        }
        const seedText = seeds.map(s => `${s.team}(第${s.rank}シード)`).join(', ');
        prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。
間もなく開幕する「${tournamentYear}年度 ${tournamentName}」の展望記事を作成してください。
### 大会の文脈 (最重要)
${tournamentContextPrompt}
シード校は「${seedContext}」の8校です。
### 参考情報：静岡県高校野球の「常識」（勢力図）
${PREFECTURE_LORE}
---
### シード校 (前大会ベスト8)
${seedText}
### 各ブロックの有力校
${blockAnalysis}
${notablePlayersText}
### 執筆指示
- 【★大会の文脈を反映】: 記事全体で、${tournamentName}ならではの視点（例：夏の3年生の想い、秋の新チームの試金石、春のシード権争い）を必ず反映させてください。
- 【★シードランク言及】: 「第1シードの〇〇」や「前大会ベスト8の△△」のように、シードランクにも触れて分析してください。
- どのシード校が最も厳しいブロックに入ったか、逆に最も楽なブロックはどこかを分析してください。
- ノーシードの実力校の中から、大会の「ダークホース」となりそうなチームを挙げてみてください。
- 記事のタイトルと本文をJSON形式で出力してください。
### 出力形式
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
                if (article) return { ...article, timestamp: Date.now() };
            }
            throw new Error("AI preview response format error.");
        } catch (error) {
            console.error("AI preview article generation failed:", error);
            return { title: "展望記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true, errorId: `preview-${Date.now()}` };
        }
    }

    // --- 2. 試合後記事の生成ロジック ---
    const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
    const loserRank = calculateRank(loserName, tournamentState);
    const loserRankDesc = getRankDescription(loserRank);
    const winnerSeedRank = getSeedRankString(winnerName, tournamentState.seeds);
    const loserSeedRank = getSeedRankString(loserName, tournamentState.seeds);
    const winnerRecord = tournamentState.teamRecords[winnerName];
    const loserRecord = tournamentState.teamRecords[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, winnerRecord);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, loserRecord);
    const winnerCoach = winnerData.coach;
    const loserCoach = loserData.coach;
    const roundName = getRoundNameFromMatchId(matchId); 
    
    let nextOpponentText = '次の対戦相手は未定。'; 
    if (nextOpponent) {
        if (nextOpponent.opponentName === '優勝') {
            nextOpponentText = (tournamentState.currentTournament === 'summer')
                ? '夏の甲子園出場が決定した。'
                : (tournamentState.currentTournament === 'autumn' ? 'センバツ出場が有力となった。' : '今大会、見事優勝を果たした。');
        }
        else if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            const nextOpponentSeed = getSeedRankString(nextOpponent.opponentName, tournamentState.seeds);
            const rankText = nextOpponent.opponentRank ? `(${nextOpponent.opponentRank}ランク)` : '';
            nextOpponentText = `次の${nextOpponent.roundName}では、${nextOpponent.opponentName}${nextOpponentSeed}${rankText}と対戦する。`;
        } 
        else if (nextOpponent.decidingMatch) {
            const dm = nextOpponent.decidingMatch;
            const team1Seed = getSeedRankString(dm.team1, tournamentState.seeds);
            const team2Seed = getSeedRankString(dm.team2, tournamentState.seeds);
            nextOpponentText = `次の${nextOpponent.roundName}では、${dm.team1}${team1Seed}(${dm.rank1}ランク)と${dm.team2}${team2Seed}(${dm.rank2}ランク)の勝者と対戦する。`;
        }
    }
    const calledGameText = matchContext.calledGame ? `\n- **【重要】** この試合は ${matchContext.calledInning}回コールド (${winnerScore}-${loserScore}) で ${winnerName} が勝利しました。` : '';
    const rivalryText = matchContext.rivalryType ? `\n- **【最重要】** この試合は「${matchContext.rivalryType}」という特別な因縁の対決でした。` : '';
    let scheduleText = '';
    if (matchContext.schedule) {
        const sched = matchContext.schedule;
        const team1Region = TEAM_DATA[dbMatch.team1]?.region || '不明';
        const team2Region = TEAM_DATA[dbMatch.team2]?.region || '不明';
        scheduleText = `\n- **試合会場:** ${sched.stadiumFull} (${sched.region}地区)\n`;
        if (sched.region === team1Region && sched.region !== team2Region) { scheduleText += `- **地の利:** ${dbMatch.team1}にとって地元球場での試合となった。\n`; }
        else if (sched.region !== team1Region && sched.region === team2Region) { scheduleText += `- **地の利:** ${dbMatch.team2}にとって地元球場での試合となった。\n`; }
    }
    let atmosphereText = '';
    if (matchContext.atmosphere_team1 || matchContext.atmosphere_team2) {
        atmosphereText = '\n--- ### **参考情報：試合前の雰囲気・公約**\n';
        if (matchContext.atmosphere_team1) atmosphereText += `- ${dbMatch.team1}: ${matchContext.atmosphere_team1}\n`;
        if (matchContext.atmosphere_team2) atmosphereText += `- ${dbMatch.team2}: ${matchContext.atmosphere_team2}\n`;
    }
    let ballQualityText = '';
    if (matchContext.team1BallQuality && matchContext.team2BallQuality) {
        ballQualityText = `\n--- ### **参考情報：チーム別 打球品質**\n- ${matchContext.team1BallQuality}\n- ${matchContext.team2BallQuality}\n`;
    }
    
    let cinderellaPraiseInstruction = ""; 
    const idParts = matchId.split('-');
    let roundNum = 0;
    if (idParts[0] === 'F') {
        roundNum = Math.log2(tournamentState.teams.length); // 7
    } else if (idParts[1] && idParts[1].startsWith('R')) {
        roundNum = parseInt(idParts[1].slice(1));
    }
    if (roundNum > 0) {
        if ( (loserRank === 'E' && roundNum >= 3) ||
             (loserRank === 'D' && roundNum >= 4) ||
             (loserRank === 'C' && roundNum >= 5) )
        {
            cinderellaPraiseInstruction = `
- **【★快進撃への言及】**: 敗北した${loserName}は${loserRankDesc}(${loserRank}ランク)でしたが、今大会は「${loserJourney}」と見事な快進撃を見せ、${roundName}まで勝ち上がりました。この記事では、${loserName}の健闘を称える一文（例：「${loserRankDesc}ながら${roundName}まで勝ち進んだ彼らに、球場全体から拍手が送られた」）を**必ず**含めてください。`;
        }
    }

    if (dbMatch.details) {
        // (Aルート：詳細入力あり)
        const { highlights, keyPlayerNames } = createHighlightsText(dbMatch, winnerName);
        const factListText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
        const winnerKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
        const winnerPlayersInGame = new Set( (dbMatch.details.batting?.[winnerKey] || []).map(p => p.name).concat((dbMatch.details.pitching?.[winnerKey] || []).map(p => p.name)) );
        const winnerKeyPlayers = keyPlayerNames.filter(name => winnerPlayersInGame.has(name));
        const loserKeyPlayers = keyPlayerNames.filter(name => !winnerPlayersInGame.has(name));
        const formatPlayerList = (playerNames, teamName, detailedTeamData) => {
            if (playerNames.length === 0) return '特になし';
            return playerNames.map(playerName => {
                const detailedInfo = detailedTeamData?.players.find(p => p.name === playerName);
                return detailedInfo ? `- **${detailedInfo.name} (${detailedInfo.year}年・${detailedInfo.position})**: ${detailedInfo.desc}` : `- **${playerName}**`;
            }).join('\n');
        };
        const winnerPlayersPrompt = formatPlayerList(winnerKeyPlayers, winnerName, winnerDetailedData);
        const loserPlayersPrompt = formatPlayerList(loserKeyPlayers, loserName, loserDetailedData);
        const lineupChangesText = `- ${winnerName}: ${winnerLineupChanges}\n- ${loserName}: ${loserLineupChanges}`;
        
        prompt = `あなたは、日本の高校野球を深く愛する、情熱的なスポーツ記者です。
あなたの唯一の仕事は、提供されたデータに基づいて最高の記事を生成することです。
---
### **参考情報：静岡県高校野球の「常識」（勢力図）**
${PREFECTURE_LORE}
---
### **現在の試合状況**
- **大会:** ${tournamentYear}年度 ${tournamentName}
- **文脈:** ${tournamentContextPrompt}
- **ラウンド:** ${roundName}
${scheduleText}
${calledGameText}
### **試合結果サマリー**
- ${winnerName} ${winnerSeedRank}が ${loserName} ${loserSeedRank}に ${winnerScore} - ${loserScore} で勝利。
${rivalryText} 
${injuryReport || ''}
### **【最重要】この記事の唯一の事実情報源 (★背番号・盗塁付きボックススコア)**
${matchContext.playerStatsText} 
---
${atmosphereText}
${ballQualityText}
### **【最重要】この記事の唯一の事実情報源 (ハイライト)**
${factListText}
---
### **今大会の主な投手登板履歴 (この試合より前)**
${pitcherGamelogInfo || '今大会、これが初登板です。'}
---
### **今大会の主な打者成績履歴 (この試合より前)**
${batterGamelogInfo || '打者の試合履歴データはありません。'}
---
### **参考情報：補足**
- **前試合からのスタメン変更**:
${lineupChangesText}
- **ユーザーによる試合の決め手**: ${dbMatch.summary || 'なし'}
---
### **参考情報：チームと選手のプロフィール (★チーム打率・通算盗塁含む)**
- **${winnerName} ${winnerSeedRank}**: ${winnerDynamicInfo}
  - **今大会の軌跡**: ${winnerJourney}
  - **監督**: ${winnerCoach ? `${winnerCoach.name} (${winnerCoach.style})` : '情報なし'}
- **主将**: ${winnerCaptainName}
  - **主な選手プロフィール**:\n${winnerPlayersPrompt}
- **${loserName} ${loserSeedRank}**: ${loserDynamicInfo}
  - **今大会の軌跡**: ${loserJourney}
  - **監督**: ${loserCoach ? `${loserCoach.name} (${loserCoach.style})` : '情報なし'}
- **主将**: ${loserCaptainName}
  - **主な選手プロフィール**:\n${loserPlayersPrompt}
---
### **執筆指示**
${cinderellaPraiseInstruction}
- **【★大会の文脈を反映】**: 記事全体で、${tournamentName}ならではの視点（例：夏の3年生の想い、秋の新チームの試金石、春のシード権争い）を必ず反映させてください。
- **【★★ 欠場者への言及 (最重要) ★★】**: もし「試合結果サマリー」の直下に「主な欠場者」（例：〇〇 [🏥] (主力), △△ [🩹] (控え)）に関する情報(${injuryReport})がある場合、その選手の**重要度（主力か控えか）**に応じて、記事の深刻度を変えてください。（例：『エース姫川(主力)の離脱はヤバすぎる』『鈴木(控え)の怪我は痛いが、まぁ...』）
- **【次戦への展望】**: 記事の最後に、次の対戦相手（${nextOpponentText}）に簡潔に触れ、今後の戦いへの展望を記述して締めくくること。
- 「事実リスト」を厳密に基に、試合の物語を再構築してください。
- **【★シードランク言及】**: **「第1シードの〇〇」**や**「シード校の△△が苦戦」**のように、シードランクにも具体的に言及し、試合の文脈を明確にしてください。
- **【監督の采配】**: 「スタメン変更」があった場合、その采配が試合にどう影響したかに触れること。
- **【物語の連続性】**: 「今大会の軌跡」情報を参考に、これまでの戦いと繋がりのある物語を描写すること。
- 試合後の両チーム監督のコメントを、試合内容やチームの背景を反映させて生成すること。
- **【次戦への展望】**: 記事の最後に、次の対戦相手（${nextOpponentText}）に簡潔に触れ、今後の戦いへの展望を記述して締めくくること。
- **【背番号の意味（裁量）】**: 記事中で選手に言及する際、**もしその背番号が物語上重要であれば**（例：エース[#1]の快投・不振、レギュラー番号[#2-9]の責任、または控え番号[#10以降]の選手が予想外の活躍をした場合など）、その背番号が持つ意味に触れてください#は背番号と言い換えてください。(例S1→背番号1)。
- **【コールドゲームの場合】**: もし試合がコールドで終了した場合、その旨を記事の冒頭やタイトルで明確に記述し、大差がついた理由にも触れること。
- **【因縁の対決】**: もし試合が「因縁の対決」であった場合、そのドラマ性を記事の中心に据え、熱く描写してください。
- **【選手の状態と打球の質（打者）】**: ボックススコアに「(状態: 〇〇)」という記述がある選手に注目し、**前回の試合からの連続性**を描写してください。
- **【試合前の雰囲気】**: もし「試合前の雰囲気・公約」が提供されている場合、その情報（例：「監督がエース温存を公言」）を**試合結果と関連付け**、記事の重要なテーマとして扱ってください。
- **【常識の反映】**: あなたが熟知している「常識」（勢力図）を**背景知識として**利用してください。
- **【球場の地の利】**: もし「地の利」情報がある場合、その**地元のアドバンテージ**が試合にどう影響したかに触れてください。
- **【ヒーローインタビュー】**: 記事の最後に「今日のヒーロー」というセクションを設けてください。ボックススコアや事実リストから**最も活躍した勝利チームの選手1名**を選び出し、その選手への架空のインタビューと、それに対するヒーローらしい回答を生成してください。
- **【監督・主将コメント】**: ヒーローインタビューの後、「両チームの声」セクションを設け、**勝利チーム**と**敗北チーム**の「監督」および「主将」の試合後の総括コメントを、それぞれ簡潔に生成してください。
- **【★注目の打席（最重要）】**:
    - 「事実リスト」（ハイライト）に「（★注目）」マークが付いている打席があります。これが**ユーザー（監督）が『試合の分水嶺』だと判断した**、最も重要な打席です。
    - あなたの記事では、**この記事の中心的なハイライト**として、この「★注目」の打席の前後を、最もドラマチックに描写してください。
- **【★今大会の成績 (最重要)】**:
    - 「参考情報：チームと選手のプロフィール」に**『今大会のチーム打率は.XXX』**という情報が含まれています。
    - この情報を**必ず記事に含め**、チームの好調・不振の文脈として描写してください。
- **【★盗塁への言及 (重要)】**:
    - 「ボックススコア」に**盗塁(SB)**が記録されている選手がいた場合、その選手の機動力（例：「〇〇が足でチャンスを広げ」）にも言及すること。
    - さらに、その選手の**「今大会の通算盗塁数」**（例：(今大会: ... 4盗)）も必ず参照し、**「〇〇はこれで今大会4個目の盗塁」**といった具体的な数字を記事に含めてください。
- **【★通算成績への言及 (裁量)】**:
    - 「参考情報」に**『(参考: チーム通算打率 .XXX, 通算 Y 盗塁)』**という情報が含まれている場合、必要に応じてそのチームの機動力にも言及すること。
- **【★登板履歴への言及 (最重要)】**: 「今大会の主な投手登板履歴」の情報を必ず確認し、以下の点をコメントに含めること。
    - **連投/登板間隔**: 「〇〇、連投じゃん」「中1日でこれはキツイ」
    - **酷使**: 「エース投げすぎだろ」「監督は鈴木を壊す気か」
    - **好不調の波**: 「前回炎上したのによう立ち直ったな」「こないだは良かったのに今日はアカンか」
- **【★打者履歴への言与 (最重要)】**: 「今大会の主な打者成績履歴」も必ず確認し、以下の点をコメントに含めること。
    - **好不調の波**: 「〇〇、今日で3試合連続ヒットやん！」「△△、10打数ノーヒットとかもう終わりだろ…」
    - **役割**: 「こいつ代打成功率100%じゃね？」「1番に上げたら打ち出したな」
---
### 編集長からの追加指示
${(userFeedback && userFeedback.include) ? `- **【最重要指示】** ${userFeedback.include}\n` : ''}
${(userFeedback && userFeedback.exclude) ? `- **【厳禁事項】** ${userFeedback.exclude}\n` : '特になし'}
---
### 出力形式【厳守】
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}
`;

   } else {
        // (Bルート：詳細入力なし)
        prompt = `あなたは、高校野球専門のAI記者です。
以下の試合結果に基づき、簡潔で分かりやすいニュース記事を作成してください。
---
### **参考情報：静岡県高校野球の「常識」（勢力図）**
${PREFECTURE_LORE}
---
### **現在の試合状況**
- **大会:** ${tournamentYear}年度 ${tournamentName}
- **文脈:** ${tournamentContextPrompt}
- **ラウンド:** ${roundName} 
${scheduleText} 
### 試合情報
- **勝利チーム**: ${winnerName} ${winnerSeedRank} (${winnerRankDesc})(主将: ${winnerCaptainName})
- **敗北チーム**: ${loserName} ${loserSeedRank} (${loserRankDesc})(主将: ${loserCaptainName})
- **スコア**: ${winnerScore} - ${loserScore}
- **ユーザーによる試合の決め手**: ${dbMatch.summary || 'なし'}
${calledGameText} 
${rivalryText} 
${injuryReport || ''}
### **参考情報：チームの背景 (★チーム打率・通算盗塁含む)**
- **${winnerName} ${winnerSeedRank}**: ${winnerDynamicInfo}
  - **今大会の軌跡**: ${winnerJourney}
- **${loserName} ${loserSeedRank}**: ${loserDynamicInfo}
  - **今大会の軌跡**: ${loserJourney}
---
### 執筆指示
- **【★大会の文脈を反映】**: 記事全体で、${tournamentName}ならではの視点（例：夏の3年生の想い、秋の新チームの試金石、春のシード権争い）を必ず反映させてください。
- **【★シードランク言及】**: **「第1シードの〇〇が順当に勝利」**や**「ノーシードの△△が第8シードを破る波乱」**のように、シードランクにも具体的に言及してください。
- **【★★ 欠場者への言及 (最重要) ★★】**: もし「試合情報」の直下に「主な欠場者」（例：〇〇 [🏥] (主力), △△ [🩹] (控え)）に関する情報(${injuryReport})がある場合、その選手の**重要度（主力か控えか）**に応じて、記事の深刻度を変えてください。（例：『エース姫川(主力)の離脱はヤバすぎる』『鈴木(控え)の怪我は痛いが、まぁ...』）
${cinderellaPraiseInstruction}
- **【★今大会の成績 (最重要)】**: 「チームの背景」にある『今大会のチーム打率は.XXX』という情報を**必ず記事に含め**、チームの好調・不振の文脈として描写してください。
- 記事の最後に、勝利チームの監督または主将の喜びのコメント（例：『〇〇監督「選手たちがよく頑張ってくれた」』）を一行追加してください。
- **記事の最後に、次の対戦相手（${nextOpponentText}）に簡潔に触れて締めくくってください。**
- 記事のタイトルと本文をJSON形式で出力してください。`;
    }

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json(); 
        if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
            const rawTextFromAi = result.candidates[0].content.parts[0].text; 
            const article = parseJsonFromText(rawTextFromAi); 
            if (article && !article.body && article.article) { article.body = article.article; }
            if (article && article.title && article.body) { 
                
                const isNewspaperWorthy = (
                    dbMatch.details && 
                    tournamentState.settings.enableArticleGeneration
                );
                const newspaperHtml = isNewspaperWorthy ? createNewspaperHtml(article, { winnerName, loserName, dbMatch, matchId }) : null;
                
                return { 
                    ...article, 
                    isNewspaper: isNewspaperWorthy,
                    timestamp: Date.now(), 
                    newspaperHtml: newspaperHtml,
                    context: matchContext
                };
            } else {
                 console.error("parseJsonFromText failed or keys (title/body/article) missing for raw text:", rawTextFromAi);
                 throw new Error("AI response format error after parsing."); 
            }
        } else {
             console.error("Unexpected AI response structure:", result);
             throw new Error("AI response structure is missing expected parts."); 
        }
    } catch (error) {
        console.error("AI記事の生成に失敗しました:", error);
        return { 
            title: "記事生成エラー", body: "AI記者との通信に失敗しました。", 
            timestamp: Date.now(), error: true, errorId: matchId,
            context: matchContext 
        };
    }
}

/**
     * AIにスキップしたラウンドのダイジェスト記事を生成させる
     */
    async function generateSkipRoundSummaryArticle(roundNumber, results) {
        // 最も番狂わせが大きかった試合を1つ選出
        const biggestUpset = results.filter(r => r.rankDiff >= 2).sort((a,b) => b.rankDiff - a.rankDiff)[0];
        
        let highlightText = "シード校や有力校が順当に勝ち進みました。";
        if (biggestUpset) {
            highlightText = `最大の波乱は${biggestUpset.winnerName}が強豪${biggestUpset.loserName}を${biggestUpset.winnerScore}-${biggestUpset.loserScore}で破った一戦でした。`;
        }

        const prompt = `あなたは高校野球専門のAI記者です。
現在、${tournamentState.tournamentYear}年度${tournamentNameMap[tournamentState.currentTournament]}が進行中です。
${roundNumber}回戦の全試合が終了しました。以下のハイライトを元に、簡潔なダイジェスト記事を生成してください。

### ${roundNumber}回戦ハイライト
- ${highlightText}
- 次のラウンドでは、勝ち上がった猛者たちによる更なる激戦が期待されます。

### 執筆指示
- 上記のハイライトを自然な文章にまとめてください。
- タイトルは「${roundNumber}回戦が終了！波乱は起きるか？」のように、次への期待感を煽るものにしてください。

### 出力形式
JSON形式で出力してください: {"title": "記事のタイトル", "body": "記事の本文"}`;

        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
                if (article) return { ...article, timestamp: Date.now() };
            }
            throw new Error("AI summary response format error.");
        } catch (error) {
            console.error("AI summary article generation failed:", error);
            return { title: "ダイジェスト記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true, errorId: `skip-summary-${roundNumber}` };
        }
    }


/**
 * 試合直前の「応援コメント」をAIに生成させる
 * (★Gamelog, DynamicInfo, 会場, 因縁の情報を追加した最終版)
 * @param {object} context - 試合とチームの全コンテキスト
 * @param {number} numComments - 生成するコメント数
 * @returns {Promise<Array<object>>} - 生成されたコメントオブジェクトの配列
 */
async function generatePreGameCheerComments(context, numComments) {
    
    // --- 1. コンテキストを分解 ---
    const {
        name: teamName,
        rank: teamRank,
        opponent: opponentName,
        opponentRank: opponentRank,
        round: roundName,
        path: tournamentPath, // (getCurrentTournamentPerformance の結果)
        detailed: detailedData, // (静的な注目選手情報)
        info: teamInfo,         // (generateDynamicTeamInfo の結果)
        playerGamelogs,       // (formatPlayerGamelogsForPrompt の結果)
        schedule,             // (試合会場・日程)
        rivalry               // (因縁情報)
    } = context;

    // --- 2. AIへのペルソナ指示 ---
    let personaInstructions = `
あなたは「${teamName}」の熱狂的な応援団、または試合に期待するファンです。以下のペルソナ（役割）になりきって、試合直前の応援コメントを合計 ${numComments} 個生成してください。

### ペルソナ（役割）と、あなたが語るべき視点
- **OB (OB・OG):**
    - **視点:** あなたの在籍時代（例：5年前、20年前）の思い出と、現在のチームを比較してください。
    - **（重要）:** もし応援するチームが「283学園」や「765総合」のような**創部数年の新しい学校**の場合、「40年前」といった矛盾した発言は**絶対にせず**、「創部まもないのに, ここまで来るとは…」「俺が1期生だった頃は…」といった、**新しい学校のOBらしい**コメントを生成してください。

- **在校生 (ブラスバンド部員や友人など):**
    - **視点:** 今の学校の雰囲気や、応援練習の様子、クラスメイトとしての選手の素顔（架空でOK）を語ってください。
    - **（例）:** 「〇〇くん、いつもは教室で静かなのにグラウンドだと凄い！」「ブラバンも気合入ってます！」

- **地元ファン (その地域に住むファン):**
    - **視点:** 地域の期待（例：「今年こそ甲子園へ」「〇〇（地名）の誇りだ」）を語ってください。

- **選手の家族 (架空の親や兄弟):**
    - **視点:** 選手の個人的な努力（架空でOK）や、家庭での様子を語ってください。
    - **（例）:** 「息子がベンチ入りできただけで奇跡です」「あの子、毎朝5時に起きて素振りしてましたから…」
`;

    if (teamRank === 'A' || teamRank === 'B') {
        personaInstructions += `
- **（無関係の）高校野球ファン:**
    - **視点:** あなたは、この試合が ${teamName}（${getRankDescription(teamRank)}）の試合だから観に来た「無関係の野球好き」です。学校関係者ではありません。
    - **（例）:** 「今日の目当てはこのカード。ハイレベルな試合を期待してる」「〇〇（注目選手）のピッチング/バッティングが見たくて有休とったわ」「どっちが勝ってもいいから熱い試合を見せてくれ」
`;
    }
    
    // --- 3. AIへのプロンプト (★新情報追加版) ---
    const prompt = `
${personaInstructions}

### 試合情報
- **応援するチーム:** ${teamName} (ランク: ${teamRank})
- **対戦相手:** ${opponentName} (ランク: ${opponentRank})
- **ラウンド:** ${roundName}
- **試合会場:** ${schedule || '未定'}
${rivalry ? `- **${rivalry}**` : ''}

### 参考情報：応援するチームの最新データ
- **チームの背景(info):** ${teamInfo || '特になし'}
- **今大会の軌跡:** ${tournamentPath || '今大会初戦'}
- **注目選手 (静的):** ${detailedData ? detailedData.players.map(p => p.name).join(', ') : '情報なし'}
- **今大会の選手成績履歴 (Gamelog):**
${playerGamelogs || '今大会の試合履歴はありません。'}

### 指示
1.  **ペルソナになりきる:** 上記のペルソナ（OB、在校生、地元ファン、家族、無関係のファン等）に完全になりきり、その立場からの応援コメントを生成してください。
2.  **文脈を反映:** 試合情報（相手が格上か、歴史的な快進撃か、注目選手は誰か）をコメントに反映させてください。
3.  **★【最重要】背景(info)の活用:** 「チームの背景(info)」を熟読してください。
    - （例：もし「川根」なら「最後の夏」や「閉校」に触れる）
    - （例：もし「浜松特支」なら「創部一年目」「52-0の大敗」の記憶に触れる）
    - （例：もし「283学園」なら「王者としてのプレッシャー」に触れる）
    - （例：もし「今大会のチーム打率は.350」とあれば、「打線好調！」に触れる）
    - この背景情報に基づいた、**具体的で解像度の高い**コメントを必ず生成してください。
4.  **★【重要】Gamelogの活用:** 「選手成績履歴(Gamelog)」を読み、具体的な選手の**好不調の波**にも言及してください。
    - （例：「〇〇くん、1回戦は3タコだったけど、2回戦はホームラン！今日が大事だぞ！」）
    - （例：「エースの△△、前回登板は中1日だったから心配してたんだ…今日は頼む！」）
5.  **★試合会場と因縁:** もし試合が「草薙球場」など**地元開催**であったり、「因縁の対決」であったりする場合、その点にも言及して期待感を高めてください。
6.  **創作を許可:** 選手や監督との（架空の）個人的な思い出や、過去の歴史（例：40年前の初勝利）を**自由に創作して**、コメントに深みを与えてください。

### 出力形式【厳守】
必ず以下のJSON配列形式"のみ"で出力してください。
[
    {"personality": "（例：〇〇高校OB）", "comment": "（生成したコメント1）"},
    {"personality": "（例：在校生）", "comment": "（生成したコメント2）"},
    {"personality": "（例：地元のファン）", "comment": "（生成したコメント3）"}
    // ... (指定されたコメント数だけ続ける) ...
]
`;

    // --- 4. AIへのリクエスト (変更なし) ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson;
            }
        }
        throw new Error("AI response format error (PreGameComments).");
    } catch (error) {
        console.error("AI応援コメントの生成に失敗しました:", error);
        return [{ personality: "システムエラー", comment: "応援コメントの生成に失敗しました..." }];
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲
// ▲▲▲ 貼り付けはここまで ▲▲
// ▲▲▲ 貼り付けはここまで ▲▲

// ▼▼▼ 大会表彰式 (Awards) 機能 ▼▼▼

document.getElementById('show-awards-btn').addEventListener('click', () => {
    renderAwardsModal();
    document.getElementById('awards-modal').classList.remove('hidden');
    document.getElementById('awards-modal').classList.add('flex');
});

document.getElementById('awards-modal-close-btn').addEventListener('click', () => {
    document.getElementById('awards-modal').classList.add('hidden');
    document.getElementById('awards-modal').classList.remove('flex');
});

/**
 * [FIXED] 表彰式モーダルを描画する (大会MVP選出機能を追加)
 */
function renderAwardsModal() {
    const contentEl = document.getElementById('awards-content');
    contentEl.innerHTML = '<div class="loader text-center py-16">全選手の記録を集計中...</div>';

    // --- 1. データ集計 ---
    const allBatters = [];
    const allPitchers = [];

    Object.keys(tournamentState.teamRecords).forEach(teamName => {
        const record = tournamentState.teamRecords[teamName];
        if (!record.playerStats) return;
        
        // 打者集計
        if (record.playerStats.batting) {
            Object.entries(record.playerStats.batting).forEach(([name, s]) => {
                if ((s.pa || 0) > 0) {
                    const ops = parseFloat(calculateOps(s));
                    const h = s.h||0; const bb=(s.bb||0)+(s.hbp||0); const ab=s.ab||0;
                    const tb = (s.tb||h) + (s.hr||0)*3;
                    const times = ab + bb;
                    let rc = times > 0 ? ((h + bb) * tb) / times : 0;
                    
                    allBatters.push({
                        name, team: teamName, stats: s,
                        avg: s.ab > 0 ? s.h / s.ab : 0,
                        ops: ops, rc: rc,
                        pos: s.pos || '指', games: s.games || 0
                    });
                }
            });
        }

        // 投手集計
        if (record.playerStats.pitching) {
            Object.entries(record.playerStats.pitching).forEach(([name, p]) => {
                const s = p.career;
                if (s && s.ip > 0) {
                    allPitchers.push({
                        name, team: teamName, stats: s,
                        era: s.er * 9 / s.ip,
                        so: s.so || 0, w: s.w || 0, ip: s.ip
                    });
                }
            });
        }
    });

    const tournamentMaxGames = allBatters.reduce((max, p) => Math.max(max, p.games), 0) || 1;
    const minPa = Math.max(10, tournamentMaxGames * 2); // 規定打席
    const minIp = Math.max(5, tournamentMaxGames * 0.5); // 規定投球回

    // --- 2. ★★★ 大会MVP選出 (新規追加) ★★★ ---
    let mvpData = null;
    const finalMatch = tournamentState.matches['F-R1-M1'];
    const championTeam = finalMatch?.winner; // 優勝チーム

    if (championTeam) {
        // 優勝チームの選手を抽出
        const champBatters = allBatters.filter(p => p.team === championTeam);
        const champPitchers = allPitchers.filter(p => p.team === championTeam);

        // 投手MVP候補 (勝利数 > 防御率 > 投球回)
        const bestChampPitcher = champPitchers.sort((a, b) => {
            if (b.stats.w !== a.stats.w) return b.stats.w - a.stats.w;
            return a.era - b.era;
        })[0];

        // 打者MVP候補 (RC > OPS)
        const bestChampBatter = champBatters.sort((a, b) => b.rc - a.rc)[0];

        // 投打の比較 (投手が3勝以上または防御率1点台なら投手を優先、それ以外は打者)
        if (bestChampPitcher && (bestChampPitcher.stats.w >= 3 || bestChampPitcher.era < 2.00)) {
            mvpData = {
                type: '投手',
                name: bestChampPitcher.name,
                team: bestChampPitcher.team,
                desc: `${bestChampPitcher.stats.w}勝 防御率${bestChampPitcher.era.toFixed(2)} ${bestChampPitcher.stats.so}奪三振`,
                detail: `エースとしてチームを優勝に導いた。`
            };
        } else if (bestChampBatter) {
            mvpData = {
                type: '野手',
                name: bestChampBatter.name,
                team: bestChampBatter.team,
                desc: `打率${bestChampBatter.avg.toFixed(3)} ${bestChampBatter.stats.hr}本塁打 ${bestChampBatter.stats.rbi}打点`,
                detail: `圧倒的な打棒でチームの勝利に貢献した。`
            };
        }
    } else {
        mvpData = { name: "???", team: "優勝決定後", desc: "大会終了後に発表されます", detail: "" };
    }
    // --- ★★★ MVP選出ここまで ★★★ ---


    // --- 3. タイトルホルダー選出 ---
    const leadingHitters = allBatters.filter(p => p.stats.pa >= minPa).sort((a, b) => b.avg - a.avg).slice(0, 5);
    const homeRunKings = allBatters.sort((a, b) => (b.stats.hr || 0) - (a.stats.hr || 0)).slice(0, 5);
    const rbiKings = allBatters.sort((a, b) => (b.stats.rbi || 0) - (a.stats.rbi || 0)).slice(0, 5);
    const sbKings = allBatters.sort((a, b) => (b.stats.sb || 0) - (a.stats.sb || 0)).slice(0, 5);
    const eraLeaders = allPitchers.filter(p => p.stats.ip >= minIp).sort((a, b) => a.era - b.era).slice(0, 5);
    const soLeaders = allPitchers.sort((a, b) => b.so - a.so).slice(0, 5);

    // --- 4. ベストナイン選出 ---
    const positions = ['投', '捕', '一', '二', '三', '遊', '外'];
    const bestNine = {};

    const bestPitcher = allPitchers.filter(p => p.stats.ip >= minIp).sort((a, b) => {
        const scoreA = (10 - a.era) * 2 + (a.stats.w * 5) + (a.stats.so * 0.1);
        const scoreB = (10 - b.era) * 2 + (b.stats.w * 5) + (b.stats.so * 0.1);
        return scoreB - scoreA;
    })[0];
    bestNine['投'] = bestPitcher;

    positions.slice(1).forEach(pos => {
        const candidates = allBatters.filter(p => p.pos && p.pos.includes(pos) && p.stats.pa >= minPa);
        if (pos === '外') {
            bestNine['外'] = candidates.sort((a, b) => b.rc - a.rc).slice(0, 3);
        } else {
            bestNine[pos] = candidates.sort((a, b) => b.ops - a.ops)[0];
        }
    });

    // --- 5. HTML生成 ---
    // (MVPカードのHTML生成)
    const mvpHtml = `
        <div class="bg-gradient-to-r from-yellow-100 to-amber-200 p-6 rounded-lg shadow-lg border-2 border-amber-400 mb-8 text-center transform transition hover:scale-105 duration-300">
            <h4 class="text-2xl font-black text-amber-800 mb-2 flex justify-center items-center">
                <span class="text-3xl mr-2">👑</span> 大会最優秀選手 (MVP) <span class="text-3xl ml-2">👑</span>
            </h4>
            <div class="mt-4">
                <p class="text-3xl font-bold text-gray-900">${mvpData.name} <span class="text-lg font-normal text-gray-700">(${mvpData.team})</span></p>
                <p class="text-xl font-bold text-blue-800 mt-2">${mvpData.desc}</p>
                <p class="text-sm text-gray-600 mt-2 italic">"${mvpData.detail}"</p>
            </div>
        </div>
    `;

    const createRankingTable = (title, list, metricLabel, metricKey, isRate = false) => `
        <div class="bg-white p-4 rounded shadow mb-4 border-t-4 border-blue-500">
            <h4 class="font-bold text-gray-700 border-b pb-2 mb-2 flex justify-between">
                ${title} <span class="text-xs font-normal text-gray-500 self-end">${metricLabel}</span>
            </h4>
            <table class="w-full text-sm">
                ${list.map((p, i) => {
                    let val = isRate ? (p[metricKey]).toFixed(3) : (metricKey.split('.').reduce((o, k) => o?.[k], p) || 0);
                    if (title === "最優秀防御率") val = p.era.toFixed(2);
                    return `
                    <tr class="${i===0 ? 'font-bold bg-yellow-50' : ''}">
                        <td class="w-6 text-center">${i+1}</td>
                        <td>${p.name} <span class="text-xs text-gray-500">(${p.team})</span></td>
                        <td class="text-right font-mono">${val}</td>
                    </tr>`;
                }).join('')}
            </table>
        </div>
    `;

    const createBestNineCard = (pos, player) => {
        if (!player) return `<div class="p-2 border rounded bg-gray-50 text-center text-gray-400 mb-2">${pos}: 該当なし</div>`;
        if (Array.isArray(player)) return player.map(p => createBestNineCard(pos, p)).join('');
        
        const statText = (pos === '投') 
            ? `防${player.era.toFixed(2)}` 
            : `OPS${player.ops.toFixed(3)}`;

        return `
            <div class="p-2 border-l-4 border-amber-400 rounded bg-white shadow-sm flex justify-between items-center mb-2">
                <div class="flex items-center">
                    <span class="w-8 text-center text-xs font-bold text-amber-800 bg-amber-100 py-1 rounded mr-2">${pos}</span>
                    <div>
                        <p class="font-bold text-gray-800 text-sm">${player.name}</p>
                        <p class="text-xs text-gray-500">${player.team}</p>
                    </div>
                </div>
                <div class="text-right">
                    <p class="font-bold text-blue-700 text-sm">${statText}</p>
                </div>
            </div>
        `;
    };

    let html = `
        ${mvpHtml}
        
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="lg:col-span-1">
                <h3 class="text-lg font-bold text-gray-800 mb-4 border-b-2 border-red-500 pb-1">⚾ 打撃部門</h3>
                ${createRankingTable('首位打者', leadingHitters, '打率', 'avg', true)}
                ${createRankingTable('本塁打王', homeRunKings, '本塁打', 'stats.hr')}
                ${createRankingTable('打点王', rbiKings, '打点', 'stats.rbi')}
                ${createRankingTable('盗塁王', sbKings, '盗塁', 'stats.sb')}
            </div>

            <div class="lg:col-span-1">
                <h3 class="text-lg font-bold text-gray-800 mb-4 border-b-2 border-blue-500 pb-1">⚾ 投手部門</h3>
                ${createRankingTable('最優秀防御率', eraLeaders, '防御率', 'era', true)}
                ${createRankingTable('最多奪三振', soLeaders, '奪三振', 'so')}
            </div>

            <div class="lg:col-span-1">
                <h3 class="text-lg font-bold text-gray-800 mb-4 border-b-2 border-amber-500 pb-1">✨ ベストナイン</h3>
                <div class="bg-gray-100 p-3 rounded-lg">
                    ${createBestNineCard('投', bestNine['投'])}
                    ${createBestNineCard('捕', bestNine['捕'])}
                    ${createBestNineCard('一', bestNine['一'])}
                    ${createBestNineCard('二', bestNine['二'])}
                    ${createBestNineCard('三', bestNine['三'])}
                    ${createBestNineCard('遊', bestNine['遊'])}
                    <div class="mt-4">
                        <p class="text-xs text-gray-500 mb-1 font-bold">外野手</p>
                        ${createBestNineCard('外', bestNine['外'])}
                    </div>
                </div>
            </div>
        </div>
    `;

    contentEl.innerHTML = html;
}

/**
 * [NEW] 試合結果に基づき、X(旧Twitter)風のトレンドワードとポストを生成する
 */
async function generateSnsPosts(matchContext) {
    const { winnerName, loserName, dbMatch, highlights, playerStatsText } = matchContext;
    const score = `${dbMatch.score1}-${dbMatch.score2}`;
    
    // トレンドワード候補の選定
    let trendCandidates = [`#${winnerName}`, `#高校野球`, `#${loserName}`];
    
    // 劇的な展開があればトレンドに追加
    if (matchContext.highlights.some(h => h.description.includes("サヨナラ"))) trendCandidates.unshift("サヨナラ");
    if (matchContext.highlights.some(h => h.description.includes("逆転"))) trendCandidates.unshift("逆転勝利");
    if (parseInt(dbMatch.score1) + parseInt(dbMatch.score2) >= 15) trendCandidates.unshift("乱打戦");
    if (parseInt(dbMatch.score1) === 0 || parseInt(dbMatch.score2) === 0) trendCandidates.unshift("完封");
    
    // 活躍選手を抽出してトレンドに追加
    if (matchContext.keyPlayerNames && matchContext.keyPlayerNames.length > 0) {
        trendCandidates.unshift(matchContext.keyPlayerNames[0]); // 最も活躍した選手
    }

    const primaryTrend = trendCandidates[0];

    const prompt = `あなたはX（旧Twitter）のユーザーです。
高校野球の試合「${winnerName} vs ${loserName}」が終了しました（結果: ${score}）。
以下のハイライトを元に、タイムラインに流れる**リアルな短文ポスト（ツイート）を10個**生成してください。

### 試合ハイライト
${highlights.map(h => h.description).join('\n')}

### トレンドワード
${trendCandidates.join(', ')}

### 執筆指示
- **BBS（なんJ）とは異なる文体**にしてください。
- 絵文字（😭, ✨, 🔥, ⚾）を適度に使ってください。
- 「感動した」「涙止まらん」「鳥肌たった」など、感情的な投稿を含めてください。
- 「${winnerName}おめでとう！」「${loserName}もお疲れ様」といった、爽やかな投稿も含めてください。
- 驚きのプレーには「えぐい」「やばすぎ」といった若者言葉を使ってください。
- 必ず全てのポストにハッシュタグ（例: #${winnerName}, #高校野球）を1つ以上付けてください。
- **${primaryTrend}** について言及するポストを多めにしてください。

### 出力形式 (JSON)
[
    {"handle": "@baseball_love", "name": "野球垢⚾️", "text": "（ポスト本文）", "likes": 120, "rts": 45},
    {"handle": "@user1234", "name": "一般人", "text": "（ポスト本文）", "likes": 5, "rts": 0}
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const posts = parseJsonFromText(result.candidates[0].content.parts[0].text);
            return { posts, trends: trendCandidates.slice(0, 5) };
        }
        return null;
    } catch (error) {
        console.error("SNS生成エラー:", error);
        return null;
    }
}

let currentSnsData = null; // グローバル変数で保持

function renderSnsModalContent(tab = 'trend') {
    const container = document.getElementById('sns-content-area');
    container.innerHTML = '';

    if (!currentSnsData) {
        container.innerHTML = '<p class="text-center p-8 text-gray-500">データがありません</p>';
        return;
    }

    if (tab === 'trend') {
        // トレンドリスト表示
        const trendsHtml = currentSnsData.trends.map((word, i) => `
            <div class="sns-trend-item" onclick="switchSnsTab('timeline')">
                <div class="sns-trend-meta">${i + 1} · スポーツ · トレンド</div>
                <div class="sns-trend-word">${word}</div>
                <div class="sns-trend-count">${Math.floor(Math.random() * 50000 + 1000).toLocaleString()}件のポスト</div>
            </div>
        `).join('');
        container.innerHTML = trendsHtml;
        
        // 下部に「話題のポスト」として少しだけTLを表示
        const previewTitle = document.createElement('div');
        previewTitle.className = "p-3 font-bold text-gray-800 bg-gray-50 border-b border-t";
        previewTitle.textContent = "話題のポスト";
        container.appendChild(previewTitle);
        
        renderTimeline(container, currentSnsData.posts.slice(0, 3));

    } else {
        // タイムライン全表示
        renderTimeline(container, currentSnsData.posts);
    }
}

function renderTimeline(container, posts) {
    posts.forEach(post => {
        const div = document.createElement('div');
        div.className = 'sns-post';
        div.innerHTML = `
            <div class="sns-avatar" style="background-color: hsl(${Math.random()*360}, 70%, 80%)"></div>
            <div class="sns-content">
                <div class="sns-user-info">
                    <span class="sns-name">${post.name}</span>
                    <span class="sns-handle">${post.handle}</span>
                    <span class="sns-time">· ${Math.floor(Math.random()*10 + 1)}分</span>
                </div>
                <div class="sns-text">${post.text.replace(/#(\S+)/g, '<span class="text-blue-500">#$1</span>')}</div>
                <div class="sns-actions">
                    <span class="sns-action-btn">💬 ${Math.floor(post.likes / 10)}</span>
                    <span class="sns-action-btn retweet"> ${post.rts}</span>
                    <span class="sns-action-btn like">❤️ ${post.likes}</span>
                    <span class="sns-action-btn">⬆️</span>
                </div>
            </div>
        `;
        container.appendChild(div);
    });
}

function switchSnsTab(tab) {
    const btnTrend = document.getElementById('sns-tab-trend');
    const btnTimeline = document.getElementById('sns-tab-timeline');
    
    if (tab === 'trend') {
        btnTrend.className = "flex-1 py-3 font-bold hover:bg-gray-100 border-b-4 border-blue-500 text-gray-900";
        btnTimeline.className = "flex-1 py-3 font-bold text-gray-500 hover:bg-gray-100";
    } else {
        btnTrend.className = "flex-1 py-3 font-bold text-gray-500 hover:bg-gray-100";
        btnTimeline.className = "flex-1 py-3 font-bold hover:bg-gray-100 border-b-4 border-blue-500 text-gray-900";
    }
    renderSnsModalContent(tab);
}

/**
 * [修正版] AIに試合結果の掲示板の反応を生成させる
 * (★「軽傷」選手への言及指示を強化)
 */
async function generateBbsComments(matchContext) {
    const { 
        winnerName, loserName, dbMatch, matchId, 
        winnerData, loserData, winnerDynamicInfo, loserDynamicInfo,
        nextOpponent, winnerSeedRank, loserSeedRank,
        loserJourney, // ★ 敗者の軌跡
        injuryReport
    } = matchContext;
    
    const winnerScore = Math.max(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const loserScore = Math.min(parseInt(dbMatch.score1) || 0, parseInt(dbMatch.score2) || 0);
    const winnerRankDesc = getRankDescription(calculateRank(winnerName, tournamentState));
    const loserRank = calculateRank(loserName, tournamentState);
    const loserRankDesc = getRankDescription(loserRank);
    
    const tournamentName = tournamentNameMap[tournamentState.currentTournament] || '大会';
    const tournamentYear = tournamentState.tournamentYear;
    let tournamentBbsContext = "";
    if (tournamentState.currentTournament === 'summer') {
        tournamentBbsContext = "3年生にとってはガチで最後の夏や。";
    } else if (tournamentState.currentTournament === 'autumn') {
        tournamentBbsContext = "新チームの初陣やな。ここでの結果がセンバツ選考に響くで。";
    } else if (tournamentState.currentTournament === 'spring') {
        tournamentBbsContext = "夏のシード権がかかった前哨戦や。";
    }

    const roundName = getRoundNameFromMatchId(matchId); 
    
    let nextOpponentText = '次の相手は未定。'; 
    if (nextOpponent) {
        if (nextOpponent.opponentName === '優勝') {
            nextOpponentText = (tournamentState.currentTournament === 'summer')
                ? '夏の甲子園出場決定！'
                : (tournamentState.currentTournament === 'autumn' ? 'センバツ出場が有力となった。' : '今大会、見事優勝を果たした。');
        }
        else if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            const nextOpponentSeed = getSeedRankString(nextOpponent.opponentName, tournamentState.seeds);
            const rankText = nextOpponent.opponentRank ? `(${nextOpponent.opponentRank}ランク)` : '';
            nextOpponentText = `次の${nextOpponent.roundName}では、${nextOpponent.opponentName}${nextOpponentSeed}${rankText}と対戦する。`;
        } 
        else if (nextOpponent.decidingMatch) {
            const dm = nextOpponent.decidingMatch;
            const team1Seed = getSeedRankString(dm.team1, tournamentState.seeds);
            const team2Seed = getSeedRankString(dm.team2, tournamentState.seeds);
            nextOpponentText = `次の${nextOpponent.roundName}では、${dm.team1}${team1Seed}(${dm.rank1}ランク)と${dm.team2}${team2Seed}(${dm.rank2}ランク)の勝者と対戦する。`;
        }
    }
    const calledGameText = matchContext.calledGame ? `\n- **特記事項:** ${matchContext.calledInning}回コールドゲーム` : '';
    const rivalryText = matchContext.rivalryType ? `\n- **特記事項:** この試合は「${matchContext.rivalryType}」という特別な因縁の対決でした。` : '';
    let scheduleText = '';
    if (matchContext.schedule) {
        const sched = matchContext.schedule;
        const team1Region = TEAM_DATA[dbMatch.team1]?.region || '不明';
        const team2Region = TEAM_DATA[dbMatch.team2]?.region || '不明';
        scheduleText = `\n- **試合会場:** ${sched.stadiumFull} (${sched.region}地区)\n`;
        if (sched.region === team1Region && sched.region !== team2Region) { scheduleText += `- **地の利:** ${dbMatch.team1}にとって地元球場での試合となった。\n`; }
        else if (sched.region !== team1Region && sched.region === team2Region) { scheduleText += `- **地の利:** ${dbMatch.team2}にとって地元球場での試合となった。\n`; }
    }
    let atmosphereText = '';
    if (matchContext.atmosphere_team1 || matchContext.atmosphere_team2) {
        atmosphereText = '\n--- ### **参考情報：試合前の雰囲気・公約**\n';
        if (matchContext.atmosphere_team1) atmosphereText += `- ${dbMatch.team1}: ${matchContext.atmosphere_team1}\n`;
        if (matchContext.atmosphere_team2) atmosphereText += `- ${dbMatch.team2}: ${matchContext.atmosphere_team2}\n`;
    }
    let ballQualityText = '';
    if (matchContext.team1BallQuality && matchContext.team2BallQuality) {
        ballQualityText = `\n--- ### **参考情報：チーム別 打球品質**\n- ${matchContext.team1BallQuality}\n- ${matchContext.team2BallQuality}\n`;
    }

    let cinderellaPraiseInstruction = "";
    const idParts = matchId.split('-');
    let roundNum = 0;
    if (idParts[0] !== 'F' && idParts[1] && idParts[1].startsWith('R')) {
        roundNum = parseInt(idParts[1].slice(1));
    }
    if ( (loserRank === 'E' && roundNum >= 3) ||
         (loserRank === 'D' && roundNum >= 4) ||
         (loserRank === 'C' && roundNum >= 5) )
    {
        cinderellaPraiseInstruction = `
- **【★快進撃への言及】**: 敗北した${loserName}は${loserRankDesc}(${loserRank}ランク)だったが、${roundName}まで勝ち上がった。この「快進撃」を**「${loserName}、ようやっとる」「来年が楽しみなチーム」**のように、必ず称賛すること。`;
    }

    let prompt; 

    if (dbMatch.details) {
        // (Aルート：詳細入力あり)
        const { highlights } = createHighlightsText(dbMatch, winnerName);
        const highlightsText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
        
        prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下の試合結果と詳細なハイライトに基づき、各キャラクターになりきって、辛辣でリアルな短いコメントを10つ生成してください。
---
### **参考情報：静岡県高校野球の「常識」（勢力図）**
${PREFECTURE_LORE}
---
### 試合情報
- **大会:** ${tournamentYear}年度 ${tournamentName} (${tournamentBbsContext})
- **ラウンド:** ${roundName}
- **勝利チーム**: ${winnerName} ${winnerSeedRank} (${winnerRankDesc})
- **敗北チーム**: ${loserName} ${loserSeedRank} (${loserRankDesc})
- **スコア**: ${winnerScore} - ${loserScore}
${calledGameText} 
${rivalryText}
${injuryReport || ''}
### 次の試合情報
- **${winnerName}の次の試合**: ${nextOpponentText}
- ユーザーが語る試合の決め手: ${dbMatch.summary || '特になし'}
${ballQualityText} 
### 試合の主なハイライト
${highlightsText}
### 今大会の主な投手登板履歴 (この試合より前)
${matchContext.pitcherGamelogInfo || '今大会、これが初登板です。'}
### 今大会の主な打者成績履歴 (この試合より前)
${matchContext.batterGamelogInfo || '打者の試合履歴データはありません。'}
### チームの背景 (★チーム打率・通算盗塁含む)
- **${winnerName} ${winnerSeedRank}**: ${winnerDynamicInfo}
- **${loserName} ${loserSeedRank}**: ${loserDynamicInfo}
  - **軌跡**: ${loserJourney}

### あなたがなりきるべきキャラクターと指示
- **【★大会の文脈を反映】**: ${tournamentName}ならではの視点（例：「夏は3年生最後やな」「秋の新チームの仕上がり見えてきたな」）をコメントに含めること。
- **【★シードランク言及】**: **「第1シードさすがやな」「第5シードが負けたンゴwww」**のように、シードランクにも具体的に言及してください。
- **【★★欠場者への言及 (最重要)】**: もし「主な欠場者」に選手名（例：〇〇 [🏥], △△ [🩹]）がある場合、その主力が欠場したことが試合にどう影響したか（例：「エース姫川[🏥]抜きでよく勝ったわ」「〇〇が[🩹]でいないのが響いたな」）を**必ず記事に含めてください。**
${cinderellaPraiseInstruction}
- **【★登板履歴への言及】**: 「今大会の主な投手登板履歴」に情報がある場合、**「〇〇、連投じゃん」**のように、登板履歴を踏まえたコメントをすること。
- **【★今大会の成績 (最重要)】**: 「チームの背景」にある『今大会のチーム打率は.XXX』という情報を**必ずコメントに含め**、チームの好調・不振にも言及してください。
- **【★盗塁への言及 (重要)】**: 「ハイライト」や「ボックススコア」に**盗塁**が記録されていたら、その選手の足（機動力）を褒めること。
- **【★注目の打席（最重要）】**: 「試合のハイライト」に「（★注目）」マークが付いている打席があります。これが**試合のターニングポイント**です。その打席が決定的な瞬間であったとコメントしてください。
- **【次戦への言及】**: 勝者チームの「次の試合情報」（${nextOpponentText}）に触れ、「次は〇〇か…」といったコメントを必ず含めてください。`;

    } else {
        // (Bルート：詳細入力なし)
        prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下の試合結果について、それぞれのキャラクターになりきって、辛辣でリアルな短いコメントを10つ生成してください。
---
### **参考情報：静岡県高校野球の「常識」（勢力図）**
${PREFECTURE_LORE}
---
### 試合情報
- **大会:** ${tournamentYear}年度 ${tournamentName} (${tournamentBbsContext})
- **ラウンド:** ${roundName} 
- **勝利チーム**: ${winnerName} ${winnerSeedRank} (${winnerRankDesc})
- **敗北チーム**: ${loserName} ${loserSeedRank} (${loserRankDesc})
- **スコア**: ${winnerScore} - ${loserScore}
${calledGameText} 
${rivalryText} 
${injuryReport || ''}
### 次の試合情報
- **${winnerName}の次の試合**: ${nextOpponentText}
- ユーザーが語る試合の決め手: ${dbMatch.summary || 'なし'}
### チームの背景 (★チーム打率・通算盗塁含む)
- **${winnerName} ${winnerSeedRank}**: ${winnerDynamicInfo}
- **${loserName} ${loserSeedRank}**: ${loserDynamicInfo}
  - **軌跡**: ${loserJourney}

### あなたがなりきるべきキャラクターと指示
- **【★大会の文脈を反映】**: ${tournamentName}ならではの視点（例：「夏は3年生最後やな」「秋の新チームの仕上がり見えてきたな」）をコメントに含めること。
- **【★シードランク言及】**: **「第1シードさすがやな」「第5シードが負けたンゴwww」**のように、シードランクにも具体的に言及してください。
- **【★★欠場者への言及 (最重要)】**: もし「主な欠場者」に選手名（例：〇〇 [🏥], △△ [🩹]）がある場合、その主力が欠場したことが試合にどう影響したか（例：「エース姫川[🏥]抜きでよく勝ったわ」「〇〇が[🩹]でいないのが響いたな」）を**必ず記事に含めてください。**
${cinderellaPraiseInstruction}
- **【★今大会の成績 (最重要)】**: 「チームの背景」にある『今大会のチーム打率は.XXX』という情報を**必ずコメントに含め**、チームの好調・不振（例：「〇〇、今大会打率.150とかマジ？」）にも言及してください。
- **【次戦への言及】**: 勝者チームの「次の試合情報」（${nextOpponentText}）に触れ、「次は〇〇か…」といったコメントを必ず含めてください。`;
    }

    const finalPrompt = prompt + `
    
### 出力形式【最重要】
解説や前置き（「はい、コメントです」や「匿名掲示板の...」など）は一切不要です。
**必ず以下の JSON 配列形式 (\`[...]\`) のみ**で出力してください。
\`\`\`json
[
  {"personality": "匿名ファンA", "comment": "（コメント本文1）"},
  {"personality": "野球通B", "comment": "（コメント本文2）"},
  {"personality": "シード校ファン", "comment": "（コメント本文3）"},
  {"personality": "敗北チームファン", "comment": "（コメント本文4）"},
  {"personality": "冷静な分析家", "comment": "（コメント本文5）"},
  {"personality": "野次馬", "comment": "（コメント本文6）"},
  {"personality": "データ厨", "comment": "（コメント本文7）"},
  {"personality": "OB", "comment": "（コメント本文8）"},
  {"personality": "アンチ", "comment": "（コメント本文9）"},
  {"personality": "次の対戦相手ファン", "comment": "（コメント本文10）"}
]
\`\`\`
`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: finalPrompt }] }] }); 
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AIからの応答が、正しい配列形式ではありません。");
    } catch (error) {
        console.error("AI掲示板コメントの生成に失敗しました:", error);
        return [{
            id: `error-${matchId}-bbs`,
            error: true,
            title: `掲示板コメント生成エラー`,
            context: matchContext 
        }];
    }
}

/**
     * AIに代矢東応援掲示板のコメントを生成させる
     */
    async function generateDaiyaBbsComments(winnerName, loserName, dbMatch, nextOpponentInfo) {
        const isDaiyaWinner = winnerName === '静岡';
        const opponentName = isDaiyaWinner ? loserName : winnerName;
        const opponentRank = calculateRank(opponentName, tournamentState);
        const resultContext = isDaiyaWinner ? '勝利' : '敗北';
        const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
        const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;
        const score = `${winnerScore} - ${loserScore}`;
        
        const prompt = `あなたは、静岡の古豪「静岡」高校野球部の熱狂的なファンです。あなたは野球に非常に詳しく、常に冷静に試合を分析し、どうすればチームが甲子園に行けるかを考えています。
以下の試合結果について、あなたらしいコメントを5つ生成してください。

### 試合情報
- 試合結果: 静岡の${resultContext}
- 対戦相手: ${opponentName} (${getRankDescription(opponentRank)})
- スコア: ${score}

### あなたのキャラクターと指示
- あなたは生粋の野球好きで、静岡のファンが集う特設掲示板の常連です。
- **もし代矢東が勝利した場合:**
  - 喜びつつも、冷静に勝因を分析してください（例：「今日の勝因は継投のタイミングだな」「あの場面のスクイズは見事だった」）。
  - すぐに次の対戦相手に目を向け、どうすれば勝てるかの戦略を語ってください（例：「次は〇〇か…キーマンは相手の3番打者だ。徹底的にインコースを攻めるべき」）。
  - 決して浮かれず、常に甲子園への道を冷静に見据えてください。
- **もし代矢東が敗北した場合:**
  - 非常に落胆し、性格の悪さを露呈してください。
  - 敗因を厳しく追及してください（例：「なぜあの場面でピッチャーを変えなかったんだ」「監督の采配ミスだろ」）。
  - 「【悲報】静岡、今年も甲子園いけず…」のような、絶望的なスレッドタイトルを必ず一つ生成してください。
  - 来年に向けての不安や、チームの課題を辛辣に指摘してください。

### 出力形式
必ず以下のJSON配列形式で出力してください。
[
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"},
  {"personality": "静岡ファン", "comment": "（コメント本文）"}
]`;
        try {
            const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
                const rawText = result.candidates[0].content.parts[0].text;
                const commentsJson = parseJsonFromText(rawText);
                if (Array.isArray(commentsJson)) {
                    return commentsJson.map(c => ({
                        id: crypto.randomUUID(),
                        personality: c.personality,
                        text: c.comment,
                        timestamp: Date.now(),
                        replies: []
                    }));
                }
            }
            throw new Error("AIからの応答が予期した形式ではありません。");
        } catch (error) {
            console.error("代矢東 掲示板コメントの生成に失敗しました:", error);
            return [];
        }
    }

   /**
 * AIに組み合わせ決定時の掲示板の反応を生成させる
 * ★★★ 詳細な組み合わせ分析を追加した完成版 ★★★
 */
async function generateBracketReactionComments(state) {
    const { teams, seeds } = state;
    // チーム数が少ない場合はコメントを生成しない
    if (teams.length < 8) return [];

    let analysis = ''; // 組み合わせ分析を入れる変数
    let commentDirections = ''; // AIへの指示を入れる変数

    // --- トーナメント表の詳細分析ロジック ---
    const numBlocks = Math.max(1, Math.ceil(teams.length / 16)); // 64チームなら4ブロック、16チームなら1ブロック
    const blockSize = Math.floor(teams.length / numBlocks);
    const blockData = []; // 各ブロックの情報を格納 [{ name: 'A', teams: [...], strongTeams: [...], matchupsR1: [...], potentialR2: [], potentialR3: [] }, ...]
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 }; // ランクの強さ

    const getTeamRank = (teamName) => calculateRank(teamName, state); // チームランク取得関数

    for (let i = 0; i < numBlocks; i++) {
        const blockName = String.fromCharCode(65 + i);
        const startIdx = i * blockSize;
        const endIdx = (i + 1) * blockSize;
        const blockTeams = teams.slice(startIdx, endIdx);
        if (blockTeams.length === 0) continue;

        const strongTeamsInBlock = blockTeams.filter(team => {
            const rank = getTeamRank(team);
            return seeds.includes(team) || ['A', 'B'].includes(rank);
        });

        const matchupsR1 = []; // 1回戦のカード
        const potentialR2 = []; // 2回戦で当たりそうなカード
        const potentialR3 = []; // 3回戦で当たりそうなカード (64チーム時)

        // 1回戦の分析
        for (let j = 0; j < blockTeams.length; j += 2) {
            const team1 = blockTeams[j];
            const team2 = blockTeams[j + 1];
            if (!team1 || !team2) continue;
            const rank1 = getTeamRank(team1);
            const rank2 = getTeamRank(team2);
            const matchup = { team1, rank1, team2, rank2 };
            matchupsR1.push(matchup);
            // 1回戦での有力校潰し合いチェック
            if ((seeds.includes(team1) || ['A', 'B'].includes(rank1)) && (seeds.includes(team2) || ['A', 'B'].includes(rank2))) {
                matchup.isCrush = true; // 潰し合いフラグ
            }
        }

        // 2回戦以降の有力カード予測 (簡易版)
        if (blockTeams.length >= 4) {
            for (let j = 0; j < matchupsR1.length; j += 2) {
                const winner1Match = matchupsR1[j];
                const winner2Match = matchupsR1[j + 1];
                if (!winner1Match || !winner2Match) continue;
                // 各1回戦で有力な方が勝ち上がると仮定
                const potentialWinner1 = rankValues[winner1Match.rank1] >= rankValues[winner1Match.rank2] ? winner1Match.team1 : winner1Match.team2;
                const potentialWinner2 = rankValues[winner2Match.rank1] >= rankValues[winner2Match.rank2] ? winner2Match.team1 : winner2Match.team2;
                // 両方とも有力校なら2回戦の注目カード候補
                if (strongTeamsInBlock.includes(potentialWinner1) && strongTeamsInBlock.includes(potentialWinner2)) {
                    potentialR2.push(`${potentialWinner1} vs ${potentialWinner2}`);
                }
            }
        }
        // 3回戦 (64チームトーナメントの場合のみ)
        if (teams.length === 64 && blockTeams.length >= 8) {
             // 簡易的にブロック内のシード校同士が当たる可能性などをリストアップ (より詳細な予測も可能)
             const blockSeeds = strongTeamsInBlock.filter(t => seeds.includes(t));
             if (blockSeeds.length >= 2) {
                 potentialR3.push(`${blockSeeds[0]} vs ${blockSeeds[1]} (予想)`); // 例: ブロック内のシード上位2校
             }
        }


        blockData.push({
            name: blockName,
            teams: blockTeams,
            strongTeams: strongTeamsInBlock,
            matchupsR1: matchupsR1,
            potentialR2: potentialR2,
            potentialR3: potentialR3
        });
    }

    // 分析結果をテキストにまとめる
    let blockSummary = '';
    let crushR1 = []; // 1回戦潰し合いリスト
    let goodCardsR2 = []; // 2回戦好カードリスト
    let goodCardsR3 = []; // 3回戦好カードリスト

    blockData.forEach(block => {
        blockSummary += `- ${block.name}ブロック: 有力校 ${block.strongTeams.length}チーム (${block.strongTeams.join(', ') || 'なし'})\n`;
        block.matchupsR1.forEach(m => {
            if (m.isCrush) {
                crushR1.push(`${block.name}ブロック: ${m.team1}(${m.rank1}) vs ${m.team2}(${m.rank2})`);
            }
        });
        if (block.potentialR2.length > 0) {
            goodCardsR2.push(...block.potentialR2.map(card => `${block.name}ブロック: ${card}`));
        }
         if (block.potentialR3.length > 0) {
            goodCardsR3.push(...block.potentialR3.map(card => `${block.name}ブロック: ${card}`));
        }
    });

    // 死のブロックと恵まれたブロックを判定
    blockData.sort((a, b) => b.strongTeams.length - a.strongTeams.length);
    const deathBlock = blockData[0];
    const blessedBlock = blockData[blockData.length - 1];

    analysis = `夏の選手権、組み合わせ決定！ 各ブロックの有力校:\n${blockSummary}`;
    analysis += `\n--- 詳細分析 ---\n`;
    analysis += `◆ 死のブロック: ${deathBlock.name}ブロック (有力校 ${deathBlock.strongTeams.length}チーム)\n`;
    analysis += `◆ 恵まれたブロック: ${blessedBlock.name}ブロック (有力校 ${blessedBlock.strongTeams.length}チーム)\n`;
    if (crushR1.length > 0) {
        analysis += `◆ 1回戦での有力校潰し合い:\n${crushR1.map(c => `  - ${c}`).join('\n')}\n`;
    } else {
        analysis += `◆ 1回戦での有力校同士の直接対決はなし。\n`;
    }
    if (goodCardsR2.length > 0) {
        analysis += `◆ 勝ち上がれば2回戦で実現しそうな好カード:\n${goodCardsR2.map(c => `  - ${c}`).join('\n')}\n`;
    }
     if (goodCardsR3.length > 0) {
        analysis += `◆ 勝ち上がれば3回戦で実現しそうな好カード:\n${goodCardsR3.map(c => `  - ${c}`).join('\n')}\n`;
    }

    commentDirections = `
- 分析結果に基づき、「死のブロック」に入ったチームへの同情や、「恵まれたブロック」への羨望コメント。
- 「1回戦の潰し合い」カードについて、「もったいない」「初戦から熱い」などの反応。
- 「2回戦・3回戦の好カード」予想について、「〇〇ブロックは3回戦が事実上の決勝だな」「△△ vs □□が見たい！」などの期待コメント。
- 自分の応援するチームがどのブロックに入り、勝ち上がりはどうなりそうか、という個人的な視点でのコメント。
- シード校が順当に勝ち上がるのか、ノーシードのダークホースが波乱を起こすのか、といった大会全体の展望。`;
    // --- ここまでが分析ロジック ---

    // --- プロンプトの組み立て (分析結果を反映) ---
    const prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
以下のトーナメントの組み合わせ分析を読んで、ファンらしいリアルな短いコメントを**7～10個**生成してください。

### 組み合わせ分析結果
${analysis}

### コメントの方向性 (上記の分析結果を踏まえて)
${commentDirections}

### 出力形式
必ず以下のJSON配列形式で出力してください。
[
  {"personality": "匿名ファンA", "comment": "（コメント本文）"},
  {"personality": "野球通B", "comment": "（コメント本文）"},
  {"personality": "悲観的なファンC", "comment": "（コメント本文）"}
]`; // personalityは適当に変えてOK

    // --- AIへのリクエストと結果の処理 (変更なし) ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                // 順序を保持しつつ、personalityを少しランダムにする
                const personalities = ["風吹けば名無し", "＠実況は実況板で", "甲子園大好き芸人", "データ厨", "OBのおっちゃん"];
                return commentsJson.map((c, index) => ({
                    id: crypto.randomUUID(),
                    // 元の personality を使いつつ、少しバリエーションを加える
                    personality: `${index + 1}: ${c.personality || personalities[Math.floor(Math.random() * personalities.length)]}`,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI組み合わせ反応コメントの生成に失敗しました:", error);
        return []; // エラー時は空配列を返す
    }
}
    
/**
 * ユーザーのコメント一つに対して、複数のAIファンからの返信を一度に生成する
 * (★チーム「通算」盗塁への言及指示を追加した最終版)
 * (★★ 故障者リストの「重要度」への言及を指示するよう修正 ★★)
 */
async function generateMultipleReplies(userCommentText) {
    const conversationHistory = `あなた: 「${userCommentText}」`;

    // --- AIに与える「知識」の部分を作成（完全版） ---
    const mentionedTeams = new Set();
    const mentionedPlayers = new Set(); 

    INITIAL_TEAM_POOL.forEach(team => {
        if (userCommentText.includes(team)) {
            mentionedTeams.add(team);
            const detailedData = DETAILED_TEAM_DATA[team];
            if (detailedData) {
                detailedData.players.forEach(p => mentionedPlayers.add({name: p.name, team: team}));
            }
        } else {
            const detailedData = DETAILED_TEAM_DATA[team];
            if(detailedData) {
                detailedData.players.forEach(p => {
                    if (userCommentText.includes(p.name)) {
                        mentionedPlayers.add({name: p.name, team: team});
                    }
                });
            }
        }
    });

    let teamInfoPromptPart = '### 参考情報：関連チームと選手の状況\n';
    
    // チーム全体の状況 (★ここでチーム打率・通算盗塁が取得される)
    mentionedTeams.forEach(teamName => {
        const teamData = TEAM_DATA[teamName];
        const teamRecord = tournamentState.teamRecords[teamName];
        const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord); 
        const fate = getTeamFateSummary(teamName);
        teamInfoPromptPart += `- **${teamName}**: ${dynamicInfo} (今大会の状況: ${fate})\n`;
    });
    
    // ▼▼▼ ★★★ Gamelog取得ロジックに置き換え ★★★ ▼▼▼
    // 会話全体（親コメント＋あなたの返信）から選手名をスキャン
    const fullConversationText = `${userCommentText}`; // ユーザーのコメントのみでスキャン
    teamInfoPromptPart += formatPlayerGamelogsForPrompt(mentionedTeams, fullConversationText);
    // ▲▲▲
// ▲▲▲ 置き換えここまで ▲▲▲
    // --- プロンプト作成 ---
    const prompt = `あなたは、匿名掲示板に集う、様々な立場の高校野球ファンです。
ユーザー「あなた」の投稿した以下のコメントに対し、4人の異なるキャラクターとして返信してください。
### **ユーザーのコメント**: 「${userCommentText}」
### **現在の大会状況**: ${getTournamentStatusSummary()}
${teamInfoPromptPart}
### **指示**:
- 各キャラクターの返信は、必ずユーザーのコメント内容に直接関連していること。
- **【重要】**: あなたの知識である「参考情報」を最大限に活用し、具体的なチーム状況や**個人成績**に触れながら、的確な返信をすること。
- **【★Gamelogの活用 (最重要)】**:
    - 「参考情報：今大会の主な選手成績履歴」に、言及された選手の**試合ごとの詳細な履歴 (Gamelog)** が含まれています。
    - あなたの返信は、この**Gamelog**を基に、以下の点を分析してください。
    - **好不調の波**: 「3試合連続ヒット中」「10打数ノーヒット」など、選手の**「調子の波」**を分析すること。
    - **対戦相手の質**: 「格下[E]相手にしか打ってない」「Aランク[A]投手から打った」など、**「相手の質」**を分析すること。
    - **役割**: 「代打で結果を出している」「1番に抜擢されてから好調」など、**「役割」**を分析すること。
    - **登板間隔**: 「連投」「中1日」など、**「投手のコンディション」**を分析すること。
- **【★今大会の成績 (重要)】**:
    - 「参考情報」に**『今大会のチーム打率は.XXX』**という情報が含まれている場合、それにも触れ、チーム全体の好調・不振について言及すること。
- **【★通算盗塁への言及 (裁量)】**:
    - 「参考情報」に**『(参考: ... 通算 Y 盗塁)』**という情報が含まれている場合、必要に応じてそのチームの機動力にも言及すること。
- **【★★ 欠場者への言及 (最重要) ★★】**: もし「参考情報」に「主な欠場者」（例：〇〇 [🏥] (主力), △△ [🩹] (控え)）に関する情報がある場合、ユーザーのコメントがその**欠場**に関連している場合は、その選手の**重要度（主力か控えか）**に応じて、反応の深刻度を変えてください。（例：『エース姫川(主力)の離脱はヤバすぎる』『鈴木(控え)の怪我は痛いが、まぁ...』）
- **【注意】**: まだ大会序盤である（例：2試合しか終わっていない）ことを考慮し、「本塁打が少ない」といった早計な批判は避けること。
---
---### **ステップ4：出力形式**
【最重要】必ず以下のJSON配列形式"のみ"で出力すること。解説や前置きは一切不要です。
[
    {"personality": "熱狂的なファン", "comment": "（コメント本文）"},
    {"personality": "上から目線の解説者", "comment": "（コメント本文）"},
    {"personality": "アンチ", "comment": "（コメント本文）"},
    {"personality": "ライバル校のファン", "comment": "（コメント本文）"}
]`;
    
    // --- 4. Call AI and Process Response ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map(c => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now(),
                    replies: []
                }));
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AI multi-reply generation failed:", error);
        return [];
    }
}

/**
 * (ホームページ用) 2024年決勝 (283 vs 菊川) の架空ボックススコアHTMLを生成する
 */
function generate2024FinalBoxScore() {
    const team1 = "常葉菊川"; // 先攻
    const team2 = "283学園";  // 後攻
    const score1 = 2;
    const score2 = 5;

    // --- 1. イニングスコアボード ---
    const scoreBoardHtml = `
        <table class="boxscore-table">
            <thead class="inning-header">
                <tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>計</th><th>H</th><th>E</th></tr>
            </thead>
            <tbody>
                <tr>
                    <td class="team-name">${team1}</td>
                    <td class="score-cell">1</td><td class="score-cell">0</td><td class="score-cell">1</td>
                    <td class="score-cell">0</td><td class="score-cell">0</td><td class="score-cell">0</td>
                    <td class="score-cell">0</td><td class="score-cell">0</td><td class="score-cell">0</td>
                    <td class="total-score">${score1}</td>
                    <td class="total-score">6</td>
                    <td class="total-score">1</td>
                </tr>
                <tr>
                    <td class="team-name">${team2}</td>
                    <td class="score-cell">0</td><td class="score-cell">0</td><td class="score-cell">2</td>
                    <td class="score-cell">0</td><td class="score-cell">1</td><td class="score-cell">0</td>
                    <td class="score-cell">2</td><td class="score-cell">0</td><td class="score-cell">X</td>
                    <td class="total-score">${score2}</td>
                    <td class="total-score">10</td>
                    <td class="total-score">0</td>
                </tr>
            </tbody>
        </table>
    `;

    // --- 2. 常葉菊川 (先攻) ---
    const team1Html = `
        <h3 class="text-xl font-bold mt-6 mb-2 text-gray-800">${team1}</h3>
        <table class="batting-stats-table">
            <thead>
                <tr>
                    <th class="pos"></th><th class="player">選手名</th>
                    <th class="at-bat">打</th><th class="runs">得</th><th class="hits">安</th><th class="rbi">点</th>
                    <th class="so">三</th><th class="walks">四</th><th class="results">打席結果</th>
                </tr>
            </thead>
            <tbody>
                <tr><td class="pos">遊</td><td class="player">1. 坂本 [3年]</td><td class="at-bat">4</td><td class="runs">1</td><td class="hits">1</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">中安, 三振, 遊ゴ, 二飛</td></tr>
                <tr><td class="pos">中</td><td class="player">2. 森 [2年]</td><td class="at-bat">4</td><td class="runs">1</td><td class="hits">1</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">投ゴ, 左安, 中飛, 三ゴ</td></tr>
                <tr><td class="pos">右</td><td class="player">3. 岡田 [3年]</td><td class="at-bat">4</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">1</td><td class="so">1</td><td class="walks">0</td><td class="results">中安①, 三ゴ, 三振, 左飛</td></tr>
                <tr><td class="pos">三</td><td class="player">4. 近藤 [3年]</td><td class="at-bat">4</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">二ゴ, 遊ゴ, 中安, 二飛</td></tr>
                <tr><td class="pos">捕</td><td class="player">5. 土方 [3年]</td><td class="at-bat">4</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">2</td><td class="walks">0</td><td class="results">三振, 二ゴ, 三振, 一ゴ</td></tr>
                <tr><td class="pos">一</td><td class="player">6. 宮本 [3年]</td><td class="at-bat">4</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">1</td><td class="so">1</td><td class="walks">0</td><td class="results">三振, 中安①, 遊ゴ, 一ゴ</td></tr>
                <tr><td class="pos">左</td><td class="player">7. 上泉 [3年]</td><td class="at-bat">3</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">二ゴ, 左飛, 遊ゴ</td></tr>
                <tr class="sub-player"><td class="pos">打</td><td class="player">└ 疋田 [2年]</td><td class="at-bat">1</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">三振</td></tr>
                <tr><td class="pos">二</td><td class="player">8. 柳生 [2年]</td><td class="at-bat">3</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">左飛, 遊安, 二ゴ</td></tr>
                <tr><td class="pos">投</td><td class="player">9. 沖田 [3年]</td><td class="at-bat">2</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">投ゴ, 一ゴ</td></tr>
                <tr class="sub-player"><td class="pos">投</td><td class="player">└ 拝 [3年]</td><td class="at-bat">1</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">二ゴ</td></tr>
                <tr class="team-totals"><td class="player" colspan="2">合計</td><td class="at-bat">34</td><td class="runs">2</td><td class="hits">6</td><td class="rbi">2</td><td class="so">6</td><td class="walks">0</td><td class="results"></td></tr>
            </tbody>
        </table>
        <table class="pitching-stats-table">
            <thead><tr><th class="result"></th><th class="player">投手名</th><th class="ip">回</th><th class="bf">打者</th><th class="hits">安</th><th class="so">三</th><th class="walks">四</th><th class="runs">失</th><th class="er">自</th><th class="era">防御率</th></tr></thead>
            <tbody>
                <tr><td class="result">●</td><td class="player">沖田 (3年)</td><td class="ip">6.0</td><td class="bf">28</td><td class="hits">7</td><td class="so">5</td><td class="walks">1</td><td class="runs">3</td><td class="er">2</td><td class="era">3.00</td></tr>
                <tr><td class="result"></td><td class="player">拝 (3年)</td><td class="ip">2.0</td><td class="bf">8</td><td class="hits">3</td><td class="so">1</td><td class="walks">0</td><td class="runs">2</td><td class="er">2</td><td class="era">9.00</td></tr>
            </tbody>
        </table>
    `;

    // --- 3. 283学園 (後攻) ---
    const team2Html = `
        <h3 class="text-xl font-bold mt-6 mb-2 text-gray-800">${team2}</h3>
        <table class="batting-stats-table">
            <thead>
                <tr>
                    <th class="pos"></th><th class="player">選手名</th>
                    <th class="at-bat">打</th><th class="runs">得</th><th class="hits">安</th><th class="rbi">点</th>
                    <th class="so">三</th><th class="walks">四</th><th class="results">打席結果</th>
                </tr>
            </thead>
            <tbody>
                <tr><td class="pos">中</td><td class="player">1. 花海 咲 [2年]</td><td class="at-bat">4</td><td class="runs">1</td><td class="hits">1</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">三振, 中安, 遊ゴ, 二ゴ</td></tr>
                <tr><td class="pos">二</td><td class="player">2. 佐藤 健太 [3年]</td><td class="at-bat">4</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">三飛, 三振, 中飛, 左安</td></tr>
                <tr><td class="pos">遊</td><td class="player">3. 十王 翔希 [2年]</td><td class="at-bat">4</td><td class="runs">1</td><td class="hits">1</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">遊ゴ, 右安, 中飛, 一ゴ</td></tr>
                <tr><td class="pos">投</td><td class="player">4. 姫川 友紀 [2年]</td><td class="at-bat">3</td><td class="runs">1</td><td class="hits">1</td><td class="rbi">2</td><td class="so">0</td><td class="walks">1</td><td class="results">二ゴ, <span style="color:red;font-weight:bold;">中本②</span>, 四球, 左飛</td></tr>
                <tr class="sub-player"><td class="pos">投</td><td class="player">└ 白瀬 咲耶 [2年]</td><td class="at-bat">1</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">投ゴ</td></tr>
                <tr><td class="pos">一</td><td class="player">5. 高橋 龍 [3年] (C)</td><td class="at-bat">4</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">1</td><td class="so">1</td><td class="walks">0</td><td class="results">三振, 二ゴ, 右安①, 遊ゴ</td></tr>
                <tr><td class="pos">捕</td><td class="player">6. 有栖川 夏葉 [2年]</td><td class="at-bat">4</td><td class="runs">1</td><td class="hits">2</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">左安, 中安, 二ゴ, 遊ゴ</td></tr>
                <tr><td class="pos">三</td><td class="player">7. 田中 浩二 [3年]</td><td class="at-bat">4</td><td class="runs">1</td><td class="hits">2</td><td class="rbi">2</td><td class="so">1</td><td class="walks">0</td><td class="results">三振, 右安, <span style="color:red;font-weight:bold;">右二②</span>, 三ゴ</td></tr>
                <tr><td class="pos">左</td><td class="player">8. 渡辺 翔 [3年]</td><td class="at-bat">3</td><td class="runs">0</td><td class="hits">1</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">二ゴ, 三振, 左安</td></tr>
                <tr class="sub-player"><td class="pos">打</td><td class="player">└ 樋口 円香 [1年]</td><td class="at-bat">1</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">三振</td></tr>
                <tr><td class="pos">右</td><td class="player">9. 鈴木 一郎 [3年]</td><td class="at-bat">3</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">1</td><td class="walks">0</td><td class="results">三振, 中飛, 左飛</td></tr>
                <tr class="sub-player"><td class="pos">打</td><td class="player">└ 鈴木(1年) [1年]</td><td class="at-bat">1</td><td class="runs">0</td><td class="hits">0</td><td class="rbi">0</td><td class="so">0</td><td class="walks">0</td><td class="results">二ゴ</td></tr>
                <tr class="team-totals"><td class="player" colspan="2">合計</td><td class="at-bat">35</td><td class="runs">5</td><td class="hits">10</td><td class="rbi">5</td><td class="so">6</td><td class="walks">1</td><td class="results"></td></tr>
            </tbody>
        </table>
        <table class="pitching-stats-table">
            <thead><tr><th class="result"></th><th class="player">投手名</th><th class="ip">回</th><th class="bf">打者</th><th class="hits">安</th><th class="so">三</th><th class="walks">四</th><th class="runs">失</th><th class="er">自</th><th class="era">防御率</th></tr></thead>
            <tbody>
                <tr><td class="result">○</td><td class="player">姫川 友紀 (2年)</td><td class="ip">6.0</td><td class="bf">24</td><td class="hits">5</td><td class="so">4</td><td class="walks">0</td><td class="runs">2</td><td class="er">2</td><td class="era">3.00</td></tr>
                <tr><td class="result">Ｓ</td><td class="player">白瀬 咲耶 (2年)</td><td class="ip">3.0</td><td class="bf">10</td><td class="hits">1</td><td class="so">1</td><td class="walks">0</td><td class="runs">0</td><td class="er">0</td><td class="era">0.00</td></tr>
            </tbody>
        </table>
    `;

    return scoreBoardHtml + team1Html + team2Html;
}
// ▲▲▲ 新規追加ここまで ▲▲▲

/**
 * AIにナムコグループからのお知らせを生成させる
 * (★BYEの場合は「2回戦から登場」とアピールする修正版)
 */
async function generateNamcoNews(state, type, matchData = null) {
    const namcoSchools = ["初星学園", "765総合高校", "283学園", "美城学園", "283学園B"];
    let prompt = '';

    if (type === 'bracket') {
        const participatingSchools = state.teams.filter(t => namcoSchools.includes(t));
        if(participatingSchools.length === 0) return null;

        const matchups = participatingSchools.map(school => {
            const schoolIndex = state.teams.indexOf(school);
            if (schoolIndex === -1) return null;
            
            // 対戦相手（隣のインデックス）を特定
            const opponentIndex = schoolIndex % 2 === 0 ? schoolIndex + 1 : schoolIndex - 1;
            const opponentName = state.teams[opponentIndex];
            
            // ★★★ 修正箇所：BYE判定 ★★★
            if (opponentName === '(BYE)') {
                return `- ${school}: 1回戦は対戦相手なし（不戦勝）。2回戦からの登場となります。`;
            } else {
                return `- ${school}: 初戦は ${opponentName} と対戦します。`;
            }
            // ★★★ 修正ここまで ★★★
            
        }).filter(item => item !== null).join('\n');

        prompt = `あなたはナムコグループの広報担当者です。
夏の高校野球選手権大会の組み合わせが決定しました。
以下の情報に基づき、グループの公式サイトに掲載する、プロフェッショナルで丁寧な「お知らせ」記事を生成してください。

### 各校の初戦の組み合わせ状況
${matchups}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）組み合わせ決定のお知らせ」とする。
- 本文では、抽選会が行われたことと、上記の組み合わせが決定したことを報告してください。
- **【重要】不戦勝（BYE）のチームについて:**
  - 「規定により1回戦は免除され、2回戦からの登場となる」ことを明記してください。
  - 「日程的な余裕を活かし、万全の状態で初戦（2回戦）に臨みます」といったポジティブな表現を含めてください。
- 最後に、系列校野球部への応援をお願いする言葉で締めくくる。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}`;

    } else if (type === 'matchResult') {
        // (試合結果のお知らせロジックは変更なし)
        const { winnerName, loserName, dbMatch } = matchData;
        const isCivilWar = (winnerName === '283学園' && loserName === '283学園B') || (winnerName === '283学園B' && loserName === '283学園');

        const namcoTeam = namcoSchools.includes(winnerName) ? winnerName : loserName;
        const opponent = namcoSchools.includes(winnerName) ? loserName : winnerName;
        const result = namcoSchools.includes(winnerName) ? '勝利' : '敗北';
        const score = namcoSchools.includes(winnerName) ? `${dbMatch.score1}-${dbMatch.score2}` : `${dbMatch.score2}-${dbMatch.score1}`;

        prompt = `あなたはナムコグループの広報担当者です。
本日行われた、夏の高校野球選手権大会の試合結果について、公式サイトに掲載する「お知らせ」記事を生成してください。

### 試合情報
- 系列校: ${namcoTeam}
- 対戦相手: ${opponent}
- 結果: ${namcoTeam}の${result}
- スコア: ${score}

### 記事のポイント
- タイトルは「野球部（夏の選手権大会）試合結果のお知らせ」とする。
- 本文では、まず試合が行われたことと、結果を簡潔に報告する。
- **もし勝利した場合:**
  - 応援への感謝を述べ、次の試合への意気込みを語る（例：「次戦もチーム一丸となって勝利を目指します」）。
- **もし敗北した場合:**
  - 選手たちの健闘を称え、応援への感謝を深く述べる（例：「皆様の熱い声援が、選手の力となりました。心より感謝申し上げます」）。
  - 新チームでの再起を誓う言葉で締めくくる。
- 全体的に、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式
以下のJSON形式で、タイトルと本文を生成してください。
{"title": "記事のタイトル", "body": "記事の本文（改行は\\nを使用）"}`;
    }

    if (!prompt) return null;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const newsJson = parseJsonFromText(rawText);
            if (newsJson) {
                return { ...newsJson, timestamp: Date.now() };
            }
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("ナムコニュースの生成に失敗しました:", error);
        return null;
    }
}

/**
 * AIが生成した新聞データからHTMLを生成する
 * (★sinbun.txtを参考に、Webニュース記事風のレイアウトに変更)
 */
function createNewspaperHtml(articleData, matchData) {
    const { winnerName, loserName, dbMatch, matchId } = matchData;
    const idParts = matchId.split('-');
    // 128チーム制(7ラウンド)に対応
    const roundNum = idParts[0] === 'F' ? Math.log2(tournamentState.teams.length) : parseInt(idParts[1].slice(1));
    const isLateRound = roundNum >= 5; // R5(準々決勝)以降
    const containerClass = isLateRound ? 'newspaper-late' : 'newspaper-early';
    const winnerScore = dbMatch.team1 === winnerName ? dbMatch.score1 : dbMatch.score2;
    const loserScore = dbMatch.team1 === winnerName ? dbMatch.score2 : dbMatch.score1;

    // AIが生成した本文(article.body)を、最初の段落（リード文）と残りの本文に分割する
    let bodyText = articleData.body.replace(/\\n/g, '\n');
    let leadSentence = articleData.title; // デフォルトではサブ見出し(h2)は記事タイトル
    let mainBody = bodyText;

    const firstParagraphBreak = bodyText.indexOf('\n\n'); // 最初の空行（段落区切り）を探す
    if (firstParagraphBreak !== -1) {
        // 最初の空行までをリード文とする
        leadSentence = bodyText.substring(0, firstParagraphBreak).trim();
        // それ以降を本文とする
        mainBody = bodyText.substring(firstParagraphBreak).trim();
    } else {
        // 段落区切りがない場合、AIが生成した記事タイトル(article.title)をリード文として使用
        mainBody = bodyText;
        leadSentence = articleData.title;
    }
    
    // sinbun.txt [cite: 63, 65] を参考に、写真キャプションを生成
    // AIが生成した newspaperData からキャプションを取得
    const photoCaption = articleData.newspaperData?.photoCaption || `[${getRoundNameFromMatchId(matchId)}の様子]`;

    // sinbun.txt  を参考に、AIが生成した大見出し (newspaperData.mainHeadline) を取得
    const mainHeadline = articleData.newspaperData?.mainHeadline || `${winnerName}、${loserName}を下し${getRoundNameFromMatchId(matchId)}突破`;

    return `
        <div class="newspaper-container ${containerClass}">
            <div class="newspaper-header">
                <h2 class="newspaper-title">熱闘スポーツ</h2>
                <p class="newspaper-date">${new Date(articleData.timestamp).toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
            </div>
            
            <div class="newspaper-content">
                <h1 class="newspaper-main-headline">${mainHeadline}</h1>
                
                <h2 class="newspaper-sub-headline">${leadSentence}</h2>
                
                ${isLateRound ? `
                    <figure class="newspaper-image-wrapper">
                        <div class="newspaper-image-placeholder">${photoCaption}</div>
                        <figcaption class="newspaper-image-caption">${photoCaption}（カメラ・AI記者）</figcaption>
                    </figure>
                ` : ''}
                
                <p class="newspaper-text">${mainBody.replace(/\n/g, '<br><br>')}</p>
                
                <div class="newspaper-score-box">
                    <h3>${getRoundNameFromMatchId(matchId)} 最終スコア</h3>
                    <p class="score">${winnerName} ${winnerScore} - ${loserScore} ${loserName}</p>
                </div>
            </div>
        </div>
    `;
}

/**
 * [UPDATED] AIスポーツ新聞記事の生成
 * (★チーム数に応じてラウンド名を動的に判定)
 */
async function generateSportsNewspaper(roundNumber) {
    // ★★★ 修正箇所: チーム数からラウンド名マップを作成 ★★★
    const numTeams = tournamentState.teams.length; 
    const finalRound = Math.log2(numTeams); // 128->7, 64->6

    const roundNameMap = {
        [finalRound]: '決勝',
        [finalRound-1]: '準決勝',
        [finalRound-2]: '準々決勝',
        [finalRound-3]: '4回戦' // 甲子園の場合は3回戦になるが、実質ベスト16決定戦
    };
    // ★★★ 修正ここまで ★★★

    const roundName = roundNameMap[roundNumber] || `${roundNumber}回戦`;
    // R1, R2などマップにないラウンドはスキップ(nullを返す)
    // ただし甲子園(64チーム)の場合、[finalRound-3]は「3回戦」になるため、発行対象とする
    if (!roundNameMap[roundNumber]) return null; 

    const matchIdsInRound = Object.keys(tournamentState.matches).filter(id => 
        (id.includes(`-R${roundNumber}-`)) || (roundNumber === finalRound && id.includes('F-R1-'))
    );
    const results = matchIdsInRound.map(id => tournamentState.matches[id]);

    const resultsText = results.map(match => {
        if (!match.winner) return null;
        const winnerRank = getRankDescription(calculateRank(match.winner, tournamentState));
        const loser = match.team1 === match.winner ? match.team2 : match.team1;
        if (!loser) return null;
        const loserRank = getRankDescription(calculateRank(loser, tournamentState));
        const winnerScore = match.team1 === match.winner ? match.score1 : match.score2;
        const loserScore = match.team1 === match.winner ? match.score2 : match.score1;
        return `${winnerRank}・${match.winner}が${loserRank}・${loser}に ${winnerScore}-${loserScore} で勝利。`;
    }).filter(Boolean).join('\n');

    if (!resultsText) return null;

    const prompt = `あなたは、読者の購買意欲を掻き立てるのが得意な、日本のスポーツ新聞の編集長です。
現在、高校野球の${tournamentState.tournamentYear}年度${tournamentNameMap[tournamentState.currentTournament]}が進行中です。${roundName}の全試合が終了しました。
以下の試合結果を基に、最も衝撃的でドラマチックな出来事を一つ選び出し、それに対応する新聞の一面を飾るテキストを生成してください。

### ${roundName} 全試合結果
${resultsText}

### あなたが作成するテキスト
以下の4つの要素を、JSON形式で出力してください。
1.  **mainHeadline**: 最も重要な結果を伝える、短く、衝撃的で、扇情的な大見出し。（例：「怪物散る！」「王者、盤石の決勝へ」）
2.  **subHeadline**: mainHeadlineを補足する、少し詳しい小見出し。
3.  **photoCaption**: その日のハイライトシーンを切り取った架空の写真に対する、情景が目に浮かぶようなキャプション。（例：「あと一歩及ばず、マウンドに崩れ落ちる〇〇高校のエース△△」）
4.  **otherResults**: その他の注目すべき結果を2つ、簡潔にまとめたもの。

### 出力形式
{"mainHeadline": "...", "subHeadline": "...", "photoCaption": "...", "otherResults": ["...", "..."]}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const newspaperData = parseJsonFromText(rawText);
            if (newspaperData) return newspaperData;
        }
        throw new Error("AI newspaper response format error.");
    } catch (error) {
        console.error("AI newspaper generation failed:", error);
        return null;
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

   /**
     * ラウンド終了時に新聞発行などのイベントを処理する
     * (★128チーム制＝7ラウンド制に対応)
     */
    async function handleRoundCompletion(roundNumber) {
        // ★★★ ここからが修正箇所 ★★★
        const numTeams = tournamentState.teams.length; // 128
        const finalRound = Math.log2(numTeams); // 7

        // R4, R5, R6, R7(決勝) で発行
        const significantRounds = [finalRound, finalRound - 1, finalRound - 2, finalRound - 3].filter(r => r > 0);
        if (!significantRounds.includes(roundNumber)) return;

        // ★ 既に「この大会の」「このラウンド」の新聞が発行済みかチェック
        const alreadyExists = tournamentState.news.some(n => 
            n.roundNumber === roundNumber && 
            n.isNewspaper &&
            n.context?.tournament === tournamentState.currentTournament // 大会キーもチェック
        );
        if (alreadyExists) return;

        const newspaperData = await generateSportsNewspaper(roundNumber);
        if (newspaperData) {
            // 128チーム制(7ラウンド)のラウンド名マップ
            const roundNameMap = {
                [finalRound]: '決勝',       // R7
                [finalRound-1]: '準決勝',   // R6
                [finalRound-2]: '準々決勝', // R5
                [finalRound-3]: '4回戦'     // R4
            };
            // ★★★ 修正ここまで ★★★
            const roundName = roundNameMap[roundNumber] || `${roundNumber}回戦`;

            tournamentState.news.push({
                title: `【熱闘新聞】${roundName}特集号が発行されました！`,
                body: newspaperData.subHeadline,
                timestamp: Date.now(),
                isNewspaper: true,
                roundNumber: roundNumber,
                newspaperData: newspaperData,
                context: { // ★ 再生成や識別用にコンテキストを追加
                    isNewspaper: true,
                    round: roundNumber,
                    tournament: tournamentState.currentTournament
                }
            });
            renderNews(tournamentState.news);
            saveState();
        }
    }
// ▲▲▲ 置き換えここまで ▲▲▲

    /**
     * 新聞モーダルを描画する
     */
    function renderNewspaperModal(newspaperData) {
        const { mainHeadline, subHeadline, photoCaption, otherResults, imageUrl } = newspaperData;
        
        const imageHtml = imageUrl 
            ? `<img src="${imageUrl}" alt="${photoCaption}" class="w-full h-auto my-4 border">` 
            : `<div class="newspaper-image-placeholder my-4"><p class="text-sm p-4">${photoCaption}</p></div>`;

        newspaperModalBody.innerHTML = `
            <div class="newspaper-container newspaper-late">
                <div class="newspaper-header">
                    <h2 class="newspaper-title">熱闘スポーツ</h2>
                    <p class="newspaper-date">${new Date().toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric' })}</p>
                </div>
                <div class="newspaper-content">
                    <h1 class="newspaper-main-headline">${mainHeadline}</h1>
                    <div class="newspaper-body-content">
                        <h2 class="newspaper-sub-headline">${subHeadline}</h2>
                        ${imageHtml}
                        <div class="newspaper-score-box">
                            <h3>その他の主な結果</h3>
                            ${otherResults.map(r => `<p>${r}</p>`).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

  /**
 * AIに掲示板の返信を生成させる（最新の環境に適合した最終版）
 * (★チーム「通算」盗塁への言及指示を追加した最終版)
 */
async function generateBbsReply(parentCommentId, userReplyText, bbsType, aiPersona, context) {
    const commentSource = bbsType === 'general' ? tournamentState.bbsComments : tournamentState.daiyaBbsComments;
    const parentComment = findCommentById(commentSource, parentCommentId);
    if (!parentComment) return null;

    // --- 1. AIに渡すための「文脈」を収集する ---
    const userReplyObject = { id: 'temp_user_reply', personality: 'あなた', text: userReplyText, replies: [] };
    parentComment.replies.push(userReplyObject);
    const conversationHistory = formatConversationHistory(commentSource, 'temp_user_reply');
    parentComment.replies.pop();

    const mentionedTeams = new Set();
    conversationHistory.split('\n').forEach(line => {
        INITIAL_TEAM_POOL.forEach(team => {
            if (line.includes(team)) {
                mentionedTeams.add(team);
            }
        });
    });

    // --- 2. AIに与える「知識」の部分を作成する ---
    let teamInfoPromptPart = '';
    if (mentionedTeams.size > 0) {
        teamInfoPromptPart = '### 関連チームの背景情報\n';
        mentionedTeams.forEach(teamName => {
            const teamData = TEAM_DATA[teamName];
            const teamRecord = tournamentState.teamRecords[teamName];
            const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord); // ★打率・通算盗塁入りの情報を取得
            teamInfoPromptPart += `- **${teamName}**: ${dynamicInfo}\n`;
        });
    }
    
    // ▼▼▼ ★★★ Gamelog取得ロジックを追加 ★★★ ▼▼▼
    // 会話全体（親コメント＋あなたの返信）から選手名をスキャン
    const fullConversationText = `${parentComment.text}\n${userReplyText}`;
    teamInfoPromptPart += formatPlayerGamelogsForPrompt(mentionedTeams, fullConversationText);
    // ▲▲▲
// ▲▲▲ 置き換えここまで ▲▲▲
    // --- 3. 最終的なプロンプトを組み立てる（★脱線防止策を適用） ---
    const prompt = `あなたは、匿名掲示板のキャラクター「${aiPersona}」です。あなたは今、他のユーザーと日本の高校野球について会話しています。
あなたの唯一の仕事は、会話の流れとあなたの知識に基づき、キャラクターになりきって自然な返信をすることです。野球以外の話題には絶対に触れないでください。
---
### **ステップ1：現在の会話状況を理解する**
- **これまでの会話の流れ**:
${conversationHistory}
- **あなたのキャラクター**: ${aiPersona}
- **現在の大会状況**: ${context.tournamentSummary}
---
### **ステップ2：関連情報を思い出す**
${teamInfoPromptPart}
---
### **ステップ3：返信する**
上記のステップ1と2の情報を元に、会話の最後の発言「${userReplyText}」に対して、あなたのキャラクターとして最も自然で的を射た返信を生成してください。
- **指示**:
  - 必ず相手の発言に直接応答することから始めること。
  - 応答の根拠として、ステップ2の「関連情報」を自然な形で会話に含めること。
  - **【★Gamelogの活用 (最重要)】**:
      - 「参考情報：今大会の主な選手成績履歴」に、言及された選手の**試合ごとの詳細な履歴 (Gamelog)** が含まれています。
      - あなたの返信は、この**Gamelog**を基に、以下の点を分析してください。
      - **好不調の波**: 「3試合連続ヒット中」「10打数ノーヒット」など、選手の**「調子の波」**を分析すること。
      - **対戦相手の質**: 「格下[E]相手にしか打ってない」「Aランク[A]投手から打った」など、**「相手の質」**を分析すること。
      - **登板間隔**: 「連投」「中1日」など、**「投手のコンディション」**を分析すること。
  - **【★今大会の成績 (重要)】**:
      - 「参考情報」に**『今大会のチーム打率は.XXX』**という情報が含まれている場合、それにも触れ、チーム全体の好調・不振について言及すること。
  - **【★通算盗塁への言及 (裁量)】**:
      - 「参考情報」に**『(参考: ... 通算 Y 盗塁)』**という情報が含まれている場合、必要に応じてそのチームの機動力にも言及すること。
// ▲▲▲ 置き換えここまで ▲▲▲
  - 相手が話していない無関係なチームや試合の情報を一方的に解説しないこと。
---
### **ステップ4：出力形式**
【最重要】必ず以下のJSON形式"のみ"で出力すること。解説や前置きは一切不要です。
{"comment": "（あなたの返信本文）"}`;
    
    // --- 4. AIを呼び出し、結果を処理する ---
    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const replyJson = parseJsonFromText(rawText);
            if (replyJson && replyJson.comment) {
                return {
                    id: crypto.randomUUID(),
                    personality: aiPersona,
                    text: replyJson.comment,
                    timestamp: Date.now(),
                    replies: []
                };
            }
        }
        throw new Error("AIの応答形式が不正です。");
    } catch (error) {
        console.error("AI返信コメントの生成に失敗しました:", error);
        return null;
    }
}


/**
     * AIからの応答テキストからJSONオブジェクトを安全に抽出する
     */
    function parseJsonFromText(text) {
        try {
            const cleanedText = text.replace(/```json/g, '').replace(/```/g, '').trim();
            const jsonMatch = cleanedText.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
        } catch (e) {
            console.error("Failed to parse JSON from text:", text, e);
        }
        return null;
    }

    /**
     * リトライ機能付きでバックエンドAPI(Netlify Function)を呼び出す
     */
    async function fetchWithRetry(payload, maxRetries = 3) {
        const functionUrl = '/.netlify/functions/generateApiContent'; // Netlify Functionのエンドポイント
        let lastError;

        for (let i = 0; i < maxRetries; i++) {
            try {
                const response = await fetch(functionUrl, {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    return response;
                }
                
                if (response.status >= 400 && response.status < 500 && response.status !== 429) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error}`);
                }

                lastError = new Error(`API Error: ${response.status}`);
                const delay = Math.pow(2, i) * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));

            } catch (error) {
                lastError = error;
                const delay = Math.pow(2, i) * 1000;
                if (i < maxRetries - 1) {
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        throw lastError;
    }

    /**
     * チームランク（A～E）から説明的な文字列を取得する
     */
    function getRankDescription(rank) {
        switch(rank) {
            case 'A': return '名門校';
            case 'B': return '強豪校';
            case 'C': return '中堅校';
            case 'D': return '発展途上のチーム';
            case 'E': return '挑戦者';
            default: return '実力不明';
        }
    }
    
/**
     * [NEW HELPER] 選手の「今大会」の通算成績を計算する
     */
    function calculateCurrentTournamentStats(battingGamelogs = [], pitchingGamelogs = [], excludeMatchId) {
        const currentTournamentKey = tournamentState.currentTournament;
        let stats = { AB: 0, H: 0, AVG: 0, IP: 0, ER: 0, ERA: Infinity };
        const isCurrentTournamentLog = (log) => {
            if (log.matchId === excludeMatchId) return false;
            const logRound = log.round || '';
            if (currentTournamentKey === 'summer') return logRound.includes('回戦') || logRound.includes('決勝');
            if (currentTournamentKey === 'summer_koshien') return true; // 甲子園
            if (currentTournamentKey === 'autumn') return logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
            if (currentTournamentKey === 'spring') return logRound.includes('地区') || logRound.includes('回戦') || logRound.includes('決勝');
            return false;
        };
        if (battingGamelogs) {
            battingGamelogs.filter(isCurrentTournamentLog).forEach(log => {
                stats.AB += log.stats?.ab || 0;
                stats.H += log.stats?.h || 0;
            });
            stats.AVG = (stats.AB > 0) ? (stats.H / stats.AB) : 0;
        }
        if (pitchingGamelogs) {
            pitchingGamelogs.filter(isCurrentTournamentLog).forEach(log => {
                stats.IP += parseFloat(log.ip) || 0;
                stats.ER += parseInt(log.er) || 0;
            });
            stats.ERA = (stats.IP > 0) ? ((stats.ER * 9) / stats.IP) : Infinity;
        }
        return stats;
    }

/**
 * [NEW] 選手の調子フラグを絵文字アイコンに変換する
 * (★「軽傷[🩹]」フラグを追加)
 */
function getPlayerConditionIcon(flag) {
    if (!flag) return "";
    
    // ★★★ 故障・体調不良 (最優先) ★★★
    if (flag === "injured" || flag === "sick") { // 重傷/病気
        return '<span class="condition-icon" title="故障中/体調不良 (起用不可)">🏥</span>';
    }
    if (flag === "minor_injury") { // 軽傷
        return '<span class="condition-icon" title="軽い怪我 (次戦起用不可)">🩹</span>';
    }
    // ★★★ 修正ここまで ★★★

    // 5段階評価
    if (flag === "peak") return '<span class="condition-icon" title="絶好調">🔥</span>';
    if (flag === "hot" || flag === "hot_streak") return '<span class="condition-icon" title="好調">👍</span>';
    if (flag === "cold" || flag === "slumping") return '<span class="condition-icon" title="不調">❄️</span>';
    if (flag === "slump") return '<span class="condition-icon" title="絶不調">🥶</span>';
    
    // 特殊フラグ
    if (flag === "fatigued") return '<span class="condition-icon" title="疲労">😓</span>';
    if (flag === "powered_up") return '<span class="condition-icon" title="一発警戒">💪</span>';
    if (flag === "clutch_hitter") return '<span class="condition-icon" title="勝負強い">✨</span>';
    if (flag === "dominant") return '<span class="condition-icon" title="圧巻">🔥</span>';
    if (flag === "crafty_pitcher") return '<span class="condition-icon" title="技巧派">👍</span>';
    if (flag === "seeking_redemption") return '<span class="condition-icon" title="要修正">❄️</span>';
    if (flag === "tough_loss" || flag === "unlucky") return '<span class="condition-icon" title="不運">😓</span>';
    
    return ""; // 'normal' や不明なフラグは何も表示しない
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
     * チーム名からシードランクの文字列 (例: "(第1シード)") を取得するヘルパー関数
     * @param {string} teamName - チーム名
     * @param {Array<object>} seeds - tournamentState.seeds (シード校のオブジェクト配列)
     * @returns {string} - "(第1シード)" または ""
     */
    function getSeedRankString(teamName, seeds) {
        if (!seeds || !teamName) return '';
        // seeds 配列が { team: "...", rank: 1 } の形式であることを前提とする
        const seedInfo = seeds.find(s => s.team === teamName);
        return seedInfo ? `(第${seedInfo.rank}シード)` : '';
    }

    /**
 * Generates a team's tournament path history, compatible with all tournament types.
 */
function getTournamentPath(teamName, startingMatchId) {
    if (!teamName) return "（不明）";
    const path = [];
    
    // Combine all matches from all tournaments into one list
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    // Determine the current round number to analyze up to that point
    const idParts = startingMatchId.split('-');
    if (idParts.length < 3) return '（地区予選突破）'; // Not a main tournament match
    let currentRoundNum = parseInt(idParts[1].slice(1));

    // Loop from the first round up to the current round
    for (let r = 1; r < currentRoundNum; r++) {
        // Find the match the team won in that round
        const matchInRound = Object.values(allMatches).find(match =>
            match.id && 
            match.id.includes(`-R${r}-`) && // Belongs to the correct round
            match.winner === teamName
        );

        if (matchInRound) {
            const opponent = matchInRound.team1 === teamName ? matchInRound.team2 : matchInRound.team1;
            const winnerScore = matchInRound.team1 === teamName ? matchInRound.score1 : matchInRound.score2;
            const loserScore = matchInRound.team1 === teamName ? matchInRound.score2 : matchInRound.score1;
            path.push(`${r}回戦 vs ${opponent} (${winnerScore}-${loserScore})`);
        }
    }

    return path.length > 0 ? path.join(' → ') : '（今大会初戦）';
}
    /**
     * AIプロンプト用に、チームの次の対戦相手情報を生成する
     */
    /**
 * Generates the next opponent info, compatible with all tournament structures.
 */
function getNextOpponentInfoForPrompt(teamName) {
    // Combine all matches from all tournaments into one list
    const allMatches = { 
        ...tournamentState.matches, 
        ...(tournamentState.autumnData?.allMatches || {}),
        ...(tournamentState.springData?.allMatches || {}) 
    };

    let latestMatch = null;
    let maxRound = -1;

    // Find the most recent game this team played in
    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        if (match.team1 === teamName || match.team2 === teamName) {
            const roundNum = match.id.includes('-R') ? parseInt(match.id.split('-')[1].slice(1)) : 0;
            if (roundNum > maxRound) {
                maxRound = roundNum;
                latestMatch = match;
            }
        }
    }

    if (!latestMatch) return "（まだ試合なし）";
    if (latestMatch.winner !== teamName) return "（この試合で敗退）";
    
    // Find the next game this team is in
    for (const matchId in allMatches) {
        const match = allMatches[matchId];
        
        // Look for a future game where this team is slotted but the opponent is not yet decided
        if ((match.team1 === teamName && !match.team2) || (match.team2 === teamName && !match.tran1)) {
             return "（次の対戦相手は未定）";
        }
        
        // Look for a future game where the opponent is known
        if (match.team1 === teamName && match.team2 && !match.winner) {
             return `次の対戦相手は${match.team2}です。`;
        }
        if (match.team2 === teamName && match.team1 && !match.winner) {
            return `次の対戦相手は${match.team1}です。`;
        }
    }

    return "（優勝、または次のステージへ）";
}
    /**
     * AIプロンプト用に、掲示板の会話履歴をフォーマットする
     */
    function formatConversationHistory(comments, targetId) {
        let history = [];
        function findPath(currentComments, currentPath) {
            for(const comment of currentComments) {
                const newPath = [...currentPath, comment];
                if(comment.id === targetId) {
                    history = newPath;
                    return true;
                }
                if(comment.replies && findPath(comment.replies, newPath)) {
                    return true;
                }
            }
            return false;
        }
        findPath(comments, []);
        return history.map(c => `${c.personality}:「${c.text}」`).join('\n');
    }

    /**
     * [UPDATED] AIプロンプト用に、現在の大会状況の要約を生成する
     * (★チーム数に応じてラウンド名を動的に判定)
     */
    function getTournamentStatusSummary() {
        if (tournamentState.currentTournament === 'autumn') {
            return `現在、${tournamentState.tournamentYear}年度 秋季大会が進行中です。フェーズ: ${tournamentState.autumnPhase}`;
        }
        
        const finalMatch = tournamentState.matches['F-R1-M1'];
        if (finalMatch?.winner) return `${finalMatch.winner}が優勝しました。`;
        if (finalMatch?.team1 && finalMatch.team2) return `決勝戦の組み合わせは ${finalMatch.team1} vs ${finalMatch.team2} です。`;
        
        // ★★★ 修正箇所: 動的なラウンドマップ作成 ★★★
        const numTeams = tournamentState.teams.length;
        const finalRound = Math.log2(numTeams); 
        
        // マップを動的に生成
        const roundNameMap = {};
        roundNameMap[finalRound] = "決勝";
        roundNameMap[finalRound - 1] = "準決勝";
        roundNameMap[finalRound - 2] = "準々決勝";
        // ★★★ 修正ここまで ★★★

        for (let r = finalRound - 1; r >= 1; r--) {
            const roundIds = Object.keys(tournamentState.matches).filter(id => id.includes(`-R${r}-`));
            // まだ勝者が決まっていない試合があるラウンドを探す
            if (roundIds.some(id => tournamentState.matches[id]?.team1 && tournamentState.matches[id]?.team2 && !tournamentState.matches[id].winner)) {
                 return `現在、${roundNameMap[r] || r + '回戦'}が進行中です。`;
            }
            // 全試合終わったラウンドの「次」を探すロジックも必要だが、
            // 簡易的に「カードが組まれている最も深いラウンド」を返すロジックで十分
        }
        
        return '大会はまもなく開始されます。';
    }
    /**
     * IDを元に、入れ子構造のコメントデータから特定のコメントを見つけ出す
     */
    function findCommentById(comments, id) {
        for (const comment of comments) {
            if (comment.id === id) return comment;
            if (comment.replies && comment.replies.length > 0) {
                const found = findCommentById(comment.replies, id);
                if (found) return found;
            }
        }
        return null;
    }

// ▼▼▼ この関数ブロックを「新規追加」(11843行目あたり) ▼▼▼

/**
 * [NEW] E/D/Cランクチームの「快進撃」を讃えるドラマチックな記事をAIに生成させる
 * (★再生成用に context への情報保存を強化)
 * @param {string} loserName - 敗退したチーム名
 * @param {string} loserRank - 敗退したチームのランク (E, D, C)
 * @param {number} roundNum - 敗退したラウンド番号 (3, 4, 5)
 * @param {object} matchContext - 試合の全コンテキスト
 * @returns {Promise<object>} - 生成された記事オブジェクト
 */
async function generateCinderellaArticle(loserName, loserRank, roundNum, matchContext) {
    const { loserJourney, winnerName, dbMatch } = matchContext;
    const loserScore = (dbMatch.team1 === loserName ? dbMatch.score1 : dbMatch.score2);
    const winnerScore = (dbMatch.team1 === loserName ? dbMatch.score2 : dbMatch.score1);
    
    const rankMap = { 'E': 'Eランク', 'D': 'Dランク', 'C': 'Cランク' };
    const roundMap = { 3: '3回戦', 4: '4回戦', 5: '準々決勝' };
    const storyTitle = `${rankMap[loserRank]}・${loserName}の快進撃、${roundMap[roundNum]}で散る。`;

    const prompt = `あなたは、情熱的で人間ドラマを描くのが得意なスポーツ記者です。
あなたは今、${tournamentState.tournamentYear}年度 夏季大会で、信じられないほどの「快進撃(シンデレラストーリー)」を見せたチームの、最後の試合を取材し終えました。
以下のデータに基づき、彼らの健闘を最大限に「褒め称える」、感動的な特集記事を執筆してください。

### 取材データ
- **主役（敗退チーム）:** ${loserName} (${rankMap[loserRank]})
- **快進撃の軌跡:** ${loserJourney}
- **最後の試合:** ${roundMap[roundNum]}、${winnerName}に ${loserScore}-${winnerScore} で敗退。
- **チームの背景:** ${TEAM_DATA[loserName]?.info || '情報なし'}
- **監督:** ${TEAM_DATA[loserName]?.coach?.name || '監督'}

### 執筆指示
1.  **タイトル:** 「${storyTitle}」のような、彼らの挑戦を讃える感動的なタイトルにしてください。
2.  **記事の焦点:** この記事の主役は**勝者ではなく、敗れた${loserName}**です。
3.  **【最重要】勝ち上がりの軌跡:**
    - 「快進撃の軌跡」(${loserJourney})を必ず記事に含めてください。
    - （例：「ノーシードのEランク校として開幕した彼ら。1回戦で〇〇を、2回戦で格上の△△を破り...」）
    - 彼らが「Eランク」や「Dランク」でありながら、ここまで勝ち上がってきたことが、どれほどの偉業であったかをドラマチックに描写してください。
4.  **最後の試合:** 今日の最後の試合が、いかに彼らが全力を出し切った素晴らしい戦いであったかを、スコア（${loserScore}-${winnerScore}）を交えて描写してください。
5.  **監督と選手のコメント:**
    - 試合後、泣き崩れる選手たち。
    - ${TEAM_DATA[loserName]?.coach?.name || '監督'}の、「選手たちは私の誇りだ。胸を張って地元に帰ろう」といった趣旨のコメントを創作してください。
    - 主将の、「ここまで来られたのは応援のおかげ。悔しいが、悔いはない」といった趣旨の涙のコメントを創作してください。
6.  **締めくくり:** 「彼らの夏は終わった。しかし、${loserName}が見せた夢は、静岡のファンの胸に確かに刻まれた」といった、彼らの挑戦を永遠に記憶するかのような、感動的な言葉で締めくくってください。

### 出力形式 (JSON)
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                return { 
                    ...article, 
                    timestamp: Date.now(),
                    // ★★★ ここからが修正箇所 ★★★
                    context: { 
                        ...matchContext, 
                        isCinderellaStory: true, 
                        loserName: loserName, // loserName を明示的に保存
                        loserRank: loserRank, // loserRank を明示的に保存
                        roundNum: roundNum    // roundNum を明示的に保存
                    }
                    // ★★★ 修正ここまで ★★★
                };
            }
        }
        throw new Error("AI cinderella response format error.");
    } catch (error) {
        console.error(`AI快進撃記事（${loserName}）の生成に失敗しました:`, error);
        return { 
            title: "快進撃 記事生成エラー", body: "AI記者との通信に失敗しました。", 
            timestamp: Date.now(), error: true, errorId: `cinderella-${matchContext.matchId}`,
            // ★★★ ここからが修正箇所 ★★★
            context: { 
                ...matchContext, 
                isCinderellaStory: true, 
                loserName: loserName, // loserName を明示的に保存
                loserRank: loserRank, // loserRank を明示的に保存
                roundNum: roundNum    // roundNum を明示的に保存
            }
            // ★★★ 修正ここまで ★★★
        };
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * [UPDATED] ラウンドが終了したかチェックし、AI新聞の生成をトリガーする
 * (★チーム数に応じて発行ラウンドを動的に判定)
 */
async function checkAndTriggerNewspaper(roundNum) {
    // ★★★ 修正箇所: チーム数から最終ラウンドを計算 ★★★
    const numTeams = tournamentState.teams.length; 
    const finalRound = Math.log2(numTeams); // 128->7, 64->6

    // 新聞を発行するラウンド：決勝、準決勝、準々決勝、その1つ前(ベスト16決定戦)
    // 128チーム制: 7, 6, 5, 4
    // 64チーム制 : 6, 5, 4, 3
    const significantRounds = [finalRound, finalRound - 1, finalRound - 2, finalRound - 3];
    
    if (!significantRounds.includes(roundNum)) return;
    // ★★★ 修正ここまで ★★★

    const alreadyExists = tournamentState.news.some(n => 
        n.roundNumber === roundNum && 
        n.isNewspaper &&
        n.context?.tournament === tournamentState.currentTournament
    );
    if (alreadyExists) return;

    let numMatchesInRound;
    let roundMatchIds;
    if (roundNum === finalRound) { // 決勝
        numMatchesInRound = 1;
        roundMatchIds = Object.keys(tournamentState.matches).filter(id => id.startsWith('F-R1-'));
    } else {
        numMatchesInRound = numTeams / Math.pow(2, roundNum);
        roundMatchIds = Object.keys(tournamentState.matches).filter(id => id.includes(`-R${roundNum}-M`));
    }

    const completedMatches = roundMatchIds.filter(id => tournamentState.matches[id].winner).length;

    if (completedMatches === numMatchesInRound) {
        console.log(`Round ${roundNum} complete! Generating Newspaper...`);
        
        const newspaperData = await generateSportsNewspaper(roundNum);
        
        if (newspaperData) {
            const roundName = getRoundNameFromMatchId(roundMatchIds[0]);
            
            tournamentState.news.push({
                title: `【熱闘新聞】${roundName}特集号が発行されました！`,
                body: newspaperData.subHeadline,
                timestamp: Date.now(),
                isNewspaper: true,
                roundNumber: roundNum,
                newspaperData: newspaperData,
                context: {
                    isNewspaper: true,
                    round: roundNum,
                    tournament: tournamentState.currentTournament
                }
            });
            
            renderNews(tournamentState.news);
            saveState();
        }
    }
}

/**
 * [NEW] 終了したラウンドを総括する「なんJまとめスレッド」をAIに生成させる
 * (★currentTournament未定義エラーを修正)
 */
async function generateRoundSummaryBbsThread(roundNum) {
    const state = tournamentState;
    const allMatches = state.matches;
    const numTeams = state.teams.length;
    const tournamentName = tournamentNameMap[state.currentTournament] || '大会';
    const roundName = getRoundNameFromMatchId(`L-R${roundNum}-M1`);
    
    if (roundNum >= Math.log2(numTeams) - 1) { // 準決勝(R6)以降は対象外
        return;
    }
    
    let analysisText = "";
    let upsets = [];
    let closeCalls = [];
    let notableNextMatchups = [];

    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    const getTeamRank = (teamName) => calculateRank(teamName, state);
    
    const roundMatchIds = Object.keys(allMatches).filter(id => id.includes(`-R${roundNum}-M`));

    roundMatchIds.forEach(matchId => {
        const match = allMatches[matchId];
        if (!match.winner) return;
        const winner = match.winner;
        const loser = (match.team1 === winner) ? match.team2 : match.team1;
        if (!loser || loser === '(BYE)') return;
        const rankW = getTeamRank(winner);
        const rankL = getTeamRank(loser);
        const rankDiff = rankValues[rankW] - rankValues[rankL];
        const scoreW = Math.max(parseInt(match.score1) || 0, parseInt(match.score2) || 0);
        const scoreL = Math.min(parseInt(match.score1) || 0, parseInt(match.score2) || 0);
        if (rankDiff <= -2) {
            upsets.push(`${winner}(${rankW}) が ${loser}(${rankL}) を ${scoreW}-${scoreL} で破る大波乱`);
        }
        else if ((rankW === 'A' || rankW === 'B') && (scoreW - scoreL <= 2)) {
            closeCalls.push(`${winner}(${rankW}) が ${loser}(${rankL}) に ${scoreW}-${scoreL} の辛勝`);
        }
    });

    const nextRoundNum = roundNum + 1;
    const nextRoundMatchIds = Object.keys(allMatches).filter(id => id.includes(`-R${nextRoundNum}-M`));

    nextRoundMatchIds.forEach(matchId => {
        const match = allMatches[matchId];
        if (match.team1 && match.team2) {
            const rank1 = getTeamRank(match.team1);
            const rank2 = getTeamRank(match.team2);
            if ((rankValues[rank1] >= 4 && rankValues[rank2] >= 4) || (rankValues[rank1] >= 4 && rankValues[rank2] === 3) || (rankValues[rank1] === 3 && rankValues[rank2] >= 4)) {
                notableNextMatchups.push(`${match.team1}(${rank1}) vs ${match.team2}(${rank2})`);
            }
        }
    });

    analysisText += "### 主な番狂わせ (ジャイアントキリング)\n";
    analysisText += upsets.length > 0 ? upsets.map(s => `- ${s}`).join('\n') : "特になし\n";
    analysisText += "\n### 強豪校の苦戦 (接戦)\n";
    analysisText += closeCalls.length > 0 ? closeCalls.map(s => `- ${s}`).join('\n') : "特になし\n";
    analysisText += `\n### 次のラウンド (${getRoundNameFromMatchId(`L-R${nextRoundNum}-M1`)}) の注目カード\n`;
    analysisText += notableNextMatchups.length > 0 ? notableNextMatchups.map(s => `- ${s}`).join('\n') : "特になし\n";

    // ★★★ ここからが修正箇所 ★★★
    let tournamentContextPrompt = "";
    // `currentTournament` ではなく `state.currentTournament` を使用
    if (state.currentTournament === 'summer') {
        tournamentContextPrompt = "3年生にとってはガチで最後の夏や。";
    } else if (state.currentTournament === 'autumn') {
        tournamentContextPrompt = "新チームの初陣やな。ここでの結果がセンバツ選考に響くで。";
    } else if (state.currentTournament === 'spring') {
        tournamentContextPrompt = "夏のシード権がかかった前哨戦や。";
    }
    // ★★★ 修正ここまで ★★★

    const prompt = `あなたは、匿名掲示板「なんでも実況J（なんJ）」の住民です。あなたは高校野球に詳しく、煽りやユーモアを交えながら会話を盛り上げます。
${state.tournamentYear}年度 ${tournamentName}の「${roundName}」が全試合終了しました。
以下の分析結果に基づき、**なんJらしいスレッドタイトル**と、そのスレッド内での**リアルタイムな反応コメントを20〜25個**生成してください。

### 大会の文脈 (最重要)
${tournamentContextPrompt}

### 参考情報：静岡県高校野球の「常識」（勢力図）
${PREFECTURE_LORE}

### ${roundName} 試合結果の分析
${analysisText}

### あなたが生成するコメントの方向性
- **スレッドタイトル:** 「${roundName}が終わったわけやが、」というフレーズを必ず使ってください。
- **【★大会の文脈を反映】**: ${tournamentName}ならではの視点（例：「夏は3年生最後やな」「秋の新チームの仕上がり見えてきたな」「春でシード取れよ」）をコメントに含めること。
- **分析結果への反応:**
    - 「主な番狂わせ」に激しく反応してください。（例：「静高がまさかの小笠に負けてて草」）
    - 「強豪校の苦戦」に反応してください。（例：「283学園が静岡北に4-3とか危なすぎワロタ」）
    - 「次のラウンドの注目カード」に期待するコメントをしてください。（例：「次の静商と翔洋の試合はガチで楽しみ」「〇〇 vs △△、事実上の決勝だろ」）
- **なんJらしさ:**
    - 短い煽りレス。「は？」「雑魚w」「ファーwww」
    - 他のコメントへの安価 (>>) 付きの返信やツッコミ。
    - 自分の応援していたチームの敗退を嘆くコメント（架空でOK）。

### 出力形式 (JSON)
{
  "threadTitle": "（${roundName}が終わったわけやが、〇〇すぎワロタwww）",
  "comments": [
    {"personality": "1: 風吹けば名無し", "comment": "（スレ主のコメント）"},
    {"personality": "2: 風吹けば名無し", "comment": "（住民2のコメント）"}
    // ... (合計20〜25個のコメント) ...
  ]
}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const bbsJson = parseJsonFromText(rawText);
            
            if (bbsJson && bbsJson.threadTitle && Array.isArray(bbsJson.comments)) {
                const threadId = `summary-thread-R${roundNum}-${state.currentTournament}`;
                return {
                    id: threadId,
                    title: bbsJson.threadTitle,
                    matchId: threadId,
                    comments: bbsJson.comments.map((c, index) => ({ 
                        id: crypto.randomUUID(),
                        personality: c.personality || `${index + 1}: 風吹けば名無し`, 
                        text: c.comment,
                        timestamp: Date.now() + index * 10, 
                        replies: [] 
                    })),
                    timestamp: Date.now(),
                    context: { isRoundSummary: true, round: roundNum }
                };
            }
        }
        throw new Error("AI round summary response format error.");
    } catch (error) {
        console.error(`AIラウンド総括スレッド(R${roundNum})の生成に失敗しました:`, error);
        return null;
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲


// ▼▼▼ この関数ブロックを「新規追加」(11842行目あたり) ▼▼▼

/**
 * [NEW] ラウンドが終了したかチェックし、AI総括スレッドの生成をトリガーする
 * (★R6(準決勝)終了時にも実行されるよう修正)
 */
async function checkAndTriggerRoundSummary(roundNum) {
    const numTeams = tournamentState.teams.length; // 128
    const finalRound = Math.log2(numTeams); // 7
    
    // ★★★ 修正箇所 ★★★
    // R6(準決勝) = 6。決勝(R7) = 7。
    // R6終了時(roundNum=6)も実行し、R7(決勝)終了時(roundNum=7)は実行しない。
    if (roundNum > (finalRound - 1)) { // (6 > 6) = false, (7 > 6) = true
        return;
    }
    // ★★★ 修正ここまで ★★★
    
    const threadId = `summary-thread-R${roundNum}-${tournamentState.currentTournament}`;
    
    if (tournamentState.matomeThreads[threadId]) {
        console.log(`Round ${roundNum} (${tournamentState.currentTournament}) summary thread already exists. Skipping.`);
        return;
    }

    const numMatchesInRound = numTeams / Math.pow(2, roundNum);
    const roundMatchIds = Object.keys(tournamentState.matches).filter(id => id.includes(`-R${roundNum}-M`));
    const completedMatches = roundMatchIds.filter(id => tournamentState.matches[id].winner).length;

    if (completedMatches === numMatchesInRound) {
        console.log(`Round ${roundNum} complete! Generating summary thread...`);
        
        const threadData = await generateRoundSummaryBbsThread(roundNum);
        
        if (threadData) {
            tournamentState.matomeThreads[threadData.id] = {
                thread: threadData.comments,
                context: threadData.context
            };
            
            const roundName = getRoundNameFromMatchId(`L-R${roundNum}-M1`);
            tournamentState.news.push({
                title: `【${tournamentNameMap[tournamentState.currentTournament]} ${roundName} 総括】${threadData.title}`,
                body: `AIが${roundName}の全試合を分析し、まとめスレッドを立てたようです。「まとめサイト」から確認できます。`,
                timestamp: Date.now(),
                isMatomeLink: true,
                matomeThreadId: threadData.id
            });
            
            renderNews(tournamentState.news);
            console.log(`Round ${roundNum} summary thread generated and saved.`);
        }
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * [NEW] 選手の「故障」や「アクシデント」に関するAI記事を生成する
 * (★「軽傷(accident_minor_injury)」シナリオを追加)
 * (★★ 選手の重要度(importance)に応じてAIのトーンを変更 ★★)
 */
async function generateAccidentArticle(teamName, playerName, accidentType, context = {}, importance) {
    // ★★★ ここからが修正箇所 ★★★
    let playerImportance = "控え選手";
    let toneInstruction = `
- **トーン:** 控え選手の離脱として、チームにとっては痛手であることを伝えつつも、冷静なトーンで報じてください。
- （例：「貴重なバックアップ戦力が離脱」「チームの層が試される」）`;

    if (importance === 'Shuryoku_Static' || importance === 'Shuryoku_Dynamic') {
        playerImportance = "主力選手（エース、主将、クリーンナップなど）";
        toneInstruction = `
- **トーン:** チームの根幹を揺るがす「大問題」として、非常に深刻なトーンで報じてください。
- （例：「${teamName}に激震！」「連覇に暗雲」「大黒柱〇〇、無念の離脱」）`;
    } else if (importance === 'Regular_Dynamic') {
        playerImportance = "レギュラー選手";
        toneInstruction = `
- **トーン:** レギュラー選手の離脱として、チームの戦力ダウンを懸念するトーンで報じてください。
- （例：「${playerName}の離脱は痛い」「監督は${playerName}の代役を誰にするのか」）`;
    }
    // ★★★ 修正ここまで ★★★

    let prompt = `あなたは「静岡 熱闘スタジアム」の緊急速報デスクです。
${teamName}の${playerName}選手に関する、ネガティブな「アクシデント」情報が入ってきました。
以下のデータに基づき、ニュース記事を生成してください。

### 取材データ
- **チーム:** ${teamName}
- **選手:** ${playerName}
- **選手の重要度:** ${playerImportance}
- **アクシデント種別:** ${accidentType}
- **関連データ:** ${context.log || '情報なし'}
- **監督:** ${TEAM_DATA[teamName]?.coach?.name || '監督'}

### 執筆指示
1.  **タイトル:** 衝撃的なタイトルにしてください。
    - (酷使故障の場合): 「【${teamName}に激震】エース${playerName}、連投の影響で背中に張りか」「${playerName}、${context.round || '次戦'}の出場絶望的」
    - (体調不良の場合): 「（号外）${teamName}にアクシデント！ ${playerName}ら主力数名が体調不良を訴え病院へ」
    - (HBP故障の場合): 「【${teamName}】${playerName}、前試合の死球の影響で骨折か」「${playerName}、無念の戦線離脱」
    - (軽傷の場合): 「【${teamName}】${playerName}、練習中に軽度の捻挫」「${context.log || '前試合での走塁'}が影響か。${playerName}、次戦は大事を取って欠場へ」
2.  **本文:**
    - (酷使故障の場合): ${playerName}が${context.log || '連投'}の影響で、身体の異常（例：肩の違和感、背中の張り）を訴えたことを描写してください。監督が「${context.round || '次戦'}は投げさせない」と明言した、というコメントを創作してください。
    - (体調不良の場合): ${playerName}が突発的な体調不良（例：食中毒、高熱）に見舞われ、次戦の出場が絶望的であることを描写してください。
    - (HBP故障の場合): ${playerName}が、${context.log || '前回の試合'}で受けた死球の影響により、病院で精密検査を受けたことを描写してください。検査の結果、「右手の甲（または肋骨）にヒビが入っており、今大会の出場は絶望的」と診断された、という衝撃的な内容にしてください。
    - (軽傷の場合): ${playerName}が${context.log || '前回の試合での走塁'}中に足首を軽度捻挫した（または練習中に軽い肉離れを起こした）と発表。監督は「大事を取って次の試合は休ませる」とコメント。
3.  **影響:** この離脱が、${teamName}の今後にどれほど深刻な影響を与えるかを分析してください。
4.  **【★重要度に応じたトーンの使い分け★】**
    ${toneInstruction}

### 出力形式 (JSON)
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                return { 
                    ...article, 
                    timestamp: Date.now(),
                    isAccident: true,
                    context: { teamName, playerName, accidentType, importance } // ★importanceを保存
                };
            }
        }
        throw new Error("AI accident response format error.");
    } catch (error) {
        console.error(`AIアクシデント記事（${playerName}）の生成に失敗しました:`, error);
        return null;
    }
}



/**
 * AIに甲子園（または東海大会）の結果を総括する記事を生成させる
 */
async function generateKoshienSummaryArticle(teamName, resultLabel, type) {
    let context, titleInstruction;

    if (type === 'summer') {
        context = `夏の甲子園、全国の頂点を目指した${teamName}の戦いが終わりました。`;
        titleInstruction = `「${teamName}、聖地での戦いの軌跡」のような、夏の終わりを感じさせる感動的なタイトルにしてください。`;
    } else if (type === 'spring') {
        context = `選抜高校野球大会に出場した${teamName}の最終結果が確定しました。`;
        titleInstruction = `「${teamName}、春の聖地に爪痕」のように、来たる夏への期待を感じさせるタイトルにしてください。`;
    } else { // tokai
        context = `秋季東海大会で、静岡県代表の${teamName}が見事な戦いを見せました。`;
        titleInstruction = `「${teamName}、センバツ当確！」のように、速報らしく、喜びが伝わるタイトルにしてください。`;
    }

    const prompt = `あなたは、情熱的な高校野球専門のAI記者です。
以下の情報に基づき、読者の心を打つような総括記事を生成してください。

### 大会結果
- チーム: ${teamName}
- 最終成績: ${resultLabel}
- 文脈: ${context}

### 執筆指示
- ${titleInstruction}
- チームのこれまでの努力や、県大会での戦いぶりを称え、今回の結果が持つ意味をドラマチックに描写してください。
- 最後に、選手たちへの賛辞や、今後のチームへの期待を述べて締めくくってください。

### 出力形式
JSON形式で出力してください: {"title": "記事のタイトル", "body": "記事の本文"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) return { ...article, timestamp: Date.now() };
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("AI甲子園記事の生成に失敗しました:", error);
        return { title: "記事生成エラー", body: "AI記者との通信に失敗しました。", timestamp: Date.now(), error: true };
    }
}
// --- Match Processing & Event Listeners ---


/**
 * [UPDATED] AIにトーナメントの組み合わせから架空の因縁を動的に創作させる
 * (★甲子園モードに対応し、全国規模の因縁を作らせる)
 */
async function generateDynamicFeuds(state) {
    const { matches, teams } = state;
    if (!matches || !teams) return [];

    // 1回戦の組み合わせと、各チームの補足情報をリストアップ
    const round1Matchups = Object.values(matches).filter(m => m.id.includes('-R1-M'));
    const matchupInfo = round1Matchups.map(match => {
        const { team1, team2 } = match;
        if (!team1 || !team2 || team1 === '(BYE)' || team2 === '(BYE)') return null;

        const team1Data = TEAM_DATA[team1];
        const team1Record = state.teamRecords[team1];
        const team1Info = `"${team1}" (${team1Data?.region || '不明'}, 監督: ${team1Data?.coach?.name}, ランク: ${calculateRank(team1, state)})`;

        const team2Data = TEAM_DATA[team2];
        const team2Record = state.teamRecords[team2];
        const team2Info = `"${team2}" (${team2Data?.region || '不明'}, 監督: ${team2Data?.coach?.name}, ランク: ${calculateRank(team2, state)})`;

        return `${team1Info} vs ${team2Info}`;
    }).filter(Boolean).join('\n');

    // ★★★ 修正箇所: プロンプトの切り替え ★★★
    let personaPrompt = "";
    let contextPrompt = "";
    
    if (state.currentTournament === 'summer_koshien') {
        personaPrompt = "あなたは、全国の高校野球事情に通じるベテランのスポーツライターです。";
        contextPrompt = "夏の甲子園（全国大会）の1回戦";
    } else {
        personaPrompt = "あなたは、静岡県の高校野球の歴史をすべて知るベテランのスポーツライターです。";
        contextPrompt = "夏の静岡県大会の1回戦";
    }
    // ★★★ 修正ここまで ★★★

    const prompt = `${personaPrompt}
${contextPrompt}の組み合わせが決定しました。以下の対戦カードリストと補足情報（地域、監督、ランク）を熟読してください。

### 1回戦 組み合わせリスト
${matchupInfo}

### 指示
上記のリストから、最もドラマチックな架空の因縁（フェイク・ストーリー）を持つ対決を**3つ**厳選し、その背景を創作してください。

### 因縁の創作パターン例
- **地域対決:** 「東北勢同士の潰し合い」「関東vs関西のプライド激突」
- **昨年のリベンジマッチ:** 昨年の大会（甲子園や地方大会）で劇的な敗北を喫した相手との再戦。
- **監督の師弟対決:** 両チームの監督が、実は大学時代の先輩と後輩だった。
- **ドラフト注目対決:** プロ注目のエースとスラッガーの対決。

### 出力形式【厳守】
以下のJSON配列形式"のみ"で出力してください。解説や「はい」などの返答は不要です。
[
  { "teams": ["チームA", "チームB"], "type": "因縁のタイプ（例：師弟対決）", "story": "AIが創作した短い背景ストーリー" },
  { "teams": ["チームC", "チームD"], "type": "東西対決", "story": "東の横綱C校と西の横綱D校が初戦から激突する事実上の決勝戦" }
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const feudsJson = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (Array.isArray(feudsJson)) {
                return feudsJson;
            }
        }
        throw new Error("AI response format error.");
    } catch (error) {
        console.error("AIによる動的因縁の生成に失敗しました:", error);
        return []; 
    }
}
/**
 * 延長イニングを全ての関連テーブルに追加する
 */
function addExtraInning() {
    // --- 1. イニングスコアのテーブルを更新 ---
    const scoreTable = document.getElementById('inning-score-table');
    if (scoreTable) {
        const headerRow = scoreTable.querySelector('thead tr');
        // 現在の最終イニング番号を取得し、1を足す
        const lastInningHeader = headerRow.children[headerRow.children.length - 3];
        const newInningNum = parseInt(lastInningHeader.textContent) + 1;

        // 新しいヘッダーを追加
        const newTh = document.createElement('th');
        newTh.className = 'w-10';
        newTh.textContent = newInningNum;
        headerRow.insertBefore(newTh, headerRow.children[headerRow.children.length - 2]);

        // 各チームの行に新しい入力欄を追加
        scoreTable.querySelectorAll('tbody tr').forEach(row => {
            const newTd = document.createElement('td');
            newTd.innerHTML = `<input type="text" value="">`;
            row.insertBefore(newTd, row.children[row.children.length - 1]);
        });
    }

    // --- 2. 両チームの打撃成績テーブルを更新 ---
    for (const teamKey of ['team1', 'team2']) {
        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (!battingTable) continue;

        // ヘッダーを更新
        const headerRow = battingTable.querySelector('thead tr');
        const lastInningHeader = headerRow.lastElementChild.previousElementSibling;
        const newInningNum = parseInt(lastInningHeader.textContent) + 1;
        const newTh = document.createElement('th');
        newTh.className = 'col-inning';
        newTh.textContent = newInningNum;
        headerRow.insertBefore(newTh, headerRow.lastElementChild);

        // 全ての選手行（スタメン・交代）に新しい入力欄を追加
        battingTable.querySelectorAll('tbody tr').forEach(row => {
            const newTd = document.createElement('td');
            newTd.innerHTML = `<input type="text" placeholder="-">`;
            row.appendChild(newTd);
        });

        // イニング出来事入力欄のcolspanを更新し、新しい入力欄を追加
        const tfoot = battingTable.querySelector('tfoot');
        if (tfoot) {
            const targetCell = tfoot.querySelector('td[colspan]');
            const currentNumInnings = parseInt(targetCell.getAttribute('colspan')) - 1;
            targetCell.setAttribute('colspan', currentNumInnings + 2);

            const newEventTd = document.createElement('td');
            newEventTd.className = 'border-t-2';
            newEventTd.innerHTML = `<input type="text" class="inning-events-input w-full text-left px-1 text-xs" data-team-key="${teamKey}" data-inning-index="${newInningNum - 1}" placeholder="例: 鈴木 盗塁">`;
            
            const eventRow = tfoot.querySelector('tr');
            eventRow.insertBefore(newEventTd, eventRow.lastElementChild);
        }
    }
}

/**
 * ニュースティッカーの表示を更新する
 */
function updateTicker() {
    const tickerContainer = document.querySelector('.ticker-content');
    const oldTickerText = document.getElementById('ticker-text');
    if (!tickerContainer || !oldTickerText) return;

    let headlines = tournamentState.tickerHeadlines || [];
    
    // 表示するヘッドラインがなければ、デフォルトのものを表示
    if (headlines.length === 0) {
        const defaultHeadlines = [
            "昨年度王者・283学園、県内連覇と「全国での一勝」へ視界良好か",
            "『公立最後の砦』静岡、名門復活へ『今年こそ』",
            "プロ注目158km右腕・斎藤擁する富士宮北、ワンマンチームの汚名返上なるか",
            "創部一年目・浜松特支、初めての夏。「まずは1点」を合言葉に挑む",
            "離島のハンデを覆せ！虎府島総合、逆境スピリッツで本土勢に挑む",
            "765総合高校、2年前の栄光再び。ノーシードからの逆襲なるか",
            "最後の夏・川根、閉校する母校の名を刻めるか",
            "『ベスト8の壁』は越えられるか。堅守の聖隷クリストファー、打線の仕上がりは"
        ];
        headlines = new Array(5).fill(defaultHeadlines).flat().sort(() => Math.random() - 0.5);
    }

    const newTextContent = headlines.join('　／／　');
    
    // アニメーションをリセットするために要素を再生成
    const newTickerText = oldTickerText.cloneNode(false);
    newTickerText.textContent = newTextContent;
    oldTickerText.remove();
    tickerContainer.appendChild(newTickerText);
}

/**
 * 試合結果からニュースティッカー用の短いヘッドラインを生成する
 * @param {object} matchData - 試合のデータオブジェクト
 * @returns {string | null} - 生成されたヘッドラインの文字列、またはnull
 */
function generateTickerHeadline(matchData) {
    const { winnerName, loserName, score1, score2 } = matchData;
    const winnerScore = Math.max(parseInt(score1), parseInt(score2));
    const loserScore = Math.min(parseInt(score1), parseInt(score2));
    const scoreDiff = winnerScore - loserScore;

    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    const rankDiff = rankValues[winnerRank] - rankValues[loserRank];

    // パターン1：大番狂わせ（ジャイアントキリング）
    if (rankDiff <= -2) {
        return `【波乱】${getRankDescription(loserRank)}・${loserName}が初戦で散る！ ${winnerName}が金星挙げる`;
    }
    // パターン2：接戦
    if (scoreDiff <= 2 && rankDiff <= 1 && rankDiff >= -1) {
        return `手に汗握る接戦！ ${winnerName}が${loserName}を${winnerScore}-${loserScore}で振り切る`;
    }
    // パターン3：圧勝
    if (scoreDiff >= 8 && rankDiff >= 2) {
        return `王者・${winnerName}、盤石の試合運びで${loserName}を圧倒。${winnerScore}対${loserScore}でコールド勝ち級の快勝`;
    }
    // パターン4：ライバル対決
    const rivalry = RIVALRIES.find(r => r.teams.includes(winnerName) && r.teams.includes(loserName));
    if (rivalry) {
        return `因縁の${rivalry.type}は${winnerName}に軍配！ ${loserName}を下す`;
    }
    // デフォルト
    return `${winnerName}が${loserName}を下し、次のラウンドへ駒を進める`;
}


/**
 * [HELPER] 打席結果の文字列を、ハイライト用の日本語に翻訳する
 * (★「注目」フラグ対応 最終版)
 */
function translateResult(res, playerInfo, eventType = '') {
    if (!res) return null;
    let tempRes = res.trim();

    // 1. 注目フラグをパース
    let markPrefix = ''; // 注目（翻訳後）
    if (tempRes.startsWith('★:')) {
        markPrefix = '（★注目）';
        tempRes = tempRes.substring(3); // "★:" を削除
    }

    // 2. 勢い(Strength)をパース
    let strengthPrefix = '';
    let strengthPrefixOut = '';
    if (tempRes.startsWith('S:')) {
        strengthPrefix = '鋭い';
        strengthPrefixOut = '鋭い当たりの';
        tempRes = tempRes.substring(2); // "S:" を削除
    } else if (tempRes.startsWith('W:')) {
        strengthPrefix = '詰まりながらも';
        strengthPrefixOut = '詰まった当たりの';
        tempRes = tempRes.substring(2); // "W:" を削除
    }

    // 3. 方向をパース
    let direction = '';
    const directionMap = {'投': 'ピッチャー', '捕': 'キャッチャー', '一': 'ファースト', '二': 'セカンド', '三': 'サード', '遊': 'ショート', '左': 'レフト', '中': 'センター', '右': 'ライト'};
    const directionKeys = Object.keys(directionMap);
    for (const key of directionKeys) {
        if (tempRes.startsWith(key)) {
            direction = directionMap[key] + 'へ';
            if (tempRes.includes('ゴロ') || tempRes.includes('飛') || tempRes.includes('邪') || tempRes.includes('直')) {
                direction = directionMap[key];
            }
            tempRes = tempRes.substring(key.length).trim();
            break;
        }
    }

    // 4. 打点とイベントタイプ
    let description = `${playerInfo}が`; // 基本の主語
    const rbiMatch = tempRes.match(/(\d+)点/);
    const eventText = eventType ? `${eventType}となる` : '';

    // 5. 結果の翻訳 (★markPrefixを全てに追加)
    if (tempRes.includes('本塁打')) {
        let hrRbiText = 'ソロ';
        if (rbiMatch) {
            const rbi = parseInt(rbiMatch[1]);
            if (rbi === 4) hrRbiText = '満塁';
            else if (rbi === 3) hrRbiText = '3ラン';
            else if (rbi === 2) hrRbiText = '2ラン';
        }
        description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${hrRbiText}ホームランを放った`;
    
    } else {
        // 本塁打以外
        const rbiText = rbiMatch ? (parseInt(rbiMatch[1]) > 1 ? `${rbiMatch[1]}点タイムリー` : 'タイムリー') : '';

        if (tempRes.includes('三塁打')) description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${rbiText}三塁打を放った`;
        else if (tempRes.includes('二塁打')) description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${rbiText}二塁打を放った`;
        else if (tempRes.includes('安')) {
            let hitDescription = "ヒット";
            let actionDesc = "放った";
            let adjective = ""; // 形容詞

            // 内野安打系（投・捕・一・二・三・遊）の場合の分岐
            const isInfield = ['ピッチャー', 'キャッチャー', 'ファースト', 'セカンド', 'サード', 'ショート'].includes(direction);

            if (isInfield) {
                if (strengthPrefix === '鋭い') {
                    // S: (強) -> 強襲ヒット
                    hitDescription = "強襲の内野安打";
                    adjective = "強烈な";
                    // 「鋭い ピッチャーへの...」とならないよう、共通prefixを消去して独自形容詞を使う
                    strengthPrefix = ""; 
                } 
                else if (strengthPrefix === '詰まりながらも') {
                    // W: (弱) -> セーフティーバント
                    hitDescription = "セーフティーバント";
                    adjective = "絶妙な";
                    actionDesc = "決めた";
                    strengthPrefix = ""; 
                }
                else {
                    // 指定なし -> ボテボテの内野安打
                    hitDescription = "内野安打";
                    adjective = "ボテボテの";
                    actionDesc = "もぎ取った";
                }

                // 内野安打用の文章生成してリターン
                description = `${playerInfo}が${markPrefix}${direction}への${adjective}${hitDescription}を${actionDesc}`;
                return description.replace(/タイムリー1点/g, 'タイムリー').replace(/1点を挙げた/g, '点を挙げた');
            }
            
            // 通常のヒット（外野ヒットなど）
            description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${rbiText}ヒットを放った`;
        }
        // ▲▲▲ 修正ここまで ▲▲▲        
        else if (tempRes.includes('犠飛')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '外野'}への${eventText}犠牲フライ${rbiMatch ? `で${rbiMatch[1]}点` : 'で1点'}を挙げた`;
        else if (tempRes.includes('犠打')) description = `${playerInfo}が${markPrefix}${direction ? direction + 'へ' : ''}送りバントを決めた`;
        
        else if (tempRes.includes('ゴロ') && rbiMatch) description = `${playerInfo}の${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}ゴロの間に${eventText}${rbiMatch[1]}点を挙げた`;
        else if ((tempRes.includes('エラー') || tempRes.includes('失')) && rbiMatch) description = `${playerInfo}が${markPrefix}相手${direction ? direction + 'の' : ''}エラーの間に${eventText}${rbiMatch[1]}点を記録した`;
        else if (tempRes.includes('野選') && rbiMatch) description = `${playerInfo}の${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}への${eventText}野選の間に${rbiMatch[1]}点を挙げた`;
        
        else if (tempRes.includes('振り逃げ')) {
            if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}三振振り逃げの間に${rbiMatch[1]}点を挙げ、打者も出塁した`;
            else description = `${playerInfo}が${markPrefix}${eventText}三振振り逃げで出塁した`;
        }
        else if (tempRes.includes('打撃妨害')) {
            if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}打撃妨害（押し出し）で${rbiMatch[1]}点を挙げ、出塁した`;
            else description = `${playerInfo}が${markPrefix}${eventText}打撃妨害で出塁した`;
        }

        else if (tempRes.includes('四球')) {
            if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}押し出しの四球を選び、${rbiMatch[1]}点を挙げた`;
            else description = `${playerInfo}が${markPrefix}四球を選んだ`;
        }
        else if (tempRes.includes('死球')) {
            if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}押し出しの死球を受け、${rbiMatch[1]}点を挙げた`;
            else description = `${playerInfo}が${markPrefix}死球で出塁した`;
        }
        else if (tempRes.includes('敬遠')) {
            if (rbiMatch) {
                description = `${playerInfo}が${markPrefix}${eventText}押し出しの敬遠四球を選び、${rbiMatch[1]}点を挙げた`;
            } else {
                description = `${playerInfo}が${markPrefix}${eventText}敬遠四球で出塁した`;
            }
        }
        
        else if (tempRes.includes('三振')) description = `${playerInfo}が${markPrefix}三振に倒れた`;
        else if (tempRes.includes('併殺')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}ゴロで併殺打に倒れた`;
        else if (tempRes.includes('邪')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || 'ファウルゾーン'}への邪飛（ファウルフライ）に倒れた`;
        else if (tempRes.includes('ゴロ')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}ゴロに倒れた`;
        else if (tempRes.includes('飛')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '外野'}フライに倒れた`;
        else if (tempRes.includes('直')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || ''}ライナーに倒れた`;
        
        // ▼▼▼ 修正：犠失を個別に翻訳してニュアンスを出す ▼▼▼
        else if (tempRes.includes('犠失')) {
            if (rbiMatch) {
                // 打点がある場合（犠飛失策の可能性大）
                description = `${playerInfo}が${markPrefix}${direction ? direction + 'への' : ''}犠牲フライ（またはバント）を放つも失策となり出塁、${eventText}${rbiMatch[1]}点を挙げた`;
            } else {
                // 打点がない場合（犠打失策の可能性大）
                description = `${playerInfo}の${markPrefix}${direction ? direction + 'への' : ''}犠牲バント（またはフライ）が相手の失策を誘い、出塁した`;
            }
        }
        // 通常のエラー
        else if (tempRes.includes('エラー') || tempRes.includes('失')) {
            description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}相手${direction ? direction + 'の' : ''}エラーで出塁した`;
        }
        // ▲▲▲ 修正ここまで ▲▲▲

        else if (tempRes.includes('野選')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction ? direction + 'への' : ''}野選で出塁した`;
        else return null;
    }

    // 6. 最終調整
    return description.replace(/タイムリー1点/g, 'タイムリー').replace(/1点を挙げた/g, '点を挙げた');
};
// ▲▲▲ 新規追加ここまで ▲▲▲


/**
 * [修正・完全版] 試合の詳細データから「事実オブジェクトの配列」と活躍選手リストを返す
 * (★変数重複エラー修正済み)
 */
function createHighlightsText(dbMatch, winnerName) {
    // 詳細データがない場合は空を返す
    if (!dbMatch || !dbMatch.details) {
        return { highlights: [], keyPlayerNames: [] };
    }

    // 守備交代履歴を取得 (★ここで宣言)
    const positionChanges = dbMatch.details.positionChanges || [];

    // --- 内部ヘルパー：そのイニング・そのチームの、特定ポジションの選手名を特定する ---
    const getFielderName = (defensiveTeamKey, currentInning, topBottom, posKey) => {
        if (!posKey) return "";

        // 1. 守備交代履歴から、この時点での最新の守備者を探す
        const relevantChanges = positionChanges.filter(change => {
            if (change.teamKey !== defensiveTeamKey) return false;
            if (change.newPos !== posKey) return false;
            
            const changeInning = parseInt(change.inning);
            if (changeInning < currentInning) return true; 
            if (changeInning === currentInning) {
                return true; 
            }
            return false;
        });

        // 最新の変更を採用
        if (relevantChanges.length > 0) {
            const lastChange = relevantChanges[relevantChanges.length - 1];
            return `・${lastChange.playerName}`;
        }

        // 2. 変更履歴になければ、スタメンから探す
        const roster = dbMatch.details.batting?.[defensiveTeamKey] || [];
        const starter = roster.find(p => {
            return p.pos === posKey && p.order && !p.order.includes('sub');
        });

        return starter ? `・${starter.name}` : "";
    };

    // --- 内部ヘルパー関数：打席結果を日本語に翻訳 ---
    const translateResult = (res, playerInfo, eventType = '', defensiveTeamKey, currentInning, topBottom) => {
        if (!res) return null;
        let tempRes = res.trim();

        let markPrefix = ''; 
        if (tempRes.startsWith('★:')) {
            markPrefix = '（★注目）';
            tempRes = tempRes.substring(3); 
        }

        let strengthPrefix = '';
        let strengthPrefixOut = '';
        if (tempRes.startsWith('S:')) {
            strengthPrefix = '鋭い';
            strengthPrefixOut = '鋭い当たりの';
            tempRes = tempRes.substring(2); 
        } else if (tempRes.startsWith('W:')) {
            strengthPrefix = '詰まりながらも';
            strengthPrefixOut = '詰まった当たりの';
            tempRes = tempRes.substring(2); 
        }

        let direction = '';
        let posKey = ''; 
        const directionMap = {'投': 'ピッチャー', '捕': 'キャッチャー', '一': 'ファースト', '二': 'セカンド', '三': 'サード', '遊': 'ショート', '左': 'レフト', '中': 'センター', '右': 'ライト'};
        const directionKeys = Object.keys(directionMap);
        
        for (const key of directionKeys) {
            if (tempRes.startsWith(key)) {
                posKey = key;
                direction = directionMap[key];
                if (!tempRes.includes('ゴロ') && !tempRes.includes('飛') && !tempRes.includes('邪') && !tempRes.includes('直')) {
                    direction += 'へ';
                }
                tempRes = tempRes.substring(key.length).trim();
                break;
            }
        }

        const getFielderStr = () => getFielderName(defensiveTeamKey, currentInning, topBottom, posKey);

        let description = `${playerInfo}が`; 
        const rbiMatch = tempRes.match(/(\d+)点/);
        const eventText = eventType ? `${eventType}となる` : '';

        if (tempRes.includes('本塁打')) {
            let hrRbiText = 'ソロ';
            if (rbiMatch) {
                const rbi = parseInt(rbiMatch[1]);
                if (rbi === 4) hrRbiText = '満塁';
                else if (rbi === 3) hrRbiText = '3ラン';
                else if (rbi === 2) hrRbiText = '2ラン';
            }
            description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'の' : ''}${eventText}${hrRbiText}ホームランを放った`;
        
        } else {
            const rbiText = rbiMatch ? (parseInt(rbiMatch[1]) > 1 ? `${rbiMatch[1]}点タイムリー` : 'タイムリー') : '';

            if (tempRes.includes('三塁打')) description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${rbiText}三塁打を放った`;
            else if (tempRes.includes('二塁打')) description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${rbiText}二塁打を放った`;
            
            else if (tempRes.includes('安')) {
                let hitDescription = "ヒット";
                let actionDesc = "放った";
                let adjective = ""; 

                const isInfieldStr = ['ピッチャー', 'キャッチャー', 'ファースト', 'セカンド', 'サード', 'ショート'].some(pos => direction.includes(pos));

                if (isInfieldStr) {
                    if (strengthPrefix === '鋭い') {
                        hitDescription = "強襲の内野安打";
                        adjective = "強烈な";
                        strengthPrefix = ""; 
                    } 
                    else if (strengthPrefix === '詰まりながらも') {
                        hitDescription = "セーフティーバント";
                        adjective = "絶妙な";
                        actionDesc = "決めた";
                        strengthPrefix = ""; 
                    }
                    else {
                        hitDescription = "内野安打";
                        adjective = "ボテボテの";
                        actionDesc = "もぎ取った";
                    }
                    
                    description = `${playerInfo}が${markPrefix}${direction}への${adjective}${hitDescription}を${actionDesc}`;
                    if (rbiText) {
                         description = `${playerInfo}が${markPrefix}${direction}への${adjective}${hitDescription}を${actionDesc}、${eventText}${rbiText.replace('タイムリー', '')}点を挙げた`;
                    }
                    return description.replace(/タイムリー1点/g, 'タイムリー').replace(/1点を挙げた/g, '点を挙げた');
                }
                
                description = `${playerInfo}が${markPrefix}${strengthPrefix ? strengthPrefix + ' ' : ''}${direction ? direction + 'への' : ''}${eventText}${rbiText}ヒットを放った`;
            }
            
            else if (tempRes.includes('犠飛')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '外野'}への${eventText}犠牲フライ${rbiMatch ? `で${rbiMatch[1]}点` : 'で1点'}を挙げた`;
            else if (tempRes.includes('犠打')) {
                if (rbiMatch) description = `${playerInfo}が${markPrefix}${direction ? direction + 'へ' : ''}スクイズを決めて${eventText}${rbiMatch[1]}点を挙げた`;
                else description = `${playerInfo}が${markPrefix}${direction ? direction + 'へ' : ''}送りバントを決めた`;
            }
            
            else if (tempRes.includes('ゴロ') && rbiMatch) description = `${playerInfo}の${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}ゴロの間に${eventText}${rbiMatch[1]}点を挙げた`;
            
            else if ((tempRes.includes('エラー') || tempRes.includes('失')) && rbiMatch && !tempRes.includes('犠失')) {
                const fielder = getFielderStr();
                description = `${playerInfo}が${markPrefix}相手${direction ? direction + fielder + 'の' : ''}タイムリーエラーで出塁、${eventText}${rbiMatch[1]}点を記録した`;
            }
            else if (tempRes.includes('野選') && rbiMatch) {
                const fielder = getFielderStr();
                description = `${playerInfo}の${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}${fielder}への${eventText}野選の間に${rbiMatch[1]}点を挙げた`;
            }

            else if (tempRes.includes('四球')) {
                if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}押し出しの四球を選び、${rbiMatch[1]}点を挙げた`;
                else description = `${playerInfo}が${markPrefix}四球を選んだ`;
            }
            else if (tempRes.includes('死球')) {
                if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}押し出しの死球を受け、${rbiMatch[1]}点を挙げた`;
                else description = `${playerInfo}が${markPrefix}死球で出塁した`;
            }
            else if (tempRes.includes('敬遠')) {
                if (rbiMatch) description = `${playerInfo}が${markPrefix}${eventText}押し出しの敬遠四球を選び、${rbiMatch[1]}点を挙げた`;
                else description = `${playerInfo}が${markPrefix}${eventText}敬遠四球で出塁した`;
            }
            
            else if (tempRes.includes('三振')) description = `${playerInfo}が${markPrefix}三振に倒れた`;
            else if (tempRes.includes('併殺')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}ゴロで併殺打に倒れた`;
            else if (tempRes.includes('邪')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || 'ファウルゾーン'}への邪飛に倒れた`;
            else if (tempRes.includes('ゴロ')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '内野'}ゴロに倒れた`;
            else if (tempRes.includes('飛')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || '外野'}フライに倒れた`;
            else if (tempRes.includes('直')) description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction || ''}ライナーに倒れた`;
            
            else if (tempRes.includes('犠失')) {
                 const fielder = getFielderStr();
                 if (rbiMatch) description = `${playerInfo}が${markPrefix}${direction ? direction + fielder + 'への' : ''}犠牲打を放つも失策となり出塁、${eventText}${rbiMatch[1]}点を挙げた`;
                 else description = `${playerInfo}の${markPrefix}${direction ? direction + fielder + 'への' : ''}犠牲バントが相手の失策を誘い、出塁した`;
            }
            else if (tempRes.includes('エラー') || tempRes.includes('失')) {
                const fielder = getFielderStr();
                description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}相手${direction ? direction + fielder + 'の' : ''}エラーで出塁した`;
            }
            else if (tempRes.includes('野選')) {
                const fielder = getFielderStr();
                description = `${playerInfo}が${markPrefix}${strengthPrefixOut ? strengthPrefixOut + ' ' : ''}${direction ? direction + fielder + 'への' : ''}野選で出塁した`;
            }
            else return null;
        }

        return description.replace(/タイムリー1点/g, 'タイムリー').replace(/1点を挙げた/g, '点を挙げた');
    };

    // --- 初期化 ---
    const highlights = []; 
    const keyPlayerNames = new Set(); 
    const winningTeamKey = dbMatch.team1 === winnerName ? 'team1' : 'team2';
    const losingTeamKey = winningTeamKey === 'team1' ? 'team2' : 'team1';
    const numInnings = dbMatch.details.inningScore?.team1?.length || 9;
    const inningScores = dbMatch.details.inningScore || { team1: Array(numInnings).fill(0), team2: Array(numInnings).fill(0) };

    let hasScored = false;
    let isReversed = false;
    let cumulativeScores = { team1: 0, team2: 0 };
    let batterIndices = { team1: 0, team2: 0 };
        
    // --- 1. イニングごとのプレーを解析 ---
    for (let i = 0; i < numInnings; i++) {
        const currentInning = i + 1;
        const scoreBeforeInning = { ...cumulativeScores };

        for (const teamKey of ['team1', 'team2']) {
            const teamName = dbMatch[teamKey];
            const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
            const topBottom = teamKey === 'team1' ? '表' : '裏';

            const allBattingData = dbMatch.details.batting?.[teamKey] || [];
            if (allBattingData.length === 0) continue;

            const sortedBattingOrder = allBattingData
                .filter(p => p.name) 
                .sort((a,b) => parseFloat(a.order.replace('-sub','.')) - parseFloat(b.order.replace('-sub','.')));
            if (sortedBattingOrder.length === 0) continue;

            let playsInHalfInning = [];
            sortedBattingOrder.forEach(player => {
                const resultString = player.results?.[i];
                if (resultString) {
                    resultString.split('、').forEach(atBatString => {
                        if(atBatString) {
                            playsInHalfInning.push({ player, atBatString });
                        }
                    });
                }
            });
            if (playsInHalfInning.length === 0) continue;

            // 打順インデックスに基づき並べ替え
            const startingBatterIndex = batterIndices[teamKey]; 
            const orderedPlays = []; 
            let currentBatterIndex = startingBatterIndex; 
            let playsFoundCount = 0; 
            const atBatsCountPerPlayer = {}; 

            while (orderedPlays.length < playsInHalfInning.length && playsFoundCount < playsInHalfInning.length * 2) {
                 const currentPlayer = sortedBattingOrder[currentBatterIndex]; 
                 const playerOrderKey = currentPlayer.order; 
                 const currentAtBatOrdinal = atBatsCountPerPlayer[playerOrderKey] || 0; 

                 let foundPlayIndex = -1;
                 let searchCount = 0;
                 for(let k=0; k < playsInHalfInning.length; k++){
                     if(playsInHalfInning[k].player.order === playerOrderKey) {
                         if(searchCount === currentAtBatOrdinal) {
                             if (!orderedPlays.includes(playsInHalfInning[k])) {
                                 foundPlayIndex = k;
                                 break;
                             }
                         }
                         searchCount++;
                     }
                 }

                 if (foundPlayIndex !== -1) {
                     orderedPlays.push(playsInHalfInning[foundPlayIndex]);
                     atBatsCountPerPlayer[playerOrderKey] = currentAtBatOrdinal + 1; 
                     currentBatterIndex = (currentBatterIndex + 1) % sortedBattingOrder.length;
                 } else {
                     currentBatterIndex = (currentBatterIndex + 1) % sortedBattingOrder.length;
                 }
                 playsFoundCount++; 
            }
            const finalOrderedPlays = orderedPlays.length === playsInHalfInning.length ? orderedPlays : playsInHalfInning;

            // ハイライト生成
            finalOrderedPlays.forEach(play => {
                const { player, atBatString } = play;
                const [batterPlay, runnerPlaysString] = atBatString.split(';'); 

                let playerRole = '';
                if (player.order.includes('sub')) {
                    switch(player.sub_type) {
                        case 'PH': playerRole = '代打の'; break;
                        case 'PR': playerRole = '代走の'; break;
                        case 'DEF': playerRole = '守備から途中出場の'; break;
                        case 'PITCHER': playerRole = 'リリーフの'; break;
                        default: playerRole = '途中出場の';
                    }
                } else {
                     playerRole = `${player.order}番`; 
                }
                const playerInfo = `${playerRole}${player.name}`;

                if (batterPlay && batterPlay.trim() !== '') {
                    let eventType = ''; 
                    const isScorePlay = batterPlay.includes('点') || batterPlay.toLowerCase().includes('hr') || batterPlay.includes('本');

                    if (isScorePlay) {
                        const prevScoreSelf = scoreBeforeInning[teamKey];
                        const prevScoreOpp = scoreBeforeInning[opponentTeamKey];
                        const rbiMatch = batterPlay.match(/(\d+)点/);
                        let addedScore = rbiMatch ? parseInt(rbiMatch[1]) : (batterPlay.includes('点') ? 1 : 0);
                        if (batterPlay.includes('本')) addedScore = Math.max(1, addedScore);
                        
                        const newScoreSelf = prevScoreSelf + addedScore;

                        if (prevScoreSelf === 0 && prevScoreOpp === 0) {
                            eventType = '先制'; 
                            hasScored = true;
                        } 
                        else if (prevScoreSelf < prevScoreOpp && newScoreSelf > prevScoreOpp && !isReversed) {
                            eventType = '逆転';
                            isReversed = true; 
                        } 
                        else if (prevScoreSelf === prevScoreOpp && newScoreSelf > prevScoreOpp) {
                            eventType = '勝ち越し';
                        }
                        else if (prevScoreSelf < prevScoreOpp && newScoreSelf === prevScoreOpp) {
                             eventType = '同点'; 
                        } 
                        else if (prevScoreSelf >= prevScoreOpp) {
                             eventType = '追加点'; 
                        } 
                        else {
                             eventType = '反撃'; 
                        }
                    }

                    const description = translateResult(batterPlay, playerInfo, eventType, opponentTeamKey, currentInning, topBottom);
                    if (description) {
                        highlights.push({ inning: currentInning, team: teamName, player: player.name, description });
                        keyPlayerNames.add(player.name);
                    }
                }

                if (runnerPlaysString) {
                    runnerPlaysString.split(',').forEach(runnerPlay => {
                        if (!runnerPlay) return;
                        const runnerPlayParts = runnerPlay.trim().split(' ');
                        if (runnerPlayParts.length < 2) return;
                        
                        const runnerName = runnerPlayParts[0];
                        const playType = runnerPlayParts[1];
                        const detail = runnerPlayParts.slice(2).join(' ') || '';
                        
                        let description = `${runnerName}が`;

                        if (playType === '盗塁') {
                            if (detail.includes('本塁')) description += `ホームスチール（重盗）を成功させた`;
                            else description += `盗塁成功（${detail}）`;
                        }
                        else if (playType === 'タッチアップ') description += `タッチアップから${detail}`;
                        else if (playType === '生還' || (playType === '進塁' && detail.includes('生還'))) description += `ホームイン`;
                        
                        else if (playType === '送球間に進塁') {
                            if (detail.includes('本塁')) description += `キャッチャーの送球の隙を突き、ホームを陥れる好走塁を見せた`;
                            else description += `送球の間に${detail}進塁する好走塁を見せた`;
                        }

                        else if (playType === '盗塁死') description += `盗塁失敗`;
                        else if (playType === '牽制死') description += `牽制アウト`;
                        else if (playType === '走塁死') description += `走塁死`;
                        else if (playType === '挟殺プレーでアウト') description += `挟殺アウト`;
                        else if (playType.includes('アウト')) description += `走塁中にアウト`;
                        else description += `${playType} ${detail}`.trim();

                        highlights.push({ type: 'baserunning', inning: currentInning, team: teamName, player: runnerName, description: description });
                        keyPlayerNames.add(runnerName);
                    });
                }
            });

            if (finalOrderedPlays.length > 0) {
                 const lastPlayer = finalOrderedPlays[finalOrderedPlays.length - 1].player;
                 const lastBatterIndexInLineup = sortedBattingOrder.findIndex(p => p.order === lastPlayer.order);
                 if (lastBatterIndexInLineup !== -1) {
                      batterIndices[teamKey] = (lastBatterIndexInLineup + 1) % sortedBattingOrder.length;
                 } else {
                      batterIndices[teamKey] = (startingBatterIndex + finalOrderedPlays.length) % sortedBattingOrder.length;
                 }
            }
        }
        cumulativeScores.team1 += parseInt(inningScores.team1?.[i] || 0);
        cumulativeScores.team2 += parseInt(inningScores.team2?.[i] || 0);
    } 

    // --- 2. 試合全体の個別要素を分析 ---
    // 惜敗投手
    const loserName = dbMatch[losingTeamKey];
    const losingPitchers = dbMatch.details.pitching?.[losingTeamKey] || [];
    if (losingPitchers.length === 1) {
        const ace = losingPitchers[0];
        if (ace.result === 'L' && parseFloat(ace.innings || 0) >= 8 && parseInt(ace.earnedRuns || 0) <= 2) {
             highlights.push({ type: 'tough_loss', team: loserName, player: ace.name, description: `${ace.name}投手は${ace.innings}回を${ace.earnedRuns}失点と好投したが、打線の援護に恵まれなかった` });
             keyPlayerNames.add(ace.name);
        }
    }

    // 代打ヒット
    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
        const teamBatting = dbMatch.details.batting?.[teamKey] || [];
        const substitutes = teamBatting.filter(p => p.sub_type && p.sub_type === 'PH');
        substitutes.forEach(subPlayer => {
            for (let i = 0; i < numInnings; i++) {
                const resultInInning = subPlayer.results?.[i];
                if (resultInInning) {
                    if (resultInInning.includes('安') || resultInInning.includes('本') || resultInInning.includes('二') || resultInInning.includes('三')) {
                         let playerRole = '代打の';
                         const playerInfo = `${playerRole}${subPlayer.name}`;
                         const description = translateResult(resultInInning, playerInfo, '', opponentTeamKey, i+1, teamKey==='team1'?'表':'裏'); 
                         if(description){
                              highlights.push({ type: 'substitute_hit', inning: i + 1, team: teamName, player: subPlayer.name, description: `${description}。見事起用に応えた` });
                              keyPlayerNames.add(subPlayer.name);
                         }
                    }
                    break; 
                }
            }
        });
    }

    // 投手成績ハイライト
    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const pitchingData = dbMatch.details.pitching?.[teamKey] || [];
        if (!pitchingData) continue;
        let pitchingRelayTextParts = []; 
        pitchingData.forEach((pitcher, pIdx) => {
            if (!pitcher.name || !pitcher.innings) return;
            const resultMark = {'W': '○', 'L': '●', 'S': 'Ｓ', 'H': 'Ｈ'}[pitcher.result] || '';
            const statsDetail = `(${pitcher.innings}回 打${pitcher.battersFaced || '-'} 球${pitcher.pitches || '-'} 被${pitcher.hits || '0'} 奪${pitcher.strikeouts || '0'} 与${pitcher.walks || '0'} 失${pitcher.runs || '0'} 自${pitcher.earnedRuns || '0'})`;
            let description = `${resultMark}${pitcher.name} ${statsDetail}`;

            let inningWhenChanged = '?'; 
            let isMidInningChange = false;
            let outsWhenChanged = 0;
            let situation = ''; 

            if (pIdx > 0) {
                const prevPitcher = pitchingData[pIdx - 1];
                if (prevPitcher.innings) {
                    const prevInningsStr = prevPitcher.innings.toString();
                    if (prevInningsStr.includes('.')) {
                        isMidInningChange = true;
                        const parts = prevInningsStr.split('.');
                        inningWhenChanged = parseInt(parts[0]) + 1;
                        outsWhenChanged = parseInt(parts[1] || 0);
                    } else {
                        isMidInningChange = false;
                        inningWhenChanged = Math.floor(parseFloat(prevInningsStr)) + 1;
                        outsWhenChanged = 0;
                    }
                    if (isNaN(inningWhenChanged)) inningWhenChanged = '?';

                    if (inningWhenChanged !== '?' && isMidInningChange) {
                        const opponentTeamKey = teamKey === 'team1' ? 'team2' : 'team1';
                        const opponentBatting = dbMatch.details.batting?.[opponentTeamKey] || [];
                        if (opponentBatting.length > 0) {
                            const opponentStartingBatterIdx = batterIndices[opponentTeamKey];
                            const simulationResult = simulateHalfInningUntilOuts(opponentBatting, inningWhenChanged - 1, outsWhenChanged, opponentStartingBatterIdx);
                            if (simulationResult) {
                                const runnerCount = simulationResult.runners.filter(r => r !== null).length;
                                if (runnerCount === 3) situation = '満塁のピンチで';
                                else if (runnerCount > 0) situation = `${runnerCount}者を背負い`;
                            }
                        }
                    }
                }
            } else {
                inningWhenChanged = 1; 
            }

            if (pIdx > 0 && inningWhenChanged !== '?') {
                 if (isMidInningChange) description = `${inningWhenChanged}回${outsWhenChanged}死${situation}登板した${description}`;
                 else description = `${inningWhenChanged}回から登板した${description}`;
            } else if (pIdx === 0) description = `先発の${description}`; 

            if (pitcher.runs === '0' && parseFloat(pitcher.innings) >= 7 && pitcher.result === 'W') description += ' 見事な完封勝利';
            else if (parseInt(pitcher.strikeouts) >= 10) description += ` ${pitcher.strikeouts}奪三振の快投`;
            else if (pitcher.result === 'L' && parseFloat(pitcher.innings) >= 8 && parseInt(pitcher.earnedRuns) <= 2) description += ' 好投も報われず';

            highlights.push({
                type: 'pitching_performance', 
                inning: inningWhenChanged !== '?' ? inningWhenChanged : undefined, 
                team: teamName,
                player: pitcher.name,
                description: description
            });
            keyPlayerNames.add(pitcher.name);
            pitchingRelayTextParts.push(`${pitcher.name}(${pitcher.innings}回)`);
        }); 
        if (pitchingRelayTextParts.length > 1) {
             highlights.push({ type: 'pitching_relay', team: teamName, description: `投手リレーは ${pitchingRelayTextParts.join(' → ')} だった` });
        }
    }

   // 守備交代 (★修正済み)
    positionChanges.forEach(change => {
        const teamName = dbMatch[change.teamKey];
        if (!teamName || !change.playerName || !change.newPos) return;
        let description = "";
        let situation = "";
        if (change.timing === 'mid') {
            const outs = change.outs || '0';
            const runners = change.runners || {};
            let runnerDesc = [];
            if (runners.r1) runnerDesc.push("1塁");
            if (runners.r2) runnerDesc.push("2塁");
            if (runners.r3) runnerDesc.push("3塁");
            if (runnerDesc.length === 3) situation = `${outs}アウト 満塁`;
            else if (runnerDesc.length > 0) situation = `${outs}アウト ${runnerDesc.join(', ')}`;
            else situation = `${outs}アウト ランナーなし`;
            situation += "の場面で、";
        }
        description = `${change.inning}回${change.topBottom}、${situation}${change.playerName}が${change.newPos}の守備に就いた`;
        highlights.push({ type: 'substitution', inning: parseInt(change.inning) || null, team: teamName, player: change.playerName, description: description });
        keyPlayerNames.add(change.playerName);
    });

    // 守備エラー/ファインプレー (変更なし)
    for (const teamKey of ['team1', 'team2']) {
        const teamName = dbMatch[teamKey];
        const fieldingPlays = dbMatch.details.fielding?.[teamKey] || [];
        const errorKeywords = ['エラー', 'トンネル', '落球', '後逸', '悪送球', 'ファンブル'];
        fieldingPlays.forEach(play => {
            if (play.player && play.play) {
                let description = '';
                const isError = errorKeywords.some(keyword => play.play.includes(keyword));
                if (isError) description = `${play.player}が${play.play}の痛恨のミスを犯した`;
                else description = `${play.player}が${play.play}のファインプレーを見せた`;
                highlights.push({ type: isError ? 'fielding_error' : 'fielding_fine_play', inning: play.inning || null, team: teamName, player: play.player, description: description });
                keyPlayerNames.add(play.player);
            }
        });
    }

    // --- 4. 総括ハイライト生成 (変更なし) ---
    let summaryHighlight = null;
    const winnerScore = parseInt(dbMatch[winningTeamKey === 'team1' ? 'score1' : 'score2'] || 0);
    const loserScore = parseInt(dbMatch[losingTeamKey === 'team1' ? 'score1' : 'score2'] || 0);
    const totalRuns = winnerScore + loserScore; 
    const winnerHits = Object.values(dbMatch.details.playerGameStats?.[winningTeamKey] || {}).reduce((sum, s) => sum + (s.h || 0), 0);
    const loserHits = Object.values(dbMatch.details.playerGameStats?.[losingTeamKey] || {}).reduce((sum, s) => sum + (s.h || 0), 0);
    const totalHits = winnerHits + loserHits; 
    let scoreAfter6th = { team1: 0, team2: 0 };
    if(inningScores?.team1 && inningScores?.team2){
        for(let i = 0; i < Math.min(numInnings, 6); i++) {
             scoreAfter6th.team1 += parseInt(inningScores.team1[i] || 0);
             scoreAfter6th.team2 += parseInt(inningScores.team2[i] || 0);
        }
    }
    const winnerScoreAfter6th = scoreAfter6th[winningTeamKey];
    const loserScoreAfter6th = scoreAfter6th[losingTeamKey];
    const lastInning = numInnings - 1; 
    let isSayonara = false;
    if (lastInning >= 8 && winningTeamKey === 'team2') {
        const scoreInLast = parseInt(inningScores?.team2[lastInning] || 0); 
        const scoreBeforeLast = winnerScore - scoreInLast; 
        if (scoreInLast > 0 && scoreBeforeLast <= loserScore) {
            isSayonara = true;
        }
    }

    let mvpPlayer = null; 
    let mvpPerformance = ''; 
    const winnerBattingStats = dbMatch.details.playerGameStats?.[winningTeamKey] || {};
    for (const playerName in winnerBattingStats) {
        const stats = winnerBattingStats[playerName];
        if (!stats || !stats.played) continue; 
        if (stats.hr >= 2) { mvpPlayer = playerName; mvpPerformance = `${stats.hr}本塁打`; break; }
        if (stats.rbi >= 4) { mvpPlayer = playerName; mvpPerformance = `${stats.rbi}打点`; break; }
        if (stats.h >= 4) { mvpPlayer = playerName; mvpPerformance = `${stats.h}安打`; break; }
    }
    const winnerPitchingData = dbMatch.details.pitching?.[winningTeamKey] || [];
    if (!mvpPlayer && winnerPitchingData.length > 0) {
        winnerPitchingData.forEach(pitcher => {
            if (!pitcher.name || !pitcher.innings) return;
            const innings = parseFloat(pitcher.innings);
            const runs = parseInt(pitcher.runs || 0); 
            const strikeouts = parseInt(pitcher.strikeouts || 0);
            if (pitcher.result === 'W') { 
                 if (runs === 0 && innings >= 7) { mvpPlayer = pitcher.name; mvpPerformance = `完封勝利`; }
                 else if (strikeouts >= 10 && innings >= 6) { mvpPlayer = pitcher.name; mvpPerformance = `${strikeouts}奪三振の快投`; }
                 else if (innings >= 6 && parseInt(pitcher.earnedRuns || 0) <= 1) { mvpPlayer = pitcher.name; mvpPerformance = `好投で試合を作る`; }
            }
             else if (pitcher.result === 'S' && innings >= 2 && parseInt(pitcher.earnedRuns || 0) === 0) { mvpPlayer = pitcher.name; mvpPerformance = `好リリーフで試合を締める`; }
        });
    }
    let isRelaySuccess = false;
    if (!mvpPlayer && winnerPitchingData.length > 1) {
        const totalER = winnerPitchingData.reduce((sum, p) => sum + parseInt(p.earnedRuns || 0), 0);
        const totalIP = winnerPitchingData.reduce((sum, p) => sum + parseFloat(p.innings || 0), 0);
        if (totalER <= 2 && totalIP >= (numInnings - 1)) isRelaySuccess = true;
    }

    let lateGameColdSummary = null;
    if (dbMatch.calledGame && dbMatch.calledInning >= 6) {
        const checkInningEnd = dbMatch.calledInning - 1; 
        let scoreBeforeBigInning = { team1: 0, team2: 0 };
        if(inningScores?.team1 && inningScores?.team2){
            for(let i = 0; i < Math.min(numInnings, checkInningEnd); i++) { 
                 scoreBeforeBigInning.team1 += parseInt(inningScores.team1[i] || 0);
                 scoreBeforeBigInning.team2 += parseInt(inningScores.team2[i] || 0);
            }
        }
        const winnerScoreBefore = scoreBeforeBigInning[winningTeamKey];
        const loserScoreBefore = scoreBeforeBigInning[losingTeamKey];
        const scoreDiffBefore = Math.abs(winnerScoreBefore - loserScoreBefore);
        if (scoreDiffBefore <= 3) {
            lateGameColdSummary = { type: 'summary', description: `${checkInningEnd}回まで${scoreDiffBefore}点差の接戦だったが、${dbMatch.calledInning}回に${winnerName}が一挙猛攻で試合を決め、コールド勝ちを収めた` };
        }
    }

    if (mvpPlayer) summaryHighlight = { type: 'summary', description: `${mvpPlayer}の${mvpPerformance}の活躍で、${winnerName}が勝利を掴んだ` };
    else if (isRelaySuccess) summaryHighlight = { type: 'summary', description: `${winnerName}投手陣が${loserName}打線を${loserScore}失点に抑える見事な継投策で勝利` };
    else if (isSayonara) summaryHighlight = { type: 'summary', description: `劇的なサヨナラ勝ちで、${winnerName}が熱戦に終止符を打った` };
    else if (lateGameColdSummary) summaryHighlight = lateGameColdSummary;
    else if (winnerScoreAfter6th < loserScoreAfter6th && winnerScore > loserScore && numInnings >= 7) summaryHighlight = { type: 'summary', description: `${winnerName}が終盤に見事な逆転劇を演じ、勝利を掴んだ` };
    else if (totalRuns <= 5 && totalHits <= 12) summaryHighlight = { type: 'summary', description: `両チーム合わせて${totalHits}安打${totalRuns}得点に終わる、息詰まる投手戦となった` };
    else if (totalRuns >= 13 && totalHits >= 20) summaryHighlight = { type: 'summary', description: `両チーム合わせて${totalHits}安打${totalRuns}得点が乱れ飛ぶ、壮絶な打撃戦となった` };
    else if (winnerScore - loserScore >= 7) summaryHighlight = { type: 'summary', description: `${winnerName}が投打に相手を圧倒し、${winnerScore}-${loserScore}で快勝した` };
    else if (winnerScore - loserScore <= 2) summaryHighlight = { type: 'summary', description: `${winnerName}が${loserName}の粘り強い追撃を振り切り、${winnerScore}-${loserScore}で接戦を制した` };
    else summaryHighlight = { type: 'summary', description: `${winnerName}が${loserName}を下し、${winnerScore}-${loserScore}で勝利した` };

    if (summaryHighlight) highlights.unshift(summaryHighlight);
    
    return { 
        highlights: highlights, 
        keyPlayerNames: Array.from(keyPlayerNames),
        summaryHighlight: summaryHighlight ? summaryHighlight.description : null 
    };
}

// ▼▼▼ ヘルパー関数：交代状況シミュレーション用 (★複数打席対応・先頭打者指定版★) ▼▼▼
/**
 * 指定されたイニングの攻撃を、特定のアウトカウントになるまで簡易的にシミュレートする
 * @param {Array} battingOrder - 相手チームの打順データ (ソート済み)
 * @param {number} inningIndex - シミュレーション対象イニングのインデックス (0始まり)
 * @param {number} targetOuts - シミュレーションを停止するアウトカウント
 * @param {number} startingBatterIdx - このイニングの先頭打者のインデックス
 * @returns {object | null} - { runners: [1B, 2B, 3B], outs: number, scoreSelf: number, scoreOpp: number, nextBatterIdx: number } または null
 */
function simulateHalfInningUntilOuts(battingOrder, inningIndex, targetOuts, startingBatterIdx) {
    if (!battingOrder || battingOrder.length === 0 || targetOuts < 0 || targetOuts > 3) return null;

    let outs = 0;
    let runners = [null, null, null]; // 1B, 2B, 3B
    let scoreSelf = 0; // 仮スコア (守備側)
    let scoreOpp = 0;  // 仮スコア (攻撃側)

    let currentBatterIndex = startingBatterIdx; // 先頭打者から開始
    let playsProcessedCount = 0; // 無限ループ防止 & デバッグ用
    const atBatsCountThisInning = {}; // このイニングでの各打者の打席数 { "1": 0, "2": 1, ... }

    // シミュレーション対象イニングの全プレーを事前に収集・打席順に並べ替える
    const playsForInning = [];
     battingOrder.forEach(player => {
         const resultString = player.results?.[inningIndex];
         if (resultString) {
             resultString.split('、').forEach(atBat => {
                 if(atBat) playsForInning.push({ player, atBat });
             });
         }
     });
     if (playsForInning.length === 0) return { runners, outs, scoreSelf, scoreOpp, nextBatterIdx: startingBatterIdx };

     // 打順並べ替え (createHighlightsText と同じロジック)
     const orderedPlays = [];
     let tempBatterIndex = startingBatterIdx;
     let playsCount = 0;
     const processedFlags = new Array(playsForInning.length).fill(false);
     const atBatsTempCount = {};
     while (orderedPlays.length < playsForInning.length && playsCount < playsForInning.length * 2) {
         const currentPlayer = battingOrder[tempBatterIndex];
         const playerOrderKey = currentPlayer.order;
         const currentAtBatOrdinal = atBatsTempCount[playerOrderKey] || 0;
         let foundPlayIndex = -1;
         let searchCount = 0;
         for(let k=0; k < playsForInning.length; k++){
             if(playsForInning[k].player.order === playerOrderKey && !processedFlags[k]) {
                 if(searchCount === currentAtBatOrdinal) {
                     foundPlayIndex = k;
                     break;
                 }
                 searchCount++;
             }
         }
         if (foundPlayIndex !== -1) {
             orderedPlays.push(playsForInning[foundPlayIndex]);
             processedFlags[foundPlayIndex] = true;
             atBatsTempCount[playerOrderKey] = currentAtBatOrdinal + 1;
             tempBatterIndex = (tempBatterIndex + 1) % battingOrder.length;
         } else {
             tempBatterIndex = (tempBatterIndex + 1) % battingOrder.length;
         }
         playsCount++;
     }
     const finalOrderedPlays = orderedPlays.length === playsForInning.length ? orderedPlays : playsForInning;


    // 並べ替えたプレーを順番に処理し、targetOuts に達するまでシミュレーション
    for (const playData of finalOrderedPlays) {
        if (outs >= targetOuts) break; // 目標アウトカウントに達したら終了

        const { player, atBat } = playData;
        const [batterPlay] = atBat.split(';');

        // 簡易アウト判定
        if (batterPlay.includes('三振') || batterPlay.includes('ゴロ') || batterPlay.includes('飛') || batterPlay.includes('直') || batterPlay.includes('犠')) {
            outs++;
            if (batterPlay.includes('併殺')) outs++;
        }
        if (outs >= targetOuts) break; // アウトが発生して targetOuts に達したら即終了

        // 簡易ランナー状況更新
        if (batterPlay.includes('安') || batterPlay.includes('塁打') || batterPlay.includes('四球') || batterPlay.includes('死球') || batterPlay.includes('エラー')) {
            if (runners[0] && runners[1] && runners[2] && (batterPlay.includes('四球') || batterPlay.includes('死球'))) {
                 scoreOpp++; // 押し出し
            } else {
                if (runners[1]) runners[2] = 'runner'; // 2塁→3塁
                if (runners[0]) runners[1] = runners[0]; // 1塁→2塁
                runners[0] = player.name; // 打者→1塁
            }
        }
        // 簡易得点計算
        if (batterPlay.includes('本塁打')) {
            scoreOpp += runners.filter(r => r !== null).length + 1;
            runners = [null, null, null];
        } else if (batterPlay.includes('点')) {
             const rbiMatch = batterPlay.match(/(\d+)点/);
             scoreOpp += rbiMatch ? parseInt(rbiMatch[1]) : 1;
             // 簡易シミュレーションのため、どの走者が還ったかは無視
        }

        playsProcessedCount++; // 処理済みプレー数
    }

    // 次の打者のインデックスを計算して返す
    const lastSimulatedPlayer = finalOrderedPlays[playsProcessedCount - 1]?.player;
    let nextBatterIdx = startingBatterIdx; // デフォルト
    if(lastSimulatedPlayer){
        const lastSimIdx = battingOrder.findIndex(p => p.order === lastSimulatedPlayer.order);
        if(lastSimIdx !== -1){
            nextBatterIdx = (lastSimIdx + 1) % battingOrder.length;
        }
    }


    return { runners, outs, scoreSelf, scoreOpp, nextBatterIdx }; // シミュレーション結果と次の打者インデックスを返す
}
// ▲▲▲ ヘルパー関数ここまで ▲▲▲

// ▲▲▲ ヘルパー関数ここまで ▲▲▲

/**
 * [修正版] 1打席分の入力ブロックHTMLを生成する
 * (★文字数順にソートして「犠飛」が「飛」に誤判定されるのを防ぐ)
 */
function createBattingResultDropdowns(playersOnField, atBatString = '') {
    // 1. 保存された文字列を「打者プレー」と「走者プレー」に分離
    const [batterPlay, runnerPlaysString] = (atBatString || '').split(';');
    
    let tempResult = (batterPlay || '').trim();

    // 3. 勢いと注目のパース
    let selectedStrength = '';
    let isMarked = false;

    if (tempResult.startsWith('★:')) {
        isMarked = true;
        tempResult = tempResult.substring(3);
    }
    if (tempResult.startsWith('S:')) {
        selectedStrength = 'S:';
        tempResult = tempResult.substring(2);
    } else if (tempResult.startsWith('W:')) {
        selectedStrength = 'W:';
        tempResult = tempResult.substring(2);
    }

    // 4. 残りの情報（結果、方向、打点など）をパースする
    let selectedResult = '', selectedDirection = '', selectedRbi = '', selectedRunnerPlay = '';
    
    if (tempResult) {
        const rbiMatch = tempResult.match(/(\d+点)/);
        if (rbiMatch) {
            selectedRbi = rbiMatch[0];
            tempResult = tempResult.replace(selectedRbi, '').trim();
        }
        if (tempResult.includes('好走塁')) {
            selectedRunnerPlay = '好走塁';
            tempResult = tempResult.replace('好走塁', '').trim();
        }
        
        // ★★★ 修正: ここでも文字数の多い順にソートする ★★★
        const allResultTypes = [ 
            ...BATTING_RESULTS.hits, 
            ...BATTING_RESULTS.outs, 
            ...BATTING_RESULTS.walks, 
            ...BATTING_RESULTS.sacrifices, 
            ...BATTING_RESULTS.other 
        ].sort((a, b) => b.length - a.length);

        for (const type of allResultTypes) {
            if (tempResult.includes(type)) {
                selectedResult = type;
                tempResult = tempResult.replace(type, '').trim(); // 見つかったら削除
                break; // 最初に見つかったもの（長い方）で確定
            }
        }
        
        if (tempResult.length > 0 && DIRECTIONS.includes(tempResult)) {
            selectedDirection = tempResult;
        }
    }

    // 5. HTMLを生成する
    // (プルダウンの選択肢順序は変えなくて良いが、selectedの判定は修正後のselectedResultを使う)
    const resultOptions = [ ...BATTING_RESULTS.hits, ...BATTING_RESULTS.outs, ...BATTING_RESULTS.walks, ...BATTING_RESULTS.sacrifices, ...BATTING_RESULTS.other ]
        .map(r => `<option value="${r}" ${selectedResult === r ? 'selected' : ''}>${r}</option>`).join('');
    const directionOptions = DIRECTIONS.map(d => `<option value="${d}" ${selectedDirection === d ? 'selected' : ''}>${d}</option>`).join('');
    const rbiOptions = RBIS.map(r => `<option value="${r}" ${selectedRbi === r ? 'selected' : ''}>${r}</option>`).join('');
    const runnerPlayOptions = ['好走塁'].map(r => `<option value="${r}" ${selectedRunnerPlay === r ? 'selected' : ''}>${r}</option>`).join('');
    const strengthOptions = `
        <option value="S:" ${selectedStrength === 'S:' ? 'selected' : ''}>強</option>
        <option value="W:" ${selectedStrength === 'W:' ? 'selected' : ''}>弱</option>
    `;

    return `
        <div class="at-bat-block border-t border-dashed pt-2 mt-2 first:mt-0 first:pt-0 first:border-t-0">
            <div class="flex items-center gap-1 batting-result-container mb-1">
                <div class="flex-grow flex gap-1">
                    <select class="batting-result-part w-[25%] text-xs p-1 border rounded result-type"><option value="">-結果-</option>${resultOptions}</select>
                    <select class="batting-result-part w-[20%] text-xs p-1 border rounded result-direction"><option value="">-方向-</option>${directionOptions}</select>
                    <select class="batting-result-part w-[20%] text-xs p-1 border rounded result-rbi"><option value="">-打点-</option>${rbiOptions}</select>
                    <select class="batting-result-part w-[15%] text-xs p-1 border rounded result-strength bg-red-50"><option value="">-勢い-</option>${strengthOptions}</select>
                    <select class="batting-result-part w-[20%] text-xs p-1 border rounded result-runner-play bg-yellow-50"><option value="">-走塁-</option>${runnerPlayOptions}</select>
                </div>
                <div class="w-12 flex-shrink-0">
                    <button class="mark-at-bat-btn w-full h-full text-xs font-bold p-1 rounded border ${isMarked ? 'bg-yellow-300 border-yellow-500 text-yellow-900' : 'bg-gray-100 border-gray-300 text-gray-500 hover:bg-gray-200'}"
                            data-marked="${isMarked ? 'true' : 'false'}"
                            title="この打席を「注目の打席」としてAIにマークします">
                        ★ 注目
                    </button>
                </div>
            </div>
            ${createRunnerInputsHTML(playersOnField, runnerPlaysString)}
        </div>
    `;
}

/**
 * トーナメント表をたどり、次の対戦相手の情報を特定する
 * (★「準決勝勝利時」の相手特定ロジックを修正した最終版)
 * @param {string} teamName - チーム名
 * @param {string} currentMatchId - そのチームが勝利した現在の試合ID
 * @returns {object|null} - 次の対戦相手に関する詳細情報
 */
function findNextOpponent(teamName, currentMatchId) {
    const allMatches = tournamentState.matches;
    if (!allMatches || !allMatches[currentMatchId]) return null;

    const idParts = currentMatchId.split('-');
    const side = idParts[0];

    if (side === 'F') {
        // 決勝戦に勝利した場合
        return { 
            opponentName: '優勝', 
            roundName: '大会終了',
            opponentRank: '',
            nextMatchSchedule: null
        };
    }

    const roundNum = parseInt(idParts[1].slice(1));
    const matchNum = parseInt(idParts[2].slice(1));
    const numTeams = tournamentState.teams.length;
    const finalRound = Math.log2(numTeams);

    let nextMatchId, roundName;
    if (roundNum === finalRound - 1) {
        // ★ 準決勝 (R5) -> 決勝 (F-R1-M1)
        nextMatchId = 'F-R1-M1';
        roundName = '決勝';
    } else if (roundNum < finalRound - 1) {
        const nextRoundNum = roundNum + 1;
        nextMatchId = `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
        const roundNameMap = { [finalRound - 1]: "準決勝", [finalRound - 2]: "準々決勝" };
        roundName = roundNameMap[nextRoundNum] || `${nextRoundNum}回戦`;
    } else {
        return null; // 既に決勝より後 (ありえないが)
    }

    const nextMatch = allMatches[nextMatchId];
    if (!nextMatch) return null;

    let opponentName = null;
    if (nextMatch.team1 && nextMatch.team1 !== teamName) opponentName = nextMatch.team1;
    else if (nextMatch.team2 && nextMatch.team2 !== teamName) opponentName = nextMatch.team2;

    if (opponentName) {
        // 相手が既に決まっている場合
        return {
            opponentName: opponentName,
            opponentRank: calculateRank(opponentName, tournamentState),
            roundName: roundName,
            nextMatchSchedule: nextMatch.schedule
        };
    } else {
        // 相手が未定の場合
        
        // ★★★ ここからが今回の修正箇所 ★★★
        let feederMatchId;
        
        // 1. 次の試合が決勝戦 (F-R1-M1) かつ、相手がまだ決まっていない場合
        if (nextMatchId === 'F-R1-M1') {
            // 反対側の山の準決勝IDを特定する (side は 'L' または 'R')
            const opponentFeederSide = (side === 'L' ? 'R' : 'L');
            feederMatchId = `${opponentFeederSide}-R${roundNum}-M1`; // 準決勝はM1しかない
        }
        // 2. (既存のロジック) 決勝戦以外で、相手が未定の場合
        else {
            const feederMatchNumber = matchNum % 2 === 1 ? matchNum + 1 : matchNum - 1;
            feederMatchId = `${side}-R${roundNum}-M${feederMatchNumber}`;
        }
        // ★★★ 修正ここまで ★★★

        const feederMatch = allMatches[feederMatchId];

        if (feederMatch && feederMatch.team1 && feederMatch.team2) {
            // 相手を決める試合のカードが揃っている場合
            return {
                opponentName: '（未定）',
                roundName: roundName,
                decidingMatch: {
                    team1: feederMatch.team1,
                    rank1: calculateRank(feederMatch.team1, tournamentState),
                    team2: feederMatch.team2,
                    rank2: calculateRank(feederMatch.team2, tournamentState)
                },
                nextMatchSchedule: nextMatch.schedule
            };
        }
        
        // (フォールバック) 相手を決める試合のカードもまだ揃っていない場合
        return { 
            opponentName: '（未定）', 
            opponentRank: '?', 
            roundName: roundName,
            nextMatchSchedule: nextMatch.schedule
        };
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 複数走者に対応した走塁入力欄のHTMLを生成する
 * @param {Array<object>} playersOnField - 現在出場中の選手リスト
 * @param {string} currentResult - 保存済みの打席結果文字列
 * @returns {string} - 生成されたHTML
 */
/**
 * 複数走者に対応した走塁入力欄のHTMLを生成する（区切り文字バグ修正版）
 */
function createRunnerInputsHTML(playersOnField, runnerPlaysString = '') {
    // ▼▼▼ 修正：「送球間に進塁」を追加 ▼▼▼
    const baserunningPlays = ['盗塁', '盗塁死', 'タッチアップ', '進塁', '送球間に進塁', '生還', '走塁死', '牽制死', '挟殺プレーでアウト'];
    // ▲▲▲ 修正ここまで ▲▲▲    

const bases = ['一塁へ', '二塁へ', '三塁へ', '本塁へ(生還)'];
    
    // ▼▼▼【重要修正】区切り文字を「、」から「,」に変更▼▼▼
    const runnerEvents = runnerPlaysString ? runnerPlaysString.split(',') : [];
    // ▲▲▲

    let html = '<div class="runner-plays-container space-y-1 mt-1">';
    
    runnerEvents.forEach(event => {
        const parts = event.trim().split(' ');
        const name = parts[0] || '';
        const play = parts[1] || '';
        const base = parts.slice(2).join(' ') || '';
        
        const nameOptions = playersOnField.map(p => `<option value="${p.name}" ${p.name === name ? 'selected' : ''}>${p.name}</option>`).join('');
        const playOptions = baserunningPlays.map(p => `<option value="${p}" ${p === play ? 'selected' : ''}>${p}</option>`).join('');
        const baseOptions = bases.map(b => `<option value="${b}" ${b === base ? 'selected' : ''}>${b}</option>`).join('');

        html += `
            <div class="runner-play-input flex gap-1 items-center mt-1">
                <select class="runner-name w-1/3 text-xs p-1 border rounded"><option value="">-誰が-</option>${nameOptions}</select>
                <select class="runner-play w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-何をした-</option>${playOptions}</select>
                <select class="runner-base w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-どこへ-</option>${baseOptions}</select>
                <button class="remove-runner-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </div>
        `;
    });

    html += '</div>';
    html += '<button class="add-runner-play-btn text-xs mt-1 bg-gray-200 px-2 py-0.5 rounded hover:bg-gray-300">+ 走者プレーを追加</button>';
    return html;
}

/**
 * 選手の大会通算成績を、AIプロンプト用の短い文章に要約する
 * (★盗塁(SB)の表示を追加した最終版)
 * @param {string} playerName - 選手名
 * @param {string} teamName - チーム名
 * @returns {string | null} - "姫川: 打率.500, 3本塁打, 10打点, 5盗塁" のような要約文。成績がなければnull。
 */
function getPlayerTournamentStatsSummary(playerName, teamName) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord || !teamRecord.playerStats) return null;

    const battingStats = teamRecord.playerStats.batting[playerName];
    const pitchingStats = teamRecord.playerStats.pitching[playerName];
    
    let summaries = [];

    if (battingStats && battingStats.ab > 0) {
        const avg = (battingStats.h / battingStats.ab).toFixed(3);
        // ▼▼▼ この行を修正 ▼▼▼
        summaries.push(`打率${avg}, ${battingStats.hr || 0}本塁打, ${battingStats.rbi || 0}打点, ${battingStats.sb || 0}盗塁`);
        // ▲▲▲ 修正ここまで ▲▲▲
    }

    if (pitchingStats && pitchingStats.ip > 0) {
        const era = pitchingStats.er > 0 ? ((pitchingStats.er * 9) / pitchingStats.ip).toFixed(2) : "0.00";
        summaries.push(`${pitchingStats.w}勝${pitchingStats.l}敗, 防御率${era}, ${pitchingStats.so}奪三振`);
    }

    if (summaries.length > 0) {
        return `${playerName}: ${summaries.join(' / ')}`;
    }
    
    return null;
}
/**
 * Analyzes the results of a half-inning, counts outs, and updates the UI (colors and disabled state).
 */
function updateInningState(teamKey, inningIndex) {
    const battingTable = document.getElementById(`batting-table-${teamKey}`);
    if (!battingTable) return;

    let outCount = 0;
    
    // --- 1. Analyze Batting Results ---
    battingTable.querySelectorAll('tbody tr').forEach(row => {
        const resultCell = row.children[5 + inningIndex];
        if (!resultCell) return;
        
        const atBatContainers = resultCell.querySelectorAll('.batting-result-container');
        atBatContainers.forEach(container => {
            const resultTypeSelect = container.querySelector('.result-type');
            const resultText = resultTypeSelect.value;
            
            // Count outs
            if (BATTING_RESULTS.outs.includes(resultText)) {
                outCount += (resultText === '併殺') ? 2 : 1;
            }

            // Color-code the dropdowns
            const dropdowns = container.querySelectorAll('select');
            dropdowns.forEach(dd => dd.classList.remove('result-hit', 'result-out', 'result-on-base'));

            if (BATTING_RESULTS.hits.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-hit'));
            } else if (BATTING_RESULTS.walks.includes(resultText) || BATTING_RESULTS.other.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-on-base'));
            } else if (BATTING_RESULTS.outs.includes(resultText) || BATTING_RESULTS.sacrifices.includes(resultText)) {
                dropdowns.forEach(dd => dd.classList.add('result-out'));
            }
        });
    });

    // --- 2. Count Outs from "Inning Events" (Baserunning) ---
    const eventsInput = document.querySelector(`.inning-events-input[data-team-key="${teamKey}"][data-inning-index="${inningIndex}"]`);
    if (eventsInput && eventsInput.value) {
        const events = eventsInput.value.split('、');
        events.forEach(event => {
            if (event.includes('盗塁死') || event.includes('走塁死')) {
                outCount++;
            }
        });
    }

    // --- 3. Lock the Inning if 3 Outs are Reached ---
    const isLocked = outCount >= 3;
    battingTable.querySelectorAll('tbody tr').forEach(row => {
        const resultCell = row.children[5 + inningIndex];
        if (!resultCell) return;
        
        const dropdowns = resultCell.querySelectorAll('.batting-result-container select');
        const addButtons = resultCell.querySelectorAll('.add-at-bat-btn');
        
        dropdowns.forEach(dd => {
            dd.disabled = isLocked;
            if (isLocked) dd.classList.add('bg-gray-100');
        });
        addButtons.forEach(btn => {
            btn.disabled = isLocked;
            if (isLocked) btn.style.visibility = 'hidden';
        });
    });
     if (eventsInput) {
        eventsInput.disabled = isLocked;
        if (isLocked) eventsInput.classList.add('bg-gray-100');
     }
}

// ▼▼▼ 適正打順分析モーダル機能 ▼▼▼


/**
 * [FIXED] 分析結果を専用のコンテンツで表示する (打率を追加版)
 */
function renderOptimalLineupModal(teamName, lineup) {
    const contentEl = document.getElementById('contribution-content');
    const teamRecord = tournamentState.teamRecords[teamName];

    // --- 1. グラフ要素の破棄 (メモリ解放) ---
    const pieChart = Chart.getChart('rc-pie-chart');
    const barChart = Chart.getChart('rc-bar-chart');
    const scatterChart = Chart.getChart('stellar-scatter-chart');
    
    if (pieChart) pieChart.destroy();
    if (barChart) barChart.destroy();
    if (scatterChart) scatterChart.destroy();

    // --- 2. 打順表のHTMLを定義 ---
    let lineupHtml = `
        <div id="optimal-lineup-table" class="bg-white p-6 rounded-lg shadow-xl mt-4">
            <h4 class="text-xl font-bold text-blue-700 mb-4">⚾ 推奨打順 (OPS・RC/G基準)</h4>
            <div class="overflow-x-auto">
                <table class="career-stats-table">
                    <thead>
                        <tr>
                            <th>打順</th>
                            <th>選手名</th>
                            <th>役割</th>
                            <th>打率</th> <th>OPS</th>
                            <th>RC/G</th>
                            <th>HR/SB</th>
                            <th>評価理由</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${lineup.map(p => {
                            const stats = teamRecord.playerStats.batting[p.name];
                            const ops = parseFloat(calculateOps(stats)).toFixed(3);
                            
                            // ★ 打率の計算を追加
                            const avg = (stats.ab > 0) ? (stats.h / stats.ab).toFixed(3) : ".000";

                            // p.rcg がNaNであれば '0.00' にする安全策
                            const rcg = (p.rcg && !isNaN(p.rcg)) ? p.rcg.toFixed(2) : '0.00'; 

                            let role = '';
                            let reason = '';
                            if (p.order === 1) { role = 'リードオフ'; reason = '最高の出塁能力と俊足'; }
                            else if (p.order === 2) { role = 'つなぎ役'; reason = 'RC/Gが最も高く、効率的な打者'; }
                            else if (p.order === 3) { role = '確実性/主軸'; reason = 'OPSと打率のバランスが優れている'; }
                            else if (p.order === 4) { role = '主砲/打点'; reason = '最も長打力と打点能力が高い'; }
                            else if (p.order === 5) { role = '後続の打点役'; reason = '4番に次ぐパワーとRCを兼ね備える'; }
                            else if (p.order === 9) { role = '下位のリードオフ'; reason = '残りの選手の中で最も出塁率が高い'; }
                            else { role = '下位打線'; reason = 'バランスの良い攻撃力'; }
                            
                            return `
                                <tr>
                                    <td><strong>${p.order}番</strong></td>
                                    <td>${p.name}</td>
                                    <td>${role}</td>
                                    <td class="font-bold text-blue-700">${avg}</td> <td>${ops}</td>
                                    <td>${rcg}</td>
                                    <td>${stats.hr || 0}HR/${stats.sb || 0}SB</td>
                                    <td>${reason}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            </div>
            <div class="mt-4 p-3 bg-gray-50 rounded text-sm">
                <p>※推奨打順は、OPSやRC(Run Created)などセイバーメトリクスの指標に基づき、各打順の「役割」に最適な選手を配置した論理的打線です。</p>
            </div>
        </div>
    `;

    // --- 3. グラフエリアと打順表の排他表示 ---

    // A. グラフエリア（貢献度分析のパーツ）を非表示にする
    const graphAreas = contentEl.querySelectorAll('.bg-white.p-6.rounded-lg.shadow-md');
    graphAreas.forEach(el => el.classList.add('hidden'));

    // B. 打順表をコンテンツエリアに挿入
    contentEl.innerHTML = `
        <div class="archive-header">
            <span class="archive-school-name">適正打順分析: ${teamName}</span>
            <span class="archive-pref">OPS・RC/Gに基づく推奨打順</span>
        </div>
        ${lineupHtml}
    `;

    contentEl.classList.remove('hidden');
}
// ▲▲▲ 置き換えここまで ▲▲▲

// ▼▼▼ この関数をまるごと挿入 ▼▼▼
/**
 * [NEW HELPER] Finds all mentioned players and formats their full gamelogs for AI prompts.
 * @param {Set<string>} mentionedTeams - A Set of team names mentioned.
 * @param {string} conversationText - The text to scan for player names.
 * @returns {string} - A formatted string block of all found gamelogs.
 */
function formatPlayerGamelogsForPrompt(mentionedTeams, conversationText) {
    let logInfo = "";
    let relevantLogsFound = false;
    
    // Helper to parse date (already exists, but let's re-define for safety/scoping if needed, or just ensure it's available)
    const parseDate = (dateStr) => {
        if (!dateStr || !dateStr.includes('/')) return null;
        const [month, day] = dateStr.split('/').map(Number);
        const year = tournamentState.tournamentYear + (month <= 3 ? 1 : 0);
        return new Date(year, month - 1, day);
    };

    const today = parseDate(tournamentState.matches['F-R1-M1']?.schedule?.date || "7/25"); // Use a fallback "today"

    mentionedTeams.forEach(teamName => {
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord || !teamRecord.playerStats) return;

        // 1. Check Batting Gamelogs
        const battingStats = teamRecord.playerStats.batting;
        if (battingStats) {
            for (const playerName in battingStats) {
                if (conversationText.includes(playerName)) {
                    const bStats = battingStats[playerName];
                    if (bStats.gamelogs && bStats.gamelogs.length > 0) {
                        if (!relevantLogsFound) logInfo += `\n### 参考情報：今大会の主な選手成績履歴\n`;
                        relevantLogsFound = true;
                        logInfo += `- ${playerName} (${teamName}, 打者):\n`;
                        
                        bStats.gamelogs.sort((a, b) => (parseDate(a.date) || 0) - (parseDate(b.date) || 0));
                        
                        bStats.gamelogs.forEach(log => {
                            const dateInfo = log.date || '日付不明';
                            const opponentRank = log.opponentRank || 'E';
                            const stats = log.stats || { ab: 0, h: 0, hr: 0, rbi: 0, sb: 0 };
                            let role = "";
                            if (log.sub_type === 'PH') role = "代打";
                            else if (log.order && log.order.includes('sub')) role = "途中出場";
                            else if (log.order) role = `${log.order}番`;
                            
                            const statsLine = `${stats.ab}打数${stats.h}安打 ${stats.hr}HR ${stats.rbi}打点 ${stats.sb}盗塁`;
                            logInfo += `  - ${log.round} (${dateInfo}) (対 ${log.opponent} [${opponentRank}]) (${role}): ${statsLine}\n`;
                        });
                    }
                }
            }
        }

        // 2. Check Pitching Gamelogs
        const pitchingStats = teamRecord.playerStats.pitching;
        if (pitchingStats) {
            for (const playerName in pitchingStats) {
                if (conversationText.includes(playerName)) {
                    const pStats = pitchingStats[playerName];
                    if (pStats.gamelogs && pStats.gamelogs.length > 0) {
                        if (!relevantLogsFound) logInfo += `\n### 参考情報：今大会の主な選手成績履歴\n`;
                        relevantLogsFound = true;
                        logInfo += `- ${playerName} (${teamName}, 投手):\n`;

                        pStats.gamelogs.sort((a, b) => (parseDate(a.date) || 0) - (parseDate(b.date) || 0));

                        pStats.gamelogs.forEach(log => {
                            let dateInfo = log.date || '日付不明';
                            if (today) {
                                const logDate = parseDate(log.date);
                                if (logDate) {
                                    const diffDays = Math.ceil(Math.abs(today - logDate) / (1000 * 60 * 60 * 24));
                                    if (diffDays === 1) dateInfo = `${log.date} (連投)`;
                                    else if (diffDays === 2) dateInfo = `${log.date} (中1日)`;
                                    else if (diffDays > 0) dateInfo = `${log.date} (中${diffDays - 1}日)`;
                                }
                            }
                            const opponentRank = log.opponentRank || 'E';
                            const resultMark = {'W': '○', 'L': '●', 'S': 'Ｓ', 'H': 'Ｈ'}[log.result] || '';
                            pitcherGamelogInfo += `  - ${log.round} (${dateInfo}) (対 ${log.opponent} [${opponentRank}]): ${resultMark}${log.ip}回 ${log.h}被安打 ${log.bb}四球 ${log.so}奪三振 ${log.r}失点(自責${log.er})\n`;
                        });
                    }
                }
            }
        }
    });

    if (!relevantLogsFound) {
        logInfo = "\n### 参考情報：今大会の主な選手成績履歴\n- 言及された選手の詳細な試合履歴は見つかりませんでした。\n";
    }
    return logInfo;
}
// ▲▲▲ 挿入ここまで ▲▲▲

// ▼▼▼ この関数をまるごと追加 ▼▼▼
/**
 * 指定されたmatchIdに関連する、過去に生成されたAIコンテンツを全て削除する
 * @param {string} matchId - 対象の試合ID
 */
function clearPreviousAiContent(matchId) {
    if (!matchId) return;

    // 1. ニュース記事 (通常記事、羽田レポート、エラー) を削除
    // (context.matchId または errorId が matchId と一致するものを削除)
    tournamentState.news = tournamentState.news.filter(article => {
        if (article.context && article.context.matchId === matchId) return false;
        if (article.errorId === matchId) return false;
        return true;
    });

    // 2. 掲示板コメント (通常BBS) を削除
    // (BBSはスレッドではなく個々のコメントなので、context.matchId で削除)
    tournamentState.bbsComments = tournamentState.bbsComments.filter(comment => {
        if (comment.context && comment.context.matchId === matchId) return false;
        if (comment.errorId && comment.errorId.includes(matchId)) return false;
        return true;
    });

    // 3. まとめスレッド (matomeThreads) を削除
    if (tournamentState.matomeThreads && tournamentState.matomeThreads[matchId]) {
        delete tournamentState.matomeThreads[matchId];
    }
}
// ▲▲▲ 追加ここまで ▲▲▲

/**
 * 試合の勝者を処理する中心的関数（全機能統合）
 * (★快進撃記事と通常記事が「両方」生成されるよう修正)
 * (★★アクシデント記事が283学園にのみ発生するよう修正)
 * (★★★アクシデント抽選を選手の重要度（主力/控え）に応じて変更★★★)
 */
async function processMatchWin(matchId, winnerName) {
    let dbMatch = findMatchById(matchId);
    if (!dbMatch || !dbMatch.team1 || !dbMatch.team2) return;
    
    if (dbMatch.team1 === '(BYE)' || dbMatch.team2 === '(BYE)') {
        console.log("BYE match processing skipped by AI.");
        return;
    }

    // --- 1. 再処理（再生成）の確認 ---
    if (dbMatch.winner) {
        const confirmed = await showConfirm(
            `この試合（${dbMatch.team1} vs ${dbMatch.team2}）は既に「${dbMatch.winner}」の勝利で処理済みです。\n\n` +
            "「詳細入力」でデータを修正しましたか？\n" +
            "「はい」を押すと、現在の詳細入力データを基に、AI記事と掲示板をすべて再生成します。\n\n" +
            "（注意：この操作は元に戻せません）"
        );
        if (!confirmed) return;
        clearPreviousAiContent(matchId);
        dbMatch.winner = null; 
    } else {
        // (初回処理の場合、一時フラグをリセット)
        for (const teamName of [dbMatch.team1, dbMatch.team2]) {
            const teamRecord = tournamentState.teamRecords[teamName];
            if (!teamRecord || !teamRecord.playerStats) continue;
            for (const playerName in teamRecord.playerStats.batting) {
                if(teamRecord.playerStats.batting[playerName]) teamRecord.playerStats.batting[playerName].narrative_flag = null;
            }
            for (const playerName in teamRecord.playerStats.pitching) {
                if(teamRecord.playerStats.pitching[playerName]) teamRecord.playerStats.pitching[playerName].narrative_flag = null;
            }
        }
    }

    const loserName = dbMatch.team1 === winnerName ? dbMatch.team2 : dbMatch.team1;
    dbMatch.winner = winnerName;
    const idParts = matchId.split('-');
    const side = idParts[0];

    // --- スコアの読み取り ---
    const scoresAlreadySetBySkip = (dbMatch.score1 !== '' && dbMatch.score2 !== '' && (dbMatch.score1 != null) && (dbMatch.score2 != null));
    if (!scoresAlreadySetBySkip) {
        const matchEl = document.querySelector(`.matchup[data-match-id="${matchId}"]`);
        if (matchEl) {
            const score1El = matchEl.querySelector('[data-team-pos="1"]');
            const score2El = matchEl.querySelector('[data-team-pos="2"]');
            if (score1El && score2El && score1El.value !== '' && score2El.value !== '') {
                dbMatch.score1 = score1El.value;
                dbMatch.score2 = score2El.value;
            } else {
                dbMatch.score1 = '0';
                dbMatch.score2 = '0';
            }
            dbMatch.summary = matchEl.querySelector('.match-summary-input')?.value || '';
        }
    }
    
   // ▼▼▼ 【修正】手動設定がなければ、自動判定を行う ▼▼▼
    if (dbMatch.calledGame === undefined) { // 手動設定がまだない場合のみ
        dbMatch.calledGame = false;
        dbMatch.calledInning = null;
        let earliestCalledInning = null;
        
        if (dbMatch.details && dbMatch.details.inningScore && dbMatch.details.inningScore.team1.length >= 5) {
            const inningScores1 = dbMatch.details.inningScore.team1;
            const inningScores2 = dbMatch.details.inningScore.team2;
            const actualNumInningsRecorded = inningScores1.length;
            let cumulativeScore1 = 0;
            let cumulativeScore2 = 0;
            for (let i = 0; i < actualNumInningsRecorded; i++) {
                cumulativeScore1 += parseInt(inningScores1[i] || 0);
                cumulativeScore2 += parseInt(inningScores2[i] || 0);
                const currentInning = i + 1;
                const scoreDiff = Math.abs(cumulativeScore1 - cumulativeScore2);
                if (currentInning === 5 && scoreDiff >= 10) { earliestCalledInning = 5; break; }
                if (currentInning === 6 && scoreDiff >= 10) { earliestCalledInning = 6; break; }
                if (currentInning === 7 && scoreDiff >= 7) { earliestCalledInning = 7; break; }
                if (currentInning === 8 && scoreDiff >= 7) { earliestCalledInning = 8; break; }
            }
            if (earliestCalledInning !== null) {
                dbMatch.calledGame = true;
                dbMatch.calledInning = earliestCalledInning;
            }
        }
    }
    // ▲▲▲ 修正ここまで ▲▲▲

    // --- 勝者を次のラウンドに進める処理 (全大会共通) ---
    if(tournamentState.teamRecords[winnerName]) tournamentState.teamRecords[winnerName].wins++;
    if(tournamentState.teamRecords[loserName]) tournamentState.teamRecords[loserName].losses++;
    if (side !== 'F') {
        const roundNum = parseInt(idParts[1].slice(1));
        const numTeamsInTournament = tournamentState.teams.length;
        const finalRound = Math.log2(numTeamsInTournament);
        if (roundNum < finalRound) {
            const matchNum = parseInt(idParts[2].slice(1));
            const nextRoundNum = roundNum + 1;
            let nextMatchId = (nextRoundNum === finalRound) ? 'F-R1-M1' : `${side}-R${nextRoundNum}-M${Math.ceil(matchNum / 2)}`;
            if (!tournamentState.matches[nextMatchId]) {
                tournamentState.matches[nextMatchId] = { id: nextMatchId, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
            }
            let slot = (nextRoundNum === finalRound) ? (side === 'L' ? 1 : 2) : (matchNum % 2 !== 0 ? 1 : 2);
            tournamentState.matches[nextMatchId][`team${slot}`] = winnerName;
            const nextMatch = tournamentState.matches[nextMatchId];
            if (nextMatch.team1 && nextMatch.team2) {
                nextMatch.rivalryType = checkRivalry(nextMatch.team1, nextMatch.team2);
            }
        }
    }
    // (決勝戦終了時の後処理)
    if (matchId.startsWith('F-R1-M1')) {
        updateTournamentFinishRecords(); // 県大会の成績を記録

        if (tournamentState.currentTournament === 'summer') {
            // ★★★ 【修正】甲子園シミュレーションではなく、実際の甲子園モードへ移行 ★★★
            
            // 1. 優勝記事（県大会）を生成
            // (一旦ここで県大会の区切りをつける)
            
            // 2. ユーザーに通知
            alert(`【祝】${winnerName}が夏の静岡大会を制覇！\n\n続いて「全国高等学校野球選手権大会（甲子園）」へ進出します！\n初戦の相手は、岩手の怪物産出校「花巻東」です！`);

            // 3. 甲子園モードのセットアップを実行
            await setupKoshienTournament(winnerName);
            return; // ここで処理を終了（以後の記事生成などは setupKoshienTournament 内で行うか、リセットされる）

        } else if (tournamentState.currentTournament === 'summer_koshien') {
            // ★★★ 甲子園決勝後の処理 ★★★
            const koshienRank = winnerName ? '全国優勝' : '準優勝';
            alert(`【号外】${winnerName}が夏の甲子園で全国制覇！\n伝説の激闘を制し、頂点に立ちました！`);
            // (必要ならここでエンディング演出や殿堂入り処理など)
        } else if (tournamentState.currentTournament === 'autumn') {
            tournamentState.senbatsuTeams = [];
            const finalists = [winnerName, loserName];
            const numTeamsInTournament = tournamentState.teams.length;
            const finalRound = Math.log2(numTeamsInTournament);
            const semiFinalLosers = Object.values(tournamentState.matches)
                .filter(m => m.id.includes(`-R${finalRound-1}-M`))
                .map(m => m.winner === m.team1 ? m.team2 : m.team1)
                .filter(Boolean);
            const candidates = [...finalists, ...semiFinalLosers];
            const selectionPromises = candidates.map(async (teamName, index) => {
                let selectionChance = 0.3; if (index < 2) selectionChance = 0.7;
                if (Math.random() < selectionChance) {
                    tournamentState.senbatsuTeams.push(teamName);
                    const senbatsuArticle = await generateKoshienSummaryArticle(teamName, 'センバツ出場決定', 'tokai');
                    if (senbatsuArticle) { tournamentState.news.push(senbatsuArticle); }
                }
            });
            await Promise.all(selectionPromises);
            renderNews(tournamentState.news);
            saveState();
        }
    }
    
    // --- 2. 試合後のデータ更新 (ティッカー、称号) ---
    const newHeadline = generateTickerHeadline({ winnerName, loserName, score1: dbMatch.score1, score2: dbMatch.score2 });
    if (newHeadline) {
        tournamentState.tickerHeadlines.unshift(newHeadline);
        if (tournamentState.tickerHeadlines.length > 20) tournamentState.tickerHeadlines.pop();
        updateTicker();
    }
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    if ((rankValues[loserRank] - rankValues[winnerRank]) >= 2) {
        const winnerRecord = tournamentState.teamRecords[winnerName];
        if (winnerRecord && !winnerRecord.teamTraits.includes('giant_killer')) {
            winnerRecord.teamTraits.push('giant_killer');
        }
    }
    let team1QualityText = "（打球品質データなし）";
    let team2QualityText = "（打球品質データなし）";
    if (dbMatch.details && dbMatch.details.playerGameStats) {
        const calculateQuality = (teamKey) => {
            const quality = { sH: 0, wH: 0, sO: 0, wO: 0, totalAB: 0 };
            const statsTeam = dbMatch.details.playerGameStats[teamKey] || {};
            for (const playerName in statsTeam) {
                const stats = statsTeam[playerName];
                quality.sH += stats.strongHits || 0;
                quality.wH += stats.weakHits || 0;
                quality.sO += stats.strongOuts || 0;
                quality.wO += stats.weakOuts || 0;
                quality.totalAB += stats.ab || 0;
            }
            return quality;
        };
        const team1Quality = calculateQuality('team1');
        const team2Quality = calculateQuality('team2');
        const formatQualityText = (teamName, quality) => {
            if (quality.totalAB === 0) return `(${teamName}: データなし)`;
            const totalHits = quality.sH + quality.wH;
            const totalOuts = quality.sO + quality.wO;
            return `(${teamName}: 安打${totalHits} (うち鋭い当たり${quality.sH}本, 詰まった当たり${quality.wH}本) / 凡退${totalOuts} (うち鋭い凡退${quality.sO}本, 詰まった凡退${quality.wO}本))`;
        };
        team1QualityText = formatQualityText(dbMatch.team1, team1Quality);
        team2QualityText = formatQualityText(dbMatch.team2, team2Quality);
    }

    // --- 3. AIコンテンツ生成の準備と実行 ---
    const matchContext = createMatchContext(matchId, winnerName, team1QualityText, team2QualityText);
    if (!matchContext) {
        console.error("AIコンテンツ生成に必要なmatchContextの作成に失敗しました。");
        renderTournament(tournamentState);
        saveState();
        return;
    }
    let articlePromise = Promise.resolve(null);
    let commentsPromise = Promise.resolve(null);
    let hadaReportPromise = Promise.resolve(null);
    let matomeThreadPromise = Promise.resolve(null);
    let homepageNewsPromise = Promise.resolve(null);
    let cinderellaArticlePromise = Promise.resolve(null);
    let accidentArticlePromise = Promise.resolve(null);
let scoutReportPromise = Promise.resolve(null);
let snsPromise = Promise.resolve(null);

    // ★★★ 甲子園モードかどうかの判定 ★★★
    const isKoshienMode = tournamentState.currentTournament === 'summer_koshien';
    const playerTeam = tournamentState.teams[0]; // 283学園(またはプレイヤーチーム)
    const isPlayerMatch = (dbMatch.team1 === playerTeam || dbMatch.team2 === playerTeam);

    if (tournamentState.settings.enableArticleGeneration) {
        newsContainer.innerHTML = `<div class="loader">AI記者が記事を執筆中...</div>`;
        
        // ★★★ 甲子園モードの分岐 ★★★
        if (isKoshienMode && isPlayerMatch) {
            // 甲子園：地元紙風の応援記事
            articlePromise = generateKoshienNewsArticle(matchContext);
        } else {
            // 通常モード：既存のロジック
            const documentary = tournamentState.documentary;
            const loserRank = calculateRank(loserName, tournamentState);
            
            // 1. 快進撃(Cinderella)の判定
            let cinderellaType = null;
            let roundNumForCinderella = 0;
            if (idParts[0] !== 'F' && tournamentState.currentTournament === 'summer') { 
                const roundNum = parseInt(idParts[1].slice(1));
                roundNumForCinderella = roundNum;
                if (loserRank === 'E' && roundNum === 3) cinderellaType = 'E_Rank_Top_32';
                else if (loserRank === 'D' && roundNum === 4) cinderellaType = 'D_Rank_Top_16';
                else if (loserRank === 'C' && roundNum === 5) cinderellaType = 'C_Rank_Top_8';
            }
            


            // 2. 快進撃記事の生成
            if (cinderellaType) {
                cinderellaArticlePromise = generateCinderellaArticle(loserName, loserRank, roundNumForCinderella, matchContext);
            }
            
// ★★★ 追加箇所: 283学園戦ならスカウティングレポートを生成 ★★★
        if (winnerName === "283学園" || loserName === "283学園") {
            scoutReportPromise = generateKuriyamaReport(matchContext);
        }
// ★★★ 追加: 283学園戦ならSNSトレンドを生成 ★★★
        if (winnerName === "283学園" || loserName === "283学園") {
             // 283学園戦以外でも「決勝」などは生成しても良いですが、API節約のため絞ります
             snsPromise = generateSnsPosts(matchContext);
        }
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

            // 3. ドキュメンタリー or 通常記事
            if (documentary && documentary.target && (documentary.target === winnerName || documentary.target === loserName)) {
                 const isWin = documentary.target === winnerName;
                 const opponentName = isWin ? loserName : winnerName;
                 const opponentData = TEAM_DATA[opponentName];
                 const matchInfoForArticle = {
                    round: matchId.includes('-R') ? parseInt(matchId.split('-R')[1].split('-')[0]) : 1,
                    opponent: opponentName,
                    score: isWin ? `${dbMatch.score1}-${dbMatch.score2}` : `${dbMatch.score2}-${dbMatch.score1}`,
                    highlights: matchContext.highlights,
                    summary: dbMatch.summary,
                    opponentInfo: opponentData?.info || '対戦相手の情報なし'
                };
                articlePromise = generateDocumentaryArticle(isWin ? 'win' : 'lose', documentary.type, documentary.target, matchInfoForArticle);
                if (!isWin) tournamentState.documentary = { target: null, type: null };
            } else {
                articlePromise = generateNewsArticle(matchContext);
            }
        }
    }
    
    const isNotableGame = (winnerRank === 'A' || winnerRank === 'B' || loserRank === 'A' || loserRank === 'B');
    // 甲子園では羽田レポートは出さない（地元紙が出るため）
    if (tournamentState.settings.enableArticleGeneration && isNotableGame && Math.random() < 0.25 && !isKoshienMode) {
        hadaReportPromise = generateHadaReport(matchContext);
    }

    if (tournamentState.settings.enableBbsGeneration) {
        bbsCommentsContainer.innerHTML = `<div class="loader">AIが掲示板を監視中...</div>`;
        
        // ★★★ 甲子園モードの分岐 ★★★
        if (isKoshienMode && isPlayerMatch) {
            commentsPromise = generateKoshienBbsComments(matchContext);      // 応援BBS
            matomeThreadPromise = generateKoshienMatomeThread(matchContext); // 応援まとめスレ
        } else {
            commentsPromise = generateBbsComments(matchContext);             // 通常なんJ
            matomeThreadPromise = generateGameMatchBbsComments(matchContext);// 通常まとめ
        }
    }
    
    if (tournamentState.settings.enableArticleGeneration && (winnerName === "283学園" || loserName === "283学園")) {
        homepageNewsPromise = generateHomepageNewsUpdate(matchContext);
    }

    // --- 5. AIコンテンツの処理と最終的な画面更新 ---
    const [generatedArticle, generatedComments, generatedHadaReport, generatedMatomeThread, generatedHomepageNews, generatedCinderellaArticle, generatedScoutReport, generatedSns] = await Promise.all([
        articlePromise, 
        commentsPromise,
        hadaReportPromise,
        matomeThreadPromise,
        homepageNewsPromise,
        cinderellaArticlePromise,
        scoutReportPromise,
        snsPromise // <--- ここに追加
    ]);

    if (generatedComments) {
        if (Array.isArray(generatedComments) && !generatedComments.some(c => c.error)) {
            const validComments = generatedComments.filter(comment => !comment.error);
            if (validComments.length > 0) {
                tournamentState.bbsComments.push(...validComments);
            }
        } else if (Array.isArray(generatedComments)) {
            const errorCommentData = generatedComments.find(comment => comment.error);
            if (errorCommentData && errorCommentData.context) {
                tournamentState.bbsComments.push({
                    title: "掲示板コメント生成エラー",
                    body: "AIによるコメント生成に一部失敗しました。",
                    timestamp: Date.now(),
                    error: true,
                    errorId: `error-${matchId}-bbs-partial`,
                    context: errorCommentData.context
                });
            }
        } else if (generatedComments.error) {
            tournamentState.bbsComments.push({
                title: generatedComments.title || "掲示板コメント生成エラー",
                body: generatedComments.body || "AIによるコメント生成に失敗しました。",
                timestamp: Date.now(),
                error: true,
                errorId: generatedComments.errorId || `error-${matchId}-bbs`,
                context: generatedComments.context || matchContext
            });
        }
    }
    
// ★★★ 追加: SNSデータの保存と通知表示 ★★★
    if (generatedSns) {
        currentSnsData = generatedSns; // データを更新
        
        // 通知バナーを表示
        const notif = document.getElementById('trend-notification');
        const wordEl = document.getElementById('trend-notification-word');
        
        // 最もホットなワードを表示
        wordEl.textContent = generatedSns.trends[0];
        
        notif.classList.add('show');
        
        // 5秒後に消す
        setTimeout(() => {
            notif.classList.remove('show');
        }, 5000);
    }

    if (generatedCinderellaArticle) {
        tournamentState.news.push(generatedCinderellaArticle);
    }
    if (generatedArticle) {
        if (!generatedArticle.error) {
             generatedArticle.context = matchContext;
             // 甲子園記事や快進撃記事はレビューモーダルを出さない（即時反映）
             if (!isKoshienMode) {
                showArticleReviewModal(generatedArticle);
             } else {
                tournamentState.news.push(generatedArticle);
             }
        } else {
            const errorArticle = {
                title: generatedArticle.title || "記事生成エラー",
                body: generatedArticle.body || "AI記者との通信に失敗しました。",
                timestamp: Date.now(),
                error: true,
                errorId: matchContext.matchId || 'error',
                context: matchContext
            };
            tournamentState.news.push(errorArticle);
        }
    }

    if (generatedHadaReport) {
        tournamentState.news.push(generatedHadaReport);
    }
// ★★★ 追加箇所: 生成されたレポートをニュースに追加 ★★★
    if (generatedScoutReport) {
        tournamentState.news.push(generatedScoutReport);
    }
    // ★★★★★★★★★★★★★★★★★★★★★★★★★★★
    if (generatedMatomeThread) {
        tournamentState.matomeThreads[matchId] = {
            thread: generatedMatomeThread,
            context: matchContext
        };
    }
    if (generatedHomepageNews && !generatedHomepageNews.error) {
        if (!tournamentState.homepageNews) tournamentState.homepageNews = [];
        tournamentState.homepageNews.unshift(generatedHomepageNews);
    }
    if (!tournamentState.activeScandal && Math.random() < 0.1) {
        triggerScandalEvent(winnerName, loserName);
    }

    // --- 6. ボックススコアHTMLの自動生成 ---
    if (dbMatch.details) {
        try {
            dbMatch.boxScoreHtml = generateBoxScoreHTML(dbMatch);
        } catch (e) {
            console.error("ボックススコアHTMLの自動生成に失敗しました:", e);
            dbMatch.boxScoreHtml = null;
        }
    }

    // --- 7. [NEW] アクシデント抽選 (283学園ベンチ入り全員) ---
    const involvedTeams = [dbMatch.team1, dbMatch.team2];
    const opponentName = involvedTeams.find(t => t !== "283学園");

    if (involvedTeams.includes("283学園")) {
        const teamName = "283学園";
        const teamRecord = tournamentState.teamRecords[teamName];
        const staticRoster = TEAM_ROSTER_MASTER[teamName]; // ベンチ入り20名
        const lastGameRoster = teamRecord.roster || []; // 1試合前のロスター(スタメン+控え)

        if (teamRecord && staticRoster) {
            
            // 試合に出場した選手を特定
            const playersInGame = new Set();
            if (dbMatch.details) {
                const teamKey = (dbMatch.team1 === teamName) ? 'team1' : 'team2';
                (dbMatch.details.batting?.[teamKey] || []).forEach(p => { if (p.name) playersInGame.add(p.name); });
                (dbMatch.details.pitching?.[teamKey] || []).forEach(p => { if (p.name) playersInGame.add(p.name); });
            }

            staticRoster.forEach(player => { // 20名全員をループ
                const playerName = player.name;
                if (!playerName) return;

                // 1. 選手の通算成績オブジェクトを取得 (なければ初期化)
                if (!teamRecord.playerStats.batting[playerName]) {
                    teamRecord.playerStats.batting[playerName] = { games: 0, pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0, gamelogs: [] };
                }
                if (!teamRecord.playerStats.pitching[playerName]) {
                     teamRecord.playerStats.pitching[playerName] = { 
                        career: { games: 0, w: 0, l: 0, ip: 0, so: 0, er: 0, h: 0, bb: 0 },
                        gamelogs: []
                    };
                }
                
                const careerBattingStats = teamRecord.playerStats.batting[playerName];
                const careerPitchingStats = teamRecord.playerStats.pitching[playerName];

                // 2. 既に故障中/体調不良/軽傷でないかチェック
                const currentBattingFlag = careerBattingStats.narrative_flag;
                const currentPitchingFlag = careerPitchingStats.narrative_flag;
                
                if (currentBattingFlag === 'injured' || currentBattingFlag === 'sick' || currentBattingFlag === 'minor_injury' ||
                    currentPitchingFlag === 'injured' || currentPitchingFlag === 'sick' || currentPitchingFlag === 'minor_injury') {
                    return; 
                }

                // 3. ★★★ 重要度 (Importance) の判定 ★★★
                let importance = 'Hikae'; // デフォルト (控え)
                const staticData = player; 
                const lastGameData = lastGameRoster.find(p => p.name === playerName);

                // (A) 静的ロスターで主力か？ (エース, 捕手, 主将)
                if (staticData.number === 1 || staticData.position.includes('捕手') || staticData.isCaptain) {
                    importance = 'Shuryoku_Static';
                }
                
                // (B) 前回の試合で主力だったか？ (スタメン、特にクリーンナップ)
                if (lastGameData && !importance.startsWith('Shuryoku')) {
                    if (lastGameData.order && !lastGameData.order.toString().includes('sub')) {
                        importance = 'Regular_Dynamic'; // レギュラー
                        const orderNum = parseInt(lastGameData.order);
                        if (orderNum >= 3 && orderNum <= 5) {
                            importance = 'Shuryoku_Dynamic'; // クリーンナップ
                        }
                        if (lastGameData.pos === '投') {
                            importance = 'Shuryoku_Dynamic'; // 先発投手
                        }
                    }
                }
                
                // (C) 今大会の成績がズバ抜けているか？ (隠れた主力判定)
                if (!importance.startsWith('Shuryoku')) {
                    // ★ 新しいヘルパー関数を使用
                    const tourneyStats = calculateCurrentTournamentStats(
                        careerBattingStats.gamelogs, 
                        careerPitchingStats.gamelogs, 
                        matchId
                    );
                    
                    if (tourneyStats.AVG > 0.400 && tourneyStats.AB >= 5) {
                        importance = 'Shuryoku_Dynamic'; // 打率4割超
                    }
                    if (tourneyStats.IP >= 5.0 && tourneyStats.ERA < 2.00) {
                        importance = 'Shuryoku_Dynamic'; // 防御率1点台
                    }
                }
                // ★★★ 重要度判定ここまで ★★★

                // 4. アクシデント抽選 (重要度に応じて確率変動)
                let accidentOccurred = false;
                const isImportant = importance.startsWith('Shuryoku') || importance.startsWith('Regular');
                
                const sickChance = isImportant ? 0.005 : 0.005; // 体調不良 (主力3%, 控え1%)
                const minorInjuryChance = isImportant ? 0.005 : 0.005; // 軽傷 (主力5%, 控え1%)

                // 4-1. ランダムアクシデント (体調不良)
                if (Math.random() < sickChance) {
                    careerBattingStats.narrative_flag = "sick";
                    careerPitchingStats.narrative_flag = "sick";
                    accidentArticlePromise = generateAccidentArticle(teamName, playerName, "accident_sickness", {}, importance);
                    accidentOccurred = true;
                }
                // 4-2. 軽傷
                else if (Math.random() < minorInjuryChance) {
                    careerBattingStats.narrative_flag = "minor_injury";
                    careerPitchingStats.narrative_flag = "minor_injury";
                    accidentArticlePromise = generateAccidentArticle(teamName, playerName, "accident_minor_injury", { 
                        log: `練習中（または${getRoundNameFromMatchId(matchId)}の${opponentName}戦でのプレー）`
                    }, importance);
                    accidentOccurred = true;
                }
                
                // 4-3. 酷使・HBP (試合出場選手のみ)
                if (!accidentOccurred && dbMatch.details && playersInGame.has(playerName)) {
                    // 打者出場チェック
                    const battingStats = dbMatch.details.playerGameStats?.[involvedTeams.indexOf(teamName) === 0 ? 'team1' : 'team2']?.[playerName];
                    if (battingStats) {
                        if (battingStats.hbp > 0 && Math.random() < 0.70) {
                            careerBattingStats.narrative_flag = "injured";
                            careerPitchingStats.narrative_flag = "injured";
                            accidentArticlePromise = generateAccidentArticle(teamName, playerName, "accident_hbp", { 
                                log: `${getRoundNameFromMatchId(matchId)}の${opponentName}戦で死球を受ける` 
                            }, importance);
                            accidentOccurred = true;
                        }
                    }
                    // 投手出場チェック
                    const pitchingData = dbMatch.details.pitching?.[involvedTeams.indexOf(teamName) === 0 ? 'team1' : 'team2'];
                    const pitcherData = pitchingData?.find(p => p.name === playerName);
                    if (pitcherData) {
                        const pitches = parseInt(pitcherData.pitches || 0);
                        let overuseLog = "";
                        let setInjury = false;
                        
                        if (careerPitchingStats.gamelogs && careerPitchingStats.gamelogs.length >= 1) {
                            const today = parseDate(dbMatch.schedule?.date);
                            const recentLogs = careerPitchingStats.gamelogs
                                .filter(log => log.matchId !== matchId)
                                .sort((a, b) => (parseDate(b.date) || 0) - (parseDate(a.date) || 0))
                                .slice(0, 2);
                            
                            if (today && recentLogs.length > 0) {
                                const lastGame = recentLogs[0];
                                const lastDate = parseDate(lastGame.date);
                                const daysRest = lastDate ? Math.ceil(Math.abs(today - lastDate) / (1000 * 60 * 60 * 24)) - 1 : 99;
                                
                                if (daysRest === 0 && Math.random() < 0.10) { 
                                    setInjury = true; overuseLog = "連投";
                                } else if (daysRest === 1 && pitches >= 80 && Math.random() < 0.20) { 
                                    setInjury = true; overuseLog = "中1日での80球以上の登板";
                                }
                            }
                        }
                        if (setInjury) {
                            careerBattingStats.narrative_flag = "injured";
                            careerPitchingStats.narrative_flag = "injured";
                            accidentArticlePromise = generateAccidentArticle(teamName, playerName, "injury_overuse", { log: overuseLog, round: getRoundNameFromMatchId(matchId) }, importance);
                            accidentOccurred = true;
                        }
                    }
                }

                // 5. 通常の調子判定 (試合出場選手のみ)
                if (!accidentOccurred && dbMatch.details && playersInGame.has(playerName)) {
                    const battingStats = dbMatch.details.playerGameStats?.[involvedTeams.indexOf(teamName) === 0 ? 'team1' : 'team2']?.[playerName];
                    if (battingStats) {
                         if (battingStats.pa > 0) {
                            if (battingStats.h >= 4 || battingStats.hr >= 2 || battingStats.rbi >= 5) careerBattingStats.narrative_flag = "peak";
                            else if (battingStats.h >= 3 || battingStats.hr >= 1 || battingStats.rbi >= 3) careerBattingStats.narrative_flag = "hot";
                            else if (battingStats.ab >= 3 && battingStats.h === 0) {
                                if (battingStats.strongOuts >= 2) careerBattingStats.narrative_flag = "cold";
                                else careerBattingStats.narrative_flag = "slump";
                            } else careerBattingStats.narrative_flag = "normal";
                        } else {
                            careerBattingStats.narrative_flag = "normal";
                        }
                    }
                    const pitchingData = dbMatch.details.pitching?.[involvedTeams.indexOf(teamName) === 0 ? 'team1' : 'team2'];
                    const pitcherData = pitchingData?.find(p => p.name === playerName);
                    if (pitcherData) {
                        const opponentTeamKey = teamName === dbMatch.team1 ? 'team2' : 'team1';
                        const opponentBattingStats = dbMatch.details.playerGameStats[opponentTeamKey] || {};
                        let totalStrongOuts = 0, totalWeakOuts = 0, totalStrongHits = 0;
                        for (const oppPlayerName in opponentBattingStats) {
                            const oppStats = opponentBattingStats[oppPlayerName];
                            totalStrongOuts += oppStats.strongOuts || 0;
                            totalWeakOuts += oppStats.weakOuts || 0;
                            totalStrongHits += oppStats.strongHits || 0;
                        }
                        const innings = parseFloat(pitcherData.innings || 0);
                        const earnedRuns = parseInt(pitcherData.earnedRuns || 0);
                        const strikeouts = parseInt(pitcherData.strikeouts || 0);
                        const walks = parseInt(pitcherData.walks || 0);
                        const hits = parseInt(pitcherData.hits || 0);
                        const pitches = parseInt(pitcherData.pitches || 0);
                        
                        if (innings >= 5) {
                            if ((innings >= 7 && earnedRuns === 0) || strikeouts >= 10) careerPitchingStats.narrative_flag = "peak";
                            else if (innings >= 6 && earnedRuns <= 2 && pitcherData.result !== 'L') careerPitchingStats.narrative_flag = "hot";
                            else if (totalWeakOuts >= 5 && earnedRuns <= 3) careerPitchingStats.narrative_flag = "hot";
                            else if (earnedRuns >= 5) careerPitchingStats.narrative_flag = "slump";
                            else if (walks >= 5 || (hits >= 8 && innings <= 6)) careerPitchingStats.narrative_flag = "cold";
                            else careerPitchingStats.narrative_flag = "normal";
                            if (pitcherData.result === 'L' && totalStrongHits >= 5) careerPitchingStats.narrative_flag = "unlucky";
                            if (pitcherData.result === 'L' && innings >= 7 && earnedRuns <= 2) careerPitchingStats.narrative_flag = "tough_loss";
                        } else if (pitches >= 100) {
                            careerPitchingStats.narrative_flag = "fatigued";
                        } else {
                            careerPitchingStats.narrative_flag = "normal";
                        }
                    }
                }
            }); // roster loop
        }
    }
    // ★★★ アクシデント抽選ここまで ★★★
    
    // --- 8. ラウンド終了チェックと総括スレッド生成 ---
    if (side !== 'F' && idParts[1] && idParts[1].startsWith('R')) {
        const roundNum = parseInt(idParts[1].slice(1));
        checkAndTriggerRoundSummary(roundNum);
    }

    // --- 9. アクシデント記事の処理 ---
    if (accidentArticlePromise) {
        const accidentArticle = await accidentArticlePromise;
        if (accidentArticle) {
            tournamentState.news.push(accidentArticle);
        }
    }

    saveState();

    // --- 10. ロスター情報（背番号、ポジション、投打）を記録 ---
    if (dbMatch.details && dbMatch.details.batting) {
        for (const teamKey of ['team1', 'team2']) {
            const teamName = dbMatch[teamKey];
            const teamRecord = tournamentState.teamRecords[teamName];
            const battingData = dbMatch.details.batting[teamKey];
            if (teamRecord && battingData && battingData.length > 0) {
                teamRecord.previousStarters = battingData
                    .filter(p => p.order && !p.order.toString().includes('sub'))
                    .map(p => ({ order: p.order, name: p.name, pos: p.pos }));
                teamRecord.roster = battingData.map(p => ({
                    order: p.order,
                    name: p.name,
                    number: p.number,
                    pos: p.currentPos || p.pos,
                    throwBat: p.throwBat,
                    sub_type: p.sub_type
                }));
            }
        }
    }

// ▼▼▼ 【ここに追加】 ▼▼▼
    // 記事生成の裏で非同期に実行させる（awaitしなくて良い）
    if (matchContext) {
        updateNarrativeImmediate(winnerName, loserName, matchContext);
    }
    // ▲▲▲ 追加ここまで ▲▲▲
    
    // --- 11. 最終描画 ---
    renderTournament(tournamentState);
}
// ▼▼▼ この関数をまるごと追加 ▼▼▼
/**
 * スキャンダルイベントを発生させる
 * @param {string} winnerName 
 * @param {string} loserName 
 */
function triggerScandalEvent(winnerName, loserName) {
    const potentialTargets = [winnerName, loserName];
    const eligibleScandals = [];

    for (const team of potentialTargets) {
        for (const scandal of SCANDAL_DEFINITIONS) {
            if (scandal.condition(team)) {
                eligibleScandals.push({ team, scandal });
            }
        }
    }

    if (eligibleScandals.length > 0) {
        const selected = eligibleScandals[Math.floor(Math.random() * eligibleScandals.length)];
        
        tournamentState.activeScandal = {
            teamName: selected.team,
            scandalId: selected.scandal.id
        };

        // ▼▼▼ この部分を修正 ▼▼▼
        const rumorArticle = {
            title: selected.scandal.rumorTitle(selected.team), // 関数として呼び出し、teamNameを渡す
            body: selected.scandal.rumorBody(selected.team),   // 関数として呼び出し、teamNameを渡す
            timestamp: Date.now(),
            isScandalRumor: true
        };
        // ▲▲▲ ここまで修正 ▲▲▲

        tournamentState.news.push(rumorArticle);
        renderNews(tournamentState.news);
        saveState();
    }
}
// ▲▲▲ ここまで追加 ▲▲▲

// --- 編集モーダル用のグローバル変数 ---
let articleForReview = null; // レビュー中の記事データを一時的に保持する

/**
 * AIが生成した記事を確認・編集するためのモーダルを表示する
 * @param {object} article - AIが生成した記事オブジェクト
 */
function showArticleReviewModal(article) {
    articleForReview = article; // 記事データを一時保存

    document.getElementById('review-title').value = article.title;
    document.getElementById('review-body').value = article.body.replace(/\\n/g, '\n');
    
    document.getElementById('review-modal').classList.remove('hidden');
}

/**
 * 編集モーダルを閉じる
 */
function closeReviewModal() {
    articleForReview = null;
    document.getElementById('review-modal').classList.add('hidden');
}

// --- 遊び方説明書モーダルのイベントリスナー ---
    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('help-modal');
    const helpModalClose = document.getElementById('help-modal-close');

    helpBtn.addEventListener('click', () => {
        helpModal.classList.remove('hidden');
    });
    helpModalClose.addEventListener('click', () => {
        helpModal.classList.add('hidden');
    }); 


// ▼▼▼ 抽選会イベント関連の関数群 ▼▼▼

const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

/**
 * 効果音を読み込む
 */
async function loadSoundEffects() {
    try {
        const drumroll = new Audio("https://actions.google.com/sounds/v1/sports/drum_roll_long.ogg");
        const cheer = new Audio("https://actions.google.com/sounds/v1/crowds/battle_crowd_cheer_med.ogg");
        const gasp = new Audio("https://actions.google.com/sounds/v1/human_sounds/gasp.ogg");
        soundEffects = { drumroll, cheer, gasp };
    } catch (e) {
        console.error("効果音の読み込みに失敗しました:", e);
    }
}

// ▼▼▼ この2つの関数ブロックをまるごと「新規追加」(13058行目あたり、startLotteryEvent の直前) ▼▼▼

/**
 * [NEW] ホームページモーダル専用の、最新トーナメント表HTMLを生成する
 * (283学園のハイライト付き、表示専用)
 * @param {object} state - tournamentState
 * @returns {string} - トーナメント表全体のHTML
 */
function generateHomepageBracketHTML(state) {
    const { matches, teams, seeds } = state;
    if (!teams || teams.length < 32) { // 64チーム制のみ対応
        return '<p class="text-center text-gray-500">（64チーム制トーナメントのデータがありません）</p>';
    }

    const bracketContentWrapper = document.createElement('div');
    bracketContentWrapper.className = 'tournament-container'; // ホームページ用のクラス

    const leftBracketEl = document.createElement('div');
    leftBracketEl.className = 'bracket-half left';

    const rightBracketEl = document.createElement('div');
    rightBracketEl.className = 'bracket-half right';
    
    // 決勝戦の準備 (renderMainBracketと同様)
    const finalRound = 6;
    const semiFinalRound = 5;
    const leftChampion = state.matches[`L-R${semiFinalRound}-M1`]?.winner ?? null;
    const rightChampion = state.matches[`R-R${semiFinalRound}-M1`]?.winner ?? null;
    const finalMatch = state.matches['F-R1-M1'] || {};
    const finalTeam1 = finalMatch.team1 ?? leftChampion;
    const finalTeam2 = finalMatch.team2 ?? rightChampion;
    const finalEl = document.createElement('div');
    finalEl.className = 'bracket-final';
    finalEl.innerHTML = `
        <div class="round-title">決勝</div>
        <div class="final-matchup">
            ${createHomepageMatchHTML('F-R1-M1', finalTeam1, finalTeam2, finalMatch, seeds)}
        </div>
        <div class="winner-box">
            <h2>${finalMatch.winner ? `🏆 優勝 ${finalMatch.winner}` : '🏆'}</h2>
        </div>
    `;

    // --- 左右のハーフを生成 ---
    const roundNameMap = { 1: "1回戦", 2: "2回戦", 3: "3回戦", 4: "準々決勝", 5: "準決勝" };
    
    // 左ハーフ
    let parentEl = leftBracketEl;
    for (let r = 1; r <= semiFinalRound; r++) {
        const roundEl = document.createElement('div');
        roundEl.className = `round r${r}`;
        roundEl.innerHTML = `<div class="round-title">${roundNameMap[r]}</div>`;
        const numMatchesInRound = 32 / Math.pow(2, r);
        for (let m = 1; m <= numMatchesInRound; m++) {
            const matchId = `L-R${r}-M${m}`;
            const dbMatch = matches[matchId] || {};
            const team1 = dbMatch.team1 || (r > 1 ? matches[`L-R${r-1}-M${(m*2)-1}`]?.winner : teams[(m-1)*2]) || null;
            const team2 = dbMatch.team2 || (r > 1 ? matches[`L-R${r-1}-M${(m*2)}`]?.winner : teams[(m-1)*2 + 1]) || null;
            roundEl.innerHTML += createHomepageMatchHTML(matchId, team1, team2, dbMatch, seeds);
        }
        parentEl.appendChild(roundEl);
    }

    // 右ハーフ
    parentEl = rightBracketEl;
    for (let r = 1; r <= semiFinalRound; r++) {
        const roundEl = document.createElement('div');
        roundEl.className = `round r${r}`;
        roundEl.innerHTML = `<div class="round-title">${roundNameMap[r]}</div>`;
        const numMatchesInRound = 32 / Math.pow(2, r);
        for (let m = 1; m <= numMatchesInRound; m++) {
            const matchId = `R-R${r}-M${m}`;
            const dbMatch = matches[matchId] || {};
            const baseIndex = 32; // 右ハーフの開始インデックス
            const team1 = dbMatch.team1 || (r > 1 ? matches[`R-R${r-1}-M${(m*2)-1}`]?.winner : teams[baseIndex + (m-1)*2]) || null;
            const team2 = dbMatch.team2 || (r > 1 ? matches[`R-R${r-1}-M${(m*2)}`]?.winner : teams[baseIndex + (m-1)*2 + 1]) || null;
            roundEl.innerHTML += createHomepageMatchHTML(matchId, team1, team2, dbMatch, seeds);
        }
        parentEl.appendChild(roundEl);
    }
    
    bracketContentWrapper.append(leftBracketEl, finalEl, rightBracketEl);
    return bracketContentWrapper.outerHTML;
}

// ▼▼▼ この関数を「新規追加」(11984行目あたり) ▼▼▼
/**
 * [NEW] チームの全投手の通算成績を集計し、チーム防御率とWHIPを計算する
 * @param {string} teamName - チーム名
 * @returns {object} - { era: string, whip: string }
 */
function calculateTeamPitchingStats(teamName) {
    const teamRecord = tournamentState.teamRecords[teamName];
    if (!teamRecord || !teamRecord.playerStats || !teamRecord.playerStats.pitching) {
        return { era: "----", whip: "----" };
    }

    const pitchingStats = teamRecord.playerStats.pitching;
    let totalER = 0;
    let totalIP = 0;
    let totalHits = 0;
    let totalWalks = 0;

    for (const playerName in pitchingStats) {
        const career = pitchingStats[playerName].career;
        if (career) {
            totalER += career.er || 0;
            totalIP += career.ip || 0;
            totalHits += career.h || 0;
            totalWalks += career.bb || 0;
        }
    }

    const era_val = (totalIP > 0) ? ((totalER * 9) / totalIP) : Infinity;
    const whip_val = (totalIP > 0) ? ((totalHits + totalWalks) / totalIP) : Infinity;

    return {
        era: (era_val === Infinity) ? "----" : era_val.toFixed(2),
        whip: (whip_val === Infinity) ? "----" : whip_val.toFixed(2)
    };
}
// ▲▲▲ 新規追加ここまで ▲▲▲

// ▼▼▼ 既存の「createHomepageMatchHTML」関数 (13115行目あたり) を、以下で「置き換え」 ▼▼▼

/**
 * [NEW] ホームページモーダル専用の、1試合分のHTMLを生成する
 * (★「一球速報」ボタン ＋ 「調子」アイコン表示を追加した最終版)
 */
function createHomepageMatchHTML(matchId, team1, team2, dbMatch, seeds = []) {
    const is283Team = (name) => name === "283学園" || name === "283学園B";

    const t1Empty = !team1;
    const t2Empty = !team2;
    
    // 283学園のハイライトクラス
    const team1Class = is283Team(team1) ? 'hp-team-283' : '';
    const team2Class = is283Team(team2) ? 'hp-team-283' : '';
    
    // 勝敗クラス
    const winnerClass1 = (dbMatch.winner === team1 && !t1Empty) ? 'winner' : '';
    const loserClass1 = (dbMatch.winner && dbMatch.winner !== team1 && !t1Empty) ? 'loser' : '';
    const winnerClass2 = (dbMatch.winner === team2 && !t2Empty) ? 'winner' : '';
    const loserClass2 = (dbMatch.winner && dbMatch.winner !== team2 && !t2Empty) ? 'loser' : '';
    
    // シード表示
    const seedInfo1 = seeds.find(s => s.team === team1);
    const seedInfo2 = seeds.find(s => s.team === team2);
    const seedLabel1 = seedInfo1 ? `[${seedInfo1.rank}] ` : '';
    const seedLabel2 = seedInfo2 ? `[${seedInfo2.rank}] ` : '';

    const roundClassMatch = matchId.includes('-R1-M') ? 'r1' : '';

    // ★★★ ここからが修正箇所 ★★★
    // 選手の調子アイコンを取得するヘルパー
    const getConditionIconForTeam = (teamName) => {
        if (!teamName) return ""; 
        
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord || !teamRecord.playerStats) return "";

        let icons = [];
        // (注: この関数は「試合前」に描画されるため、アイコンは「前の試合」の結果です)
        // 打者の調子
        if (teamRecord.playerStats.batting) {
            for (const playerName in teamRecord.playerStats.batting) {
                const flag = teamRecord.playerStats.batting[playerName].narrative_flag;
                const icon = getPlayerConditionIcon(flag);
                if (icon) icons.push(icon);
            }
        }
        // 投手の調子
        if (teamRecord.playerStats.pitching) {
            for (const playerName in teamRecord.playerStats.pitching) {
                const flag = teamRecord.playerStats.pitching[playerName].narrative_flag;
                const icon = getPlayerConditionIcon(flag);
                if (icon) icons.push(icon);
            }
        }
        // 重複を除去して返す
        return [...new Set(icons)].join('');
    };

    const team1ConditionIcons = getConditionIconForTeam(team1);
    const team2ConditionIcons = getConditionIconForTeam(team2);

    let footerButtonHTML = '';
    if (dbMatch.winner && dbMatch.boxScoreHtml) {
        footerButtonHTML = `
            <div class="matchup-footer mt-1 text-center">
                <button class="boxscore-btn text-xs bg-blue-600 text-white font-bold px-3 py-1 rounded hover:bg-blue-700" data-match-id="${matchId}">
                    一球速報
                </button>
            </div>
        `;
    }
    // ★★★ 修正ここまで ★★★

    return `
        <div class="matchup ${roundClassMatch}">
            <div class="match">
                <div class="team ${team1Class} ${winnerClass1} ${loserClass1}">
                    <span class="name">${seedLabel1}${team1 || '---'} ${team1ConditionIcons}</span>
                    <span class="score">${dbMatch.score1 ?? ''}</span>
                </div>
                <div class="team ${team2Class} ${winnerClass2} ${loserClass2}">
                    <span class="name">${seedLabel2}${team2 || '---'} ${team2ConditionIcons}</span>
                    <span class="score">${dbMatch.score2 ?? ''}</span>
                </div>
            </div>
            ${footerButtonHTML}
            ${matchId.includes('-R1-M') ? '' : '<div class="connector-line"></div>'}
            ${matchId.includes('-R2-M') ? '<div class="connector-path"></div>' : ''}
            ${matchId.includes('-R3-M') ? '<div class="connector-path"></div>' : ''}
            ${matchId.includes('-R4-M') ? '<div class="connector-path"></div>' : ''}
            ${matchId.includes('-R5-M') ? '<div class="connector-path"></div>' : ''}
        </div>
    `;
}
// ▲▲▲ 置き換えここまで ▲▲▲


/**
 * 抽選会イベントを開始する
 * (★128チーム制＝128スロットに対応)
 */
async function startLotteryEvent() {
    const lotteryModal = document.getElementById('lottery-modal');
    lotteryModal.classList.remove('hidden');
    lotteryModal.classList.add('flex');

    // (シード校決定ロジックは変更なし)
    const historicalRanks = INITIAL_TEAM_POOL.map(teamName => ({ name: teamName, rank: getRankFromHistoryString(TEAM_DATA[teamName].last) }));
    historicalRanks.sort((a, b) => a.rank - b.rank);
    const seeds = historicalRanks.slice(0, 8).map((t, i) => ({ team: t.name, rank: i + 1 })); 
    
    // ★★★ ここからが修正箇所 ★★★
    // 簡易トーナメント表を作成 (128チーム分)
    const leftBracket = document.getElementById('lottery-bracket-left');
    const rightBracket = document.getElementById('lottery-bracket-right');
    leftBracket.innerHTML = '';
    rightBracket.innerHTML = '';
    for(let i=0; i<128; i++){ // 64 -> 128
        const slot = document.createElement('div');
        slot.className = 'lottery-slot';
        slot.dataset.index = i;
        slot.innerHTML = `<span>${i+1}.</span> <span class="team-name-placeholder">---</span>`;
        // 64未満は左、64以上は右
        document.getElementById(i < 64 ? 'lottery-bracket-left' : 'lottery-bracket-right').appendChild(slot);
    }
    // ★★★ 修正ここまで ★★★

    // (ボタンイベントリスナーは変更なし)
    document.getElementById('start-lottery-btn').onclick = () => runLotteryAnimation(lotteryOrder, seeds);
    document.getElementById('skip-lottery-btn').onclick = () => {
        lotteryModal.classList.add('hidden');
        SoundManager.stopBgm();
        createNewTournament(false, 'summer');
    };

    // (抽選順の決定ロジックは変更なし)
    const seedTeamsList = seeds.map(s => s.team);
    const nonSeeds = INITIAL_TEAM_POOL.filter(t => !seedTeamsList.includes(t));
    
    // ★ 不戦勝(BYE)を抽選対象に追加
    const byesNeeded = 128 - nonSeeds.length - seeds.length;
    const byes = Array(byesNeeded).fill('(BYE)');
    const lotteryOrder = [...seedTeamsList, ...shuffleArray([...nonSeeds, ...byes])];

    SoundManager.startBgm();
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 抽選会のアニメーションを実行する
 * (★128チーム制・7ラウンド制に対応した最終版)
 * @param {Array<string>} lotteryOrder - 全チームの抽選順 (シード校が先)
 * @param {Array<object>} seeds - シード校8チームのランク付きオブジェクト配列
 */
async function runLotteryAnimation(lotteryOrder, seeds) {
    // --- 1. 初期設定 ---
    document.getElementById('lottery-pot').onclick = null;
    document.getElementById('skip-lottery-btn').style.display = 'none';
    
    const initialAiEnabled = document.getElementById('initial-ai-generation-toggle').checked;

    const commentaryEl = document.getElementById('lottery-commentary').querySelector('p');
    const drawnTeamContainer = document.getElementById('drawn-team-container');
    const drawnTeamEl = document.getElementById('drawn-team');
    const potEl = document.getElementById('lottery-pot');
    const potNameEl = document.getElementById('pot-name');
    
    // ★★★ 修正点 ★★★
    const teamPositions = Array(128).fill(null); // 64 -> 128
    const seedPositionsTemplate = [0, 64, 32, 96, 16, 80, 48, 112]; // 128チーム用の配置
    // ★★★ 修正ここまで ★★★
    
    // (シード配置スロットの準備ロジック ... 変更なし)
    const rank1_4_teams_sorted = seeds.filter(s => s.rank <= 4).sort((a, b) => a.rank - b.rank);
    const rank1_4_teams = [
        rank1_4_teams_sorted[0], // 第1シード
        rank1_4_teams_sorted[1], // 第2シード
        rank1_4_teams_sorted[3], // 第4シード
        rank1_4_teams_sorted[2]  // 第3シード
    ].filter(Boolean);
    const rank5_8_teams = shuffleArray(seeds.filter(s => s.rank > 4));
    const rank1_4_positions = seedPositionsTemplate.slice(0, 4); // [0, 64, 32, 96]
    const rank5_8_positions = shuffleArray(seedPositionsTemplate.slice(4)); // [16, 80, 48, 112] をシャッフル
    
    // ★★★ 修正点 ★★★
    let availableNonSeedSlots = Array.from({length: 128}, (_, i) => i).filter(p => !seedPositionsTemplate.includes(p)); // 64 -> 128
    const blockDeathAnnounced = { A: false, B: false, C: false, D: false };

    // (内部ヘルパー関数: playSound, isStrongRank ... 変更なし)
    const playSound = (id) => {
        const soundElement = document.getElementById(id);
        if (soundElement) {
            soundElement.currentTime = 0;
            soundElement.play().catch(e => console.warn(`Audio play failed for ${id}:`, e));
        }
    };
    const isStrongRank = (team) => ['A'].includes(calculateRank(team, {}));

    // (内部ヘルパー関数: checkDeathBlock ... ★修正★)
    const checkDeathBlock = (position) => {
        // 128チーム / 4ブロック = 1ブロック32チーム
        const blockName = position < 32 ? 'A' : position < 64 ? 'B' : position < 96 ? 'C' : 'D';
        const startIdx = position < 32 ? 0 : position < 64 ? 32 : position < 96 ? 64 : 96;
        constblockSize = 32; // ★ 16 -> 32
        
        if (blockDeathAnnounced[blockName]) return false;
        
        const teamsInBlock = teamPositions.slice(startIdx, startIdx + blockSize);
        // ★ 3チーム -> 4チーム に変更
        const strongTeamsCount = teamsInBlock.filter(team => team && ['A', 'B'].includes(calculateRank(team, {}))).length; 
        if (strongTeamsCount >= 4) { // ★ 3 -> 4
            commentaryEl.textContent = `これは...！ ${blockName}ブロックは有力校が集中する「死のブロック」になりました！`;
            blockDeathAnnounced[blockName] = true;
            playSound('sound-gasp');
            return true;
        }
        return false;
    };
    // ★★★ 修正ここまで ★★★


    // --- 2. 抽選会フェーズ1：シード校の配置 ---
    potNameEl.textContent = "シード校";
    
    // (第1〜第4シードの配置 (固定位置・山分け) ... 変更なし)
    for (let i = 0; i < rank1_4_teams.length; i++) {
        const teamName = rank1_4_teams[i].team;
        const teamRank = rank1_4_teams[i].rank;
        const position = rank1_4_positions[i]; 

        let dreadBg = null;
        if (isStrongRank(teamName) && initialAiEnabled) {
            dreadBg = document.createElement('div');
            dreadBg.className = 'dread-mode-bg';
            document.body.appendChild(dreadBg);
            potEl.classList.add('dread');
            commentaryEl.textContent = `会場が静まり返る... 第${teamRank}シード、 ${teamName} です...`;
            await sleep(2500);
        }

        commentaryEl.textContent = `第${teamRank}シード、${teamName}がクジを引きます...`;
        playSound('sound-drumroll');
        await sleep(1500);
        drawnTeamEl.textContent = teamName;
        drawnTeamContainer.classList.add('fade-in-out');
        teamPositions[position] = teamName;
        await sleep(1250);
        const targetSlot = document.querySelector(`.lottery-slot[data-index="${position}"]`);
        targetSlot.querySelector('.team-name-placeholder').textContent = `[${teamRank}] ${teamName}`;
        targetSlot.classList.add('filled', 'highlight'); 
        playSound('sound-cymbal');
        if (dreadBg) {
            dreadBg.remove();
            potEl.classList.remove('dread');
            playSound('sound-gasp');
        }
        commentaryEl.textContent = `第${teamRank}シード、${teamName}は ${position + 1}番に決定！`;
        await sleep(1500);
        drawnTeamContainer.classList.remove('fade-in-out');
        targetSlot.classList.remove('highlight');
    }

    // (第5〜第8シードの配置 (ランダム位置) ... 変更なし)
    for (let i = 0; i < rank5_8_teams.length; i++) {
        const teamName = rank5_8_teams[i].team;
        const teamRank = rank5_8_teams[i].rank;
        const position = rank5_8_positions[i]; 
        commentaryEl.textContent = `第${teamRank}シード、${teamName}がクジを引きます...`;
        playSound('sound-drumroll');
        await sleep(1500);
        drawnTeamEl.textContent = teamName;
        drawnTeamContainer.classList.add('fade-in-out');
        teamPositions[position] = teamName;
        await sleep(1250);
        const targetSlot = document.querySelector(`.lottery-slot[data-index="${position}"]`);
        targetSlot.querySelector('.team-name-placeholder').textContent = `[${teamRank}] ${teamName}`;
        targetSlot.classList.add('filled', 'highlight');
        playSound('sound-cymbal');
        commentaryEl.textContent = `第${teamRank}シード、${teamName}は ${position + 1}番に決定！`;
        await sleep(1500);
        drawnTeamContainer.classList.remove('fade-in-out');
        targetSlot.classList.remove('highlight');
    }


    // --- 3. 抽選会フェーズ2：ノーシード校の配置 (ロジック変更なし) ---
    potNameEl.textContent = "ノーシード校";
    const nonSeeds = lotteryOrder.filter(t => !seeds.map(s => s.team).includes(t));
    for (const teamName of nonSeeds) {
        let dreadBg = null;
        if (isStrongRank(teamName) && initialAiEnabled) {
            dreadBg = document.createElement('div');
            dreadBg.className = 'dread-mode-bg';
            document.body.appendChild(dreadBg);
            potEl.classList.add('dread');
            commentaryEl.textContent = `会場が静まり返る... ノーシードの強豪 ${teamName} が登場...`;
            await sleep(2500);
        }

        commentaryEl.textContent = `${teamName}がクジを引きます...`;
        playSound('sound-drumroll');
        await sleep(250);
        drawnTeamEl.textContent = teamName;
        drawnTeamContainer.classList.add('fade-in-out');
        const slotIndex = Math.floor(Math.random() * availableNonSeedSlots.length);
        const position = availableNonSeedSlots.splice(slotIndex, 1)[0];
        teamPositions[position] = teamName;
        await sleep(200);
        const targetSlot = document.querySelector(`.lottery-slot[data-index="${position}"]`);
        targetSlot.querySelector('.team-name-placeholder').textContent = teamName;
        targetSlot.classList.add('filled');
        playSound('sound-cymbal');
        if (dreadBg) {
            dreadBg.remove();
            potEl.classList.remove('dread');
            playSound('sound-gasp');
        }
        commentaryEl.textContent = `${teamName}は ${position + 1}番 に決定！`;
        
        let didComment = false;
        if (initialAiEnabled) {
             didComment = checkDeathBlock(position);
        }

        if (!didComment) {
            const opponentIndex = position % 2 === 0 ? position + 1 : position - 1;
            if(teamPositions[opponentIndex]) {
                const opponentName = teamPositions[opponentIndex];
                const opponentIsSeed = seeds.some(s => s.team === opponentName);
                const isRival = (isStrongRank(teamName) && opponentIsSeed) || 
                              (['A','B'].includes(calculateRank(teamName, {})) && ['A','B'].includes(calculateRank(opponentName, {})));
                if (isRival && initialAiEnabled) {
                    commentaryEl.textContent = `決まったー！1回戦から屈指の好カード！ ${teamName} vs ${opponentName}`;
                    playSound('sound-gasp');
                    document.querySelector(`.lottery-slot[data-index="${opponentIndex}"]`).classList.add('highlight');
                    targetSlot.classList.add('highlight');
                    await sleep(1500);
                    document.querySelector(`.lottery-slot[data-index="${opponentIndex}"]`).classList.remove('highlight');
                    targetSlot.classList.remove('highlight');
                }
            }
        }
        await sleep(250);
        drawnTeamContainer.classList.remove('fade-in-out');
    }

    // --- 4. 終了処理 ---
    commentaryEl.textContent = '全ての組み合わせが決定しました！';
    await sleep(2000);
    
    if (initialAiEnabled) {
        await generateCaptainInterviews(teamPositions);
    } else {
        document.getElementById('lottery-modal').classList.add('hidden');
        SoundManager.stopBgm();
        createNewTournament(false, 'summer', teamPositions);
    }
}
// ▲▲▲ 置き換えここまで ▲▲▲

// ▲▲▲ 置き換えここまで ▲▲▲
/**
 * [UPDATED] 抽選会後の主将インタビューを生成・表示する
 * (★甲子園モードに対応)
 */
async function generateCaptainInterviews(teamPositions) {
    const interviewModal = document.getElementById('interview-modal');
    const interviewContent = document.getElementById('interview-content');
    interviewContent.innerHTML = `<div class="loader">AI記者が主将インタビューを作成中...</div>`;
    interviewModal.classList.remove('hidden');

    const matchups = [];
    // 128チーム制(県) or 64チーム制(甲子園)
    const numTeams = teamPositions.length;
    for(let i=0; i<numTeams; i+=2){
        if (teamPositions[i] && teamPositions[i+1]) {
            matchups.push({team1: teamPositions[i], team2: teamPositions[i+1]});
        }
    }

    const notableMatchups = shuffleArray(matchups).slice(0, 5);

    const matchupsWithRanks = notableMatchups.map(m => ({
        team1: m.team1,
        rank1: calculateRank(m.team1, tournamentState),
        team2: m.team2,
        rank2: calculateRank(m.team2, tournamentState)
    }));
    const promptDataText = matchupsWithRanks.map(m => 
        `- ${m.team1} (ランク: ${m.rank1}) vs ${m.team2} (ランク: ${m.rank2})`
    ).join('\n');

    // ★★★ 修正箇所: プロンプトの切り替え ★★★
    const isKoshien = tournamentState.currentTournament === 'summer_koshien';
    const contextText = isKoshien ? "夏の甲子園（全国大会）" : "夏の県大会";
    const extraInstruction = isKoshien 
        ? "- 甲子園という大舞台への緊張感や、全国制覇への意気込みを含めてください。" 
        : "- チームの背景（例：王者、古豪）も少しだけコメントに反映させてください。";
    // ★★★ 修正ここまで ★★★

    const prompt = `あなたは高校野球専門のAI記者です。${contextText}の組み合わせ抽選会が終了しました。
以下の注目カードについて、両チームの主将になりきって、抽選結果に対するリアルな反応を語ってください。

### 注目カードと各チームのランク
${promptDataText}

### あなたがなりきる「高校生の主将」の思考パターン
- **(BYE) 不戦勝と当たった場合:**
  - 「初戦が不戦勝なのはラッキーだ」「まずは2回戦に向けてしっかり準備したい」と、安堵と油断のなさを表明する。
- **格下の相手と当たった場合 (例: Aランク vs Dランク):**
  - 少し安堵した様子を見せる。「自分たちの野球をすれば負けない」
  - しかし油断は禁物だと付け加える。「一戦必勝で戦いたい」
- **格上の相手と当たった場合 (例: Eランク vs Aランク):**
  - 「まさか初戦で当たるとは…」と驚きつつ、「胸を借りるつもりで全力でぶつかりたい」と闘志を見せる。
- **実力が拮抗している相手と当たった場合 (例: Cランク vs Cランク):**
  - 「ここが最初の山場になる」「最高の試合をしたい」と、ライバルとの対戦を心待ちにしている様子を見せる。

### 指示
- 上記の思考パターンに基づき、各カードの両主将のコメントを生成してください。
${extraInstruction}

### 出力形式 (JSON配列)
[
    {"team": "〇〇高校", "captain_comment": "（主将のコメント）"},
    {"team": "△△高校", "captain_comment": "（主将のコメント）"}
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        const interviews = parseJsonFromText(result.candidates[0].content.parts[0].text);

        if (interviews && Array.isArray(interviews)) {
            interviewContent.innerHTML = interviews.map(iv => `
                <div class="p-4 bg-gray-50 rounded-lg mb-2">
                    <h4 class="font-bold text-lg text-gray-800">${iv.team} 主将</h4>
                    <p class="mt-1 text-gray-700">「${iv.captain_comment}」</p>
                </div>
            `).join('');
        } else {
            throw new Error("Parsed JSON is not an array or is null.");
        }
    } catch (e) {
        interviewContent.innerHTML = `<p class="text-center text-red-500">インタビューの生成に失敗しました。</p>`;
        console.error(e);
    }
    
    // 閉じるボタンの処理 (モードによって再開処理を変える)
    document.getElementById('close-interview-btn').onclick = () => {
        interviewModal.classList.add('hidden');
        document.getElementById('lottery-modal').classList.add('hidden');
        SoundManager.stopBgm();
        
        if (isKoshien) {
            // 甲子園モードなら setupKoshienTournament は既に完了しているので、再描画のみでOKだが、
            // 実際には抽選会アニメーションは県大会でしか呼ばれない想定のUIになっているため、
            // もし甲子園で抽選会をするならここを調整。
            // 現状のフローでは甲子園は抽選アニメなしで開始されるので、ここは主に県大会用。
            createNewTournament(false, 'summer', teamPositions);
        } else {
            createNewTournament(false, 'summer', teamPositions);
        }
    };
}
     
/**
 * [NEW] スクロール連動アニメーション用のIntersection Observer
 */
function setupScrollAnimation() {
    const scrollContainer = document.getElementById('homepage-scroll-container');
    if (!scrollContainer) return;

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('is-visible');
                // 一度表示されたら監視を解除（オプション）
                // observer.unobserve(entry.target);
            } else {
                 // スクロールアウトしたら非表示に戻す場合（オプション）
                 // entry.target.classList.remove('is-visible');
            }
        });
    }, {
        root: scrollContainer, // 監視対象をモーダルのスクロールコンテナに設定
        rootMargin: '0px',
        threshold: 0.1 // 10%見えたらトリガー
    });

    // モーダル内の全セクションを監視対象に追加
    scrollContainer.querySelectorAll('.fade-in-section').forEach(section => {
        observer.observe(section);
    });
}

/**
 * [NEW] ホームページモーダルを開く/閉じるアニメーションのトリガー
 */
function toggleHomepageModal(show) {
    const modal = document.getElementById('homepage-modal');
    if (!modal) return;

    if (show) {
        // モーダルを開く
        modal.classList.remove('hidden');
        modal.classList.add('flex');
        
        // ヒーローセクションのアニメーションをリセット＆トリガー
        const slogan = modal.querySelector('.slogan');
        const subtitle = modal.querySelector('.animate-fade-in-up');
        if (slogan) slogan.classList.remove('animate-fade-in-down');
        if (subtitle) subtitle.classList.remove('is-visible');
        
        // requestAnimationFrame を挟むことで、クラスの再適用を確実にする
        requestAnimationFrame(() => {
            if (slogan) slogan.classList.add('animate-fade-in-down');
            if (subtitle) subtitle.classList.add('is-visible');
        });

        // スクロール連動アニメーションをセットアップ
        setupScrollAnimation();
        
    } else {
        // モーダルを閉じる
        modal.classList.add('hidden');
        modal.classList.remove('flex');
        
        // 閉じる時にアニメーションクラスをリセット（次回開くときのため）
        modal.querySelectorAll('.fade-in-section').forEach(section => {
            section.classList.remove('is-visible');
        });
        modal.querySelector('.slogan')?.classList.remove('animate-fade-in-down');
        modal.querySelector('.animate-fade-in-up')?.classList.remove('is-visible');
    }
}
// ▲▲▲ 新規追加ここまで ▲▲▲


// ▼▼▼ 甲子園・激闘シナリオモードの実装 ▼▼▼

/**
 * [UPDATED] 夏の県大会優勝チームを迎え、甲子園激闘トーナメントをセットアップする
 * (★県大会成績保存、号外、そして「代表校紹介記事」の生成を追加)
 */
async function setupKoshienTournament(winnerName) {
    console.log(`甲子園モード起動: 代表校 ${winnerName}`);
    
    // 1. 強豪校データの注入
    addLegendaryTeamsData();

    // 2. 県大会成績の保存とリセット
    const championRecord = tournamentState.teamRecords[winnerName];
    if (championRecord && championRecord.tournamentStats) {
        championRecord.prefecturalStats = JSON.parse(JSON.stringify(championRecord.tournamentStats));
        championRecord.tournamentStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, r: 0, so: 0, bb: 0, hbp: 0, sf: 0 };
    }

    // 3. ステートの更新
    tournamentState.currentTournament = 'summer_koshien';
    tournamentState.matches = {}; 

    // 4. 参加チームの生成
    const playerTeam = winnerName;
    const bossTeams = ["花巻東", "横浜", "報徳学園", "浦和学院", "大阪桐蔭", "日大三"];
    const dummyTeams = generateDummyTeams(57, [playerTeam, ...bossTeams]);

    // 5. トーナメント表への配置
    const teams = Array(64).fill(null);
    teams[0] = playerTeam;      
    teams[1] = bossTeams[0];    
    teams[2] = bossTeams[1];    
    teams[4] = bossTeams[2];    
    teams[8] = bossTeams[3];    
    teams[16] = bossTeams[4];   
    teams[32] = bossTeams[5];   
    
    let dummyIdx = 0;
    for (let i = 0; i < 64; i++) {
        if (!teams[i]) {
            teams[i] = dummyTeams[dummyIdx++];
        }
        if (!tournamentState.teamRecords[teams[i]]) {
            tournamentState.teamRecords[teams[i]] = {
                wins: 0, losses: 0, best: null, history: [], lastFinish: 64,
                playerStats: { batting: {}, pitching: {} },
                tournamentStats: { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, r: 0, so: 0 }
            };
        }
    }
    tournamentState.teams = teams;
    tournamentState.seeds = []; 

    // 6. 試合オブジェクトの生成
    const round1Setup = teams.reduce((acc, team, i) => {
        if (i % 2 === 0) acc.push({ team1: team, team2: null });
        else acc[acc.length - 1].team2 = team;
        return acc;
    }, []);
    
    round1Setup.forEach((match, index) => {
        const side = index < 16 ? 'L' : 'R';
        const matchNum = index < 16 ? index + 1 : index - 15;
        const matchId = `${side}-R1-M${matchNum}`;
        let rivalry = null;
        // 浦和学院との因縁設定
        if ((match.team1.includes("283") && match.team2 === "浦和学院") || (match.team1 === "浦和学院" && match.team2.includes("283"))) {
            rivalry = "昨夏の雪辱戦";
        }
        tournamentState.matches[matchId] = { 
            id: matchId, team1: match.team1, team2: match.team2, winner: null, 
            score1: '', score2: '', details: null, summary: '', rivalryType: rivalry 
        };
    });

    const finalRound = 6;
    for (let r = 2; r < finalRound; r++) {
        const numMatchesInRound = 64 / Math.pow(2, r);
        for (let m = 1; m <= numMatchesInRound / 2; m++) {
            const matchIdL = `L-R${r}-M${m}`;
            tournamentState.matches[matchIdL] = { id: matchIdL, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
            const matchIdR = `R-R${r}-M${m}`;
            tournamentState.matches[matchIdR] = { id: matchIdR, team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };
        }
    }
    tournamentState.matches['F-R1-M1'] = { id: 'F-R1-M1', team1: null, team2: null, winner: null, score1: '', score2: '', details: null, summary: '' };

    // 7. スケジュール割り当て
    const koshienStadium = [{ name: "阪神甲子園球場", abbr: "甲", region: "全国" }];
    
    // 1回戦 (32試合): 8日間 (1日4試合)
    const r1Ids = Object.keys(tournamentState.matches).filter(id => id.includes('-R1-'));
    scheduleRoundMatches(r1Ids, [
        "8/6", "8/7", "8/8", "8/9", "8/10", "8/11", "8/12", "8/13"
    ], koshienStadium, 4);

    // 2回戦 (16試合): 4日間 (1日4試合)
    const r2Ids = Object.keys(tournamentState.matches).filter(id => id.includes('-R2-'));
    scheduleRoundMatches(r2Ids, [
        "8/14", "8/15", "8/16", "8/17"
    ], koshienStadium, 4);

    // 3回戦 (8試合): 2日間 (1日4試合) ※8/18は休養日想定
    const r3Ids = Object.keys(tournamentState.matches).filter(id => id.includes('-R3-'));
    scheduleRoundMatches(r3Ids, [
        "8/19", "8/20"
    ], koshienStadium, 4);

    // 準々決勝 (4試合): 1日 (一斉開催) ※8/21は休養日想定
    const r4Ids = Object.keys(tournamentState.matches).filter(id => id.includes('-R4-'));
    scheduleRoundMatches(r4Ids, ["8/22"], koshienStadium, 4);

    // 準決勝 (2試合): 1日 ※8/23は休養日想定
    const r5Ids = Object.keys(tournamentState.matches).filter(id => id.includes('-R5-'));
    scheduleRoundMatches(r5Ids, ["8/24"], koshienStadium, 2);

    // 決勝 (1試合) ※8/25は休養日想定
    const finalId = Object.keys(tournamentState.matches).filter(id => id.startsWith('F-R1-'));
    scheduleRoundMatches(finalId, ["8/26"], koshienStadium, 1);
    mainBracketWrapper.classList.remove('hidden');
    renderTournament(tournamentState);
    
    // ニュース生成キュー
    const newsQueue = [];

    // 1. 号外
    newsQueue.push({
        title: "【号外】夏の甲子園 組み合わせ決定！ 代表校は「死のブロック」へ",
        body: `${winnerName}の甲子園初戦の相手は、岩手の怪物産出校「花巻東」に決定しました。\nさらに勝ち上がれば横浜、報徳学園と続く激戦区に入っており、準々決勝では因縁の浦和学院、準決勝では大阪桐蔭との対戦が予想される「地獄のロード」となりました。`,
        timestamp: Date.now(),
        context: { isBracketAnalysis: true }
    });

    // 2. 代表校紹介
    newsContainer.innerHTML = `<div class="loader">AI記者が甲子園特集記事を執筆中...</div>`;
    const introArticle = await generateKoshienTeamIntro(winnerName);
    if (introArticle) newsQueue.push(introArticle);

    // 3. ★★★ 注目選手10選 ★★★
    const top10Article = await generateTopPlayersArticle();
    if (top10Article) newsQueue.push(top10Article);

    // まとめて追加
    tournamentState.news.push(...newsQueue);
    renderNews(tournamentState.news);
    saveState();
}

/**
 * [UPDATED] 強豪6校のデータと、その主力選手の「予選成績」を生成して登録する
 * (★全チームAランクになるよう偏差値を強化)
 */
function addLegendaryTeamsData() {
    // 1. チーム基本情報の登録 (偏差値を80以上に設定)
    const newTeams = {
        "花巻東": { region: "東北", type: "私立", deviation: 88, info: "岩手の怪物産出校。", coach: { name: '佐々木 洋', style: '常識打破' }, best: "甲子園ベスト4", last: "甲子園出場" },
        "横浜": { region: "関東", type: "私立", deviation: 89, info: "神奈川の名門。", coach: { name: '村田 浩明', style: '育成上手' }, best: "甲子園優勝", last: "甲子園出場" },
        "報徳学園": { region: "近畿", type: "私立", deviation: 87, info: "逆転の報徳。", coach: { name: '大角 健二', style: '全員野球' }, best: "甲子園優勝", last: "センバツ準優勝" },
        "浦和学院": { region: "関東", type: "私立", deviation: 86, info: "超強力打線。", coach: { name: '森 大', style: '超攻撃型' }, best: "甲子園優勝", last: "甲子園ベスト8" },
        "大阪桐蔭": { region: "近畿", type: "私立", deviation: 95, info: "絶対王者。", coach: { name: '西谷 浩一', style: '王道野球' }, best: "甲子園優勝", last: "甲子園優勝" },
        "日大三": { region: "関東", type: "私立", deviation: 88, info: "強打の日三。", coach: { name: '三木 有造', style: '積極打撃' }, best: "甲子園優勝", last: "甲子園ベスト4" }
    };
    Object.assign(TEAM_DATA, newTeams);

    // 2. 詳細選手データ（スター選手）の登録
    const legendaryPlayers = {
        "花巻東": [
            { name: "佐々木(麟)", year: 3, position: "一塁手", stats: { avg: .480, hr: 8, rbi: 25, sb: 5 }, desc: "高校通算140発の怪物スラッガー" },
            { name: "大谷(翔)", year: 3, position: "投手", stats: { era: 0.80, w: 5, so: 60, k9: 12.5 }, desc: "最速160kmを誇る二刀流の天才" }
        ],
        "横浜": [
            { name: "松坂", year: 3, position: "投手", stats: { era: 1.10, w: 6, so: 55, k9: 10.2 }, desc: "「平成の怪物」の再来。スライダーが武器" },
            { name: "筒香", year: 3, position: "右翼手", stats: { avg: .450, hr: 6, rbi: 20, sb: 2 }, desc: "ハマのゴジラ。広角に打ち分ける長距離砲" }
        ],
        "報徳学園": [
            { name: "小園", year: 3, position: "遊撃手", stats: { avg: .510, hr: 3, rbi: 15, sb: 12 }, desc: "超高校級の守備と俊足、打撃センスを兼備" }
        ],
        "浦和学院": [
            { name: "森(士)", year: 3, position: "投手", stats: { era: 1.50, w: 5, so: 40, k9: 8.5 }, desc: "関東No.1左腕。精密機械のような制球力" },
            { name: "西川", year: 3, position: "中堅手", stats: { avg: .390, hr: 4, rbi: 18, sb: 8 }, desc: "天才的なバットコントロール" }
        ],
        "大阪桐蔭": [
            { name: "中田", year: 3, position: "一塁手", stats: { avg: .550, hr: 9, rbi: 30, sb: 3 }, desc: "「怪物」の名をほしいままにする大会最強打者" },
            { name: "藤浪", year: 3, position: "投手", stats: { era: 0.50, w: 6, so: 70, k9: 13.0 }, desc: "197cmから投げ下ろす剛速球はアンタッチャブル" },
            { name: "森(友)", year: 2, position: "捕手", stats: { avg: .420, hr: 5, rbi: 22, sb: 1 }, desc: "天才的な打撃技術を持つ司令塔" }
        ],
        "日大三": [
            { name: "畔上", year: 3, position: "右翼手", stats: { avg: .410, hr: 5, rbi: 24, sb: 4 }, desc: "強打の日三を象徴する主将" }
        ]
    };

    // 3. teamRecords にデータを注入
    for (const [teamName, players] of Object.entries(legendaryPlayers)) {
        DETAILED_TEAM_DATA[teamName] = {
            summary: TEAM_DATA[teamName].info,
            players: players.map(p => ({ name: p.name, year: p.year, position: p.position, desc: p.desc }))
        };

        if (!tournamentState.teamRecords[teamName]) {
            tournamentState.teamRecords[teamName] = {
                playerStats: { batting: {}, pitching: {} },
                tournamentStats: { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, r: 0, so: 0 }
            };
        }
        
        players.forEach(p => {
            const record = tournamentState.teamRecords[teamName];
            if (p.position === "投手") {
                const ip = 40.0;
                const er = Math.round((p.stats.era * ip) / 9);
                record.playerStats.pitching[p.name] = {
                    career: { ip: ip, w: p.stats.w, l: 0, er: er, so: p.stats.so, h: 20, bb: 10 },
                    narrative_flag: 'peak'
                };
            } else {
                const ab = 25;
                const h = Math.round(ab * p.stats.avg);
                record.playerStats.batting[p.name] = {
                    ab: ab, h: h, hr: p.stats.hr, rbi: p.stats.rbi, sb: p.stats.sb,
                    narrative_flag: 'peak'
                };
            }
        });
    }
}

/**
 * [NEW] 甲子園開幕特別企画：大会注目選手10選の記事を生成する
 * (予選成績に基づき、プレイヤー選手と全国の怪物をランキング化)
 */
async function generateTopPlayersArticle() {
    const allPlayers = [];

    // 1. 全チームをスキャンして選手データを収集
    Object.keys(tournamentState.teamRecords).forEach(teamName => {
        const record = tournamentState.teamRecords[teamName];
        if (!record.playerStats) return;

        // 打者
        if (record.playerStats.batting) {
            Object.entries(record.playerStats.batting).forEach(([name, stats]) => {
                // 予選成績 (prefecturalStatsがある場合はそちらを優先したいが、
                // 個人成績はplayerStatsに通算されているため、それを使用)
                if (stats.ab >= 10) { // 規定打席(仮)
                    const avg = stats.h / stats.ab;
                    // 評価スコア (打率 + HR重視)
                    const score = (avg * 100) + (stats.hr * 5) + (stats.rbi * 2) + (stats.sb * 1);
                    allPlayers.push({
                        name: name, team: teamName, type: 'batter',
                        value: score,
                        desc: `打率${avg.toFixed(3)} ${stats.hr}本 ${stats.rbi}打点`
                    });
                }
            });
        }
        // 投手
        if (record.playerStats.pitching) {
            Object.entries(record.playerStats.pitching).forEach(([name, stats]) => {
                const s = stats.career;
                if (s.ip >= 15) { // 規定投球回(仮)
                    const era = (s.er * 9) / s.ip;
                    // 評価スコア (防御率が低いほど高得点 + 奪三振)
                    const score = (10 - era) * 10 + (s.so * 2) + (s.w * 5);
                    allPlayers.push({
                        name: name, team: teamName, type: 'pitcher',
                        value: score,
                        desc: `防御率${era.toFixed(2)} ${s.w}勝 ${s.so}奪三振`
                    });
                }
            });
        }
    });

    // 2. スコア順にソートしてトップ10を抽出
    const top10 = allPlayers.sort((a, b) => b.value - a.value).slice(0, 10);

    // 3. 記事生成
    if (top10.length === 0) return null;

    const rankingText = top10.map((p, i) => 
        `${i + 1}位: ${p.name} (${p.team}) - ${p.desc}`
    ).join('\n');

    const prompt = `あなたはスポーツ雑誌「Number」の記者です。
まもなく開幕する夏の甲子園に向けて、「大会注目のスーパープレイヤー10選」という特集記事を書いてください。
以下のリストは、各都道府県予選で圧倒的な成績を残したトップ10選手です。

### 注目選手ランキング (予選成績に基づく)
${rankingText}

### 執筆指示
- タイトルは「【甲子園開幕】スカウトも熱視線！ 今大会の"BIG10"を一挙紹介」のようなワクワクするものに。
- 1位から順に、選手を紹介してください。
- **あなたのチーム（${tournamentState.teams[0]}）の選手がランクインしている場合は、特に熱く、「地元の期待の星」として紹介してください。**
- 大阪桐蔭や花巻東などの有名選手については、「世代最強」「怪物の再来」といった異名をつけて盛り上げてください。
- 予選の成績データ(${rankingText})を必ず引用して、凄みを伝えてください。

### 出力形式 (JSON)
{"title": "記事タイトル", "body": "記事本文"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                return { 
                    ...article, 
                    timestamp: Date.now(),
                    context: { isFeatureArticle: true }
                };
            }
        }
        return null;
    } catch (error) {
        console.error("注目選手記事生成エラー:", error);
        return null;
    }
}

/**
 * [FIXED] ダミーチームを生成する
 * (★全チームAランクになるよう偏差値を80に設定)
 */
function generateDummyTeams(count, excludeNames) {
    const prefixes = ["北海", "仙台", "前橋", "智弁", "広島", "福岡", "鹿児島", "沖縄", "京都", "愛工大", "天理", "星稜", "明徳", "広陵", "作新", "関東"];
    const suffixes = ["学園", "実業", "大付属", "商業", "工業", "学院", "第一"];
    const dummies = [];
    let attempts = 0;
    
    // 1. ランダムな名前で生成
    while (dummies.length < count && attempts < 1000) {
        const name = prefixes[Math.floor(Math.random() * prefixes.length)] + suffixes[Math.floor(Math.random() * suffixes.length)];
        if (!excludeNames.includes(name) && !dummies.includes(name) && !TEAM_DATA[name]) {
            dummies.push(name);
            TEAM_DATA[name] = { 
                name_yomi: "だみー", region: "全国", type: "私立", deviation: 80, // ★偏差値80
                best: "甲子園出場", last: "予選突破", 
                info: "各都道府県の代表校。非常に強力な戦力を有する。", 
                coach: { name: "モブ監督", style: "堅実", experience: "中堅" } 
            };
        }
        attempts++;
    }
    
    // 2. 足りない分を連番で埋める
    while (dummies.length < count) {
        const name = `代表高校${dummies.length + 1}`;
        if (!dummies.includes(name)) {
            dummies.push(name);
            TEAM_DATA[name] = { 
                name_yomi: "だいひょうこう", region: "全国", type: "公立", deviation: 80, // ★偏差値80
                best: "甲子園出場", last: "予選突破",
                info: "各都道府県の代表校。", 
                coach: { name: "監督", style: "普通", experience: "中堅" } 
            };
        }
    }
    return dummies;
}
/**
 * [NEW] 甲子園用：地元紙風のニュース記事を生成する
 * (★県大会同様のフルデータを注入)
 * (★★ ユーザーからの再生成指示(userFeedback)に対応 ★★)
 */
async function generateKoshienNewsArticle(matchContext, userFeedback = null) {
    const {
        winnerName, loserName, dbMatch, matchId,
        winnerData, loserData, winnerDetailedData, loserDetailedData,
        winnerLineupChanges, loserLineupChanges,
        winnerJourney, loserJourney,
        nextOpponent, nextOpponentJourney, 
        pitcherGamelogInfo, batterGamelogInfo,
        injuryReport, playerStatsText, highlights,
        prefecturalStatsText // ★追加
    } = matchContext;

    const myTeam = tournamentState.teams[0]; 
    const isWin = (winnerName === myTeam);
    const opponentName = isWin ? loserName : winnerName;
    const score = `${dbMatch.score1}-${dbMatch.score2}`;
    const roundName = getRoundNameFromMatchId(matchId);
    
    // データ整形
    const winnerRecord = tournamentState.teamRecords[winnerName];
    const loserRecord = tournamentState.teamRecords[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, winnerRecord);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, loserRecord);
    const highlightsText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
    const lineupChangesText = `- ${winnerName}: ${winnerLineupChanges}\n- ${loserName}: ${loserLineupChanges}`;
    const calledGameText = matchContext.calledGame ? `\n- **特記事項:** ${matchContext.calledInning}回コールドゲーム` : '';
    const rivalryText = matchContext.rivalryType ? `\n- **特記事項:** この試合は「${matchContext.rivalryType}」という因縁の対決でした。` : '';

    let scheduleText = '';
    if (matchContext.schedule) {
        const sched = matchContext.schedule;
        scheduleText = `\n- **試合会場:** ${sched.stadiumFull} (聖地・甲子園)\n`;
    }
    
    let atmosphereText = '';
    if (matchContext.atmosphere_team1 || matchContext.atmosphere_team2) {
        atmosphereText = '\n### データ5：試合前の雰囲気・公約\n';
        if (matchContext.atmosphere_team1) atmosphereText += `- ${dbMatch.team1}: ${matchContext.atmosphere_team1}\n`;
        if (matchContext.atmosphere_team2) atmosphereText += `- ${dbMatch.team2}: ${matchContext.atmosphere_team2}\n`;
    }

    let ballQualityText = '';
    if (matchContext.team1BallQuality && matchContext.team2BallQuality) {
        ballQualityText = `\n### データ4：チーム別 打球品質レポート\n- ${matchContext.team1BallQuality}\n- ${matchContext.team2BallQuality}\n`;
    }

    // 次戦情報
    let nextOpponentText = '次戦の相手は未定です。';
    let nextOpponentJourneyText = '';
    if (nextOpponent) {
        if (nextOpponent.opponentName === '優勝') {
            nextOpponentText = '悲願の全国制覇を成し遂げました！';
        } else if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            nextOpponentText = `次戦は${nextOpponent.roundName}、強豪・${nextOpponent.opponentName}と対戦します。`;
            if (matchContext.nextOpponentJourney) {
                 nextOpponentJourneyText = `(相手の軌跡: ${matchContext.nextOpponentJourney})`;
            }
        }
    }

    // ★★★ フィードバック指示の構築 ★★★
    let feedbackPrompt = '';
    if (userFeedback) {
        if (userFeedback.include) feedbackPrompt += `\n- **【デスクからの追加指示(必須)】**: ${userFeedback.include}`;
        if (userFeedback.exclude) feedbackPrompt += `\n- **【デスクからの禁止事項】**: ${userFeedback.exclude}`;
    }
    // ★★★★★★★★★★★★★★★★★

    const prompt = `あなたは「静岡新聞」のスポーツ担当記者です。
郷土の代表「${myTeam}」の甲子園での試合記事を執筆してください。
**全国紙のような中立な視点ではなく、静岡県民の視点に立ち、詳細なデータに基づいて選手たちを称える温かい記事**にしてください。

### 試合情報
- ラウンド: ${roundName}
- 結果: ${myTeam}の${isWin ? '勝利' : '敗北'} (${score})
- 対戦相手: ${opponentName}
${injuryReport || ''}

### 試合の詳細データ (あなたの取材メモ)
- **試合のハイライト**:
${highlightsText}
- **個人成績 (ボックススコア)**:
${playerStatsText}
- **県大会(予選)の成績**:
${prefecturalStatsText || '情報なし'}
- **チーム状況**:
  - ${winnerName}: ${winnerDynamicInfo}
  - ${loserName}: ${loserDynamicInfo}
- **スタメン変更**:
${lineupChangesText}
- **これまでの活躍 (Gamelog)**:
${pitcherGamelogInfo}
${batterGamelogInfo}
${ballQualityText}
${atmosphereText}
${scheduleText}

### 執筆指示
1.  **タイトル**: 「やったぞ${myTeam}！」「夢をありがとう${myTeam}」のように感情を込めつつ、試合の決定的な場面（サヨナラ、完封など）も含めてください。
2.  **本文**:
    - **「詳細データ（ハイライト、個人成績、Gamelog）」**に基づいて、試合経過を具体的に描写してください。（例：「〇回、△△くんの（★注目）勝ち越しタイムリーで...」「エース□□くんがGamelog通りの粘りの投球で...」）
    - 活躍した選手を具体名で挙げ、そのプレーを最大限に称賛してください。
    - **【比較分析】**: 県大会の成績(${prefecturalStatsText})や過去のGamelogと比較し、「県大会から好調を維持」「予選で苦しんだエースが甲子園で覚醒」といった分析を加えてください。
    - もし「故障者リスト」(${injuryReport})に記載のある選手がいれば、「（主力）〇〇くんの不在を感じさせない戦いだった」「満身創痍の中でよく戦った」と、その選手の重要度も考慮して労ってください。
    - **勝利時**: 「県勢〇〇年ぶりの快挙」「次戦の${nextOpponentText}もこの勢いで」と盛り上げてください。
    - **敗戦時**: 「胸を張って静岡に帰ってきてほしい」「この夏、私たちに夢を見せてくれた」と感謝で締めくくってください。
    - 最後に、次の対戦相手（${nextOpponentText}）に触れてください。
${feedbackPrompt}

### 出力形式 (JSON)
{"title": "記事タイトル", "body": "記事本文"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                article.body += "\n\n　（静岡新聞 特設取材班）";
                return { 
                    ...article, 
                    timestamp: Date.now(), 
                    context: matchContext,
                    isKoshienNews: true // フラグ維持
                };
            }
        }
        return null;
    } catch (error) {
        console.error("甲子園記事生成エラー:", error);
        return null;
    }
}

/**
 * [NEW] 甲子園用：県民応援掲示板のコメントを生成する
 * (★県大会同様のフルデータを注入)
 */
async function generateKoshienBbsComments(matchContext) {
    const { 
        winnerName, loserName, dbMatch, matchId, injuryReport,
        playerStatsText, highlights, pitcherGamelogInfo, batterGamelogInfo,
        nextOpponent, nextOpponentJourney,
        winnerLineupChanges, loserLineupChanges,
        winnerData, loserData, winnerDetailedData, loserDetailedData,
        winnerJourney, loserJourney,
        hadaReportSummary, prefecturalStatsText // ★追加
    } = matchContext;

    const myTeam = tournamentState.teams[0]; // プレイヤーチーム(県代表)
    const isWin = (winnerName === myTeam);
    const opponentName = isWin ? loserName : winnerName;
    const score = `${dbMatch.score1}-${dbMatch.score2}`;
    const roundName = getRoundNameFromMatchId(matchId);

    // --- 詳細データの生成 ---
    const tournamentYear = tournamentState.tournamentYear;
    const tournamentName = "全国高等学校野球選手権大会";
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const winnerSeedRank = ""; 
    const loserSeedRank = "";
    
    const winnerRecord = tournamentState.teamRecords[winnerName];
    const loserRecord = tournamentState.teamRecords[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, winnerRecord);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, loserRecord);
    
    const highlightsText = highlights.map(fact => `- ${fact.inning || ''}回 ${fact.team || ''} ${fact.player || ''}: ${fact.description}`).join('\n');
    const lineupChangesText = `- ${winnerName}: ${winnerLineupChanges}\n- ${loserName}: ${loserLineupChanges}`;
    const calledGameText = matchContext.calledGame ? `\n- **特記事項:** ${matchContext.calledInning}回コールドゲーム` : '';
    const rivalryText = matchContext.rivalryType ? `\n- **特記事項:** この試合は「${matchContext.rivalryType}」という因縁の対決でした。` : '';
    
    let scheduleText = '';
    if (matchContext.schedule) {
        const sched = matchContext.schedule;
        scheduleText = `\n- **試合会場:** ${sched.stadiumFull}\n`;
    }
    
    let atmosphereText = '';
    if (matchContext.atmosphere_team1 || matchContext.atmosphere_team2) {
        atmosphereText = '\n### データ6：試合前の雰囲気・公約\n';
        if (matchContext.atmosphere_team1) atmosphereText += `- ${dbMatch.team1}: ${matchContext.atmosphere_team1}\n`;
        if (matchContext.atmosphere_team2) atmosphereText += `- ${dbMatch.team2}: ${matchContext.atmosphere_team2}\n`;
    }

    let ballQualityText = '';
    if (matchContext.team1BallQuality && matchContext.team2BallQuality) {
        ballQualityText = `\n### データ4：チーム別 打球品質レポート\n- ${matchContext.team1BallQuality}\n- ${matchContext.team2BallQuality}\n`;
    }

    // 次戦情報
    let nextOpponentText = '次戦の相手は未定です。';
    let nextOpponentJourneyText = '';
    if (nextOpponent) {
        if (nextOpponent.opponentName === '優勝') {
            nextOpponentText = '悲願の全国制覇を成し遂げました！';
        } else if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            nextOpponentText = `次戦は${nextOpponent.roundName}、強豪・${nextOpponent.opponentName}と対戦します。`;
            if (matchContext.nextOpponentJourney) {
                 nextOpponentJourneyText = `(相手の軌跡: ${matchContext.nextOpponentJourney})`;
            }
        }
    }

    const hadaReportText = hadaReportSummary ? `\n### データ6：記者の視点\n${hadaReportSummary}\n` : '';

    const prompt = `あなたは、静岡県代表「${myTeam}」を応援する地元のファンたちが集まる掲示板の住人です。
甲子園 ${roundName}、${opponentName}戦の結果について、**提供された詳細データに基づき**、温かく熱いコメントを20個生成してください。

### 現在の試合状況
- **大会:** ${tournamentYear}年度 ${tournamentName}
- **文脈:** 地元の誇り、県代表を全力応援
- **ラウンド:** ${roundName}
${scheduleText}

### データ1：試合結果
- **勝利:** ${winnerName} ${winnerSeedRank} (ランク: ${winnerRank})
- **敗北:** ${loserName} ${loserSeedRank} (ランク: ${loserRank})
- **スコア:** ${score}
- **スタメン変更:**
${lineupChangesText}
${calledGameText}
${rivalryText}
${injuryReport || ''}

### データ2：チームの背景
- **${winnerName}**: ${winnerDynamicInfo}
  - **軌跡**: ${winnerJourney}
- **${loserName}**: ${loserDynamicInfo}
  - **軌跡**: ${loserJourney}

### データ3：この試合の個人成績 (最終結果の要約)
${playerStatsText || '個人成績データはありません。'}
- **県大会(予選)の成績**:
${prefecturalStatsText || '情報なし'}

### データ4：試合の主な出来事 (ハイライト)
${highlightsText}
${ballQualityText}

### データ5：トーナメント全体の状況
- **次の試合**: ${nextOpponentText} ${nextOpponentJourneyText}
${atmosphereText}
${hadaReportText}

### データ6：今大会の主な投手登板履歴 (この試合より前)
${pitcherGamelogInfo || '今大会、これが初登板です。'}

### データ7：今大会の主な打者成績履歴 (この試合より前)
${batterGamelogInfo || '打者の試合履歴データはありません。'}

### あなたが演じるキャラクター (アンチはいません)
- **地元のおっちゃん**: プレー内容を具体的に褒める。「〇〇のあの（★注目）ヒットが大きかったな！」
- **OB/OG**: 後輩たちの活躍に涙する。「俺たちの時とは比べ物にならん...」
- **データ好きのファン**: 「今日の〇〇は打率5割超えてるぞ」「県大会の成績よりさらに進化してるな」
- **心配性なファン**: 怪我人(${injuryReport})を気遣う。「〇〇くん(主力)が[🏥]でいないのに勝つなんて！」「△△くん(控え)[🩹]、無理しないで」

### 指示
- **誹謗中傷、煽り、「戦犯」などの言葉は禁止です。**
- **「詳細データ」**にある具体的なプレー（特に「★注目」ハイライト、個人成績、Gamelog）に言及してください。
- **県大会の成績と比較**して、チームや選手の成長（または不調）に言及するコメントを必ず1つ以上入れてください。
- 負けた場合でも、「よく頑張った」「胸を張って帰ってこい」と選手を労ってください。
- 勝った場合は、手放しで称賛し、次戦への期待を語ってください。
- **${injuryReport}** に記載のある選手（特に主力か控えか）を見て、その影響や復帰を願うコメントを入れてください。

### 出力形式 (JSON配列)
[
  {"personality": "地元のおっちゃん", "comment": "（コメント）"},
  {"personality": "283学園OB", "comment": "（コメント）"},
  {"personality": "静岡県民", "comment": "（コメント）"}
]`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const commentsJson = parseJsonFromText(rawText);
            if (Array.isArray(commentsJson)) {
                return commentsJson.map((c, index) => ({
                    id: crypto.randomUUID(),
                    personality: c.personality,
                    text: c.comment,
                    timestamp: Date.now() + index * 10,
                    replies: []
                }));
            }
        }
        return [];
    } catch (error) {
        console.error("甲子園BBS生成エラー:", error);
        return [];
    }
}

/**
 * [NEW] 甲子園用：まとめサイト風スレッドを生成する
 * (★県大会同様のフルデータを注入し、圧倒的な情報量を持たせる)
 */
async function generateKoshienMatomeThread(matchContext) {
    const { 
        winnerName, loserName, dbMatch, matchId, injuryReport,
        playerStatsText, highlights, pitcherGamelogInfo, batterGamelogInfo,
        nextOpponent, nextOpponentJourney,
        winnerLineupChanges, loserLineupChanges,
        winnerData, loserData, winnerDetailedData, loserDetailedData,
        winnerJourney, loserJourney,
        hadaReportSummary, prefecturalStatsText // ★追加
    } = matchContext;

    const myTeam = tournamentState.teams[0]; // プレイヤーチーム
    const isWin = (winnerName === myTeam);
    const opponentName = isWin ? loserName : winnerName;
    const score = `${dbMatch.score1}-${dbMatch.score2}`;
    const roundName = getRoundNameFromMatchId(matchId);

    // --- 詳細データの生成 ---
    const tournamentYear = tournamentState.tournamentYear;
    const tournamentName = "全国高等学校野球選手権大会";
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    
    const winnerRecord = tournamentState.teamRecords[winnerName];
    const loserRecord = tournamentState.teamRecords[loserName];
    const winnerDynamicInfo = generateDynamicTeamInfo(winnerName, winnerData, winnerRecord);
    const loserDynamicInfo = generateDynamicTeamInfo(loserName, loserData, loserRecord);
    
    const highlightsText = highlights.map(fact => `- ${fact.inning || ''}回: ${fact.description}`).join('\n');
    const lineupChangesText = `- ${winnerName}: ${winnerLineupChanges}\n- ${loserName}: ${loserLineupChanges}`;
    const calledGameText = matchContext.calledGame ? `\n- **特記事項:** ${matchContext.calledInning}回コールドゲーム` : '';
    const rivalryText = matchContext.rivalryType ? `\n- **特記事項:** この試合は「${matchContext.rivalryType}」という因縁の対決でした。` : '';
    
    let scheduleText = '';
    if (matchContext.schedule) {
        const sched = matchContext.schedule;
        scheduleText = `\n- **試合会場:** ${sched.stadiumFull}\n`;
    }
    
    let atmosphereText = '';
    if (matchContext.atmosphere_team1 || matchContext.atmosphere_team2) {
        atmosphereText = '\n### データ6：試合前の雰囲気・公約\n';
        if (matchContext.atmosphere_team1) atmosphereText += `- ${dbMatch.team1}: ${matchContext.atmosphere_team1}\n`;
        if (matchContext.atmosphere_team2) atmosphereText += `- ${dbMatch.team2}: ${matchContext.atmosphere_team2}\n`;
    }

    let ballQualityText = '';
    if (matchContext.team1BallQuality && matchContext.team2BallQuality) {
        ballQualityText = `\n### データ4：チーム別 打球品質レポート\n- ${matchContext.team1BallQuality}\n- ${matchContext.team2BallQuality}\n`;
    }

    // 次戦情報
    let nextOpponentText = '次戦の相手は未定';
    if (nextOpponent) {
        if (nextOpponent.opponentName === '優勝') nextOpponentText = '全国制覇！';
        else if (nextOpponent.opponentName && nextOpponent.opponentName !== '（未定）') {
            nextOpponentText = `次戦: ${nextOpponent.opponentName}`;
            if (matchContext.nextOpponentJourney) {
                 nextOpponentText += ` (相手の軌跡: ${matchContext.nextOpponentJourney})`;
            }
        }
    }

    const prompt = `あなたは、静岡県代表「${myTeam}」を全力で応援するネット掲示板（なんJ）の住民です。
甲子園 ${roundName}、${opponentName}戦の結果を受けて、**提供された膨大な詳細データを元に**、喜び（または健闘を称える）スレッドを作成してください。

### 現在の試合状況
- **大会:** ${tournamentYear}年度 ${tournamentName}
- **ラウンド:** ${roundName}
${scheduleText}

### データ1：試合結果
- **結果:** ${myTeam}の${isWin ? '勝利' : '敗北'} (${score}) vs ${opponentName}
- **スタメン変更:**
${lineupChangesText}
${calledGameText}
${rivalryText}
${injuryReport || ''}

### データ2：チームの背景
- **${winnerName}**: ${winnerDynamicInfo}
  - **軌跡**: ${winnerJourney}
- **${loserName}**: ${loserDynamicInfo}
  - **軌跡**: ${loserJourney}

### データ3：この試合の個人成績 (最終結果の要約)
${playerStatsText || '個人成績データはありません。'}
- **県大会(予選)の成績**:
${prefecturalStatsText || '情報なし'}

### データ4：試合の主な出来事 (ハイライト)
${highlightsText}
${ballQualityText}

### データ5：トーナメント全体の状況
- **次の試合**: ${nextOpponentText}
${atmosphereText}

### データ6：今大会の主な投手登板履歴 (この試合より前)
${pitcherGamelogInfo || '今大会、これが初登板です。'}

### データ7：今大会の主な打者成績履歴 (この試合より前)
${batterGamelogInfo || '打者の試合履歴データはありません。'}

### 指示
- スレタイは「【速報】${myTeam}、強豪${opponentName}を撃破！！」「【悲報】${myTeam}散る...しかしよくやった！」のように、結果と相手の強さを反映させてください。
- レス内容は、全員が味方でアンチなし。
- **以下のデータポイントに必ず言及してください：**
    1. **具体的なプレー:** 「データ4(ハイライト)」にある決定打やファインプレー。
    2. **個人のスタッツ:** 「データ3(個人成績)」を見て、猛打賞や完封などの数字。
    3. **これまでの文脈:** 「データ6,7(Gamelog)」を見て、「連投お疲れ」「不振脱出か？」などのコメント。
    4. **県大会との比較:** 「データ3(県大会成績)」と比較し、「予選より打ってる」「甲子園に来て覚醒したな」などのコメント。
    5. **怪我人情報:** 「${injuryReport}」がある場合、その選手の重要度（主力/控え）も考慮し、心配や労いのレスを含めること。
    6. **次戦への展望:** 勝った場合、「データ5(次戦情報)」の相手について語ること。

### 出力形式 (JSON)
{
  "threadTitle": "（スレタイ）",
  "comments": [
    {"personality": "1: 静岡の誇り", "comment": "（スレ主の熱いコメント。スコアや勝因に触れる）"},
    {"personality": "2: 名無しさん", "comment": "（具体的なハイライトへの反応）"},
    {"personality": "3: データ厨", "comment": "（Gamelogやスタッツに基づいた分析的称賛）"},
    {"personality": "4: 心配性", "comment": "（怪我人や次戦の相手を気にするコメント）"}
    // ... 合計20個程度
  ]
}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const bbsJson = parseJsonFromText(rawText);
            if (bbsJson && bbsJson.threadTitle && Array.isArray(bbsJson.comments)) {
                return {
                    id: `koshien-thread-${Date.now()}`,
                    title: bbsJson.threadTitle,
                    matchId: 'koshien',
                    comments: bbsJson.comments.map((c, index) => ({
                        id: crypto.randomUUID(),
                        personality: c.personality,
                        text: c.comment,
                        timestamp: Date.now() + index * 10,
                        replies: []
                    })),
                    timestamp: Date.now(),
                    context: { ...matchContext, isKoshien: true } // ★フルコンテキストを保存
                };
            }
        }
        return null;
    } catch (error) {
        console.error("甲子園まとめ生成エラー:", error);
        return null;
    }
}

/**
 * [UPDATED] 甲子園モードのチームデータを復元する
 * (★再読み込み時も、ダミーチームを含めて全員Aランク(偏差値80以上)として復元する)
 */
function restoreKoshienData(teams) {
    // 1. レジェンド校（ボス）のデータを再登録 (偏差値88〜95の最強データ)
    addLegendaryTeamsData();

    // 2. ダミーチーム（その他の代表校）のデータを再登録
    teams.forEach(teamName => {
        // まだTEAM_DATAにない（＝ダミーチームの）場合
        if (teamName !== '(BYE)' && !TEAM_DATA[teamName]) {
            TEAM_DATA[teamName] = { 
                name_yomi: "だいひょうこう", 
                region: "全国", 
                type: "公立", 
                deviation: 85, // ★★★ 修正: 偏差値を85に設定し、確実にAランクにする ★★★
                best: "甲子園出場", 
                last: "予選突破", 
                info: "各都道府県の代表校。非常に強力な戦力を有する。", 
                coach: { name: "モブ監督", style: "堅実", experience: "中堅" } 
            };
        }
    });
}

/**
 * [UPDATED] 甲子園開幕直前：静岡代表チームの紹介記事を生成する
 * (★Info, 283学園のリベンジ, 予選成績, 注目選手(詳細数値付き), 優勝予想ランクA-E)
 */
async function generateKoshienTeamIntro(teamName) {
    const teamData = TEAM_DATA[teamName];
    const teamRecord = tournamentState.teamRecords[teamName];
    const rank = calculateRank(teamName, tournamentState); // 内部ランク(A~E)
    
    // 1. 283学園の場合の特別コンテキスト
    let specialContext = "";
    if (teamName === "283学園") {
        specialContext = "【特記事項】昨夏の甲子園初戦で浦和学院に敗れており、選手たちは「打倒・浦学」を掲げ、リベンジに燃えている。";
    }

    // 2. 県大会成績の整形 (チーム全体)
    let statsText = "情報なし";
    if (teamRecord.prefecturalStats) {
        const p = teamRecord.prefecturalStats;
        const avg = p.ab > 0 ? (p.h / p.ab).toFixed(3) : '.---';
        statsText = `県大会成績: チーム打率${avg}, 本塁打${p.hr}, 総得点${p.r}, 盗塁${p.sb}, 失策${p.e || 0}`;
    }

    // 3. ★★★ 注目選手データ (詳細数値付き) の生成 ★★★
    let keyPlayersList = [];
    
    if (teamRecord.playerStats) {
        // 打者 (打率3割5分以上 または 本塁打1本以上 または 盗塁3以上)
        if (teamRecord.playerStats.batting) {
            Object.entries(teamRecord.playerStats.batting).forEach(([name, stats]) => {
                // ※ここでは通算成績(=予選成績)を使用
                const avgVal = stats.ab > 0 ? (stats.h / stats.ab) : 0;
                
                if (avgVal >= 0.35 || stats.hr >= 1 || stats.sb >= 3 || stats.narrative_flag === 'peak') {
                    const avg = avgVal.toFixed(3);
                    keyPlayersList.push(`- 打者・${name}: 打率${avg}, ${stats.hr}本塁打, ${stats.rbi}打点, ${stats.sb}盗塁`);
                }
            });
        }
        
        // 投手 (防御率2.50以下 または 奪三振率が高い選手)
        if (teamRecord.playerStats.pitching) {
            Object.entries(teamRecord.playerStats.pitching).forEach(([name, stats]) => {
                const career = stats.career;
                const ip = parseFloat(career.ip);
                if (ip >= 5) { // 5回以上投げていること
                    const eraVal = ip > 0 ? ((career.er * 9) / ip) : 99.99;
                    const k9 = ip > 0 ? ((career.so * 9) / ip).toFixed(2) : 0;
                    
                    if (eraVal <= 2.50 || career.so >= 10 || stats.narrative_flag === 'peak') {
                        const era = eraVal.toFixed(2);
                        keyPlayersList.push(`- 投手・${name}: 防御率${era}, ${career.w}勝${career.l}敗, 奪三振${career.so} (K/9: ${k9})`);
                    }
                }
            });
        }
    }
    
    // AIに渡すリスト（多すぎるとあふれるので、活躍度が高い順などでソートするのが理想だが、ここでは上位7名程度に絞る）
    const keyPlayersText = keyPlayersList.slice(0, 7).join('\n') || "（特筆すべき個人成績なし。全員野球で勝ち上がった）";

    const prompt = `あなたは「週刊ベースボール」の高校野球担当記者です。
夏の甲子園に出場する静岡代表「${teamName}」のチーム紹介記事を作成してください。

### チームデータ
- **チーム名:** ${teamName}
- **内部評価ランク:** ${rank}
- **チーム背景:** ${teamData.info}
- **${specialContext}**
- **予選(県大会)成績:** ${statsText}

### 注目選手データ (予選成績)
${keyPlayersText}

### 執筆指示
- タイトルは「【代表校紹介：静岡】${teamName}」から始めて、キャッチーなフレーズを続けてください。
- 本文では、チームの特徴（背景情報）と予選での戦いぶり（チーム成績）を組み合わせて紹介してください。
- **【選手紹介コーナー】を必ず設け、上記の「注目選手データ」にある具体的な数値（打率、本塁打数、防御率など）を引用して、主力選手たちの活躍ぶりを詳しく紹介してください。**
- **「優勝予想ランク」**を、戦力に基づいて **E, D, C, B, A** の5段階で独自に格付けし、記事の最後に理由とともに明記してください。（※内部評価ランク ${rank} を参考にしてください）
- **${teamName}が283学園の場合**は、必ず「浦和学院へのリベンジ」について熱く触れてください。

### 出力形式 (JSON)
{"title": "記事タイトル", "body": "記事本文"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const article = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (article) {
                return { 
                    ...article, 
                    timestamp: Date.now(),
                    context: { isKoshienIntro: true, teamName: teamName }
                };
            }
        }
        return null;
    } catch (error) {
        console.error("甲子園チーム紹介記事生成エラー:", error);
        return null;
    }
}

/**
 * [NEW] AIナラティブ・アップデートシステム
 * 大会終了後、ドラマがあったチームの紹介文(info)をAIに書き直させる
 */
async function updateNarrativesWithAI(state) {
    const updates = [];
    const historySummary = []; // AIへの入力用（全体の文脈）

    // 1. 更新対象のチームをピックアップ
    const teamRecords = state.teamRecords;
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };

    Object.keys(teamRecords).forEach(teamName => {
        const record = teamRecords[teamName];
        const history = record.history || [];
        if (history.length === 0) return;

        const lastRank = history[0].rank; // 今回の順位
        const baseRank = calculateRank(teamName, state); // 本来のランク
        const originalInfo = TEAM_DATA[teamName].info;

        let reason = null;

        // (A) 優勝・準優勝校 (必ず更新)
        if (lastRank === 1) reason = "champion";
        else if (lastRank === -1) reason = "koshien_champion"; // 甲子園優勝
        else if (lastRank === 2) reason = "runner_up";
        
        // (B) 下剋上 (E/Dランクがベスト8以上)
        else if (['D', 'E'].includes(baseRank) && lastRank <= 8 && lastRank > 0) {
            reason = "cinderella";
        }
        
        // (C) 没落 (Aランクが初戦敗退)
        else if (baseRank === 'A' && lastRank >= 32) {
            reason = "slump";
        }

        if (reason) {
            updates.push({ teamName, reason, lastRank, baseRank, originalInfo });
            historySummary.push(`- ${teamName} (${baseRank}ランク): ${getRankString(lastRank)}`);
        }
    });

    // 更新対象がいなければ終了
    if (updates.length === 0) return;

    // 2. AIへのプロンプト作成
    // チームごとに個別にリクエストすると遅いので、まとめてリクエストする
    const updateRequestText = updates.map(u => 
        `■チーム名: ${u.teamName}\n` +
        `・現在の紹介文: "${u.originalInfo}"\n` +
        `・今大会の結果: ${getRankString(u.lastRank)}\n` +
        `・本来の評価: ${u.baseRank}ランク\n` +
        `・更新理由: ${u.reason}`
    ).join('\n\n');

    const prompt = `あなたは「高校野球ガイドブック」の編集者です。
最新の大会結果を受けて、以下の注目チームの「チーム紹介文（info）」を刷新してください。

### 指示
- **文脈の継承:** 「現在の紹介文」の内容（創部年数や特徴など）を活かしつつ、「今大会の結果」という新しい歴史を組み込んでください。
- **ドラマチックに:** - 優勝校なら王者の風格を。
    - 下剋上ならその衝撃と期待を。
    - 没落なら復活への課題やファンの嘆きを。
- **長さ:** 各チーム 80〜100文字程度。
- **出力:** JSON形式で、チーム名をキー、新しい紹介文を値にしてください。

### 更新対象リスト
${updateRequestText}

### 出力形式 (JSON)
{
  "チームA": "新しい紹介文...",
  "チームB": "新しい紹介文..."
}`;

    // 3. AIリクエスト実行
    // 画面にローディングを表示（ニュース欄を借用）
    const newsContainer = document.getElementById('news-articles');
    const loadingMsg = document.createElement('div');
    loadingMsg.className = "bg-yellow-100 p-4 rounded text-center text-yellow-800 font-bold animate-pulse";
    loadingMsg.textContent = `📢 AIが最新の戦績を分析し、チーム紹介文を書き換えています... (${updates.length}校)`;
    if(newsContainer) newsContainer.prepend(loadingMsg);

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const newInfos = parseJsonFromText(result.candidates[0].content.parts[0].text);
            
            if (newInfos) {
                let updateCount = 0;
                for (const [teamName, newInfo] of Object.entries(newInfos)) {
                    if (TEAM_DATA[teamName]) {
                        console.log(`[Info Update] ${teamName}: ${newInfo}`);
                        TEAM_DATA[teamName].info = newInfo; // データを上書き
                        updateCount++;
                    }
                }
                
                // 完了メッセージ
                loadingMsg.className = "bg-green-100 p-4 rounded text-center text-green-800 font-bold";
                loadingMsg.textContent = `✅ チーム紹介文が更新されました！ (${updateCount}校)`;
                setTimeout(() => loadingMsg.remove(), 5000);
            }
        }
    } catch (error) {
        console.error("AIチーム紹介文更新エラー:", error);
        loadingMsg.textContent = "⚠️ 紹介文の更新に失敗しました。";
        setTimeout(() => loadingMsg.remove(), 3000);
    }
}

    async function initializeApp() {
  SoundManager.init(); 
 // --- 1. Preload the background image ---
    const bgContainer = document.querySelector('.ballpark-background');
    if (bgContainer) {
        const img = new Image();
        const imageUrl = 'ballpark.jpg'; // The local image path
        
        img.onload = function() {
            // Image loaded successfully, set it as the background and start the dust effect
            bgContainer.style.backgroundImage = `url(${imageUrl})`;
            createDustEffect();
        };
        img.onerror = function() {
            // If the image fails to load, log an error but still start the dust effect
            console.error('Failed to load the background image.');
            createDustEffect();
        };
        
        img.src = imageUrl; // This starts the image download
    } else {
        // If the background container doesn't exist, just start the dust effect
        createDustEffect();
    }
       
 // --- ここから診断コード ---
        try {
            alert('デバッグ開始：initializeApp関数が実行されました。');
            
            if (teamsTextarea) {
                alert('成功：チーム一覧を表示するテキストエリアが見つかりました。');
            } else {
                alert('エラー：チーム一覧を表示するテキストエリアが見つかりません！ id="teams-list" を確認してください。');
                return;
            }

            if (INITIAL_TEAM_POOL && INITIAL_TEAM_POOL.length > 0) {
                alert(`成功：${INITIAL_TEAM_POOL.length}件のチームデータが読み込まれました。`);
            } else {
                alert('エラー：チームデータが読み込めていません！ TEAM_DATAの定義を確認してください。');
                return;
            }

            teamsTextarea.value = INITIAL_TEAM_POOL.join('\n');
            alert('成功：チーム一覧をテキストエリアに表示しました。');

        } catch (e) {
            alert('致命的なエラーが発生しました： ' + e.message);
        }

        // --- ここまで診断コード ---

        
    const savedStateJSON = localStorage.getItem('tournamentState');
    if (savedStateJSON) {
        try {
            const lastState = JSON.parse(savedStateJSON);
            if (lastState && lastState.tournamentYear) {
                const confirmed = await showConfirm("前回の続きから再開しますか？\n（「いいえ」で最初から、または「合い言葉」で再開）");
                
                if (confirmed) { // 「はい」が押された場合
                    tournamentState = lastState;

// ★★★ ここからが修正箇所 (甲子園データの復元) ★★★
                        if (tournamentState.currentTournament === 'summer_koshien') {
                            restoreKoshienData(tournamentState.teams);
                        }
                        // ★★★ 修正ここまで ★★★

// ▼▼▼ このブロックをまるごと追加 ▼▼▼
                    // --- 古いセーブデータへの「互換性パッチ」 ---
                    if (tournamentState.teamRecords) {
                        for (const teamName in tournamentState.teamRecords) {
                            const record = tournamentState.teamRecords[teamName];
                            
                            // 1. (model_156) チーム打率(tournamentStats)がなければ初期化
                            if (!record.tournamentStats) {
                                record.tournamentStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0 };
                            }
                            
                            // 2. (model_164) ロスター(roster)がなければ初期化
                            if (!record.roster) {
                                record.roster = null;
                            }
                        }
                    }
                    // 3. (model_106) 応援コメント(preGameComments)がなければ初期化
                    if (!tournamentState.preGameComments) {
                        tournamentState.preGameComments = {};
                    }
                    // ▲▲▲ 追加ここまで ▲▲▲

// ▼▼▼ この1行をまるごと追加 ▼▼▼
                    if (!tournamentState.matomeThreads) tournamentState.matomeThreads = {};
                    // ▲▲▲ 追加ここまで ▲▲▲

                    setupEl.classList.add('hidden');
                    tournamentDisplayEl.classList.remove('hidden');
                    renderTournament(tournamentState);
                    return; 
                } else { // ▼▼▼ 「いいえ」が押された場合の処理を追加 ▼▼▼
                    // 古いセーブデータを完全に消去する
                    localStorage.removeItem('tournamentState');
                }
            }
        } catch (e) {
            console.error("保存されたデータの読み込みに失敗:", e);
            localStorage.removeItem('tournamentState'); 
        }
    }        
        setupEl.classList.remove('hidden');
        tournamentDisplayEl.classList.add('hidden');
　　　　teamsTextarea.value = INITIAL_TEAM_POOL.join('\n');

 updateTicker();
}

    // --- Event Listeners ---
    
    generateBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("新しいトーナメントを開始すると、現在の進行状況は失われます。よろしいですか？");
    if (confirmed) startLotteryEvent();
});
    resumeBtn.addEventListener('click', () => {
        saveLoadModal.classList.remove('hidden');
        loadTabBtn.click();
    });

    nextTournamentBtn.addEventListener('click', async () => {
        const confirmed = await showConfirm("現在の大会を終了し、次の大会へ進みますか？");
        if(confirmed) {

await updateNarrativesWithAI(tournamentState);

            let nextTournamentType;
            
            // ★★★ 修正箇所: 甲子園 -> 秋大会 の遷移を追加 ★★★
            if (tournamentState.currentTournament === 'summer') {
                 // (通常はここで甲子園に行かず秋に行く場合もあるが、
                 // processMatchWinで自動移行しなかった場合の予備として)
                 nextTournamentType = 'autumn';
            }
            else if (tournamentState.currentTournament === 'summer_koshien') {
                 nextTournamentType = 'autumn';
            }
            else if (tournamentState.currentTournament === 'autumn') {
                 nextTournamentType = 'spring';
            }
            else { // spring -> summer
                 nextTournamentType = 'summer';
            }
            // ★★★ 修正ここまで ★★★
            
            createNewTournament(true, nextTournamentType);
        }
    });

    resetBtn.addEventListener('click', async () => {
        const confirmed = await showConfirm("すべての大会記録をリセットして、最初の状態に戻しますか？");
        if(confirmed){
            localStorage.clear();
            location.reload();
        }
    });

    saveBtn.addEventListener('click', () => {
        document.getElementById('save-code-area').classList.add('hidden');
        saveLoadModal.classList.remove('hidden');
        saveTabBtn.click();
    });
    
    startRankingPlayoffsBtn.addEventListener('click', async () => {
         const confirmed = await showConfirm("全ブロックの予選が終了しました。地区内順位決定戦に進みますか？");
         if(confirmed) setupAutumnRankingTournaments();
    });
    
    // startMainTournamentBtn のイベントリスナー内

startMainTournamentBtn.addEventListener('click', async () => {
    // ★★★ 春季大会用の分岐を追加 ★★★
    if (tournamentState.currentTournament === 'spring') {
        const confirmed = await showConfirm("全代表校が決定しました。県大会本戦に進みますか？");
        if (confirmed) setupSpringMainTournament_Round1();
    } 
    // ★★★ ここまで追加 ★★★
    else { // 秋季大会の既存ロジック
        const confirmed = await showConfirm("全代表校が決定しました。県大会本戦に進みますか？");
        if (confirmed) setupAutumnMainTournament();
    }
});
// --- スキップボタン・ダイジェストボタンのグローバル変数宣言 ---
    
    skipR1Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("1回戦を自動で進行しますか？");
        if (confirmed) skipRound(1);
    });
    skipR2Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("2回戦を自動で進行しますか？");
        if (confirmed) skipRound(2);
    });
    skipR3Btn.addEventListener('click', async () => {
        const confirmed = await showConfirm("3回戦を自動で進行しますか？");
        if (confirmed) skipRound(3);
    });

skipR4Btn.addEventListener('click', async () => {
    const confirmed = await showConfirm("4回戦を自動で進行しますか？");
    if (confirmed) skipRound(4);
});

skipR5Btn.addEventListener('click', async () => {
    const confirmed = await showConfirm("準々決勝を自動で進行しますか？");
    if (confirmed) skipRound(5);
});

skipR6Btn.addEventListener('click', async () => {
    const confirmed = await showConfirm("準決勝を自動で進行しますか？");
    if (confirmed) skipRound(6);
});

skipFinalBtn.addEventListener('click', async () => {
    const confirmed = await showConfirm("決勝戦を自動で進行しますか？");
    if (confirmed) skipFinal();
});


    generateSummaryBtn.addEventListener('click', async () => {
        generateSummaryBtn.disabled = true;
        generateSummaryBtn.textContent = '記事を生成中...';
        newsContainer.innerHTML = `<div class="loader">AI記者が準々決勝の展望記事を執筆中...</div>`;
        
        // ★★★ 新しい関数を呼び出す ★★★
        const summaryArticle = await generateBest16PreviewArticle();
        // ★★★ 修正ここまで ★★★

        if (summaryArticle) {
            tournamentState.news.push(summaryArticle);
            saveState();
            renderNews(tournamentState.news);
        }
        generateSummaryBtn.classList.add('hidden');
        generateSummaryBtn.disabled = false;
        generateSummaryBtn.textContent = '準々決勝 展望記事を生成';
    });


/**
 * [NEW] 283学園ホームページ用の「お知らせ」記事をAIに生成させる
 * @param {object} matchContext - 試合の全コンテキストデータ
 * @returns {Promise<object|null>} - { title, body, timestamp }
 */
async function generateHomepageNewsUpdate(matchContext) {
    const { winnerName, loserName, dbMatch, matchId, nextOpponent } = matchContext;
    
    // 283学園が勝ったかどうか
    const is283Match = (winnerName === "283学園" || loserName === "283学園");
    if (!is283Match) return null;
    
    const teamName = "283学園";
    const result = (winnerName === teamName) ? '勝利' : '敗北';
    const opponentName = (winnerName === teamName) ? loserName : winnerName;
    const score = (winnerName === teamName) 
        ? `${dbMatch.score1} - ${dbMatch.score2}` 
        : `${dbMatch.score2} - ${dbMatch.score1}`;
    const roundName = getRoundNameFromMatchId(matchId);

    // 1. 戦評の生成
    let summary = dbMatch.summary || matchContext.highlights?.[0]?.description || "熱戦が繰り広げられました。";
    if (result === '敗北') {
        summary = `惜しくも${opponentName}に敗れ、今大会の挑戦は終了となりました。`;
    }

    // 2. 次の試合情報の生成
    let nextMatchText = "";
    if (result === '勝利' && nextOpponent) {
        if (nextOpponent.opponentName === '優勝') {
            nextMatchText = "次戦はありません（県大会優勝）。たくさんのご声援ありがとうございました！";
        } else {
            const opponent = nextOpponent.decidingMatch 
                ? `${nextOpponent.decidingMatch.team1} と ${nextOpponent.decidingMatch.team2} の勝者`
                : (nextOpponent.opponentName || '（未定）');
            
            const schedule = nextOpponent.nextMatchSchedule;
            const location = schedule?.stadiumFull || '未定';
            const date = schedule?.date || '未定';
            const gameNum = schedule?.game ? `第${schedule.game}試合` : '';

            nextMatchText = `次戦（${nextOpponent.roundName}）は、${opponent}と対戦します。\n` +
                            `日時: ${date} ${gameNum}\n` +
                            `場所: ${location}\n\n` +
                            `引き続きのご声援をよろしくお願いいたします。`;
        }
    } else if (result === '敗北') {
        nextMatchText = "皆様の熱い声援が、選手の力となりました。心より感謝申し上げます。\n新チームでの再起にご期待ください。";
    }

    // 3. AIにプロンプトを送信
    const prompt = `あなたは「283学園」野球部の広報担当者です。
以下の試合結果データに基づき、学園のホームページに掲載する「お知らせ」記事のタイトルと本文を、丁寧な「です・ます調」で生成してください。

### 試合データ
- **大会名:** ${tournamentNameMap[tournamentState.currentTournament] || '大会'} ${roundName}
- **自チーム:** ${teamName}
- **対戦相手:** ${opponentName}
- **結果:** ${teamName} の ${result}
- **スコア:** ${score}
- **簡単な戦評(AI生成):** ${summary}
- **次の試合情報(テキスト):** ${nextMatchText}

### 指示
1.  **タイトル:** 「【野球部】（大会名 ラウンド） 試合結果のお知らせ」という形式にしてください。
2.  **本文:**
    - 試合が行われたこと、対戦相手、スコア、勝敗を報告してください。
    - 「簡単な戦評」を自然な文章に直して挿入してください。
    - 最後に「次の試合情報」をそのまま挿入してください。
    - 全体を、企業の公式発表としてふさわしい、丁寧でフォーマルな文体にすること。

### 出力形式 (JSON)
{"title": "（ここに記事のタイトル）", "body": "（ここに記事の本文、改行は\\nを使用）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const rawText = result.candidates[0].content.parts[0].text;
            const newsJson = parseJsonFromText(rawText);
            if (newsJson && newsJson.title && newsJson.body) {
                return { ...newsJson, timestamp: Date.now() };
            }
        }
        throw new Error("AIからの応答が予期した形式ではありません。");
    } catch (error) {
        console.error("283学園ホームページニュースの生成に失敗しました:", error);
        return {
            title: "記事生成エラー",
            body: "AI広報担当者との通信に失敗しました。",
            timestamp: Date.now(),
            error: true
        };
    }
}

document.getElementById('contribution-close-btn').addEventListener('click', () => {

    // 1. 貢献度モーダルを隠す処理

    document.getElementById('contribution-modal').classList.add('hidden');

    document.getElementById('contribution-modal').classList.remove('flex');



    // 2. ★ Chart.jsのグラフ要素を破棄し、メモリを解放する

    const pieChart = Chart.getChart('rc-pie-chart');

    const barChart = Chart.getChart('rc-bar-chart');

    const scatterChart = Chart.getChart('stellar-scatter-chart');

    

    if (pieChart) pieChart.destroy();

    if (barChart) barChart.destroy();

    if (scatterChart) scatterChart.destroy();



    // 3. 閉じた際に、貢献度コンテンツ（グラフ）を隠す

    document.getElementById('contribution-content').classList.add('hidden');

});


document.body.addEventListener('click', async (e) => {




    // --- 試合進行ボタン (▶) ---
    if (e.target.matches('.win-btn')) {
        const teamSlot = e.target.closest('.team-slot');
        const matchEl = e.target.closest('[data-match-id]');
        if (!teamSlot || !matchEl || teamSlot.classList.contains('empty')) return;

        const matchId = matchEl.dataset.matchId;
        const winnerName = teamSlot.dataset.teamName;
        if (!winnerName) return;

        const score1El = matchEl.querySelector('[data-team-pos="1"]');
        const score2El = matchEl.querySelector('[data-team-pos="2"]');

        if(!score1El || !score2El || score1El.value === '' || score2El.value === '') {
            showAlert('スコアを入力してください。');
            return;
        }

        let dbMatch = findMatchById(matchId);
        if (dbMatch) {
            dbMatch.score1 = score1El.value;
            dbMatch.score2 = score2El.value;
            dbMatch.summary = matchEl.querySelector('.match-summary-input')?.value || '';
        }

        await processMatchWin(matchId, winnerName);
    }

    // --- 「勢力図をアニメーションで見る」ボタン ---
    if (e.target.matches('.view-analysis-btn')) {
        document.getElementById('analysis-modal').classList.remove('hidden');
        currentBlock = 'A';
        playBlockAnimation(currentBlock);
    }
    
    // --- 勢力図モーダル内のタブボタン ---
    if (e.target.matches('.analysis-block-tab-btn')) {
        const blockId = e.target.dataset.block;
        if (blockId && blockId !== currentBlock) {
            currentBlock = blockId;
            playBlockAnimation(blockId);
        }
    }
    
    // --- 勢力図モーダルを閉じるボタン ---
    if (e.target.matches('#analysis-modal-close-btn')) {
        document.getElementById('analysis-modal').classList.add('hidden');
    }

    // --- 試合詳細入力ボタン ---
    if (e.target.matches('.details-btn')) {
        openDetailsModal(e.target.dataset.matchId);
    }

    // --- 【詳細モーダル内】イニング追加ボタン ---
    if (e.target.matches('.add-inning-btn') || e.target.matches('#add-inning-score-btn')) {
        e.preventDefault();
        addExtraInning();
    }

    // --- 【詳細モーダル内】守備ファインプレーを追加ボタン ---
    if (e.target.matches('.add-fielding-play-btn')) {
        e.preventDefault();
        const teamKey = e.target.dataset.teamKey;
        const fieldingTableEl = document.getElementById(`fielding-table-${teamKey}`);
        const battingTableEl = document.getElementById(`batting-table-${teamKey}`);
        
        if (!fieldingTableEl || !battingTableEl) {
            console.error(`エラー: ${teamKey} の fielding-table または batting-table が見つかりません。`);
            alert("致命的なエラー：テーブル要素が見つかりません。コンソールを確認してください。");
            return;
        }
        
        const tableBody = fieldingTableEl.querySelector('tbody');
        const playersOnField = Array.from(battingTableEl.querySelectorAll('.player-name')).map(input => ({name: input.value.trim()})).filter(p => p.name);
        const playerOptions = playersOnField.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
        
        const newRow = tableBody.insertRow();
        newRow.dataset.fieldingIndex = tableBody.rows.length;
        newRow.innerHTML = `
            <td class="w-16"><input type="number" class="fielding-inning" min="1"></td>
            <td>
                <select class="player-name w-full">
                    <option value="">- 選手 -</option>
                    ${playerOptions}
                </select>
            </td>
            <td><input type="text" class="fielding-play" placeholder="例: ダイビングキャッチ"></td>
            <td class="w-12 text-center">
                <button class="remove-fielding-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </td>
        `;
    }

    // --- 【詳細モーダル内】守備ファインプレーを削除ボタン ---
    if (e.target.matches('.remove-fielding-play-btn')) {
        e.preventDefault();
        e.target.closest('tr').remove();
    }

    // --- 天候ボタン ---
    if (e.target.matches('.weather-btn')) {
        const weatherType = e.target.dataset.weather;
        setWeather(weatherType);
    }

// ▼▼▼ 追加: キャプテンボタンのクリック処理 ▼▼▼
    if (e.target.matches('.captain-btn')) {
        e.preventDefault();
        const btn = e.target;
        
        // 既にアクティブならOFFにする（キャプテンなしの状態も許容する場合）
        if (btn.classList.contains('active')) {
            btn.classList.remove('active');
        } else {
            // 同じテーブル（チーム）内の他のキャプテンボタンを全てOFFにする
            const table = btn.closest('table');
            if (table) {
                table.querySelectorAll('.captain-btn.active').forEach(activeBtn => {
                    activeBtn.classList.remove('active');
                });
            }
            // クリックされたボタンをONにする
            btn.classList.add('active');
        }
    }
    // ▲▲▲ 追加ここまで ▲▲▲

    // --- 「チーム通算成績」ボタン（トーナメント表の 📊 ボタン） ---
    if (e.target.matches('.show-team-stats-btn')) {
        e.preventDefault();
        const teamName = e.target.dataset.teamName;
        if (!teamName) return;
        renderTeamStatsModal(teamName); // 統計タブの中身だけ先に描画
        document.getElementById('team-stats-modal').classList.remove('hidden');
        document.getElementById('team-stats-modal').classList.add('flex');
    }

    // --- チーム通算成績モーダルを閉じるボタン ---
    if (e.target.matches('#team-stats-modal-close')) {
        e.preventDefault();
        document.getElementById('team-stats-modal').classList.add('hidden');
        document.getElementById('team-stats-modal').classList.remove('flex');
    }

    // --- [新機能] チーム通算成績モーダルのタブ切り替え ---
    if (e.target.matches('.team-stats-tab-btn')) {
        e.preventDefault();
        const btn = e.target;
        if (btn.classList.contains('active')) return;
        const modal = btn.closest('#team-stats-modal');
        const tabId = btn.dataset.tab;
        const teamName = modal.querySelector('#team-stats-modal-title').textContent.split(' ')[0];
        modal.querySelectorAll('.team-stats-tab-btn').forEach(b => b.classList.remove('active'));
        modal.querySelectorAll('.team-stats-tab-content').forEach(c => c.classList.add('hidden'));
        btn.classList.add('active');
        const contentEl = document.getElementById(`team-stats-tab-content-${tabId}`);
        contentEl.classList.remove('hidden');
        if (tabId === 'lineups') {
            if (contentEl.querySelector('.loader')) {
                renderStartingLineupHistory(teamName);
            }
        }
    }

// --- [NEW] 投手成績の自動計算ボタン ---
        else if (e.target.closest('.calc-pitcher-stats-btn')) {
            e.preventDefault();
            const btn = e.target.closest('.calc-pitcher-stats-btn');
            
            // 連打防止 & タップフィードバック
            btn.disabled = true;
            const originalText = btn.textContent;
            btn.textContent = "計算中...";

            const pitchingTeamKey = btn.dataset.pitchingTeam;
            const battingTeamKey = btn.dataset.battingTeam;
            
            // 非同期処理を実行
            (async () => {
                try {
                    // 計算ロジック呼び出し
                    await fillPitcherStatsFromBatting(pitchingTeamKey, battingTeamKey);
                } catch (err) {
                    console.error("自動計算エラー:", err);
                    // スマホでもエラー内容がわかるようにアラートを出す
                    alert("計算中にエラーが発生しました:\n" + err.message);
                } finally {
                    // 処理が終わったら（成功・失敗に関わらず）ボタンを元に戻す
                    btn.disabled = false;
                    btn.textContent = originalText;
                }
            })();
        }
// --- [NEW] イニング欄からの「代打」ボタン ---
        else if (e.target.closest('.inning-add-sub-btn')) {
            e.preventDefault();
            const btn = e.target.closest('.inning-add-sub-btn');
            const teamKey = btn.dataset.teamKey;
            const inningIndex = parseInt(btn.dataset.inning, 10);
            const currentOrder = btn.dataset.order;
            const baseOrder = currentOrder.split('-')[0];
            const row = btn.closest('tr');
            const tableBody = row.closest('tbody');

            // 1. 本来の「+ 交代」ボタンを探して、プログラムでクリックする
            // (※注: data-orderが "1" や "1-sub-1" など、可変なため、
            // 　オリジナルの "1" や "2" を持つボタンを探す必要がある)
            // (※[data-order="${baseOrder}"] で、 "1" や "2" のスタメン行のボタンを探す)
            const mainSubButton = tableBody.querySelector(`tr[data-order="${baseOrder}"] .add-sub-row-btn`);
            
            if (!mainSubButton) {
                console.error("オリジナルの「+ 交代」ボタンが見つかりません。");
                return;
            }
            
            // 2. メインの「+ 交代」ボタンをクリックして、新しい行を追加させる
            mainSubButton.click();

            // 3. 新しく追加された行（＝その打順の最後の行）を取得
            const allOrderRows = Array.from(tableBody.querySelectorAll(`tr[data-order^="${baseOrder}"]`));
            const newRow = allOrderRows[allOrderRows.length - 1];

            if (newRow) {
                // 4. 新しい行のドロップダウンを「PH (代打)」に設定
                const subTypeSelect = newRow.querySelector('.sub-type-select');
                if (subTypeSelect) {
                    subTypeSelect.value = 'PH';
                }
                
                // 5. 新しい行の、クリックされたイニングのセルにフォーカスを当てる
                const inningCell = newRow.querySelectorAll('td.col-inning')[inningIndex];
                if (inningCell) {
                    // そのセル内の最初の入力可能な要素にフォーカスする
                    const firstInput = inningCell.querySelector('select, input');
                    if (firstInput) {
                        firstInput.focus();
                    }
                }
            }
        }


// --- [NEW] 簡易入力モーダルを開く ---
    else if (e.target.closest('.scorecard-open-btn')) {
        e.preventDefault();
        openScorecardModal(e.target.closest('.scorecard-open-btn').dataset.matchId);
    }
    // --- [NEW] 簡易入力モーダルを閉じる ---
    else if (e.target.closest('#scorecard-close-btn')) {
        e.preventDefault();
        if (confirm("入力内容を保存せずに閉じますか？")) {
            document.getElementById('scorecard-modal').classList.add('hidden');
            document.getElementById('scorecard-modal').classList.remove('flex');
            activeScorecardState = {};
        }
    }
    
    // ★★★ ここからが修正箇所 (順序入れ替え) ★★★

    // --- [NEW] 簡易入力モーダル：「打点」または「併殺/犠飛/犠打」ボタン (優先度 1) ---
    else if (e.target.closest('.rbi-btn, .result-btn[data-action="out-dp"], .result-btn[data-action="out-sac-f"], .result-btn[data-action="out-sac-b"]')) {
        e.preventDefault();
        
        // 1. もし「結果入力待ち(STEP 1)」なら、まず結果をセット
        if (activeScorecardState.currentStep === "waiting_for_result") {
            const action = e.target.closest('button').dataset.action;
            if (action) {
                handleScorecardAction(action); // これで pendingPlay がセットされ、stepが "waiting_for_direction" に進む
                return; // このクリックでの処理はここまで
            }
        }
        
        // 2. もし「打点入力待ち(STEP 3)」なら、打点をセットしてプレー確定
        if (activeScorecardState.currentStep === "waiting_for_rbi") {
            const btn = e.target.closest('button');
            const rbiValue = btn.dataset.rbi; // "0", "1", "2"...
            
            // (併殺・犠飛・犠打は data-rbi 属性を持たないので、actionから判断)
            const action = btn.dataset.action;
            if (action === 'out-dp') activeScorecardState.pendingPlay.rbi = 'dp';
            else if (action === 'out-sac-f') activeScorecardState.pendingPlay.rbi = 'sf';
            else if (action === 'out-sac-b') activeScorecardState.pendingPlay.rbi = 'sh';
            else activeScorecardState.pendingPlay.rbi = rbiValue; // "0", "1" など
            
            processPlay(); // プレーを確定
        }
    }

    // --- [NEW] 簡易入力モーダル：「結果」または「走塁」ボタン (優先度 2) ---
    // (併殺・犠飛・犠打ボタンは上のifで処理されるため、ここはそれ以外が対象)
    else if (e.target.closest('.result-btn')) {
        e.preventDefault();
        // action は 'hit-1b' や 'run-sb' など
        handleScorecardAction(e.target.closest('.result-btn').dataset.action);
    }
    
    // --- [NEW] 簡易入力モーダル：「打球方向」ホットスポット ---
    else if (e.target.closest('.direction-hotspot')) {
        e.preventDefault();
        if (activeScorecardState.currentStep !== "waiting_for_direction") return;
        
        const direction = e.target.closest('.direction-hotspot').dataset.direction;
        activeScorecardState.pendingPlay.direction = direction; // 方向をセット
        
        // ★ 次のステップ（打点入力）へ
        activeScorecardState.currentStep = "waiting_for_rbi";
        renderScorecard(); // UIを「打点入力モード」に更新
    }

    // --- [NEW] 簡易入力モーダル：「ランナー」クリック (走塁処理) ---
    else if (e.target.closest('.base.runner')) {
        e.preventDefault();
        const state = activeScorecardState;
        if (!state.currentStep.startsWith("waiting_for_runner_")) return;

        const baseEl = e.target.closest('.base.runner');
        let baseIndex = -1; // 0=1B, 1=2B, 2=3B
        if (baseEl.id === 'base-1b') baseIndex = 0;
        else if (baseEl.id === 'base-2b') baseIndex = 1;
        else if (baseEl.id === 'base-3b') baseIndex = 2;
        
        if (baseIndex === -1 || !state.runners[baseIndex]) return; // クリックされた塁にランナーがいない

        const runnerName = state.runners[baseIndex];
        let resultString = "";
        let newOuts = state.outs;
        
        if (state.currentStep === "waiting_for_runner_sb") {
            // 盗塁
            if (baseIndex === 2) { // 3塁ランナー
                state.runners[2] = null;
                state.score[state.topBottom === '表' ? 'team1' : 'team2']++; // ホームスチール
                resultString = `${runnerName} ホームスチール成功`;
            } else if (baseIndex === 1) { // 2塁ランナー
                state.runners[1] = null;
                state.runners[2] = runnerName;
                resultString = `${runnerName} 盗塁 (三塁へ)`;
            } else { // 1塁ランナー
                state.runners[0] = null;
                state.runners[1] = runnerName;
                resultString = `${runnerName} 盗塁 (二塁へ)`;
            }
        } 
        else if (state.currentStep === "waiting_for_runner_cs") {
            // 盗塁死
            state.runners[baseIndex] = null;
            newOuts++;
            resultString = `${runnerName} 盗塁死`;
        }
        else if (state.currentStep === "waiting_for_runner_out") {
            // 走塁死
            state.runners[baseIndex] = null;
            newOuts++;
            resultString = `${runnerName} 走塁死`;
        }

        // ログを記録 (打席とは独立したプレーとして)
        state.playLog.push({
            inning: state.inning,
            topBottom: state.topBottom,
            batterName: `(走者 ${runnerName})`,
            batterOrder: '-',
            resultString: resultString,
            outs: newOuts
        });
        state.outs = newOuts; // アウトカウントを更新

        // 3アウトになったか？
        if (state.outs >= 3) {
            if (state.topBottom === '表') {
                state.topBottom = '裏';
            } else {
                state.topBottom = '表';
                state.inning++;
            }
            state.outs = 0;
            state.runners = [null, null, null];
        }

        // 状態をリセット
        state.currentStep = "waiting_for_result";
        renderScorecard();
    }
    
    // ★★★ 修正ここまで ★★★

    // --- [NEW] 簡易入力モーダルの保存ボタン ---
    else if (e.target.closest('#scorecard-save-btn')) {
        e.preventDefault();
        saveScorecardAndClose();
    }
    // --- [NEW] 簡易入力モーダルの「戻る」ボタン ---
    else if (e.target.closest('#scorecard-undo-btn')) {
        e.preventDefault();
        alert("「1プレー戻す」機能は現在開発中です。");
    }
// ▲▲▲ 置き換えここまで ▲▲▲

// ▲▲▲ 置き換えここまで ▲▲▲
// --- [NEW] (ホームページ内) スマホメニューの開閉 ---
    else if (e.target.closest('#mobile-menu-button')) {
        e.preventDefault();
        const menu = document.getElementById('mobile-menu');
        menu.classList.toggle('hidden');
    }
    // --- [NEW] (ホームページ内) スマホメニューのリンククリック時に閉じる ---
    else if (e.target.closest('.mobile-nav-link')) {
        const menu = document.getElementById('mobile-menu');
        menu.classList.add('hidden');
    }
// ▲▲▲ 新規追加ここまで ▲▲▲

// --- [NEW] (ホームページ内) インタラクティブ・マップ ホットスポット ---
    else if (e.target.closest('.hotspot')) {
        e.preventDefault();
        const hotspot = e.target.closest('.hotspot');
        const popup = document.getElementById('hotspot-popup');
        const dataId = hotspot.dataset.id;
        const data = FACILITY_DATA[dataId];

        if (!data || !popup) return;

        // 1. データをポップアップに注入
        document.getElementById('hotspot-popup-title').textContent = data.title;
        document.getElementById('hotspot-popup-text').textContent = data.text;
        document.getElementById('hotspot-popup-image').src = data.imgSrc;
        
        // 2. ポップアップの位置をホットスポットの近くに調整
        const hotspotRect = hotspot.getBoundingClientRect();
        const mapRect = document.getElementById('campus-map-container').getBoundingClientRect();
        
        // ホットスポットの「マップコンテナ内での」相対Y座標
        const hotspotYInMap = hotspotRect.top - mapRect.top; 
        
        // マップの下半分にある場合はポップアップを「上」に、上半分なら「下」に出す
        if (hotspotYInMap > (mapRect.height / 2)) {
            popup.style.top = 'auto';
            popup.style.bottom = `${mapRect.height - hotspotYInMap + 20}px`; // ホットスポットの真上 (20pxオフセット)
        } else {
            popup.style.top = `${hotspotYInMap + hotspotRect.height + 20}px`; // ホットスポットの真下 (20pxオフセット)
            popup.style.bottom = 'auto';
        }
        
        // X座標はホットスポットの左端に合わせる (CSSのtransformは使わない方がシンプル)
        popup.style.left = `${hotspot.offsetLeft}px`;
        // transform をリセット
        popup.style.transform = 'translateY(-10px)'; // 上に浮き上がるアニメーション用

        // 3. 表示
        popup.classList.remove('hidden');
        // 'visible' クラスを少し遅れて追加してCSSアニメーションを発火
        setTimeout(() => popup.classList.add('visible'), 10);
    }
    
    // --- [NEW] (ホームページ内) ホットスポット・ポップアップを閉じる ---
    else if (e.target.closest('#hotspot-popup-close-btn')) {
        e.preventDefault();
        const popup = document.getElementById('hotspot-popup');
        popup.classList.remove('visible');
        popup.style.transform = 'translateY(0)'; // 元の位置に戻る
        // アニメーションが終わるのを待ってから隠す
        setTimeout(() => popup.classList.add('hidden'), 300);
    }
// ▲▲▲ 新規追加ここまで ▲▲▲

// ▼▼▼ [NEW] スレ立てモーダルを開くボタン ▼▼▼
    else if (e.target.closest('#open-new-thread-modal-btn')) {
        e.preventDefault();
        // フォームをリセット
        document.getElementById('new-thread-title').value = '';
        document.getElementById('new-thread-comment').value = '';
        // モーダルを表示
        document.getElementById('new-thread-modal').classList.remove('hidden');
    }
    // ▲▲▲ 挿入ここまで ▲▲▲
// ▼▼▼ [NEW] スレ立てモーダルを閉じるボタン (キャンセル) ▼▼▼
    else if (e.target.closest('#new-thread-cancel')) {
        e.preventDefault();
        document.getElementById('new-thread-modal').classList.add('hidden');
    }

/// --- [NEW] 283学園ホームページモーダルを開くボタン ---
   else if (e.target.closest('#status-modal-homepage-link')) {
        e.preventDefault();
        const modalId = e.target.closest('#status-modal-homepage-link').dataset.target;
        if (modalId === 'homepage-modal') {
            
            // 1. 最新のトーナメント表を描画
            const homepageBracketPlaceholder = document.getElementById('current-tournament-bracket-container');
            if (homepageBracketPlaceholder) {
                const currentBracketHTML = generateHomepageBracketHTML(tournamentState);
                if(currentBracketHTML.trim() !== "") {
                    homepageBracketPlaceholder.innerHTML = currentBracketHTML;
                } else {
                    homepageBracketPlaceholder.innerHTML = '<p class="text-center text-gray-500">（トーナメントがまだ開始されていません）</p>';
                }
            }

            // 2. 最新の「お知らせ」を動的に描画
            const dynamicNewsListEl = document.getElementById('homepage-dynamic-news-list');
            if (dynamicNewsListEl) {
                const homepageNews = tournamentState.homepageNews || [];
                if (homepageNews.length > 0) {
                    dynamicNewsListEl.innerHTML = homepageNews.map(article => {
                        if (article.error) return '';
                        const bodyForAttr = article.body.replace(/\n/g, '&#10;').replace(/"/g, '&quot;');
                        
                        return `
                            <li class="border-b border-gray-200 pb-3 mb-3 last:border-b-0">
                                <span class="text-sm text-red-600 font-bold">NEW!</span>
                                <span class="text-sm text-gray-500">${new Date(article.timestamp).toLocaleDateString('ja-JP')}</span>
                                <p class-"font-semibold text-gray-800 hover:text-blue-600 cursor-pointer homepage-news-item" 
                                   data-article-body="${bodyForAttr}" 
                                   data-article-title="${article.title.replace(/"/g, '&quot;')}">
                                    ${article.title}
                                </p>
                            </li>
                        `;
                    }).join('');
                    dynamicNewsListEl.classList.remove('hidden');
                } else {
                    dynamicNewsListEl.innerHTML = '';
                    dynamicNewsListEl.classList.add('hidden');
                }
            }

            // ★★★ 3. アニメーション付きでモーダルを開く ★★★
            toggleHomepageModal(true);
            
            // チームステータスモーダルは閉じない（上に重ねる）
        }
    }
// ▲▲▲ 置き換えここまで ▲▲▲

// --- [NEW] (ホームページ内) 動的お知らせクリック ---
    else if (e.target.closest('.homepage-news-item')) {
        e.preventDefault();
        const p = e.target.closest('p');
        const title = p.dataset.articleTitle;
        const body = p.dataset.articleBody.replace(/&#10;/g, '\n'); // 改行を元に戻す
        
        // 既存の一球速報モーダルを流用して表示
        const modal = document.getElementById('boxscore-modal');
        const modalTitle = document.getElementById('boxscore-modal-title');
        const modalBody = document.getElementById('boxscore-modal-body');
        
        modalTitle.textContent = title;
        // 本文を <pre> タグで囲むことで、\n の改行をそのまま表示する
        modalBody.innerHTML = `<pre class="p-4 whitespace-pre-wrap leading-relaxed text-sm">${body}</pre>`;
        
        modal.classList.remove('modal-hidden');
        modal.classList.add('flex');
    }
// ▲▲▲ 新規追加ここまで ▲▲▲

// ▼ boxscore-btn の処理ブロックを修正 ▼

// --- [修正版] 試合後 ボックススコア表示ボタン (一球速報) ---
    // ★重複している場合は、古い方を削除して、このブロック1つに統一してください
    else if (e.target.closest('.boxscore-btn')) {
        e.preventDefault();
        const btn = e.target.closest('.boxscore-btn');
        const matchId = btn.dataset.matchId;
        
        // 試合データを取得
        const dbMatch = findMatchById(matchId);
        
        if (!dbMatch || !dbMatch.details) {
            alert("詳細データが見つかりません。");
            return;
        }
        
        // HTMLを再生成（グラフ用タグを確実に含めるため）
        const freshHtml = generateBoxScoreHTML(dbMatch);
        
        // モーダル要素を取得
        const modal = document.getElementById('boxscore-modal');
        const modalTitle = document.getElementById('boxscore-modal-title');
        const modalBody = document.getElementById('boxscore-modal-body');
        
        // タイトル設定
        const roundName = getRoundNameFromMatchId(matchId);
        modalTitle.textContent = `ボックススコア: ${dbMatch.team1} vs ${dbMatch.team2} (${roundName})`;
        
        // HTMLを注入
        modalBody.innerHTML = freshHtml;
        
        // モーダルを表示
        modal.classList.remove('modal-hidden');
        modal.classList.remove('hidden'); 
        modal.classList.add('flex');

        // ▼▼▼ グラフ描画処理（修正済み） ▼▼▼
        setTimeout(() => {
            // 1. 勝率グラフ (Win Probability)
            const canvasProb = document.getElementById('win-prob-chart');
            if (canvasProb) {
                // ★修正: getContext('2d') を取得する
                const ctxProb = canvasProb.getContext('2d');
                
                if (dbMatch.details && dbMatch.details.inningScore) {
                    const scores1 = dbMatch.details.inningScore.team1;
                    const scores2 = dbMatch.details.inningScore.team2;
                    const { labels, dataPoints } = calculateWinProbData(dbMatch.team1, dbMatch.team2, scores1, scores2, tournamentState, dbMatch);

                    renderWinProbChart(ctxProb, dbMatch.team1, dbMatch.team2, labels, dataPoints);
                }
            } else {
                console.warn("勝率グラフのCanvasが見つかりません (ID: win-prob-chart)");
            }

            // 2. 熱狂度グラフ (Excitement)
            const canvasExcitement = document.getElementById('excitement-chart');
            if (canvasExcitement) {
                // ★修正: getContext('2d') を取得する
                // これがないと createLinearGradient でエラーになります
                const ctxExcitement = canvasExcitement.getContext('2d');

                const exData = calculateExcitementData(dbMatch);
                if (exData) {
                    renderExcitementChart(ctxExcitement, exData);
                    
                    // ランクバッジの更新
                    const badge = document.getElementById('excitement-rank-badge');
                    if (badge) {
                        badge.textContent = `ランク: ${exData.rank}`;
                        if (exData.rank.startsWith('S')) {
                            badge.className = "text-xs bg-red-100 text-red-800 px-2 py-1 rounded font-bold border border-red-500";
                        } else if (exData.rank.startsWith('A')) {
                             badge.className = "text-xs bg-orange-100 text-orange-800 px-2 py-1 rounded font-bold";
                        } else {
                            badge.className = "text-xs bg-gray-100 text-gray-800 px-2 py-1 rounded";
                        }
                    }
                }
            } else {
                console.warn("熱狂度グラフのCanvasが見つかりません (ID: excitement-chart)");
            }
        }, 300); // 描画待ち時間
    }

// --- [NEW] ランク別フィルター検索ボタン ---
    if (e.target.closest('.rank-filter-btn')) {
        e.preventDefault();
        const rank = e.target.closest('.rank-filter-btn').dataset.rank;
        
        // 全チームデータを取得 (TEAM_DATAにあるすべてのチーム)
        const allTeams = Object.keys(TEAM_DATA);
        
        // 指定されたランクのチームだけをフィルタリング
        const filteredTeams = allTeams.filter(teamName => {
            // calculateRank関数を使って現在のランクを判定
            return calculateRank(teamName, tournamentState) === rank;
        });

        // 名前順（あいうえお順）または偏差値順にソート
        filteredTeams.sort((a, b) => {
            const devA = TEAM_DATA[a].deviation || 50;
            const devB = TEAM_DATA[b].deviation || 50;
            return devB - devA; // 偏差値が高い順
        });

        if (filteredTeams.length > 0) {
            // 既存の検索結果表示関数を使ってモーダルを開く
            showSearchResultsList(filteredTeams, `${rank}ランク高校 一覧`);
        } else {
            alert(`現在、${rank}ランクのチームは存在しません。`);
        }
    }

    // --- [NEW] 283学園ホームページモーダルを閉じるボタン ---
   else if (e.target.closest('#homepage-modal-close')) {
        e.preventDefault();
        // ★★★ 4. アニメーション付きでモーダルを閉じる ★★★
        toggleHomepageModal(false);
    }
    // --- [NEW] (ホームページ内) ボックススコア表示ボタン ---
    else if (e.target.closest('#show-boxscore-btn-2024')) {
        e.preventDefault();
        const modal = document.getElementById('boxscore-modal');
        const modalBody = document.getElementById('boxscore-modal-body');
        
        // 架空のスコア表HTMLを生成
        const boxScoreHtml = generate2024FinalBoxScore(); 
        
        document.getElementById('boxscore-modal-title').textContent = "ボックススコア: 283学園 vs 常葉菊川 (2024年 決勝)";
        modalBody.innerHTML = boxScoreHtml;
        modal.classList.remove('modal-hidden');
        modal.classList.add('flex'); // hidden ではなく flex で表示
    }

    // --- [NEW] ボックススコアモーダルを閉じるボタン ---
    else if (e.target.closest('#boxscore-modal-close')) {
        e.preventDefault();
        const modal = document.getElementById('boxscore-modal');
        modal.classList.add('modal-hidden');
        modal.classList.remove('flex');
    }

    // --- [NEW] (ホームページ内) 動的お知らせクリック ---
    else if (e.target.closest('#homepage-dynamic-news-list p')) {
        e.preventDefault();
        const p = e.target.closest('p');
        const title = p.dataset.articleTitle;
        const body = p.dataset.articleBody.replace(/&#10;/g, '\n'); // 改行を元に戻す
        
        // 既存の一球速報モーダルを流用して表示
        const modal = document.getElementById('boxscore-modal');
        const modalTitle = document.getElementById('boxscore-modal-title');
        const modalBody = document.getElementById('boxscore-modal-body');
        
        modalTitle.textContent = title;
        // 本文を <pre> タグで囲むことで、\n の改行をそのまま表示する
        modalBody.innerHTML = `<pre class="p-4 whitespace-pre-wrap leading-relaxed text-sm">${body}</pre>`;
        
        modal.classList.remove('modal-hidden');
        modal.classList.add('flex');
    }

// ▲▲▲ 新規追加ここまで ▲▲▲

    // ▼▼▼ 既存の「#new-thread-submit」の else if ブロックと、このブロックを「置き換え」 ▼▼▼
    else if (e.target.closest('#new-thread-submit')) {
        e.preventDefault();
        
        // ★ AIが動作中であることをユーザーに示す
        const submitBtn = e.target.closest('#new-thread-submit');
        submitBtn.disabled = true;
        submitBtn.textContent = 'AIがレス作成中...';

        const title = document.getElementById('new-thread-title').value.trim();
        const comment = document.getElementById('new-thread-comment').value.trim();
        const fullUserText = `${title} ${comment}`; // ★ スキャン用の結合テキスト

        if (!title || !comment) {
            alert('タイトルと本文の両方を入力してください。');
            submitBtn.disabled = false;
            submitBtn.textContent = 'スレを立てる';
            return;
        }

        const threadId = 'user-' + Date.now();
        const timestamp = Date.now();

        // 1. 記事一覧に表示するための「記事オブジェクト」を作成
        const threadArticle = {
            id: threadId,
            headline: title,
            type: 'game', // AIスレと同じ 'game' タイプとして扱う
            matchId: threadId, // matomeThreads との連携キー
            timestamp: timestamp,
            category: '自スレ' // 専用カテゴリ
        };
        
        if (!tournamentState.userThreads) tournamentState.userThreads = [];
        tournamentState.userThreads.push(threadArticle);

        // 2. スレ主(>>1)のコメントを作成
        const firstComment = {
            id: crypto.randomUUID(),
            personality: '1: 風吹けば名無し (スレ主)',
            text: comment,
            timestamp: timestamp,
            replies: []
        };
        
        // ★★★ ここからが修正箇所 ★★★
        // 3. ユーザーの入力テキストから関連情報をスキャンし、AI用のコンテキストを生成
        
        const mentionedTeams = new Set();
        INITIAL_TEAM_POOL.forEach(team => {
            if (fullUserText.includes(team)) {
                mentionedTeams.add(team);
            }
        });

        let gameContext = ""; // AIに渡すための情報テキスト
        if (mentionedTeams.size > 0) {
            // チーム情報 (打率, 盗塁, 軌跡)
            mentionedTeams.forEach(teamName => {
                const teamData = TEAM_DATA[teamName];
                const teamRecord = tournamentState.teamRecords[teamName];
                const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord); 
                const fate = getTeamFateSummary(teamName);
                gameContext += `\n- **${teamName}**: ${dynamicInfo} (今大会の状況: ${fate})\n`;
            });

            // 選手情報 (Gamelog)
            // formatPlayerGamelogsForPrompt は「言及されたチーム」に所属する「言及された選手」のログを返す
            gameContext += formatPlayerGamelogsForPrompt(mentionedTeams, fullUserText);
        }
        
        // 4. AIにレスポンスを生成させる (★ gameContext を渡す)
        const aiComments = await generateUserThreadBbsComments(title, comment, gameContext);
        // ★★★ 修正ここまで ★★★

        if (!tournamentState.matomeThreads) tournamentState.matomeThreads = {};
        
        // 5. スレ主のコメントとAIのレスを結合して保存
        if (aiComments && Array.isArray(aiComments)) {
            tournamentState.matomeThreads[threadId] = {
                thread: [firstComment, ...aiComments], // ★ AIのレスを結合
                context: { isUserThread: true, title: title } 
            };
        } else {
             // AI生成失敗時も、スレ主のコメントだけでスレは立てる
            tournamentState.matomeThreads[threadId] = {
                thread: [firstComment], 
                context: { isUserThread: true, title: title } 
            };
             alert('AIによるレスの自動生成に失敗しました。スレッドは作成されます。');
        }


        // 6. 保存してUIを更新
        saveState();
        document.getElementById('new-thread-modal').classList.add('hidden');
        
        // 7. まとめサイトの記事一覧をリフレッシュ
        const articlesContainer = document.getElementById('matome-articles-container');
        articlesContainer.innerHTML = `<div class="loader text-center py-8">スレッドを立てています...</div>`;
        (async () => {
            const matomeHtml = await generateMatomeSiteHtml();
            articlesContainer.innerHTML = matomeHtml;
        })();

        // 8. ボタンの状態を元に戻す
        submitBtn.disabled = false;
        submitBtn.textContent = 'スレを立てる';
    }
// ▲▲▲ 置き換えここまで ▲▲▲

    // --- ★★★ ソート機能（ヘッダーTHクリック） ★★★ ---
    if (e.target.matches('.sortable-header')) {
        e.preventDefault();
        const header = e.target.closest('.sortable-header');
        const modal = e.target.closest('#team-stats-modal');
        const tableType = header.dataset.tableType;
        const newSortKey = header.dataset.sortKey;
        const teamName = document.getElementById('team-stats-modal-title').textContent.split(' ')[0];
        let currentKey, currentDir;
        if (tableType === 'batting') {
            currentKey = modal.dataset.sortKeyBatting;
            currentDir = modal.dataset.sortDirBatting;
        } else {
            currentKey = modal.dataset.sortKeyPitching;
            currentDir = modal.dataset.sortDirPitching;
        }
        let newSortDir = 'desc';
        if (newSortKey === currentKey && currentDir === 'desc') {
            newSortDir = 'asc';
        }
        if (tableType === 'batting') {
            modal.dataset.sortKeyBatting = newSortKey;
            modal.dataset.sortDirBatting = newSortDir;
        } else {
            modal.dataset.sortKeyPitching = newSortKey;
            modal.dataset.sortDirPitching = newSortDir;
        }
        renderTeamStatsModal(teamName);
    }

    // --- 「個人通算成績」ボタン（モーダルを開く） ---
    if (e.target.matches('.show-player-stats-btn')) {
        e.preventDefault();
        const btn = e.target;
        const teamName = btn.dataset.teamName;
        const row = btn.closest('tr');
        const playerNameInput = row.querySelector('.player-name');
        if (!playerNameInput) { alert('エラー: 選手名入力欄が見つかりません。'); return; }
        const playerName = playerNameInput.value.trim();
        if (!playerName) { alert('選手名が入力されていません。'); return; }
        renderCareerStatsModal(playerName, teamName);
        document.getElementById('player-stats-modal').classList.remove('hidden');
        document.getElementById('player-stats-modal').classList.add('flex');
    }

    // --- 個人通算成績モーダルを閉じるボタン ---
    if (e.target.matches('#player-stats-modal-close')) {
        e.preventDefault();
        document.getElementById('player-stats-modal').classList.add('hidden');
        document.getElementById('player-stats-modal').classList.remove('flex');
    }

    // --- 【詳細モーダル内】「打順からコピー」ボタン（投手） ---
    if (e.target.matches('.copy-pitchers-from-batting-btn')) {
        e.preventDefault();
        const teamKey = e.target.dataset.teamKey;
        const battingTable = document.getElementById(`batting-table-${teamKey}`);
        if (!battingTable) { alert('打撃テーブルが見つかりません。'); return; }
        const pitchingTableBody = document.getElementById(`pitching-table-${teamKey}`)?.querySelector('tbody');
        if (!pitchingTableBody) { alert('投手テーブルが見つかりません。'); return; }
        const pitchersInBatting = [];
        battingTable.querySelectorAll('tbody tr').forEach(row => {
            const posSelect = row.querySelector('.player-pos');
            const nameInput = row.querySelector('.player-name');
            const throwBatSelect = row.querySelector('.player-throw-bat');
            if (posSelect && posSelect.value === '投' && nameInput && nameInput.value.trim() !== '') {
                pitchersInBatting.push({ name: nameInput.value.trim(), throwBat: throwBatSelect ? throwBatSelect.value : '' });
            }
        });
        if (pitchersInBatting.length === 0) {
            alert('打撃テーブルに「投」と設定された選手が見つかりません。\n先に打撃テーブルの「守備」欄を「投」に設定してください。');
            return;
        }
        const pitchingRows = pitchingTableBody.querySelectorAll('tr');
        let updatedCount = 0;
        pitchersInBatting.forEach((pitcher, index) => {
            if (pitchingRows[index]) {
                const nameInput = pitchingRows[index].querySelector('.pitcher-name');
                const throwBatSelect = pitchingRows[index].querySelector('.pitcher-throw-bat');
                if (nameInput) nameInput.value = pitcher.name;
                if (throwBatSelect) throwBatSelect.value = pitcher.throwBat;
                updatedCount++;
            }
        });
        alert(`${updatedCount}人の投手を打撃テーブルからコピーしました。`);
    }

    // --- 【まとめサイト】スレッド再生成ボタン ---
    if (e.target.matches('#retry-matome-thread-btn')) {
        e.preventDefault();
        const btn = e.target;
        const matchId = btn.dataset.matchId;
        const originalData = tournamentState.matomeThreads[matchId];
        
        if (!originalData || !originalData.context) {
            alert("再生成に必要な「試合終了時の情報（コンテキスト）」が見つかりません。");
            return;
        }
        
        const matchContext = originalData.context;
        const threadContentEl = document.getElementById('bbs-thread-content');
        btn.disabled = true;
        btn.textContent = '生成中...';
        threadContentEl.innerHTML = `<div class="loader text-center py-8">AIがスレッドを再生成中です...（${matchContext.winnerLineupChanges || 'スタメン変更なし'}）</div>`;
        
        let newCommentsArray = null;
        
        try {
            // ★★★ ここからが修正箇所 (甲子園分岐) ★★★
            const isKoshien = tournamentState.currentTournament === 'summer_koshien';
            const playerTeam = tournamentState.teams[0];
            const isPlayerMatch = (matchContext.winnerName === playerTeam || matchContext.loserName === playerTeam);

            if (isKoshien && isPlayerMatch) {
                // 甲子園モード & プレイヤー戦 -> 応援スレッドを再生成
                const result = await generateKoshienMatomeThread(matchContext);
                // generateKoshienMatomeThread は { comments: [...] } を返す
                newCommentsArray = result ? result.comments : null;
            } else {
                // 通常モード -> なんJスレッドを再生成
                const result = await generateGameMatchBbsComments(matchContext);
                // generateGameMatchBbsComments は [...] (配列) または { comments: [...] } を返す可能性があるため両対応
                if (Array.isArray(result)) {
                    newCommentsArray = result;
                } else if (result && result.comments) {
                    newCommentsArray = result.comments;
                }
            }
            // ★★★ 修正ここまで ★★★

            if (newCommentsArray && Array.isArray(newCommentsArray)) {
                // 保存
                tournamentState.matomeThreads[matchId].thread = newCommentsArray;
                saveState();
                
                // 描画
                threadContentEl.innerHTML = '';
                for (const comment of newCommentsArray) {
                    const commentEl = document.createElement('div');
                    commentEl.className = 'bbs-comment opacity-0 transition-opacity duration-500';
                    commentEl.innerHTML = `<p class="font-semibold text-gray-700 text-sm">${comment.personality}</p><p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>`;
                    threadContentEl.appendChild(commentEl);
                    setTimeout(() => { commentEl.classList.remove('opacity-0'); }, 50);
                    await new Promise(resolve => setTimeout(resolve, 50));
                    threadContentEl.scrollTop = threadContentEl.scrollHeight;
                }
            } else {
                threadContentEl.innerHTML = `<p class="text-center text-red-500">スレッドの再生成に失敗しました。</p>`;
            }
        } catch (err) {
            console.error("まとめスレッド再生成中にエラー:", err);
            threadContentEl.innerHTML = `<p class="text-center text-red-500">エラーが発生しました: ${err.message}</p>`;
        }
        
        btn.disabled = false;
        btn.textContent = '再生成';
    }

    // --- 「まとめサイトを見る」ボタン ---
    const showMatomeBtn = e.target.closest('#show-matome-site-btn');
    if (showMatomeBtn) {
        const modal = document.getElementById('integrated-matome-modal');
        const articlesContainer = document.getElementById('matome-articles-container');
        modal.classList.remove('hidden');
        articlesContainer.innerHTML = `<div class="loader text-center py-8">記事を読み込んでいます...</div>`;
        document.querySelectorAll('.matome-tab-content').forEach(tab => tab.classList.add('hidden'));
        document.getElementById('matome-tab-top').classList.remove('hidden');
        document.querySelectorAll('.matome-tab-btn').forEach(btn => btn.classList.remove('active', 'bg-blue-600', 'text-white'));
        document.querySelector('.matome-tab-btn[data-tab="top"]').classList.add('active', 'bg-blue-600', 'text-white');
        (async () => {
            const matomeHtml = await generateMatomeSiteHtml();
            articlesContainer.innerHTML = matomeHtml;
        })();
    }

    // --- 設定モーダルを開く/閉じる ---
   // --- 設定モーダルを開く/閉じる ---
if (e.target.closest('#open-settings-btn')) {
    document.getElementById('toggle-article-generation').checked = tournamentState.settings.enableArticleGeneration;
    document.getElementById('toggle-bbs-generation').checked = tournamentState.settings.enableBbsGeneration;
    
    // ▼▼▼ 【追加】 ピラミッドを描画 ▼▼▼
    renderRankPyramid();
    // ▲▲▲ 追加ここまで ▲▲▲

    document.getElementById('settings-modal').classList.remove('hidden');
    
    document.getElementById('settings-modal').classList.add('flex'); 
}

// --- 設定モーダルを閉じるボタンのイベントリスナー ---
document.getElementById('settings-modal-close-btn').addEventListener('click', () => {
    const modal = document.getElementById('settings-modal');
    modal.classList.add('hidden');
    modal.classList.remove('flex'); // flexで表示していた場合の対策
});

    // --- 統合型まとめサイトモーダルを閉じるボタン ---
    if (e.target.closest('#matome-modal-close-btn')) {
        document.getElementById('integrated-matome-modal').classList.add('hidden');
        document.getElementById('bbs-thread-display-area').classList.add('hidden');
    }

    // --- まとめサイト内のタブ切り替え ---
    const tabBtn = e.target.closest('.matome-tab-btn');
    if (tabBtn) {
        document.querySelectorAll('.matome-tab-btn').forEach(btn => {
            btn.classList.remove('active', 'bg-blue-600', 'text-white', 'hover:bg-blue-700');
            btn.classList.add('text-gray-700', 'hover:bg-gray-100');
        });
        tabBtn.classList.add('active', 'bg-blue-600', 'text-white');
        tabBtn.classList.remove('text-gray-700', 'hover:bg-gray-100');
        const tabId = tabBtn.dataset.tab;
        document.querySelectorAll('.matome-tab-content').forEach(content => {
            content.classList.add('hidden');
        });
        document.getElementById(`matome-tab-${tabId}`).classList.remove('hidden');
        document.getElementById('bbs-thread-display-area').classList.add('hidden');
        if (tabId === 'top') {
            const articlesContainer = document.getElementById('matome-articles-container');
            articlesContainer.innerHTML = `<div class="loader text-center py-8">記事を読み込んでいます...</div>`;
            (async () => {
                const matomeHtml = await generateMatomeSiteHtml();
                articlesContainer.innerHTML = matomeHtml;
            })();
        }
    }
    
    // --- まとめサイト内の記事リンククリック ---
    const matomeLink = e.target.closest('.matome-article-link');
    if (matomeLink) {
        e.preventDefault();
        const headline = matomeLink.dataset.headline;
        const type = matomeLink.dataset.type;
        const category = matomeLink.dataset.category;
        const matchId = matomeLink.dataset.matchId;
        const threadDisplayArea = document.getElementById('bbs-thread-display-area');
        const threadTitleEl = document.getElementById('bbs-thread-title');
        const threadContentEl = document.getElementById('bbs-thread-content');
        document.querySelectorAll('.matome-tab-content').forEach(content => content.classList.add('hidden'));
        threadDisplayArea.classList.remove('hidden');
        threadTitleEl.textContent = headline;
        threadContentEl.innerHTML = `<div class="loader text-center py-8">AIが掲示板の反応を生成中...</div>`;
        (async () => {
            let commentsArray;
            const retryBtn = document.getElementById('retry-matome-thread-btn');
            if (type === 'game' && matchId) {
                const preGeneratedData = tournamentState.matomeThreads[matchId];
                const preGeneratedThread = preGeneratedData ? preGeneratedData.thread : null;
                if (preGeneratedData && preGeneratedData.context) {
                    retryBtn.dataset.matchId = matchId;
                    retryBtn.classList.remove('hidden');
                } else {
                    retryBtn.classList.add('hidden');
                }
                if (preGeneratedThread) {
                    if (Array.isArray(preGeneratedThread)) {
                        commentsArray = preGeneratedThread;
                    } else if (preGeneratedThread.error) {
                        threadContentEl.innerHTML = `<p class="text-center text-red-500">スレッドの生成に失敗しました。(エラー: ${preGeneratedThread.body || '不明'})</p>`;
                        return;
                    }
                } else {
                    threadContentEl.innerHTML = `<p class="text-center text-gray-500">この試合のまとめスレッドはまだありません。</p>`;
                    retryBtn.classList.add('hidden');
                    return;
                }
            } else if (type === 'real') {
                retryBtn.classList.add('hidden');
                commentsArray = await generateRealNewsBbsComments(headline, category);
            }
            if (commentsArray && Array.isArray(commentsArray)) {
                threadContentEl.innerHTML = '';
                for (const comment of commentsArray) {
                    const commentEl = document.createElement('div');
                    commentEl.className = 'bbs-comment opacity-0 transition-opacity duration-500';
                    commentEl.innerHTML = `<p class="font-semibold text-gray-700 text-sm">${comment.personality}</p><p class="text-gray-800 my-1 whitespace-pre-wrap">${comment.text}</p>`;
                    threadContentEl.appendChild(commentEl);
                    setTimeout(() => { commentEl.classList.remove('opacity-0'); }, 50);
                    const delay = Math.random() * 800 + 200;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    threadContentEl.scrollTop = threadContentEl.scrollHeight;
                }
            } else if (!commentsArray) {
                threadContentEl.innerHTML = `<p class="text-center text-red-500">スレッドの読み込みに失敗しました。</p>`;
            }
        })();
    }

    // --- BBSスレッドから一覧に戻るボタン ---
    if (e.target.closest('#bbs-thread-back-btn')) {
        document.getElementById('bbs-thread-display-area').classList.add('hidden');
        document.getElementById('matome-tab-top').classList.remove('hidden');
    }

    // --- スキャンダル告発/無視ボタン ---
    const scandalBtn = e.target.closest('.report-scandal-btn, .ignore-scandal-btn');
    if (scandalBtn && tournamentState.activeScandal) {
        const { teamName, scandalId } = tournamentState.activeScandal;
        const scandalDef = SCANDAL_DEFINITIONS.find(s => s.id === scandalId);
        if (!scandalDef) return;
        const choice = scandalBtn.classList.contains('report-scandal-btn') ? 'report' : 'ignore';
        const consequence = scandalDef.consequences[choice];
        consequence.applyEffect(teamName, tournamentState);
        const outcomeArticle = {
            title: consequence.outcomeTitle(teamName),
            body: consequence.outcomeBody(teamName),
            timestamp: Date.now()
        };
        tournamentState.news = tournamentState.news.filter(n => !n.isScandalRumor);
        tournamentState.news.push(outcomeArticle);
        tournamentState.activeScandal = null;
        renderTournament(tournamentState);
        saveState();
    }

    // --- ドキュメンタリー密着取材ボタン（各種） ---
    if (e.target.matches('.underdog-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？...`);
        if (confirmed) startDocumentary('underdog', teamName);
    }
    if (e.target.matches('.powerhouse-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) startDocumentary('powerhouse', teamName);
    }
    if (e.target.matches('.powerhouse-revival-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) startDocumentary('powerhouse_revival', teamName);
    }
    if (e.target.matches('.one-man-team-doc-btn')) {
        const teamName = e.target.dataset.teamName;
        const confirmed = await showConfirm(`「${teamName}」の密着ドキュメンタリーを開始しますか？\nこの大会中、他のチームは選択できなくなります。`);
        if (confirmed) startDocumentary('one_man_team', teamName);
    }

    // --- 走者プレー「追加」ボタン ---
    if (e.target.matches('.add-runner-play-btn')) {
        e.preventDefault();
        const container = e.target.closest('.at-bat-block').querySelector('.runner-plays-container');
        if (!container) return;
        if (container.children.length >= 3) {
            alert('一度に追加できる走者プレーは3つまでです。');
            return;
        }
        const table = e.target.closest('.batting-table');
        const playersOnField = Array.from(table.querySelectorAll('.player-name')).map(input => ({name: input.value.trim()})).filter(p => p.name);
        const nameOptions = playersOnField.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
        const baserunningPlays = ['盗塁', '盗塁死', 'タッチアップ', '進塁', '生還', '走塁死', '牽制死', '挟殺プレーでアウト'];
        const bases = ['一塁へ', '二塁へ', '三塁へ', '本塁へ(生還)'];
        const playOptions = baserunningPlays.map(p => `<option value="${p}">${p}</option>`).join('');
        const baseOptions = bases.map(b => `<option value="${b}">${b}</option>`).join('');
        const newPlayHTML = `
            <div class="runner-play-input flex gap-1 items-center mt-1">
                <select class="runner-name w-1/3 text-xs p-1 border rounded"><option value="">-誰が-</option>${nameOptions}</select>
                <select class="runner-play w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-何をした-</option>${playOptions}</select>
                <select class="runner-base w-1/3 text-xs p-1 border rounded bg-green-50"><option value="">-どこへ-</option>${baseOptions}</select>
                <button class="remove-runner-play-btn text-red-500 hover:text-red-700 font-bold text-lg leading-none p-1">×</button>
            </div>
        `;
        container.insertAdjacentHTML('beforeend', newPlayHTML);
    }
    
    // --- 走者プレー「削除」ボタン ---
    if (e.target.matches('.remove-runner-play-btn')) {
        e.target.closest('.runner-play-input').remove();
    }

    // --- おまかせ入力ボタン ---
    if (e.target.matches('.quick-sim-btn')) {
        e.preventDefault();
        autoFillMatchDetails(e.target.dataset.matchId);
    }

    // --- 1イニングに複数打席を追加するボタン ---
    if (e.target.matches('.add-at-bat-btn')) {
        e.preventDefault();
        const table = e.target.closest('.batting-table');
        const playersOnField = Array.from(table.querySelectorAll('.player-name')).map(input => ({ name: input.value.trim() })).filter(p => p.name);
        const newAtBatHTML = createBattingResultDropdowns(playersOnField, '');
        e.target.insertAdjacentHTML('beforebegin', newAtBatHTML);
    }

    // --- 交代選手追加ボタン ---
    // --- 交代選手追加ボタン ---
    if (e.target.matches('.add-sub-row-btn')) {
        e.preventDefault();
        const btn = e.target;
        const teamKey = btn.dataset.teamKey;

        // ★★★ ここからが修正箇所 ★★★
        // エラーの原因: dbMatch が未定義だったため、ここで match を再取得します
        const match = findMatchById(currentMatchIdForDetails);
        if (!match) {
            console.error("Could not find match to add substitute player.");
            return; 
        }
        // ★★★ 修正ここまで ★★★

        const currentOrder = btn.dataset.order;
        const baseOrder = currentOrder.split('-')[0];
        const tableBody = btn.closest('tbody');
        if (!tableBody) return;
        const allOrderRows = Array.from(tableBody.querySelectorAll(`tr[data-order^="${baseOrder}"]`));
        const targetRow = allOrderRows[allOrderRows.length - 1];
        const subCount = allOrderRows.filter(row => row.dataset.order.includes('sub')).length + 1;
        const newOrder = `${baseOrder}-sub-${subCount}`;
        const newRow = document.createElement('tr');
        newRow.dataset.order = newOrder;
        const throwBatOptionsList = [
            { val: "R/R", label: "右/右" }, { val: "R/L", label: "右/左" }, { val: "R/S", label: "右/両" },
            { val: "L/L", label: "左/左" }, { val: "L/R", label: "左/右" }, { val: "L/S", label: "左/両" }
        ];
        const tbOptionsHtml = throwBatOptionsList.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const subThrowBatSelect = `<select class="player-throw-bat w-full bg-transparent"><option value="">-投/打-</option>${tbOptionsHtml}</select>`;
        const numberOptions = Array.from({length: 20}, (_, i) => `<option value="${i + 1}">${i + 1}</option>`).join('');
        const posOptions = ['投', '捕', '一', '二', '三', '遊', '左', '中', '右'].map(p => `<option value="${p}">${p}</option>`).join('');
        const numInnings = tableBody.parentElement.querySelector('thead tr').children.length - 7;
        let resultInputs = '';
        for (let j = 0; j < numInnings; j++) {
            resultInputs += `<td class="col-inning batting-result-cell align-top p-1">
                                ${createBattingResultDropdowns(null, '')}
                                <button class="add-at-bat-btn text-xs mt-2 bg-blue-100 px-2 py-1 rounded hover:bg-blue-200 w-full font-semibold">＋ 2打席目を追加</button>
                             </td>`;
        }
        newRow.innerHTML = `
            <td class="col-order"></td>
            <td class="col-number"><select class="player-number w-full bg-transparent"><option value=""></option>${numberOptions}</select></td>
            <td class="col-throw-bat">${subThrowBatSelect}</td>
            <td class="col-player pl-4">
                <div class="flex items-center gap-1">
                    <input type="text" class="player-name w-full" placeholder="交代選手名">
                    <button class="show-player-stats-btn text-lg p-1 text-blue-600 hover:bg-blue-100 rounded" 
                            data-team-name="${teamKey === 'team1' ? match.team1 : match.team2}" 
                            data-player-order-key="${newOrder}" 
                            title="通算成績を表示">📊</button>
                </div>
            </td>
            <td class="col-pos">
                <div class="flex items-center justify-between">
                    <select class="player-pos w-full bg-transparent"><option value=""></option>${posOptions}</select>
                    <button class="text-xs bg-gray-200 px-1 ml-1 rounded pos-change-btn" data-team-key="${teamKey}">変更</button>
                </div>
                <span class="text-xs text-gray-500 truncate" title=""></span>
            </td>
            <td class="col-sub-type align-top">
                <select class="sub-type-select w-full bg-transparent mb-1">
                    <option value="" selected>-</option>
                    <option value="PH">代打</option><option value="PR">代走</option>
                    <option value="DEF">守備</option><option value="PITCHER">投手</option>
                </select>
                <button class="add-sub-row-btn text-xs bg-gray-200 px-2 py-1 rounded hover:bg-gray-300 w-full" data-order="${newOrder}" data-team-key="${teamKey}">
                    + 交代
                </button>
            </td>
            ${resultInputs}
        `;
        targetRow.parentNode.insertBefore(newRow, targetRow.nextSibling);
    }
// ▲▲▲ 置き換えここまで ▲▲▲

    // --- 守備変更ボタン（モーダルを開く） ---
    if (e.target.matches('.pos-change-btn')) {
        const btn = e.target;
        const teamKey = btn.dataset.teamKey;
        const row = btn.closest('tr');
        const playerNameInput = row.querySelector('.player-name');
        if (!playerNameInput) return;
        const playerName = playerNameInput.value.trim();
        if (!playerName) {
            alert("先に選手名を入力してください。");
            return;
        }
        const modal = document.getElementById('substitution-modal');
        document.getElementById('sub-modal-player-name').value = playerName;
        modal.dataset.teamKey = teamKey;
        modal.dataset.playerName = playerName;
        modal.dataset.matchId = currentMatchIdForDetails;
        document.getElementById('sub-modal-inning').value = 1;
        document.getElementById('sub-modal-top-bottom').value = '表';
        document.getElementById('sub-modal-timing-start').checked = true;
        document.getElementById('sub-modal-timing-mid').checked = false;
        document.getElementById('sub-modal-mid-inning-details').classList.add('hidden');
        document.getElementById('sub-modal-outs').value = '0';
        document.getElementById('sub-modal-runner1').checked = false;
        document.getElementById('sub-modal-runner2').checked = false;
        document.getElementById('sub-modal-runner3').checked = false;
        document.getElementById('sub-modal-new-pos').value = '';
        modal.classList.remove('hidden');
    }   

    // --- 投手追加ボタン ---
    if (e.target.matches('.add-row-btn')) {
        e.preventDefault();
        const tableId = e.target.dataset.tableId;
        const table = document.getElementById(tableId).querySelector('tbody');
        const newRow = table.insertRow();
        const throwBatOptions = [ { val: "R/R", label: "右/右" }, { val: "R/L", label: "右/左" }, { val: "R/S", label: "右/両" }, { val: "L/L", label: "左/左" }, { val: "L/R", label: "左/右" }, { val: "L/S", label: "左/両" } ];
        const throwStyleOptions = [ { val: "over", label: "オーバー" }, { val: "three_quarter", label: "スリークォーター" }, { val: "side", label: "サイド" }, { val: "under", label: "アンダー" } ];
        const pitcherTypeOptions = [ { val: "honkaku", label: "本格派" }, { val: "sokkyu", label: "速球派" }, { val: "giko", label: "技巧派" }, { val: "nanto", label: "軟投派" } ];
        const velocityOptions = [];
        for (let v = 100; v <= 165; v += 5) { velocityOptions.push({ val: `${v}km`, label: `${v}km帯` }); }
        const tbOptionsHtml = throwBatOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const styleOptionsHtml = throwStyleOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const typeOptionsHtml = pitcherTypeOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        const velocityOptionsHtml = velocityOptions.map(opt => `<option value="${opt.val}">${opt.label}</option>`).join('');
        newRow.innerHTML = `
            <td class="col-pitcher-result"><select class="pitcher-result"><option value="" selected>-</option><option value="W">○</option><option value="L">●</option><option value="S">S</option><option value="H">H</option></select></td>
            <td class="col-pitcher-name"><input type="text" class="pitcher-name" value=""></td>
            <td class="col-pitcher-throw-bat"><select class="pitcher-throw-bat w-full bg-transparent"><option value="">-投/打-</option>${tbOptionsHtml}</select></td>
            <td class="col-pitcher-style"><select class="pitcher-throw-style w-full bg-transparent"><option value="">-投げ方-</option>${styleOptionsHtml}</select></td>
            <td class="col-pitcher-type"><select class="pitcher-type w-full bg-transparent"><option value="">-タイプ-</option>${typeOptionsHtml}</select></td>
            <td class="col-pitcher-velocity"><select class="pitcher-velocity w-full bg-transparent"><option value="">-球速帯-</option>${velocityOptionsHtml}</select></td>
            <td class="col-stat"><input type="text" class="pitcher-innings" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-batters" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-pitches" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-hits" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-so" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-walks" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-runs" value=""></td>
            <td class="col-stat"><input type="number" class="pitcher-er" value=""></td>
        `;
    }

    // --- 先攻後攻入れ替えボタン ---
    if (e.target.matches('#swap-teams-btn')) {
        swapTeamDetails(e.target.dataset.matchId);
    }

// ▼▼▼ このブロックを「新規追加」 ▼▼▼
    // --- チームステータスモーダル（簡易版）を閉じるボタン ---
    const statusModalCloseBtn = e.target.closest('#status-modal-close');
    if (statusModalCloseBtn) {
        e.preventDefault();
        document.getElementById('team-status-modal').classList.add('hidden');
    }
    // ▲▲▲ 追加ここまで ▲▲▲

    // ★★★★★ ここが修正箇所 ★★★★★
    // --- チーム名クリック（ステータス表示） ---
    // (他のボタン操作と競合しないよう、ボタン以外がクリックされたかチェック)
    else if (e.target.closest('.clickable-team-name') && !e.target.closest('button')) {
            const clickableTeamName = e.target.closest('.clickable-team-name');
            const teamName = clickableTeamName.dataset.teamName;
            
            // ★★★ 修正箇所 ★★★
                        if(teamName && teamName !== 'null' && teamName !== '') {
                // ★ matchId を渡さない
                showTeamStatusModal(teamName); 
            }
            // ★★★ 修正ここまで ★★★
        }    // ★★★★★ 修正ここまで ★★★★★

    // --- 記事表示ボタン（通常記事の「本文」） ---
    const newsArticleBtn = e.target.closest('.news-article-btn');
    if (newsArticleBtn) {
        const article = tournamentState.news[parseInt(newsArticleBtn.dataset.index, 10)];
        if (article && article.body) {
            document.getElementById('modal-title').textContent = article.title;
            document.getElementById('modal-body').textContent = article.body;
            document.getElementById('modal-meta').innerHTML = `<p>${new Date(article.timestamp).toLocaleDateString('ja-JP')}</p>`;
            newsModal.classList.remove('hidden');
            newsModal.classList.add('flex');
        } else {
            alert('記事の本文データを取得できませんでした。');
        }
    }

    // ▼▼▼ このブロックを「新規追加」(17805行目あたり) ▼▼▼
    // --- 記事表示ボタン（新聞の「新聞を読む」） ---
   else if (e.target.closest('.newspaper-view-btn')) {
        const newspaperViewBtn = e.target.closest('.newspaper-view-btn');
        const article = tournamentState.news[parseInt(newspaperViewBtn.dataset.index, 10)];
        
        if (article.isNewspaper) {
            if (article.newspaperData) {
                // --- 1. ラウンド終了時の「特集号」を開くロジック ---
                renderNewspaperModal(article.newspaperData);
                newspaperModal.classList.remove('hidden');
                
            // ★★★ ▼▼▼ 以下の else if ブロックを「新規追加」 ▼▼▼ ★★★
            } else if (article.newspaperHtml) {
                // --- 2. 「個別の試合」の新聞を開くロジック ---
                // （個別の新聞は、記事生成時にHTMLも一緒に保存されています）
                newspaperModalBody.innerHTML = article.newspaperHtml;
                newspaperModal.classList.remove('hidden');
            // ★★★ ▲▲▲ 追加ここまで ▲▲▲ ★★★
                
            } else {
                alert('新聞データの形式が正しくありません。(newspaperData も newspaperHtml も見つかりません)');
            }
        }
    }
    // ▲▲▲ 新規追加ここまで ▲▲▲

// ▼▼▼ この else if ブロックをまるごと追加 ▼▼▼
    else if (e.target.closest('.skip-newspaper-view-btn')) {
        // --- 「スキップ新聞を読む」ボタン (ニュース欄から) ---
        e.preventDefault();
        const btn = e.target.closest('.skip-newspaper-view-btn');
        const index = parseInt(btn.dataset.index, 10);
        const article = tournamentState.news[index];

        if (!article || !article.isSkipNewspaper || !article.articleData || !article.resultsBoxHtml) {
            alert("スキップ新聞のデータが見つかりません。");
            return;
        }

        // 1. モーダル要素を取得
        const modal = document.getElementById('skip-newspaper-modal');
        const bodyEl = document.getElementById('skip-newspaper-body');
        const dateEl = document.getElementById('skip-newspaper-date');
        const topTitleEl = document.getElementById('skip-newspaper-top-title');
        const resultsTitleEl = document.getElementById('skip-newspaper-results-title');
        
        // 2. 保存されたデータでモーダルを再構築
        const { articleData, resultsBoxHtml, dateString, roundNumber } = article;
        const roundName = getRoundNameFromMatchId(`L-R${roundNumber}-M1`); // ラウンド名を取得

        dateEl.textContent = dateString || `${tournamentState.tournamentYear}年`;
        topTitleEl.textContent = `熱戦の${roundName}、静岡を席巻`;
        resultsTitleEl.textContent = `${roundName} 全試合結果`;
        
        bodyEl.innerHTML = `
            <div class="skip-newspaper-main-headline">
                ${articleData.mainHeadline}
            </div>
            <div class="skip-newspaper-main-article">
                <div class="skip-newspaper-main-image">
                    写真：${articleData.mainImageCaption}
                </div>
                <p class="skip-newspaper-image-caption">${articleData.mainImageCaption}</p>
                <div class="skip-newspaper-main-body">
                    <h4>${articleData.mainArticleSubHeadline}</h4>
                    <p>${articleData.mainArticleBody.replace(/\n/g, '<br><br>')}</p>
                </div>
            </div>
            <div class="skip-newspaper-side-article right">
                <h3 class="skip-newspaper-side-headline">${articleData.sideArticle1Headline}</h3>
                <div class="skip-newspaper-side-body">
                    <p>${articleData.sideArticle1Body.replace(/\n/g, '<br><br>')}</p>
                </div>
            </div>
            <div class="skip-newspaper-side-article left">
                <h3 class="skip-newspaper-side-headline">${articleData.sideArticle2Headline}</h3>
                <div class="skip-newspaper-side-body">
                    <p>${articleData.sideArticle2Body.replace(/\n/g, '<br><br>')}</p>
                </div>
            </div>
            <div class="skip-newspaper-results-section">
                <h2 id="skip-newspaper-results-title">${roundName} 全試合結果</h2>
                <div id="skip-newspaper-match-grid" class="skip-newspaper-match-grid">
                    ${resultsBoxHtml}
                </div>
            </div>
        `;

        // 3. モーダルを表示
        modal.classList.remove('hidden');
    }
    // ▲▲▲ 追加ここまで ▲▲▲

    // --- 掲示板の「返信する」ボタン ---
    const replyBtn = e.target.closest('.reply-btn');
    if (replyBtn) {
        e.preventDefault();
        const commentId = replyBtn.dataset.commentId;
        const formContainer = document.getElementById(`reply-form-container-${commentId}`);
        if (formContainer) {
            formContainer.classList.toggle('hidden');
        }
        return; 
    }
    
    // --- AI記事の再生成ボタン（エラー記事・成功記事の両方に対応） ---
    const regenerateBtn = e.target.closest('.regenerate-btn, .retry-btn');
    if (regenerateBtn) {
        const articleIndex = parseInt(regenerateBtn.dataset.index, 10);
        const originalArticle = tournamentState.news[articleIndex];
        if (!originalArticle || !originalArticle.context) {
            alert("この記事は再生成できません。");
            return;
        }
        articleForRegeneration = { index: articleIndex, article: originalArticle };
        document.getElementById('feedback-include').value = '';
        document.getElementById('feedback-exclude').value = '';
        document.getElementById('feedback-modal').classList.remove('hidden');
    }
    
// --- 【新規】AI分析を再実行するボタン ---
    else if (e.target.matches('#run-archive-analysis-btn')) {
        e.preventDefault();
        const targetTeam = e.target.dataset.teamName;
        
        // ★ 処理を直接 runArchiveAnalysis 関数に委譲
        runArchiveAnalysis(targetTeam);
    }

    // --- フィードバックモーダルからの再生成実行ボタン ---
   else if (e.target.closest('#feedback-submit-btn')) {
        e.preventDefault();
        const feedbackSubmitBtn = e.target.closest('#feedback-submit-btn');

        if (!articleForRegeneration) return;
        const { index, article } = articleForRegeneration;
        const context = article.context; 
        
        feedbackSubmitBtn.textContent = '生成中...';
        feedbackSubmitBtn.disabled = true;
        
        const userFeedback = {
            include: document.getElementById('feedback-include').value,
            exclude: document.getElementById('feedback-exclude').value
        };
        
        document.getElementById('feedback-modal').classList.add('hidden');
        articleForRegeneration = null;
        
        // 古い記事を削除
        tournamentState.news.splice(index, 1);
        renderNews(tournamentState.news);
        
        newsContainer.innerHTML = `<div class="loader">AI記者があなたの指示を基に記事を再執筆中です...</div>`;
        
        (async () => {
            let articlePromise;
            
            // エラー記事用のフォールバックコンテキスト
            const createErrorArticle = () => ({
                title: "記事生成エラー", body: "記事の再生成に失敗しました。",
                timestamp: Date.now(), error: true,
                errorId: context.matchId || context.errorId || `regen-error-${Date.now()}`,
                context: context // 元のコンテキストを保持
            });

            if (context.isDocumentary) {
                const { type, teamName, matchData } = context;
                articlePromise = generateDocumentaryArticle('intro', type, teamName, matchData, userFeedback);
            
            } else if (context.isBracketAnalysis) {
                articlePromise = generateBracketAnalysisNewsArticle(tournamentState); 
            
            } else if (context.isKoshienNews) {
                // 甲子園ニュース
                articlePromise = generateKoshienNewsArticle(context, userFeedback);
                
            } else if (context.isCinderellaStory) {
                const { loserName, loserRank, roundNum, ...restOfContext } = context;
                articlePromise = generateCinderellaArticle(loserName, loserRank, roundNum, restOfContext);

            } else if (context.isHadaReport) {
                articlePromise = generateHadaReport(context, userFeedback);
                
            } else if (context.isTopicArticle || context.theme) {
                const rank = calculateRank(context.teamName, tournamentState); 
                articlePromise = createTopicArticle(context.teamName, rank, context.theme); 
                
            } else if (context.isAccident) {
                const { teamName, playerName, accidentType, importance } = context;
                articlePromise = generateAccidentArticle(teamName, playerName, accidentType, {}, importance);

            // ★★★ 新機能用の分岐を追加 ★★★
            } else if (context.isKoshienIntro) {
                // 代表校紹介記事の再生成
                articlePromise = generateKoshienTeamIntro(context.teamName);
                
            } else if (context.isFeatureArticle) {
                // 注目選手10選の再生成
                articlePromise = generateTopPlayersArticle();
            // ★★★ 追加ここまで ★★★

            } else {
                // 通常記事の再生成
                articlePromise = generateNewsArticle(context, userFeedback);
            }
            
            const newArticle = await articlePromise;
            
            if (newArticle && !newArticle.error) {
                newArticle.context = context; // 元のコンテキストを保持
                tournamentState.news.splice(index, 0, newArticle);
                
                // レビューモーダルを表示（甲子園系の記事は即時反映でもOKですが、統一して確認できるようにしています）
                // ※甲子園ニュース(isKoshienNews)などは即時反映したい場合、条件から除外してください
                if (!context.isBracketAnalysis && !context.isHadaReport && !context.isTopicArticle && !context.theme && !context.isCinderellaStory && !context.isAccident && !context.isKoshienNews && !context.isKoshienIntro && !context.isFeatureArticle) {
                    showArticleReviewModal(newArticle);
                }
            } else {
                tournamentState.news.splice(index, 0, createErrorArticle());
            }
            
            saveState();
            renderNews(tournamentState.news);
            feedbackSubmitBtn.textContent = 'この指示で再生成';
            feedbackSubmitBtn.disabled = false;
        })();
    }

// ▲▲▲ 置き換えここまで ▲▲▲

    // --- 試合前 応援コメントボタン（モーダルを開くだけ） ---
    if (e.target.matches('.pre-game-cheer-btn')) {
        e.preventDefault();
        const btn = e.target;
        const matchId = btn.dataset.matchId;
        const match = findMatchById(matchId);
        if (!match || !match.team1 || !match.team2) {
            alert("対戦カードが未定のため、コメントを読み込めません。");
            return;
        }
        const modal = document.getElementById('pre-game-modal');
        const titleEl = document.getElementById('pre-game-title');
        const bodyEl = document.getElementById('pre-game-body');
        const tab1 = document.getElementById('pre-game-tab-team1');
        const tab2 = document.getElementById('pre-game-tab-team2');
        titleEl.textContent = `【${match.team1} vs ${match.team2}】試合前 応援コメント`;
        tab1.textContent = `${match.team1} 応援席`;
        tab2.textContent = `${match.team2} 応援席`;
        tab1.dataset.matchId = matchId;
        tab1.dataset.teamName = match.team1;
        tab1.dataset.opponentName = match.team2;
        tab2.dataset.matchId = matchId;
        tab2.dataset.teamName = match.team2;
        tab2.dataset.opponentName = match.team1;
        tab1.classList.remove('active', 'text-blue-600', 'border-blue-600');
        tab2.classList.remove('active', 'text-blue-600', 'border-blue-600');
        tab1.classList.add('text-gray-500', 'border-transparent');
        tab2.classList.add('text-gray-500', 'border-transparent');
        bodyEl.innerHTML = `<p class="text-gray-500 text-center p-8">↑ 見たいチームの応援席タブをクリックしてください ↑</p>`;
        modal.classList.remove('hidden');
    }

    // --- 守備交代モーダル：「キャンセル」ボタン ---
    if (e.target.matches('#sub-modal-cancel')) {
        document.getElementById('substitution-modal').classList.add('hidden');
    }

    // --- 守備交代モーダル：「交代を記録」ボタン ---
    if (e.target.matches('#sub-modal-save')) {
        const modal = document.getElementById('substitution-modal');
        const matchId = modal.dataset.matchId;
        const teamKey = modal.dataset.teamKey;
        const playerName = modal.dataset.playerName;
        const match = findMatchById(matchId);
        if (!match) {
            alert("エラー: 該当の試合が見つかりません。");
            return;
        }
        const newPos = document.getElementById('sub-modal-new-pos').value;
        if (!newPos) {
            alert("「新しい守備位置」を選択してください。");
            return;
        }
        const substitutionData = {
            playerName: playerName,
            teamKey: teamKey,
            inning: document.getElementById('sub-modal-inning').value,
            topBottom: document.getElementById('sub-modal-top-bottom').value,
            timing: document.querySelector('input[name="sub-timing"]:checked').value,
            newPos: newPos,
            outs: null,
            runners: null
        };
        if (substitutionData.timing === 'mid') {
            substitutionData.outs = document.getElementById('sub-modal-outs').value;
            substitutionData.runners = {
                r1: document.getElementById('sub-modal-runner1').checked,
                r2: document.getElementById('sub-modal-runner2').checked,
                r3: document.getElementById('sub-modal-runner3').checked
            };
        }
        if (!match.details) match.details = {};
        if (!match.details.positionChanges) match.details.positionChanges = [];
        match.details.positionChanges.push(substitutionData);
        saveState();
        alert(`${substitutionData.inning}回${substitutionData.topBottom}、${playerName}選手を${newPos}に交代しました。`);
        modal.classList.add('hidden');
    }

    // --- 【詳細モーダル内】「★ 注目」ボタン（トグル） ---
    if (e.target.matches('.mark-at-bat-btn')) {
        e.preventDefault();
        const btn = e.target;
        const isMarked = btn.dataset.marked === 'true';
        if (isMarked) {
            btn.dataset.marked = 'false';
            btn.classList.remove('bg-yellow-300', 'border-yellow-500', 'text-yellow-900');
            btn.classList.add('bg-gray-100', 'border-gray-300', 'text-gray-500', 'hover:bg-gray-200');
        } else {
            btn.dataset.marked = 'true';
            btn.classList.add('bg-yellow-300', 'border-yellow-500', 'text-yellow-900');
            btn.classList.remove('bg-gray-100', 'border-gray-300', 'text-gray-500', 'hover:bg-gray-200');
        }
    }

    // --- 応援モーダル内の「チームタブ」クリック ---
    // --- 応援モーダル内の「チームタブ」クリック ---
    if (e.target.matches('.pre-game-team-tab')) {
        e.preventDefault();
        const tabBtn = e.target;
        if (tabBtn.classList.contains('active')) return;
        
        // --- タブのUI切り替え ---
        document.querySelectorAll('.pre-game-team-tab').forEach(btn => {
            btn.classList.remove('active', 'text-blue-600', 'border-blue-600');
            btn.classList.add('text-gray-500', 'border-transparent');
        });
        tabBtn.classList.add('active', 'text-blue-600', 'border-blue-600');
        tabBtn.classList.remove('text-gray-500', 'border-transparent');
        
        // --- AIに渡すための情報収集 ---
        const teamKey = tabBtn.dataset.teamKey;
        const matchId = tabBtn.dataset.matchId;
        const teamName = tabBtn.dataset.teamName;
        const opponentName = tabBtn.dataset.opponentName;
        const bodyEl = document.getElementById('pre-game-body');
        const cacheKey = `${matchId}_${teamName}`;

        // --- キャッシュチェック ---
        if (tournamentState.preGameComments[cacheKey]) {
            bodyEl.innerHTML = tournamentState.preGameComments[cacheKey];
            return;
        }

        bodyEl.innerHTML = `<div class="loader text-center py-8">${teamName} 応援団（OB, 在校生, 地元ファン）のコメントを生成中...</div>`;

        // --- ★★★ ここからが新しいコンテキスト構築 ★★★ ---
        
        const rankValues = { 'A': 10, 'B': 8, 'C': 5, 'D': 3, 'E': 2 };
        const rank = calculateRank(teamName, tournamentState);
        const opponentRank = calculateRank(opponentName, tournamentState);
        const numComments = rankValues[rank] || 2;
        
        const teamData = TEAM_DATA[teamName] || {};
        const teamRecord = tournamentState.teamRecords[teamName];
        const match = findMatchById(matchId);

        // 1. チームの動的情報 (打率、通算盗塁、過去成績など)
        const dynamicInfo = generateDynamicTeamInfo(teamName, teamData, teamRecord);

        // 2. 注目選手情報 (静的)
        const detailedData = DETAILED_TEAM_DATA[teamName] || null;

        // 3. 今大会の勝ち上がり (試合「前」の全軌跡)
        const tournamentPath = getCurrentTournamentPerformance(teamName, matchId);

        // 4. 選手個人のGamelog (今大会の成績履歴)
        // (試合前なので、スキャン対象はチーム名だけ。AIが文中の選手名を読み取る)
        const mentionedTeams = new Set([teamName]);
        const playerGamelogs = formatPlayerGamelogsForPrompt(mentionedTeams, teamName);

        // 5. 試合情報 (球場、因縁)
        const scheduleInfo = match?.schedule 
            ? `試合会場: ${match.schedule.stadiumFull} (${match.schedule.date} ${['①', '②', '③', '④'][match.schedule.game - 1]})`
            : "試合会場: 未定";
        const rivalryInfo = (match?.rivalryType || match?.feudType)
            ? `特記事項: これは「${match.rivalryType || match.feudType}」という因縁の対決です。`
            : null;

        const context = {
            name: teamName, 
            rank: rank,
            opponent: opponentName, 
            opponentRank: opponentRank,
            round: getRoundNameFromMatchId(matchId),
            path: tournamentPath,      // ★強化 (getCurrentTournamentPerformance)
            detailed: detailedData,
            info: dynamicInfo,         // ★強化 (generateDynamicTeamInfo)
            playerGamelogs: playerGamelogs, // ★新設 (Gamelog)
            schedule: scheduleInfo,    // ★新設 (会場)
            rivalry: rivalryInfo       // ★新設 (因縁)
        };
        // --- ★★★ コンテキスト構築ここまで ★★★ ---

        const comments = await generatePreGameCheerComments(context, numComments);
        let html = '';
        comments.forEach(c => {
            html += `<div class="bbs-comment"><p class="font-semibold text-gray-700 text-sm">${c.personality}</p><p class="text-gray-800 my-1 whitespace-pre-wrap">${c.comment}</p></div>`;
        });
        bodyEl.innerHTML = html;
        tournamentState.preGameComments[cacheKey] = html; // 生成結果をキャッシュ
        saveState();
    }
// ▲▲▲ 置き換えここまで ▲▲▲

    // --- フィードバックモーダルの「キャンセル」ボタン ---
    if (e.target.matches('#feedback-cancel-btn')) {
        document.getElementById('feedback-modal').classList.add('hidden');
        articleForRegeneration = null;
    }

    // --- 掲示板コメントのエラー再生成ボタン ---
    if (e.target.matches('.retry-bbs-btn')) {
        const btn = e.target;
        const index = parseInt(btn.dataset.index, 10);
        
        const targetItem = tournamentState.bbsComments[index]; 
        
        const regenType = btn.dataset.type;
        
        if (!targetItem || !targetItem.context) {
            alert("再生成に必要な情報が見つかりません。");
            return;
        }

        btn.textContent = '生成中...';
        btn.disabled = true;
        let newBbsData = null;

        try {
            if (regenType === 'bracket-thread') {
                // 組み合わせスレッドの再生成
                newBbsData = await generateBracketBbsThread(tournamentState);
            } 
            else if (regenType === 'match-comments' && targetItem.context.matchId) {
                // 試合コメントの再生成
                if (targetItem.context.winnerName && targetItem.context.dbMatch) {
                    
                    const isKoshien = tournamentState.currentTournament === 'summer_koshien';
                    const playerTeam = tournamentState.teams[0];
                    const isPlayerMatch = (targetItem.context.winnerName === playerTeam || targetItem.context.loserName === playerTeam);

                    if (isKoshien && isPlayerMatch) {
                        newBbsData = await generateKoshienBbsComments(targetItem.context);
                    } else {
                        newBbsData = await generateBbsComments(targetItem.context);
                    }

                } else {
                    throw new Error("試合後コメント再生成のためのContext情報が不足しています。");
                }
            } else {
                 throw new Error("不明な再生成タイプです: " + regenType);
            }

            if (newBbsData) {
                if (Array.isArray(newBbsData)) {
                    
                    if (targetItem.title) {
                         targetItem.comments = newBbsData.map(c => ({
                             ...c,
                             replies: []
                         }));
                         targetItem.error = false; 
                    } else {
                        tournamentState.bbsComments[index] = {
                             title: "再生成された反応",
                             comments: newBbsData,
                             context: targetItem.context,
                             timestamp: Date.now()
                        };
                    }
                } else if (!newBbsData.error) {
                     tournamentState.bbsComments[index] = newBbsData;
                } else {
                     alert('再生成に失敗しました: ' + newBbsData.body);
                     btn.textContent = '再生成';
                     btn.disabled = false;
                     return;
                }
            }
        } catch(err) {
             console.error("BBS再生成中にエラー:", err);
             alert('再生成処理中にエラーが発生しました。');
             btn.textContent = '再生成';
             btn.disabled = false;
             return;
        }
        
        renderBbsComments(tournamentState.bbsComments);
        saveState();
    }
});
// <script>タグの、他のイベントリスナーの近くに追加

document.body.addEventListener('change', (e) => {
    if (e.target.matches('#toggle-article-generation')) {
        tournamentState.settings.enableArticleGeneration = e.target.checked;
        saveState();
    }
    if (e.target.matches('#toggle-bbs-generation')) {
        tournamentState.settings.enableBbsGeneration = e.target.checked;
        saveState();
    }
// ▼▼▼ この else if ブロックをまるごと追加 ▼▼▼
    // --- 守備交代モーダルのラジオボタン ---
    else if (e.target.name === 'sub-timing') {
        const detailsDiv = document.getElementById('sub-modal-mid-inning-details');
        if (e.target.value === 'mid') {
            detailsDiv.classList.remove('hidden');
        } else {
            detailsDiv.classList.add('hidden');
        }
    }
    // ▲▲▲ 追加ここまで ▲▲▲

});



   // ==========================================================
//  2.「送信」イベントを処理するリスナー (新設)
// ==========================================================
document.body.addEventListener('submit', async (e) => {
    
    // --- 掲示板の「返信フォーム」が送信された場合 ---
    if (e.target.matches('.reply-form')) {
        e.preventDefault();
        const form = e.target;
        const parentCommentId = form.dataset.commentId;
        const bbsType = form.dataset.bbsType;
        const textarea = form.querySelector('textarea');
        const userReplyText = textarea.value;

        if (!userReplyText.trim()) return;

        form.innerHTML = `<div class="loader text-xs">AIが返信を考えています...</div>`;
        
        const commentSource = bbsType === 'general' ? tournamentState.bbsComments : tournamentState.daiyaBbsComments;
        const parentComment = findCommentById(commentSource, parentCommentId);
        const aiPersona = parentComment.personality;
        const context = { tournamentSummary: getTournamentStatusSummary() };
        
        const aiReply = await generateBbsReply(parentCommentId, userReplyText, bbsType, aiPersona, context);

        if (aiReply) {
            const freshParentComment = findCommentById(commentSource, parentCommentId);
            if (freshParentComment) {
                if (!freshParentComment.replies) {
                    freshParentComment.replies = [];
                }
                freshParentComment.replies.push(aiReply);
            }
            if (bbsType === 'general') renderBbsComments(tournamentState.bbsComments);
            else renderDaiyaBbsComments(tournamentState.daiyaBbsComments);
            saveState();
        } else {
            form.innerHTML = `<textarea class="w-full p-2 border rounded text-sm" placeholder="返信を入力..." required></textarea><button type="submit" class="mt-1 bg-blue-500 text-white px-3 py-1 text-xs rounded hover:bg-blue-600">送信</button>`;
            alert("AIが返信を生成できませんでした。");
        }
    } 
    // --- メインのコメント投稿フォームが送信された場合 ---
    else if (e.target.matches('#main-comment-form')) {
        e.preventDefault();
        const textarea = document.getElementById('main-comment-textarea');
        const userCommentText = textarea.value;
        if (!userCommentText.trim()) return;

        textarea.disabled = true;
        e.target.querySelector('button').disabled = true;
        e.target.querySelector('button').textContent = 'AIが返信中...';

        const userComment = {
            id: crypto.randomUUID(),
            personality: 'あなた',
            text: userCommentText,
            timestamp: Date.now(),
            replies: []
        };
        
        const aiReplies = await generateMultipleReplies(userCommentText);
        userComment.replies = aiReplies;

        tournamentState.bbsComments.push(userComment);
        renderBbsComments(tournamentState.bbsComments);
        saveState();

        textarea.value = '';
        textarea.disabled = false;
        e.target.querySelector('button').disabled = false;
        e.target.querySelector('button').textContent = '投稿する';
    }

}); // ★★★ 閉じカッコ } の正しい位置はここです ★★★

// --- 編集モーダルの「この記事で確定」ボタン ---
    document.getElementById('review-save-btn').addEventListener('click', () => {
        if (articleForReview) {
            // テキストボックスの現在の内容で記事データを更新
            articleForReview.title = document.getElementById('review-title').value;
            articleForReview.body = document.getElementById('review-body').value.replace(/\n/g, '\\n');
            
            // 更新した記事をニュースリストに追加
            tournamentState.news.push(articleForReview);
            renderNews(tournamentState.news);
            saveState();
            
            closeReviewModal();
        }
    });

    // --- 編集モーダルの「キャンセル」ボタン ---
    document.getElementById('review-cancel-btn').addEventListener('click', () => {
        closeReviewModal();
    });

document.body.addEventListener('input', (e) => {
        if (e.target.matches('.match-summary-input')) {
            const matchId = e.target.dataset.matchId;
            let match;
            if (tournamentState.matches[matchId]) {
                match = tournamentState.matches[matchId];
            } else {
                 const [region, bracketId] = matchId.split('-');
                 if (tournamentState.autumnData?.regions[region]) {
                    const regionData = tournamentState.autumnData.regions[region];
                    if(bracketId.startsWith('B')) match = regionData.blocks.find(b=>b.id === `${region}-${bracketId}`).matches[matchId];
                    else if(bracketId === 'CHAMP') match = regionData.champBracket.matches[matchId];
                    else if(bracketId === 'REP') match = regionData.repechageBracket.matches[matchId];
                 }
            }
            if (match) {
                match.summary = e.target.value;
                saveState();
            }
        }

// ▼▼▼ この else if ブロックをまるごと追加 ▼▼▼
    // --- 試合前の雰囲気/公約 ---
    else if (e.target.matches('.team-atmosphere-input')) {
        const matchId = e.target.dataset.matchId;
        const teamKey = e.target.dataset.teamKey; // 'team1' or 'team2'
        const match = findMatchById(matchId);

        if (match) {
            // 'atmosphere_team1' または 'atmosphere_team2' というキーで保存
            match[`atmosphere_${teamKey}`] = e.target.value;
            saveState(); // 入力するたびに自動保存
        }
    }
    // ▲▲▲ 追加ここまで ▲▲▲

// --- ★ 283学園の選手名自動入力 (＆ 調子アイコンの動的更新) ---
        else if (e.target.matches('.player-name')) {
            const input = e.target;
            const playerName = input.value.trim();
            const row = input.closest('tr');
            const table = input.closest('.batting-table');
            if (!row || !table || !currentMatchIdForDetails) return;

            const match = findMatchById(currentMatchIdForDetails);
            if (!match) return;

            const teamKey = table.id.includes('team1') ? 'team1' : 'team2';
            const teamName = match[teamKey];
            
          // --- 1. 選手名簿(Roster)からの自動入力 ---
            const roster = TEAM_ROSTER_MASTER[teamName];
            if (roster) {
                const playerData = roster.find(p => p.name === playerName);
                if (playerData) {
                    const numberSelect = row.querySelector('.player-number');
                    const throwBatSelect = row.querySelector('.player-throw-bat');
                    if (numberSelect) numberSelect.value = playerData.number;
                    if (throwBatSelect) throwBatSelect.value = playerData.throwBat;

                    // ▼▼▼ ここに追加: キャプテンの自動反映 ▼▼▼
                    const captainBtn = row.querySelector('.captain-btn');
                    if (captainBtn) {
                        if (playerData.isCaptain) {
                            // 1. 同じチーム(テーブル)内の他のキャプテンを全て解除
                            const table = row.closest('table');
                            if (table) {
                                table.querySelectorAll('.captain-btn.active').forEach(btn => btn.classList.remove('active'));
                            }
                            // 2. この選手のボタンをONにする
                            captainBtn.classList.add('active');
                        } else {
                            // キャプテンじゃない選手名に変えた場合、OFFにする
                            captainBtn.classList.remove('active');
                        }
                    }
                    // ▲▲▲ 追加ここまで ▲▲▲
                }
            }

            // --- 2. 調子アイコンの動的更新 (全チーム共通) ---
            const teamRecord = tournamentState.teamRecords[teamName];
            let conditionIconHTML = ""; // デフォルトは空
            
            if (playerName && teamRecord?.playerStats?.batting[playerName]) {
                // 打撃の調子を取得
                const flag = teamRecord.playerStats.batting[playerName].narrative_flag;
                conditionIconHTML = getPlayerConditionIcon(flag);
            } else if (playerName && teamRecord?.playerStats?.pitching[playerName]) {
                // 投手（野手で打席に立ってない場合）の調子を取得
                const flag = teamRecord.playerStats.pitching[playerName].narrative_flag;
                conditionIconHTML = getPlayerConditionIcon(flag);
            }

            // 3. アイコンをHTMLに挿入/置換
            const container = input.parentElement;
            let iconSpan = container.querySelector('.condition-icon');
            
            if (conditionIconHTML) { // 新しいアイコンがある場合
                if (iconSpan) {
                    // 既存のアイコンを置き換え
                    iconSpan.outerHTML = conditionIconHTML;
                } else {
                    // 新しくアイコンを挿入 (📊ボタンの前に)
                    const statsBtn = container.querySelector('.show-player-stats-btn');
                    if (statsBtn) {
                        statsBtn.insertAdjacentHTML('beforebegin', conditionIconHTML);
                    }
                }
            } else if (iconSpan) {
                // 新しいアイコンがなく、古いアイコンが残っている場合は削除
                iconSpan.remove();
            }
        }
// ▲▲▲ 置き換えここまで ▲▲▲


// イニングスコアが入力された場合
    else if (e.target.closest('#inning-score-table')) {
        updateTotalScores();
    }


    
// ▼▼▼ THIS IS THE NEW BLOCK TO ADD ▼▼▼
    // --- When an "Inning Event" is typed in ---
    else if (e.target.matches('.inning-events-input')) {
        const teamKey = e.target.dataset.teamKey;
        const inningIndex = parseInt(e.target.dataset.inningIndex, 10);
        if (inningIndex >= 0) {
            updateInningState(teamKey, inningIndex); // Instantly update the out count
        }
    }
    // ▲▲▲ END OF ADDITION ▲▲▲
});
// ==========================================================
//  プルダウン変更イベントの監視 (change)
// ==========================================================
document.body.addEventListener('change', (e) => {
    // --- 打席結果プルダウンが変更された場合 ---
    if (e.target.matches('.batting-result-part')) {
        const cell = e.target.closest('td.batting-result-cell');
        if (!cell) return;
        
        const inningIndex = Array.from(cell.parentElement.children).indexOf(cell) - 5;
        const teamKey = e.target.closest('table.batting-table').id.includes('team1') ? 'team1' : 'team2';
        
        if (inningIndex >= 0) {
            updateInningState(teamKey, inningIndex); // 即座にアウトカウントを更新
        }
    }
});

    modalBg.addEventListener('click', () => newsModal.classList.add('hidden'));
    modalClose.addEventListener('click', () => newsModal.classList.add('hidden'));
    document.getElementById('details-save').addEventListener('click', saveDetailedStats);
    document.getElementById('details-close').addEventListener('click', () => detailsModal.classList.add('hidden'));
    saveLoadCloseBtn.addEventListener('click', () => saveLoadModal.classList.add('hidden'));
    newspaperCloseBtn.addEventListener('click', () => newspaperModal.classList.add('hidden'));
document.getElementById('skip-newspaper-close-btn').addEventListener('click', closeSkipNewspaper);
// ▼▼▼ この2行を 10953行目 の直後に追加 ▼▼▼
    const preGameModalClose = document.getElementById('pre-game-modal-close');
    if (preGameModalClose) preGameModalClose.addEventListener('click', () => document.getElementById('pre-game-modal').classList.add('hidden'));
    // ▲▲▲ 追加ここまで ▲▲▲
document.getElementById('status-modal-close').addEventListener('click', () => {
    document.getElementById('team-status-modal').classList.add('hidden');
});

    saveTabBtn.addEventListener('click', () => {
        saveTabBtn.classList.add('border-blue-500'); saveTabBtn.classList.remove('text-gray-500');
        loadTabBtn.classList.remove('border-blue-500'); loadTabBtn.classList.add('text-gray-500');
        saveTabContent.classList.remove('hidden'); loadTabContent.classList.add('hidden');
    });
    loadTabBtn.addEventListener('click', () => {
        loadTabBtn.classList.add('border-blue-500'); loadTabBtn.classList.remove('text-gray-500');
        saveTabBtn.classList.remove('border-blue-500'); saveTabBtn.classList.add('text-gray-500');
        loadTabContent.classList.remove('hidden'); saveTabContent.classList.add('hidden');
    });
    generateSaveCodeBtn.addEventListener('click', () => {
        const jsonString = JSON.stringify(tournamentState);
        const compressed = pako.deflate(jsonString);
        const base64 = uint8ArrayToBase64(compressed);
        document.getElementById('save-code-output').textContent = base64;
        document.getElementById('save-code-area').classList.remove('hidden');
    });
    copySaveCodeBtn.addEventListener('click', () => {
        navigator.clipboard.writeText(document.getElementById('save-code-output').textContent);
        const feedback = document.getElementById('copy-feedback');
        feedback.textContent = 'コピーしました！';
        setTimeout(() => { feedback.textContent = '' }, 2000);
    });
    loadFromCodeBtn.addEventListener('click', () => {
        try {
            const code = document.getElementById('load-code-input').value;
            const binaryString = atob(code);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) { bytes[i] = binaryString.charCodeAt(i); }
            const decompressed = pako.inflate(bytes, { to: 'string' });
            const loadedState = JSON.parse(decompressed);
            tournamentState = loadedState;
            saveState();
            location.reload();
        } catch (e) {
            showAlert('データの読み込みに失敗しました。');
        }
    });

let activeScorecardState = {};

/**
 * 簡易入力モーダルを開き、状態を初期化する
 * (★打球方向・打点・走塁入力ステップを追加)
 */
async function openScorecardModal(matchId) {
    const match = findMatchById(matchId);
    if (!match || !match.team1 || !match.team2) {
        alert("チームが設定されていません。");
        return;
    }

    // 1. 状態(State)の初期化
    activeScorecardState = {
        matchId: matchId,
        team1: match.team1,
        team2: match.team2,
        inning: 1,      // 現在のイニング (1始まり)
        topBottom: '表', // '表' or '裏'
        outs: 0,
        score: { team1: 0, team2: 0 },
        runners: [null, null, null], // [1B, 2B, 3B] (中身は選手名)
        battingOrder: { team1: [], team2: [] },
        batterIndex: { team1: 0, team2: 0 },
        playLog: [], // { teamKey, batterName, resultString, ... }
        
        // ★★★ ここからが修正箇所 ★★★
        currentStep: "waiting_for_result", // "waiting_for_result", "waiting_for_direction", "waiting_for_rbi", "waiting_for_runner_sb", "waiting_for_runner_cs"
        pendingPlay: { // ユーザーの入力を一時的に保持
            type: null,    // "安", "ゴロ", "三振" など
            bases: 0,    // 1, 2, 3, 4
            outs: 0,
            walk: false,
            direction: null, // "遊", "中", "投"
            rbi: 0       // 0, 1, 2, 3, 4
        }
        // ★★★ 修正ここまで ★★★
    };

    // 2. 両チームの打順を取得
    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const roster = TEAM_ROSTER_MASTER[teamName];
        if (roster) {
            activeScorecardState.battingOrder[teamKey] = roster.slice(0, 9).map(p => p.name);
        } else {
            // 2-2. 他チームなら仮の名前を9人分作成
            activeScorecardState.battingOrder[teamKey] = Array.from({length: 9}, (_, i) => `${teamName.slice(0, 3)} ${i+1}番`);
        }
    }

    // 3. モーダルを表示
    document.getElementById('scorecard-modal').classList.remove('hidden');
    document.getElementById('scorecard-modal').classList.add('flex');
    
    // 4. UIを初期状態に描画
    renderScorecard();
}
// ▲▲▲ 置き換えここまで ▲▲▲

/**
 * 簡易入力モーダルのUIを、現在の `activeScorecardState` に基づいて更新する
 * (★全入力ステップの表示切り替えを追加)
 */
function renderScorecard() {
    const state = activeScorecardState;
    
    // 1. ヘッダー
    document.getElementById('scorecard-inning').textContent = `${state.inning}回${state.topBottom}`;
    document.getElementById('scorecard-team1').textContent = `${state.team1}: ${state.score.team1}`;
    document.getElementById('scorecard-team2').textContent = `${state.team2}: ${state.score.team2}`;
    
    // 2. アウトカウント
    const outsEl = document.getElementById('scorecard-outs');
    outsEl.innerHTML = `
        <span class="${state.outs >= 1 ? 'text-red-500' : 'text-gray-400'}">●</span>
        <span class="${state.outs >= 2 ? 'text-red-500' : 'text-gray-400'}">●</span>
        <span class="${state.outs >= 3 ? 'text-red-500' : 'text-gray-400'}">●</span>
    `;

    // 3. ランナー
    document.getElementById('base-1b').classList.toggle('runner', !!state.runners[0]);
    document.getElementById('base-2b').classList.toggle('runner', !!state.runners[1]);
    document.getElementById('base-3b').classList.toggle('runner', !!state.runners[2]);

    // ★★★ ここからが修正箇所 ★★★
    // 4. 現在の打者 と 入力ステップ
    const currentTeamKey = state.topBottom === '表' ? 'team1' : 'team2';
    const currentBatterIndex = state.batterIndex[currentTeamKey];
    const currentBatterName = state.battingOrder[currentTeamKey][currentBatterIndex];
    const batterNameEl = document.getElementById('scorecard-batter-name');
    const diamondEl = document.querySelector('.baseball-diamond');
    const resultPanel = document.getElementById('scorecard-result-panel');
    const rbiPanel = document.getElementById('scorecard-rbi-panel');

    // 全ての特殊モードをリセット
    diamondEl.classList.remove('direction-mode', 'runner-select-mode');
    resultPanel.classList.add('hidden');
    rbiPanel.classList.add('hidden');

    if (state.currentStep === "waiting_for_direction") {
        batterNameEl.textContent = `(${currentBatterIndex + 1}) ${currentBatterName} - STEP 2: 打球方向を選択`;
        diamondEl.classList.add('direction-mode'); // ホットスポット表示
    } else if (state.currentStep === "waiting_for_rbi") {
        batterNameEl.textContent = `(${currentBatterIndex + 1}) ${currentBatterName} - STEP 3: 打点 / アウト`;
        rbiPanel.classList.remove('hidden'); // RBIボタン表示
    } else if (state.currentStep === "waiting_for_runner_sb") {
        batterNameEl.textContent = `[走塁] 盗塁したランナーを選択...`;
        diamondEl.classList.add('runner-select-mode'); // ランナー点滅
    } else if (state.currentStep === "waiting_for_runner_cs") {
        batterNameEl.textContent = `[走塁] 盗塁死したランナーを選択...`;
        diamondEl.classList.add('runner-select-mode');
    } else if (state.currentStep === "waiting_for_runner_out") {
        batterNameEl.textContent = `[走塁] 走塁死したランナーを選択...`;
        diamondEl.classList.add('runner-select-mode');
    } else {
        // (C) "waiting_for_result"
        batterNameEl.textContent = `(${currentBatterIndex + 1}) ${currentBatterName} - STEP 1: 打席結果を選択`;
        resultPanel.classList.remove('hidden'); // 結果ボタン表示
    }
    // ★★★ 修正ここまで ★★★

    // 5. ログ
    const logContent = document.getElementById('scorecard-log-content');
    logContent.innerHTML = state.playLog.map(log => 
        `[${log.inning}${log.topBottom}] ${log.batterName}: ${log.resultString} (${log.outs}アウト)`
    ).join('<br>');
    logContent.scrollTop = logContent.scrollHeight;
}
// ▲▲▲ 置き換えここまで ▲▲▲


// ▼▼▼ 既存の「handleScorecardAction」と「saveScorecardAndClose」 (18510行目〜) を、
// ▼▼▼ 以下の3つの関数で「まるごと置き換え」 ▼▼▼

// ▼▼▼ 既存の「handleScorecardAction」と「processPlay」 (18510行目〜) を、
// ▼▼▼ 以下の2つの関数で「まるごと置き換え」 ▼▼▼

// ▼▼▼ 既存の「handleScorecardAction」と「processPlay」 (18510行目〜) を、
// ▼▼▼ 以下の2つの関数で「まるごと置き換え」 ▼▼▼

/**
 * [改修] 簡易入力モーダルの「結果」ボタンクリックを処理する
 * (★併殺・犠打・犠飛をSTEP 1に統合)
 * @param {string} action - 'hit-1b', 'out-dp', 'run-sb' など
 */
function handleScorecardAction(action) {
    const state = activeScorecardState;
    if (state.outs >= 3) return; // 3アウトなら操作不可

    // --- A. 打席結果の入力 ---
    if (state.currentStep === "waiting_for_result" && action.startsWith('run-') === false) {
        state.pendingPlay = { type: null, bases: 0, outs: 0, walk: false, direction: null, rbi: 0 };
        let needsDirection = true;
        let nextStep = "waiting_for_direction"; // デフォルトは方向入力

        switch (action) {
            // ヒット系
            case 'hit-1b': state.pendingPlay.type = '安'; state.pendingPlay.bases = 1; break;
            case 'hit-2b': state.pendingPlay.type = '二塁打'; state.pendingPlay.bases = 2; break;
            case 'hit-3b': state.pendingPlay.type = '三塁打'; state.pendingPlay.bases = 3; break;
            case 'hit-hr': state.pendingPlay.type = '本塁打'; state.pendingPlay.bases = 4; needsDirection = false; nextStep = "waiting_for_rbi"; break;
            // 四死球
            case 'walk-bb': state.pendingPlay.type = '四球'; state.pendingPlay.bases = 1; state.pendingPlay.walk = true; needsDirection = false; nextStep = "waiting_for_rbi"; break;
            case 'walk-hbp': state.pendingPlay.type = '死球'; state.pendingPlay.bases = 1; state.pendingPlay.walk = true; needsDirection = false; nextStep = "waiting_for_rbi"; break;
            // アウト系
            case 'out-k': state.pendingPlay.type = '三振'; state.pendingPlay.outs = 1; needsDirection = false; nextStep = "process_play"; break; // ★打点なし・方向なし
            case 'out-go': state.pendingPlay.type = 'ゴロ'; state.pendingPlay.outs = 1; break;
            case 'out-fo': state.pendingPlay.type = '飛'; state.pendingPlay.outs = 1; break;
            // ★★★ 修正箇所 ★★★
            case 'out-dp': state.pendingPlay.type = '併殺'; state.pendingPlay.outs = 2; break; // ★STEP 2 (方向) -> STEP 3 (打点/0点) へ
            case 'out-sac-b': state.pendingPlay.type = '犠打'; state.pendingPlay.outs = 1; break; // ★STEP 2 (方向) -> STEP 3 (打点/0点) へ
            case 'out-sac-f': state.pendingPlay.type = '犠飛'; state.pendingPlay.outs = 1; break; // ★STEP 2 (方向) -> STEP 3 (打点/1点) へ
            // ★★★ 修正ここまで ★★★
            // その他
            case 'other-error': state.pendingPlay.type = 'エラー'; state.pendingPlay.bases = 1; break;
            case 'other-fc': state.pendingPlay.type = '野選'; state.pendingPlay.bases = 1; break;
            
            default: return;
        }

        // 2. 次のステップを判断
        if (nextStep === "process_play") {
            // 三振など、即時処理
            state.pendingPlay.direction = "投"; // 仮の方向
            processPlay();
        } else if (needsDirection) {
            state.currentStep = "waiting_for_direction";
        } else {
            state.pendingPlay.direction = "投"; // 仮の方向
            state.currentStep = "waiting_for_rbi";
        }
    }
    // --- B. 走塁プレーの入力 ---
    else if (state.currentStep === "waiting_for_result" && action.startsWith('run-')) {
        if (action === 'run-sb') { // 盗塁
            if (state.runners[0] === null && state.runners[1] === null) { alert("盗塁できるランナーがいません。"); return; }
            state.currentStep = "waiting_for_runner_sb";
        }
        else if (action === 'run-cs') { // 盗塁死
            if (state.runners[0] === null && state.runners[1] === null) { alert("盗塁できるランナーがいません。"); return; }
            state.currentStep = "waiting_for_runner_cs";
        }
        else if (action === 'run-other-out') { // 走塁死
            if (state.runners.every(r => r === null)) { alert("ランナーがいません。"); return; }
            state.currentStep = "waiting_for_runner_out";
        }
    }
    
    renderScorecard(); // UIを更新
}

/**
 * [改修・完全版] プレーを確定し、ゲームステートを更新する
 * (★詳細入力と互換性のある文字列フォーマットで保存)
 */
function processPlay() {
    const state = activeScorecardState;
    if (!state.pendingPlay.type) return;

    let { type, bases, outs, walk, direction, rbi } = state.pendingPlay;
    const currentTeamKey = state.topBottom === '表' ? 'team1' : 'team2';
    const currentBatterIndex = state.batterIndex[currentTeamKey];
    const currentBatterName = state.battingOrder[currentTeamKey][currentBatterIndex];

    // 1. 打点入力による最終決定
    if (state.currentStep === "waiting_for_rbi") {
        rbi = (rbi === 'dp' || rbi === 'sf' || rbi === 'sh') ? 0 : parseInt(rbi, 10);
        // 併殺・犠飛・犠打の打点は別途計算（rbi変数は選択肢のIDとして使われているためリセット）
        if (state.pendingPlay.rbi === 'sf') rbi = 1; // 犠飛はデフォルト1点（選択肢がない場合）
        // ※今回のUIでは「[1点]」ボタンを押させるので、parseInt(rbi) で正しい点数が入る
    }

    // 2. アウトカウントを加算
    state.outs += outs;

    // 3. ランナーを進塁
    let scoreThisPlay = 0;
    const newRunners = [null, null, null];
    
    if (bases === 4) { // ホームラン
        if (state.runners[2]) scoreThisPlay++;
        if (state.runners[1]) scoreThisPlay++;
        if (state.runners[0]) scoreThisPlay++;
        state.runners = [null, null, null];
        scoreThisPlay += 1; // 打者生還
    } else if (walk) { // 四死球
        if (state.runners[0] && state.runners[1] && state.runners[2]) { // 押し出し
            scoreThisPlay = (rbi > 0 ? rbi : 1);
        } else {
            if (state.runners[0] && state.runners[1]) newRunners[2] = state.runners[1];
            if (state.runners[0]) newRunners[1] = state.runners[0];
            newRunners[0] = currentBatterName;
        }
    } else if (bases > 0) { // ヒット、エラー、野選
        scoreThisPlay = rbi; // 打点をそのまま加算（簡易シミュ）
        if (state.runners[0]) newRunners[bases] = state.runners[0]; // 簡易的に押し出し
        newRunners[bases - 1] = currentBatterName;
    } else if (type === '犠飛' || type === 'ゴロ' || type === '併殺') {
        scoreThisPlay = rbi;
        // 簡易: 犠飛なら3塁ランナー生還とみなす
        if (rbi > 0 && state.runners[2]) state.runners[2] = null;
    } else if (type === '犠打') {
        // 簡易: ランナーを進める
        if (state.runners[1]) newRunners[2] = state.runners[1];
        if (state.runners[0]) newRunners[1] = state.runners[0];
    } else {
        // その他（三振など）はランナー動かず
        state.runners.forEach((r, i) => newRunners[i] = r);
    }
    
    state.runners = newRunners;
    state.score[currentTeamKey] += scoreThisPlay;

    // 4. ログ（詳細入力互換フォーマット）を生成
    // ★方向 + 結果 (例: "中安", "遊ゴ")
    let resultString = direction ? direction + type : type;
    
    // ★点数 (例: "中安2点")
    if (scoreThisPlay > 0 && type !== '本塁打') {
        resultString += `${scoreThisPlay}点`;
    } else if (type === '本塁打' && scoreThisPlay > 0) {
         // 本塁打は点数を含めないのが一般的だが、詳細入力のパースに合わせておく
         // (詳細入力は "右本" だけで打点を自動計算しないため、明示的に点数を入れるか、パース側で対応が必要)
         // ここでは念のため点数を入れておく
         resultString += `${scoreThisPlay}点`;
    }

    state.playLog.push({
        inning: state.inning,
        topBottom: state.topBottom,
        batterName: currentBatterName,
        batterOrder: (currentBatterIndex + 1).toString(),
        resultString: resultString,
        outs: state.outs
    });

    // 5. 次の打者へ
    state.batterIndex[currentTeamKey] = (currentBatterIndex + 1) % state.battingOrder[currentTeamKey].length;

    // 6. 3アウトチェンジ
    if (state.outs >= 3) {
        if (state.topBottom === '表') {
            state.topBottom = '裏';
        } else {
            state.topBottom = '表';
            state.inning++;
        }
        state.outs = 0;
        state.runners = [null, null, null];
    }
    
    // 7. 状態リセット
    state.currentStep = "waiting_for_result";
    state.pendingPlay = {};
    
    renderScorecard();
}

// ▲▲▲ 置き換えここまで ▲▲▲
// ▼▼▼ 既存の「saveScorecardAndClose」 (18610行目〜) を、以下で「置き換え」 ▼▼▼

/**
 * [改修・完全版] 簡易入力のデータを「詳細入力」の形式に変換・保存・集計する
 * (★dbMatch未定義エラーを修正)
 */
function saveScorecardAndClose() {
    const state = activeScorecardState;
    const match = findMatchById(state.matchId);
    if (!match) return;

    // 1. 新しい `details` オブジェクトを準備
    const numInnings = Math.max(9, state.inning);
    const details = { 
        inningScore: { team1: Array(numInnings).fill(0), team2: Array(numInnings).fill(0) }, 
        batting: { team1: [], team2: [] }, 
        pitching: { team1: [], team2: [] }, 
        fielding: { team1: [], team2: [] }, 
        playerGameStats: { team1: {}, team2: {} },
        positionChanges: []
    };

    // 2. 打順リストを details.batting に変換 (初期化)
    for (const teamKey of ['team1', 'team2']) {
        details.batting[teamKey] = state.battingOrder[teamKey].map((name, index) => ({
            order: (index + 1).toString(),
            name: name,
            number: '', pos: '', throwBat: '', sub_type: null,
            results: Array(numInnings).fill('') 
        }));
    }

    // 3. プレーログ(playLog)を解析してデータを注入
    state.playLog.forEach(log => {
        const inningIndex = log.inning - 1;
        const teamKey = log.topBottom === '表' ? 'team1' : 'team2';
        
        // A. イニングスコアの更新
        const rbiMatch = log.resultString.match(/(\d+)点/);
        if (rbiMatch) {
            details.inningScore[teamKey][inningIndex] += parseInt(rbiMatch[1], 10);
        } else if (log.resultString.includes('本塁打')) {
            if (!log.resultString.includes('点')) details.inningScore[teamKey][inningIndex] += 1;
        }
        if (log.resultString.includes('生還') || log.resultString.includes('ホームイン')) {
             if (!log.resultString.includes('点') && !log.resultString.includes('本塁打')) {
                 details.inningScore[teamKey][inningIndex] += 1;
             }
        }

        // B. 打席結果の格納
        if (log.batterOrder === '-') {
            // 走塁プレー
            const teamBatters = details.batting[teamKey];
            let targetBatter = null;
            for (let i = teamBatters.length - 1; i >= 0; i--) {
                if (teamBatters[i].results[inningIndex]) {
                    targetBatter = teamBatters[i];
                    break;
                }
            }
            if (targetBatter) {
                let currentRes = targetBatter.results[inningIndex];
                if (!currentRes.includes(';')) {
                    targetBatter.results[inningIndex] += `; ${log.resultString}`;
                } else {
                    targetBatter.results[inningIndex] += `, ${log.resultString}`;
                }
            }
        } else {
            // 打撃プレー
            const batter = details.batting[teamKey].find(p => p.order === log.batterOrder);
            if (batter) {
                if (batter.results[inningIndex]) {
                    batter.results[inningIndex] += `、${log.resultString}`;
                } else {
                    batter.results[inningIndex] = log.resultString;
                }
            }
        }
    });
    
    // 4. スコアの保存
    match.score1 = details.inningScore.team1.reduce((sum, s) => sum + s, 0);
    match.score2 = details.inningScore.team2.reduce((sum, s) => sum + s, 0);

    // 5. コールド判定 (イニング数に基づく)
    const lastInning = state.inning;
    if (lastInning < 9 && (Math.abs(match.score1 - match.score2) >= 7)) {
         match.calledGame = true;
         match.calledInning = lastInning;
    }

    // 6. match.details を更新
    match.details = details;

    // 7. 通算成績の集計を実行
    updatePlayerStatsFromDetails(match);
    
    // 8. ボックススコアHTML生成 
    match.boxScoreHtml = generateBoxScoreHTML(match);

    // 9. 保存して閉じる
    saveState();
    document.getElementById('scorecard-modal').classList.add('hidden');
    document.getElementById('scorecard-modal').classList.remove('flex');
    activeScorecardState = {}; 
    
    renderTournament(tournamentState);
    alert("試合経過を保存し、詳細データに反映しました。");
}

/**
 * [NEW] リアルタイム・ナラティブ更新
 * 試合直後、劇的な勝利（ジャイアントキリング等）を挙げたチームのinfoを即座に書き換える
 */
async function updateNarrativeImmediate(winnerName, loserName, matchContext) {
    const winnerRank = calculateRank(winnerName, tournamentState);
    const loserRank = calculateRank(loserName, tournamentState);
    const rankValues = { 'A': 5, 'B': 4, 'C': 3, 'D': 2, 'E': 1 };
    
    // 更新条件: 格上撃破（ランク差2以上） または Eランクが勝利
    const isGiantKilling = (rankValues[loserRank] - rankValues[winnerRank]) >= 2;
    const isCinderella = (winnerRank === 'E' || winnerRank === 'D') && ['A', 'B'].includes(loserRank);

    // 通常の勝利では更新しない（API節約と、特別感を出すため）
    if (!isGiantKilling && !isCinderella) return;

    const originalInfo = TEAM_DATA[winnerName].info;
    const roundName = getRoundNameFromMatchId(matchContext.matchId);
    const score = `${matchContext.dbMatch.score1}-${matchContext.dbMatch.score2}`;

    // ニュース欄に更新通知を出す演出
    const newsContainer = document.getElementById('news-articles');
    const notifyEl = document.createElement('div');
    notifyEl.className = "bg-blue-50 p-3 rounded border border-blue-200 text-blue-800 text-sm mb-2 animate-pulse";
    notifyEl.innerHTML = `🔄 <strong>${winnerName}</strong>の評価が急上昇しています...（紹介文更新中）`;
    if(newsContainer) newsContainer.prepend(notifyEl);

    const prompt = `あなたは高校野球のデータ担当者です。
今しがた行われた試合で、以下の劇的な勝利がありました。
この結果を反映して、**勝利チーム「${winnerName}」のチーム紹介文（info）**を、即座に書き換えてください。

### 状況
- **チーム:** ${winnerName} (元の評価: ${winnerRank}ランク)
- **対戦相手:** ${loserName} (元の評価: ${loserRank}ランク)
- **結果:** ${roundName}にて、${score} で勝利
- **これまでの紹介文:** "${originalInfo}"

### 指示
- 元の特徴（地域や学校の特色）を残しつつ、「強豪${loserName}を撃破した」という最新の実績を強調した文章にしてください。
- 「一躍、今大会の台風の目となった」「旋風を巻き起こしている」といった、勢いを感じさせる表現を使ってください。
- 100文字以内。

### 出力形式 (JSON)
{"newInfo": "（新しい紹介文）"}`;

    try {
        const response = await fetchWithRetry({ contents: [{ role: "user", parts: [{ text: prompt }] }] });
        const result = await response.json();
        if (result.candidates?.[0]?.content?.parts?.[0]) {
            const json = parseJsonFromText(result.candidates[0].content.parts[0].text);
            if (json && json.newInfo) {
                console.log(`[Realtime Update] ${winnerName}: ${json.newInfo}`);
                
                // ★データを即座に上書き
                TEAM_DATA[winnerName].info = json.newInfo;
                
                // 通知を更新
                notifyEl.classList.remove('animate-pulse', 'bg-blue-50', 'border-blue-200', 'text-blue-800');
                notifyEl.classList.add('bg-green-50', 'border-green-200', 'text-green-800');
                notifyEl.innerHTML = `✅ <strong>${winnerName}</strong>のチーム紹介文が「${roundName}突破仕様」に更新されました！`;
                setTimeout(() => notifyEl.remove(), 5000);
            }
        }
    } catch (e) {
        console.error("ナラティブ更新エラー", e);
        notifyEl.remove();
    }
}

/**
 * [NEW] 試合の詳細データ(details)を基に、チームと個人の通算成績を更新する
 * (saveDetailedStats と saveScorecardAndClose で共有するロジック)
 */
function updatePlayerStatsFromDetails(match) {
    const details = match.details;
    if (!details || !details.batting) return;

    // 成績リセット処理は呼び出し元で行う前提

    for (const teamKey of ['team1', 'team2']) {
        const teamName = match[teamKey];
        const teamRecord = tournamentState.teamRecords[teamName];
        if (!teamRecord) continue;

        if (!teamRecord.playerStats) teamRecord.playerStats = { batting: {}, pitching: {} };
        if (!teamRecord.tournamentStats) teamRecord.tournamentStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0 };

        const playersAppearedThisGame = new Set();
        const battingData = details.batting[teamKey] || [];
        const playerGameStats = {}; // この試合の集計結果を一時保存

        // --- A. 打撃成績の集計 ---
        battingData.forEach(playerData => {
            const playerName = playerData.name;
            if (!playerName) return;

            // 初期化
            if (!teamRecord.playerStats.batting[playerName]) {
                teamRecord.playerStats.batting[playerName] = { games: 0, pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0, gamelogs: [] };
            }
            const careerStats = teamRecord.playerStats.batting[playerName];
            const gameStats = { pa: 0, ab: 0, h: 0, hr: 0, rbi: 0, sb: 0, bb: 0, hbp: 0, sf: 0, tb: 0, r: 0, so: 0, played: false, strongHits: 0, weakHits: 0, strongOuts: 0, weakOuts: 0 };

            // 打席結果の解析
            playerData.results.forEach(inningResultString => {
                (inningResultString || '').split('、').forEach(atBatString => {
                    if (!atBatString) return;
                    const [batterPlay, runnerPlaysString] = atBatString.split(';');
                    
                    // 打者プレー
                    if (batterPlay && batterPlay.trim() !== '') {
                        let clean = batterPlay.trim().replace(/^★:/, '').replace(/^[SW]:/, '');
                        
                        gameStats.played = true; gameStats.pa++;
                        
                        const isHit = BATTING_RESULTS.hits.some(h => clean.includes(h));
                        const isWalk = ['四球', '死球', '敬遠'].some(w => clean.includes(w));
                        const isSac = ['犠飛', '犠打', '犠失'].some(w => clean.includes(w));
                        const isOut = BATTING_RESULTS.outs.some(o => clean.includes(o));

                        if (!isWalk && !isSac && !clean.includes('妨害')) { gameStats.ab++; }
                        
                        if (clean.includes('四球') || clean.includes('敬遠')) gameStats.bb++;
                        if (clean.includes('死球')) gameStats.hbp++;
                        if (clean.includes('犠飛')) gameStats.sf++;

                        if (clean.includes('本塁打')) { gameStats.h++; gameStats.tb += 4; gameStats.hr++; }
                        else if (clean.includes('三塁打')) { gameStats.h++; gameStats.tb += 3; }
                        else if (clean.includes('二塁打')) { gameStats.h++; gameStats.tb += 2; }
                        else if (clean.includes('安')) { gameStats.h++; gameStats.tb += 1; }

                        if (clean.includes('点')) { 
                            const rbiValue = (clean.match(/(\d+)点/) || [0, 0])[1];
                            gameStats.rbi += parseInt(rbiValue, 10);
                        }
                        if (clean.includes('三振')) gameStats.so++;
                        
                        // 勢い集計 (AI用)
                        if (batterPlay.startsWith('S:')) { if(isHit) gameStats.strongHits++; if(isOut) gameStats.strongOuts++; }
                        if (batterPlay.startsWith('W:')) { if(isHit) gameStats.weakHits++; if(isOut) gameStats.weakOuts++; }
                    }

                    // 走塁プレー
                    (runnerPlaysString || '').split(',').forEach(runnerPlay => {
                        const parts = runnerPlay.trim().split(' ');
                        // フォーマット: [選手名, プレー, 詳細]
                        // ここではplayerData.nameと一致する場合のみ集計（またはrunnerPlay内の名前を信じる）
                        if (parts[0] === playerName) {
                            if (parts[1] === '盗塁') gameStats.sb++;
                            if (parts[1] === '生還' || (parts[1] === '進塁' && parts[2] === '本塁へ(生還)')) gameStats.r++;
                        }
                    });
                });
            });

            // 通算成績への加算
            const isNonBattingSub = playerData.sub_type === 'DEF' || playerData.sub_type === 'PR';
            if ((gameStats.played || isNonBattingSub) && !playersAppearedThisGame.has(playerName)) {
                careerStats.games++;
                playersAppearedThisGame.add(playerName);
            }

            for (const key of Object.keys(gameStats)) {
                if (typeof gameStats[key] === 'number') {
                    careerStats[key] = (careerStats[key] || 0) + gameStats[key];
                    // チーム合計にも加算
                    if (['pa', 'ab', 'h', 'hr', 'rbi', 'sb', 'bb', 'hbp', 'sf', 'tb', 'r', 'so'].includes(key)) {
                        teamRecord.tournamentStats[key] = (teamRecord.tournamentStats[key] || 0) + gameStats[key];
                    }
                }
            }

            // Gamelog保存
            playerGameStats[playerName] = gameStats;
            if (!careerStats.gamelogs) careerStats.gamelogs = [];
            const opponentName = teamKey === 'team1' ? match.team2 : match.team1;
            const opponentRank = calculateRank(opponentName, tournamentState);
            
            // 既存のログがあれば更新、なければ追加
            const existingLogIdx = careerStats.gamelogs.findIndex(l => l.matchId === match.id);
            const newLog = {
                matchId: match.id,
                date: match.schedule?.date || '不明',
                round: getRoundNameFromMatchId(match.id),
                opponent: opponentName,
                opponentRank: opponentRank,
                order: playerData.order,
                sub_type: playerData.sub_type,
                stats: gameStats
            };
            
            if (existingLogIdx >= 0) careerStats.gamelogs[existingLogIdx] = newLog;
            else careerStats.gamelogs.push(newLog);
        });

        // match.details に試合ごとのスタッツを保存
        if (!details.playerGameStats) details.playerGameStats = { team1: {}, team2: {} };
        details.playerGameStats[teamKey] = playerGameStats;
        
        // --- B. 投手成績の集計 (簡易入力では入力されないが、枠組みは残す) ---
        // (詳細入力で入力された場合に備えて、既存のロジックを維持)
        // ... (投手集計ロジックは省略。fillPitcherStatsFromBattingなどを使う前提) ...
    }
}

// 通知バナーをクリック -> SNSモーダルを開く
    const trendNotification = document.getElementById('trend-notification');
    if (trendNotification) {
        trendNotification.addEventListener('click', () => {
            const snsModal = document.getElementById('sns-modal');
            snsModal.classList.remove('hidden');
            snsModal.classList.add('flex');
            switchSnsTab('trend'); // デフォルトはトレンドタブ
            trendNotification.classList.remove('show'); // 通知は消す
        });
    }

    // SNSモーダルを閉じる
    const snsModalClose = document.getElementById('sns-modal-close');
    if (snsModalClose) {
        snsModalClose.addEventListener('click', () => {
            const snsModal = document.getElementById('sns-modal');
            snsModal.classList.add('hidden');
            snsModal.classList.remove('flex');
        });
    }

    // タブ切り替え関数をHTML側(onclick属性)から呼べるようにグローバルに登録
    window.switchSnsTab = switchSnsTab;

    // アプリケーション起動
    initializeApp();
</script>

<script>
    mermaid.initialize({ startOnLoad: true });
</script>




<div id="homepage-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[200]">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-6xl max-h-[95vh] flex flex-col">
        <div class="flex-shrink-0 flex justify-between items-center border-b p-4 bg-gray-50 rounded-t-lg">
            <h3 class="text-xl font-bold text-blue-700">283学園 高等学校 - 硬式野球部</h3>
            <button id="homepage-modal-close" class="text-gray-500 hover:text-gray-700 text-3xl">&times;</button>
        </div>
        
        <div id="homepage-scroll-container" class="flex-grow overflow-y-auto" style="font-family: 'Noto Sans JP', sans-serif; background-color: #f4f7fa;">
            
            <header class="homepage-nav">
    <div class="container mx-auto px-6 py-3 flex justify-between items-center">
        <div class="flex items-center gap-2">
            <div class="w-8 h-8 bg-blue-700 rounded flex items-center justify-center text-white font-bold text-lg shadow-sm">2</div>
            <span class="text-xl font-extrabold text-gray-800 tracking-tighter">
                <span class="text-blue-700">283</span>学園
            </span>
        </div>
        <nav class="hidden md:flex space-x-6 text-sm font-bold text-gray-600">
            <a href="#about" class="hover:text-blue-700 transition-colors">チーム</a>
            <a href="#players" class="hover:text-blue-700 transition-colors">選手</a>
            <a href="#roster" class="hover:text-blue-700 transition-colors">部員</a>
            <a href="#results" class="hover:text-blue-700 transition-colors">戦績</a>
            <a href="#access" class="hover:text-blue-700 transition-colors">アクセス</a>
        </nav>
        <div class="md:hidden">
            <button id="mobile-menu-button" class="text-gray-500 hover:text-blue-700 p-1">
                <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg>
            </button>
        </div>
    </div>
    <div id="mobile-menu" class="hidden md:hidden bg-white border-t border-gray-100 absolute w-full shadow-lg">
        <div class="flex flex-col p-2">
            <a href="#about" class="mobile-nav-link block py-3 px-4 text-gray-700 font-bold hover:bg-blue-50 rounded-lg">チーム</a>
            <a href="#players" class="mobile-nav-link block py-3 px-4 text-gray-700 font-bold hover:bg-blue-50 rounded-lg">選手</a>
            <a href="#roster" class="mobile-nav-link block py-3 px-4 text-gray-700 font-bold hover:bg-blue-50 rounded-lg">部員</a>
            <a href="#results" class="mobile-nav-link block py-3 px-4 text-gray-700 font-bold hover:bg-blue-50 rounded-lg">戦績</a>
        </div>
    </div>
</header>

<section class="hero-section">
    <h1 class="text-6xl md:text-8xl font-black text-white tracking-widest mb-2" style="text-shadow: 0 4px 10px rgba(0,0,0,0.5); font-family: 'Yuji Syuku', serif;">強</h1>
    <p class="text-white/90 text-lg md:text-xl font-medium bg-black/30 px-6 py-1 rounded-full backdrop-blur-sm">
        個の技量に頼らず、一人ひとりの力を集めて戦う。
    </p>
</section>

            <div class="container mx-auto px-4 sm:px-6 py-20">
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-12">

                    <main class="lg:col-span-2 space-y-20">

                        <section id="about" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-6">野球部について</h2>
                            <span class="inline-block bg-blue-700 text-white text-sm font-bold px-4 py-1 rounded-full mb-6">昨年度県大会王者・第1シード</span>
                            <div class="space-y-5 text-gray-700 leading-relaxed text-base">
                                <p>昨年度、創部まもなくして夏の県大会初優勝を果たし、第1シード校として今大会に臨みます。しかし、初出場となった昨夏の甲子園では初戦（対 浦和学院 7-9）で敗退。全国の舞台での「一勝」の重みを痛感しました。</p>
                                <p>名将・天井努監督の下、昨年の経験を糧に「県大会連覇」と、その先の「甲子園での一勝」を揺るぎない目標として掲げています。王者としてのプレッシャーをはねのけ、チームスローガンである<strong class="font-bold text-blue-700">『強』</strong>を体現します。</p>
                            </div>
                            <div class="mt-10 bg-gray-50 p-6 rounded-lg border border-gray-200">
                                <h4 class="text-xl font-bold text-gray-800 mb-3">監督・部長あいさつ</h4>
                                <div class="flex items-start space-x-4">
                                    <div class="flex-shrink-0 w-24 h-24 bg-gray-300 rounded-md flex items-center justify-center text-gray-500 text-xs">[監督イメージ]</div>
                                    <div>
                                        <p class="text-gray-700 italic">「我々の強みは、守備の一体感と打線のつながりです。姫川、白瀬を中心とした投手リレーは全国でもピカイチと自負しています。個の力に頼らず、全員の力を集めて『強い』チームとして戦います。」</p>
                                        <p class="text-right font-bold text-gray-800 mt-3">- 283学園野球部 監督　天井 努</p>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <section id="philosophy" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">指導方針・練習内容</h2>
                            <div class="space-y-6 text-gray-700 leading-relaxed">
                                <div>
                                    <h4 class="text-xl font-bold text-blue-700 mb-2">1. ID野球とデータ解析</h4>
                                    <p>天井監督の指導の下、全試合・全練習を映像データ化。専属アナリストが常駐する「データ解析室」にて、選手のフォーム、打球傾向、投球の回転数に至るまでを徹底的に分析。科学的根拠に基づいた「ID野球」がチームの基盤です。</p>
                                </div>
                                <div>
                                    <h4 class="text-xl font-bold text-blue-700 mb-2">2. 「二軍」制度の導入（283学園B）</h4>
                                    <p>部員数100名超に対応するため、他校にはない「二軍（283学園B）」制度を導入。七草はづきコーチの指導の下、Bチームも独自の練習試合を重ね、Aチームと常に入れ替え戦を行う環境を整備。この熾烈な内部競争が、王者としての層の厚さを生み出しています。</p>
                                </div>
                            </div>
                        </section>

                        <section id="players" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">注目選手</h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div class="player-card border p-5 rounded-lg bg-gray-50"><div class="flex justify-between items-baseline"><h5 class="text-xl font-bold text-blue-700">姫川 (3年・投手)</h5><span class="text-xs font-medium bg-red-100 text-red-800 px-2 py-0.5 rounded-full">プロ注目</span></div><p class="text-gray-700 mt-2">投打の中心。MAX151kmの直球とスプリットで圧倒する怪物。高校通算42本塁打。</p></div>
                                <div class="player-card border p-5 rounded-lg bg-gray-50"><h5 class="text-xl font-bold text-blue-700">白瀬 (3年・投手)</h5><p class="text-gray-700 mt-2">絶対的守護神。MAX155kmの伸び上がるストレートが武器。春の静岡高戦で完全試合を達成。</p></div>
                                <div class="player-card border p-5 rounded-lg bg-white"><h5 class="text-xl font-bold text-gray-800">花海 咲 (3年・中堅手)</h5><p class="text-gray-700 mt-2">1年夏からレギュラーの経験豊富なスラッガー。走攻守三拍子揃った攻守の要。</p></div>
                                <div class="player-card border p-5 rounded-lg bg-blue-50 border-blue-200"><div class="flex justify-between items-baseline"><h5 class="text-xl font-bold text-blue-700">花海 佑 (1年・右翼手)</h5><span class="text-xs font-medium bg-blue-100 text-blue-800 px-2 py-0.5 rounded-full">1年生</span></div><p class="text-gray-700 mt-2">1年生のスーパースター。兄・咲との連携も抜群。入学以来、既に通算13本塁打を記録。</p></div>
                            </div>
                        </section>

                        <section id="roster" class="bg-white p-4 md:p-8 rounded-xl shadow-sm border border-gray-200 scroll-mt-24">
    <h2 class="text-xl md:text-2xl font-bold text-gray-800 mb-6 flex items-center">
        <span class="w-1.5 h-6 bg-blue-600 mr-3 rounded-full"></span>部員紹介 (2025年度)
    </h2>
    
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
        <div class="player-profile-card">
            <div class="player-profile-header flex items-baseline justify-between border-b pb-2 mb-2">
                <span class="text-3xl font-black text-blue-900 mr-2">1</span>

                                        <span class="player-profile-name">白瀬</span>
                                        <span class="player-profile-grade">3年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[投]</strong> <strong>[右投/右打]</strong><br>
                                        184cm / 82kg<br>
                                        出身: 東京シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">2</span>
                                        <span class="player-profile-name">有栖川</span>
                                        <span class="player-profile-grade">3年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[捕]</strong> <strong>[右投/左打]</strong><br>
                                        178cm / 78kg<br>
                                        出身: 神奈川ボーイズ
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">3</span>
                                        <span class="player-profile-name">姫川</span>
                                        <span class="player-profile-grade">3年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[投/一]</strong> <strong>[右投/右打]</strong><br>
                                        182cm / 80kg<br>
                                        出身: 大阪シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">4</span>
                                        <span class="player-profile-name">樋口</span>
                                        <span class="player-profile-grade">3年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[二]</strong> <strong>[右投/右打]</strong><br>
                                        170cm / 68kg<br>
                                        出身: 静岡葵中学
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">5</span>
                                        <span class="player-profile-name">八宮</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[三]</strong> <strong>[右投/右打]</strong><br>
                                        175cm / 72kg<br>
                                        出身: 浜松ボーイズ
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">6</span>
                                        <span class="player-profile-name">十王</span>
                                        <span class="player-profile-grade">3年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[遊]</strong> <strong>[右投/左打]</strong><br>
                                        176cm / 70kg<br>
                                        出身: 名古屋ドリームス
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">7</span>
                                        <span class="player-profile-name">芹沢</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[外]</strong> <strong>[右投/両打]</strong><br>
                                        172cm / 69kg<br>
                                        出身: 沼津シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">8</span>
                                        <span class="player-profile-name">花海佑</span>
                                        <span class="player-profile-grade">1年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[外]</strong> <strong>[右投/右打]</strong><br>
                                        177cm / 73kg<br>
                                        出身: 北海道シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">9</span>
                                        <span class="player-profile-name">花海咲</span>
                                        <span class="player-profile-grade">3年<span class="player-profile-captain">(主将)</span></span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[外]</strong> <strong>[左投/左打]</strong><br>
                                        178cm / 75kg<br>
                                        出身: 北海道シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">10</span>
                                        <span class="player-profile-name">黛</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[投]</strong> <strong>[右投/右打]</strong><br>
                                        180cm / 76kg<br>
                                        出身: 富士シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">11</span>
                                        <span class="player-profile-name">市川</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[投]</strong> <strong>[左投/左打]</strong><br>
                                        179cm / 74kg<br>
                                        出身: 静岡蒲原中学
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">12</span>
                                        <span class="player-profile-name">福丸</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[捕]</strong> <strong>[右投/右打]</strong><br>
                                        176cm / 77kg<br>
                                        出身: 焼津リトルシニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">13</span>
                                        <span class="player-profile-name">鈴木</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[一]</strong> <strong>[右投/左打]</strong><br>
                                        181cm / 85kg<br>
                                        出身: 愛知ボーイズ
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">14</span>
                                        <span class="player-profile-name">有村</span>
                                        <span class="player-profile-grade">1年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[内]</strong> <strong>[右投/右打]</strong><br>
                                        173cm / 67kg<br>
                                        出身: 福岡シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">15</span>
                                        <span class="player-profile-name">田中</span>
                                        <span class="player-profile-grade">3年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[内]</strong> <strong>[右投/右打]</strong><br>
                                        174cm / 70kg<br>
                                        出身: 静岡服織中学
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">16</span>
                                        <span class="player-profile-name">大崎</span>
                                        <span class="player-profile-grade">1年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[外]</strong> <strong>[右投/左打]</strong><br>
                                        170cm / 68kg<br>
                                        出身: 三島リトルシニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">17</span>
                                        <span class="player-profile-name">風野</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[内]</strong> <strong>[右投/右打]</strong><br>
                                        169cm / 65kg<br>
                                        出身: 新潟シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">18</span>
                                        <span class="player-profile-name">西城</span>
                                        <span class="player-profile-grade">2年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[投]</strong> <strong>[右投/右打]</strong><br>
                                        183cm / 81kg<br>
                                        出身: 広島ボーイズ
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">19</span>
                                        <span class="player-profile-name">浅倉</span>
                                        <span class="player-profile-grade">1年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[内]</strong> <strong>[右投/右打]</strong><br>
                                        168cm / 64kg<br>
                                        出身: 長崎シニア
                                    </div>
                                </div>
                                <div class="player-profile-card">
                                    <div class="player-profile-header">
                                        <span class="player-profile-number">20</span>
                                        <span class="player-profile-name">杜野</span>
                                        <span class="player-profile-grade">1年</span>
                                    </div>
                                    <div class="player-profile-body">
                                        <strong>[外]</strong> <strong>[左投/左打]</strong><br>
                                        171cm / 67kg<br>
                                        出身: 宮城シニア
                                    </div>
                                </div>
                            </div>
                        </section>
                        
                       <section id="facility" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">施設紹介</h2>
                            <p class="text-gray-700 leading-relaxed mb-6">ナムコグループの全面的な支援により、本校は全国トップクラスの練習環境を誇ります。マップ上の「<span class="font-bold text-blue-700">+</span>」アイコンをクリックして、各施設をご覧ください。</p>
                            
                            <div id="campus-map-container">
                                <img id="campus-map-image" src="https://img.freepik.com/premium-vector/university-campus-map-vector-illustration_147933-461.jpg" alt="283学園 キャンパスマップ">

                                <div class="hotspot" style="top: 60%; left: 25%;" data-id="ground"><span>+</span></div>
                                <div class="hotspot" style="top: 35%; left: 45%;" data-id="dome"><span>+</span></div>
                                <div class="hotspot" style="top: 20%; left: 70%;" data-id="data-lab"><span>+</span></div>
                                
                                <div id="hotspot-popup" class="hotspot-popup hidden">
                                    <button id="hotspot-popup-close-btn" class="hotspot-popup-close">&times;</button>
                                    <img id="hotspot-popup-image" src="" alt="施設写真" class="hotspot-popup-image">
                                    <div class="hotspot-popup-content">
                                        <h4 id="hotspot-popup-title" class="hotspot-popup-title"></h4>
                                        <p id="hotspot-popup-text" class="hotspot-popup-text"></p>
                                    </div>
                                </div>
                            </div>
                        </section>                        
                        <section id="school-song" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">283学園 校歌</h2>
                            <div class="text-center max-w-lg mx-auto">
                                <p class="text-sm text-gray-600">作詞: 天井 努　/　作曲: 283学園音楽科</p>
                                <div class="mt-6"><p class="text-lg leading-relaxed text-gray-800">一、<br>蒼き空 仰ぎ見る<br>我らが学び舎 283学園<br>若き翼（つばさ） 胸に抱き<br>未来（あす）へと羽ばたく 強い意志<br>ああ 輝ける光よ 我らにあれ</p></div>
                                <div class="mt-8"><p class="text-lg leading-relaxed text-gray-800">二、<br>遠州の風 受けながら<br>真理（まこと）を求めん 友と共に<br>鍛えし知恵 磨きし技<br>『強』なる理想を 追い求めて<br>ああ 誇り高き 我らが 283学園</p></div>
                            </div>
                        </section>

                        <section id="results" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                            
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">2025年 選手権静岡大会 (最新の戦績)</h2>
                            <p class="text-gray-700 leading-relaxed mb-6">
                                現在進行中、または終了した最新の大会の戦績です。試合が終了すると、このトーナメント表も更新されます。
                            </p>
                            <div id="current-tournament-bracket-container" class="bracket-wrapper">
                                <p class="text-center text-gray-500">（現在のトーナメント表を読み込み中...）</p>
                            </div>
                            
                            <h2 class="text-3xl font-bold text-gray-900 section-title mb-8 mt-12">2024年 選手権静岡大会 (昨年度)</h2>
                            
                            <p class="text-gray-700 leading-relaxed mb-6">
                                姫川(2年)、花海咲(2年)ら、現3年生が中心となり、創部以来初の「夏の甲子園」出場を果たした大会の全軌跡です。
                            </p>
                            <div class="bracket-wrapper">
                                <div class="tournament-container">
                                    <div class="bracket-half left">
                                        <div class="round r1">
                                            <div class="round-title">1回戦</div>
                                            <div class="matchup"><div class="match"><div class="team winner hp-team-283"><span class="name">283学園</span><span class="score">20</span></div><div class="team loser"><span class="name">新居</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">浜松開誠館</span><span class="score">7</span></div><div class="team loser"><span class="name">初星学園</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">聖隷クリストファー</span><span class="score">10</span></div><div class="team loser"><span class="name">浜松特支</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">日大三島</span><span class="score">8</span></div><div class="team loser"><span class="name">裾野</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">掛川西</span><span class="score">5</span></div><div class="team loser"><span class="name">富士宮北</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">東海大翔洋</span><span class="score">6</span></div><div class="team loser"><span class="name">美城学園</span><span class="score">2</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">藤枝明誠</span><span class="score">11</span></div><div class="team loser"><span class="name">沼津高専</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡学園</span><span class="score">9</span></div><div class="team loser"><span class="name">三島南</span><span class="score">2</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">浜松市立</span><span class="score">7</span></div><div class="team loser"><span class="name">御殿場南</span><span class="score">6</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">磐田東</span><span class="score">4</span></div><div class="team loser"><span class="name">浜松学院</span><span class="score">3</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">焼津水産</span><span class="score">5</span></div><div class="team loser"><span class="name">御殿場西</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">科学技術</span><span class="score">8</span></div><div class="team loser"><span class="name">誠恵</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡</span><span class="score">8</span></div><div class="team loser"><span class="name">小山</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">知徳</span><span class="score">5</span></div><div class="team loser"><span class="name">虎府島総合</span><span class="score">4</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静清</span><span class="score">10</span></div><div class="team loser"><span class="name">富士東</span><span class="score">9</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner hp-team-283"><span>283学園B</span><span class="score">5</span></div><div class="team loser"><span class="name">伊豆伊東</span><span class="score">3</span></div></div></div>
                                        </div>
                                        <div class="round r2">
                                            <div class="round-title">2回戦</div>
                                            <div class="matchup"><div class="match"><div class="team winner hp-team-283"><span class="name">283学園</span><span class="score">11</span></div><div class="team loser"><span class="name">浜松開誠館</span><span class="score">1</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">聖隷クリストファー</span><span class="score">5</span></div><div class="team loser"><span class="name">日大三島</span><span class="score">3</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">掛川西</span><span class="score">4</span></div><div class="team loser"><span class="name">東海大翔洋</span><span class="score">0</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">藤枝明誠</span><span class="score">6</span></div><div class="team loser"><span class="name">静岡学園</span><span class="score">4</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">磐田東</span><span class="score">7</span></div><div class="team loser"><span class="name">浜松市立</span><span class="score">3</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">科学技術</span><span class="score">5</span></div><div class="team loser"><span class="name">焼津水産</span><span class="score">2</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡</span><span class="score">7</span></div><div class="team loser"><span class="name">知徳</span><span class="score">0</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span>静清</span><span class="score">7</span></div><div class="team loser hp-team-283"><span class="name">283学園B</span><span class="score">0</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                        </div>
                                        <div class="round r3">
                                            <div class="round-title">3回戦</div>
                                            <div class="matchup"><div class="match"><div class="team winner hp-team-283"><span class="name">283学園</span><span class="score">10</span></div><div class="team loser"><span class="name">聖隷クリストファー</span><span class="score">2</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">藤枝明誠</span><span class="score">5</span></div><div class="team loser"><span class="name">掛川西</span><span class="score">1</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">科学技術</span><span class="score">3</span></div><div class="team loser"><span class="name">磐田東</span><span class="score">2</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡</span><span class="score">4</span></div><div class="team loser"><span class="name">静清</span><span class="score">3</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                        </div>
                                        <div class="round r4">
                                            <div class="round-title">準々決勝</div>
                                            <div class="matchup"><div class="match"><div class="team winner hp-team-283"><span class="name">283学園</span><span class="score">8</span></div><div class="team loser"><span class="name">藤枝明誠</span><span class="score">3</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡</span><span class="score">7</span></div><div class="team loser"><span class="name">科学技術</span><span class="score">0</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                        </div>
                                        <div class="round r5">
                                            <div class="round-title">準決勝</div>
                                            <div class="matchup"><div class="match"><div class="team winner hp-team-283"><span class="name">283学園</span><span class="score">6</span></div><div class="team loser"><span class="name">静岡</span><span class="score">1</span></div></div><div class="connector-line"></div></div>
                                        </div>
                                    </div>
                                    <div class="bracket-final">
                                        <div class="round-title">決勝</div>
                                        <div class="final-matchup">
                                            <div class="match">
                                                <div class="team winner hp-team-283"><span class="name">283学園</span><span class="score">5</span></div>
                                                <div class="team loser"><span class="name">常葉菊川</span><span class="score">2</span></div>
                                            </div>
                                            <button id="show-boxscore-btn-2024" class="mt-2 w-full text-sm bg-blue-600 text-white font-bold px-4 py-2 rounded hover:bg-blue-700 transition-all">
                                                決勝戦ボックススコア
                                            </button>
                                            </div>
                                        <div class="winner-box">
                                            <h2>🏆 優勝 283学園</h2>
                                        </div>
                                    </div>
                                    <div class="bracket-half right">
                                        <div class="round r1">
                                            <div class="round-title">1回戦</div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span>常葉菊川</span><span class="score">15</span></div><div class="team loser"><span class="name">川根</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">浜松工業</span><span class="score">6</span></div><div class="team loser"><span class="name">島田工業</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">765総合高校</span><span class="score">8</span></div><div class="team loser"><span class="name">袋井</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">常葉橘</span><span class="score">10</span></div><div class="team loser"><span class="name">桐陽</span><span class="score">1</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">駿河総合</span><span class="score">7</span></div><div class="team loser"><span class="name">飛龍</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">加藤学園</span><span class="score">11</span></div><div class="team loser"><span class="name">磐田南</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">伊豆総合</span><span class="score">5</span></div><div class="team loser"><span class="name">富士宮西</span><span class="score">4</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">韮山</span><span class="score">6</span></div><div class="team loser"><span class="name">市立沼津</span><span class="score">3</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">三島北</span><span class="score">10</span></div><div class="team loser"><span class="name">湖西</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">富士市立</span><span class="score">7</span></div><div class="team loser"><span class="name">熱海</span><span class="score">1B</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">オイスカ浜松国際</span><span class="score">4</span></div><div class="team loser"><span class="name">静岡市立</span><span class="score">3</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">浜松商業</span><span class="score">9</span></div><div class="team loser"><span class="name">城南静岡</span><span class="score">2</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡商業</span><span class="score">7</span></div><div class="team loser"><span class="name">浜松南</span><span class="score">0</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">島田</span><span class="score">4</span></div><div class="team loser"><span class="name">伊豆中央</span><span class="score">2</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">沼津城北</span><span class="score">8</span></div><div class="team loser"><span class="name">浜松城北工業</span><span class="score">7</span></div></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">天竜</span><span class="score">5</span></div><div class="team loser"><span class="name">下田</span><span class="score">0</span></div></div></div>
                                        </div>
                                        <div class="round r2">
                                            <div class="round-title">2回戦</div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">常葉菊川</span><span class="score">9</span></div><div class="team loser"><span class="name">浜松工業</span><span class="score">0</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span>常葉橘</span><span class="score">4</span></div><div class="team loser"><span class="name">765総合高校</span><span class="score">3</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">駿河総合</span><span class="score">5</span></div><div class="team loser"><span class="name">加藤学園</span><span class="score">4</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">韮山</span><span class="score">8</span></div><div class="team loser"><span class="name">伊豆総合</span><span class="score">1B</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">三島北</span><span class="score">8</span></div><div class="team loser"><span class="name">富士市立</span><span class="score">1G</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">浜松商業</span><span class="score">6</span></div><div class="team loser"><span class="name">オイスカ浜松国際</span><span class="score">5</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡商業</span><span class="score">10</span></div><div class="team loser"><span class="name">島田</span><span class="score">0</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">天竜</span><span class="score">4</span></div><div class="team loser"><span class="name">沼津城北</span><span class="score">0</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                        </div>
                                        <div class="round r3">
                                            <div class="round-title">3回戦</div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">常葉菊川</span><span class="score">7</span></div><div class="team loser"><span class="name">常葉橘</span><span class="score">0</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span>韮山</span><span class="score">5</span></div><div class="team loser"><span class="name">駿河総合</span><span class="score">2</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">三島北</span><span class="score">2</span></div><div class="team loser"><span class="name">浜松商業</span><span class="score">0</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡商業</span><span class="score">6</span></div><div class="team loser"><span class="name">天竜</span><span class="score">1</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                        </div>
                                        <div class="round r4">
                                            <div class="round-title">準々決勝</div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">常葉菊川</span><span class="score">7</span></div><div class="team loser"><span class="name">韮山</span><span class="score">1</span></div></div><div class="connector-line"></div></div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">静岡商業</span><span class="score">3</span></div><div class="team loser"><span class="name">三島北</span><span class="score">0</span></div></div><div class="connector-line"></div><div class="connector-path"></div></div>
                                        </div>
                                        <div class="round r5">
                                            <div class="round-title">準決勝</div>
                                            <div class="matchup"><div class="match"><div class="team winner"><span class="name">常葉菊川</span><span class="score">4</span></div><div class_name="name">静岡商業</span><span class="score">3</span></div></div><div class="connector-line"></div></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="space-y-6 mt-12">
                            <div><h3 class="text-xl font-bold text-gray-800">2023年（2年生）</h3><hr class="my-2"><p class="text-sm text-gray-600">秋季静岡大会 優勝 / 選手権静岡大会 決勝敗退 (対 765総合 2-3) / 春季静岡大会 決勝敗退 (対 加藤学園 1-2)</p></div>
                            <div><h3 class="text-xl font-bold text-gray-800">2022年（1年生）</h3><hr class="my-2"><p class="text-sm text-gray-600">秋季静岡大会 準決勝敗退 / 選手権静岡大会 準決勝敗退</p></div>
                            <div><h3 class="text-xl font-bold text-gray-800">2021年（創部2年目）</h3><hr class="my-2"><p class="text-sm text-gray-600">秋季静岡大会 準々決勝敗退 / 選手権静岡大会 4回戦敗退</p></div>
                            <div><h3 class="text-xl font-bold text-gray-800">2020年（創部1年目）</h3><hr class="my-2"><p class="text-sm text-gray-600">秋季静岡大会 2回戦敗退 / 選手権静岡大会 2回戦敗退</p></div>
                        </div>
                    </section>

                    <section id="ob-career" class="bg-white p-4 md:p-8 rounded-xl shadow-sm border border-gray-200 scroll-mt-24">
    <h2 class="text-xl md:text-2xl font-bold text-gray-800 mb-6 flex items-center">
        <span class="w-1.5 h-6 bg-blue-600 mr-3 rounded-full"></span>OBの主な進路
    </h2>
    <p class="text-sm text-gray-600 leading-relaxed mb-4">
        創部まもなくながら、卒業生は野球を継続する道を選んでいます。<br>
        <span class="text-xs text-gray-400">※表は横にスクロールできます</span>
    </p>
    
    <div class="table-scroll-wrapper">
        <table class="w-full min-w-[600px] text-left text-sm whitespace-nowrap">
            <thead class="bg-gray-50 border-b">
                <tr>
                    <th class="px-4 py-3 font-semibold text-gray-700">選手名</th>
                    <th class="px-4 py-3 font-semibold text-gray-700">卒業年度</th>
                    <th class="px-4 py-3 font-semibold text-gray-700">ポジション</th>
                    <th class="px-4 py-3 font-semibold text-gray-700">主な進路</th>
                </tr>
            </thead>
            <tbody class="divide-y divide-gray-100">
                <tr class="hover:bg-blue-50">
                    <td class="px-4 py-3 font-medium">高山 翼</td>
                    <td class="px-4 py-3">2025年3月卒</td>
                    <td class="px-4 py-3">投手</td>
                    <td class="px-4 py-3 font-bold text-blue-800">東京六大学リーグ (進学)</td>
                </tr>
                <tr class="hover:bg-blue-50">
                    <td class="px-4 py-3 font-medium">早川 瞬</td>
                    <td class="px-4 py-3">2025年3月卒</td>
                    <td class="px-4 py-3">内野手</td>
                    <td class="px-4 py-3 font-bold text-blue-800">社会人野球 (ナムコG)</td>
                </tr>
                 <tr class="hover:bg-blue-50">
                    <td class="px-4 py-3 font-medium">伊集院 北斗</td>
                    <td class="px-4 py-3">2024年3月卒</td>
                    <td class="px-4 py-3">外野手</td>
                    <td class="px-4 py-3 font-bold text-blue-800">東都大学リーグ (進学)</td>
                </tr>
            </tbody>
        </table>
    </div>
</section>
                    <section id="gallery" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                        <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">ギャラリー</h2>
                        <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                            <a href="https://source.unsplash.com/random/1200x800/?baseball,victory" target="_blank" class="gallery-image aspect-video rounded-lg overflow-hidden shadow-md"><img src="https://source.unsplash.com/random/800x600/?baseball,victory" alt="昨夏 優勝の瞬間" class="w-full h-full object-cover"></a>
                            <a href="https://source.unsplash.com/random/1200x800/?baseball,pitcher" target="_blank" class="gallery-image aspect-video rounded-lg overflow-hidden shadow-md"><img src="https://source.unsplash.com/random/800x600/?baseball,pitcher" alt="姫川の投球フォーム" class="w-full h-full object-cover"></a>
                            <a href="https://source.unsplash.com/random/1200x800/?baseball,stadium" target="_blank" class="gallery-image aspect-video rounded-lg overflow-hidden shadow-md"><img src="https://source.unsplash.com/random/800x600/?baseball,stadium" alt="甲子園での試合風景" class="w-full h-full object-cover"></a>
                            <a href="https://source.unsplash.com/random/1200x800/?baseball,batter" target="_blank" class="gallery-image aspect-video rounded-lg overflow-hidden shadow-md"><img src="https://source.unsplash.com/random/800x600/?baseball,batter" alt="花海佑のバッティング" class="w-full h-full object-cover"></a>
                            <a href="https://source.unsplash.com/random/1200x800/?baseball,practice" target="_blank" class="gallery-image aspect-video rounded-lg overflow-hidden shadow-md"><img src="https://source.unsplash.com/random/800x600/?baseball,practice" alt="室内練習場での打撃練習" class="w-full h-full object-cover"></a>
                            <a href="https://source.unsplash.com/random/1200x800/?baseball,team" target="_blank" class="gallery-image aspect-video rounded-lg overflow-hidden shadow-md"><img src="https://source.unsplash.com/random/800x600/?baseball,team" alt="チーム全員での円陣" class="w-full h-full object-cover"></a>
                        </div>
                    </section>

                    <section id="access" class="bg-white p-8 rounded-xl shadow-xl fade-in-section">
                        <h2 class="text-3xl font-bold text-gray-900 section-title mb-8">アクセス</h2>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                            <div><img src="https://source.unsplash.com/random/800x600/?map" alt="地図" class="w-full h-64 object-cover rounded-lg"></div>
                            <div class="text-gray-700">
                                <h4 class="text-lg font-semibold mb-2">283学園 高等学校</h4>
                                <p class="mb-4">〒430-XXXX 静岡県浜松市（ダミー住所）</p>
                                <h5 class="font-semibold mb-1">電車でお越しの場合</h5>
                                <p class="mb-4">JR「浜松駅」よりバスで約20分、「283学園前」下車すぐ。</p>
                                <h5 class="font-semibold mb-1">お車でお越しの場合</h5>
                                <p>東名高速道路「浜松IC」より約15分。<br>(※来客用駐車場には限りがございます)</p>
                            </div>
                        </div>
                    </section>

                </main>

                <aside id="news" class="lg:col-span-1">
                    <div class="bg-white p-6 rounded-xl shadow-xl sticky top-24">
                        <h3 class="text-xl font-bold text-blue-800 section-title mb-6">お知らせ</h3>
                        
                        <ul id="homepage-dynamic-news-list" class="space-y-4 mb-6 border-b pb-4 hidden">
                            </ul>
                        
                        <ul class="space-y-4">
                            <li><span class="text-sm text-gray-500">2025/11/10</span><p class="font-semibold text-gray-800 hover:text-blue-600 cursor-pointer">文化祭「283フェスティバル」開催のお知らせ</p></li>
                            <li><span class="text-sm text-gray-500">2025/11/05</span><p class="font-semibold text-gray-800 hover:text-blue-600 cursor-pointer">【野球部】夏の選手権大会 組み合わせ決定</p></li>
                            <li><span class="text-sm text-gray-500">2025/11/01</span><p class="font-semibold text-gray-800 hover:text-blue-600 cursor-pointer">【野球部】春季大会優勝、第1シード決定！</p></li>
                            <li><span class="text-sm text-gray-500">2025/10/28</span><p class="font-semibold text-gray-800 hover:text-blue-600 cursor-pointer">【野球部】1年生・花海佑 練習試合で2HR</p></li>
                            <li><span class="text-sm text-gray-500">2025/10/20</span><p class="font-semibold text-gray-800 hover:text-blue-600 cursor-pointer">オープンキャンパスの申し込みを開始しました。</p></li>
                        </ul>
                    </div>
                </aside>

            </div>
        </div>

        <footer class="homepage-footer">
    <div class="container mx-auto px-6 text-center">
        <div class="flex flex-col md:flex-row justify-center items-center gap-4 mb-4">
            <div class="flex items-center gap-2">
                 <div class="w-6 h-6 bg-gray-400 rounded flex items-center justify-center text-white font-bold text-xs">2</div>
                 <p class="font-bold text-lg text-gray-700">283学園 高等学校</p>
            </div>
            <span class="hidden md:inline text-gray-300">|</span>
            <p class="text-sm text-gray-500">硬式野球部 公式サイト</p>
        </div>
        
        <div class="flex justify-center gap-6 mb-4 text-xs font-medium text-gray-400">
            <a href="#" class="hover:text-blue-600 transition">学校トップ</a>
            <a href="#" class="hover:text-blue-600 transition">入試情報</a>
            <a href="#" class="hover:text-blue-600 transition">お問い合わせ</a>
        </div>

        <p class="text-[10px] text-gray-400">
            &copy; 2025 Tsubasa Gakuen High School. All rights reserved. Powered by Namco Group
        </p>
    </div>
</footer>
 </div>
        </div>
 </div>
        



<div id="boxscore-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 modal-hidden items-center justify-center z-[160]">
    <div class="bg-white p-4 md:p-6 rounded-lg shadow-xl w-full max-w-6xl max-h-[95vh] flex flex-col">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 id="boxscore-modal-title" class="text-xl font-bold text-gray-800">ボックススコア</h3>
            <button id="boxscore-modal-close" class="text-gray-400 hover:text-gray-600">&times;</button>
        </div>
        <div id="boxscore-modal-body" class="overflow-y-auto flex-grow">
            <div class="loader text-center py-16">ボックススコアを読み込み中...</div>
        </div>
    </div>
</div>

<div id="scorecard-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[180]">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-6xl max-h-[95vh] flex flex-col">
        
        <div id="scorecard-header" class="flex-shrink-0 flex justify-between items-center border-b p-3 md:p-4 bg-gray-800 text-white rounded-t-lg">
            <div class="flex items-center">
                <span id="scorecard-inning" class="text-xl md:text-3xl font-bold mr-3">1回表</span>
                <span id="scorecard-at-bat" class="text-sm md:text-lg">
                    打者: <span id="scorecard-batter-name" class="font-semibold">---</span>
                </span>
            </div>
            <div class="flex items-center space-x-3 md:space-x-4">
                <div id="scorecard-outs" class="text-lg md:text-xl font-semibold">
                    <span class="text-gray-400">●</span> <span class="text-gray-400">●</span> <span class="text-gray-400">●</span>
                </div>
                <div id="scorecard-teams" class="text-right">
                    <div id="scorecard-team1" class="text-sm md:text-base font-semibold">TEAM A: 0</div>
                    <div id="scorecard-team2" class="text-sm md:text-base font-semibold">TEAM B: 0</div>
                </div>
            </div>
        </div>

        <div class="scorecard-grid flex-grow overflow-y-auto bg-gray-100">

            <div id="baseball-diamond-container" class="flex items-center justify-center p-4">
                <div class="baseball-diamond">
                    <div id="base-1b" class="base"></div>
                    <div id="base-2b" class="base"></div>
                    <div id="base-3b" class="base"></div>
                    <div id="base-home" class="base"></div>
                    <div id="pitchers-mound"></div>
                    
                    <div id="pos-p" class="direction-hotspot" data-direction="投">投</div>
                    <div id="pos-c" class="direction-hotspot" data-direction="捕">捕</div>
                    <div id="pos-1b" class="direction-hotspot" data-direction="一">一</div>
                    <div id="pos-2b" class="direction-hotspot" data-direction="二">二</div>
                    <div id="pos-3b" class="direction-hotspot" data-direction="三">三</div>
                    <div id="pos-ss" class="direction-hotspot" data-direction="遊">遊</div>
                    <div id="pos-lf" class="direction-hotspot" data-direction="左">左</div>
                    <div id="pos-cf" class="direction-hotspot" data-direction="中">中</div>
                    <div id="pos-rf" class="direction-hotspot" data-direction="右">右</div>
                </div>
            </div>

           <div id="scorecard-actions" class="p-2 md:p-4">
                
                <div id="scorecard-result-panel">
                    <h4 class="font-bold mb-2 text-gray-700">STEP 1: 打席結果</h4>
                    <div class="grid grid-cols-3 gap-2">
                        <button class="result-btn result-btn-hit" data-action="hit-1b">[ 1B ] ヒット</button>
                        <button class="result-btn result-btn-hit" data-action="hit-2b">[ 2B ] 二塁打</button>
                        <button class="result-btn result-btn-hit" data-action="hit-3b">[ 3B ] 三塁打</button>
                        <button class="result-btn result-btn-hit" data-action="hit-hr">[ HR ] 本塁打</button>
                        <button class="result-btn result-btn-walk" data-action="walk-bb">[ BB ] 四球</button>
                        <button class="result-btn result-btn-walk" data-action="walk-hbp">[ HBP ] 死球</button>
                        <button class="result-btn result-btn-out" data-action="out-k">[ K ] 三振</button>
                        <button class="result-btn result-btn-out" data-action="out-go">[ GO ] ゴロ</button>
                        <button class="result-btn result-btn-out" data-action="out-fo">[ FO ] フライ</button>
                        <button class="result-btn result-btn-out" data-action="out-dp">[ DP ] 併殺</button>
                        <button class="result-btn result-btn-out" data-action="out-sac-b">[ SH ] 犠打</button>
                        <button class="result-btn result-btn-out" data-action="out-sac-f">[ SF ] 犠飛</button>
                        <button class="result-btn result-btn-other" data-action="other-error">[ E ] エラー</button>
                        <button class="result-btn result-btn-other" data-action="other-fc">[ FC ] 野選</button>
                    </div>
                </div>

                <div id="scorecard-rbi-panel" class="hidden">
                    <h4 class="font-bold mb-2 text-green-700">STEP 3: 打点/得点</h4>
                    <div class="grid grid-cols-3 gap-2">
                        <button class="rbi-btn" data-rbi="0">[ 0点 ]</button>
                        <button class="rbi-btn" data-rbi="1">[ 1点 ]</button>
                        <button class="rbi-btn" data-rbi="2">[ 2点 ]</button>
                        <button class="rbi-btn" data-rbi="3">[ 3点 ]</button>
                        <button class="rbi-btn" data-rbi="4">[ 4点 ]</button>
                    </div>
                </div>

                <h4 class="font-bold mt-4 mb-2 text-gray-700">走塁・その他</h4>
                <div class="grid grid-cols-3 gap-2">
                    <button class="result-btn result-btn-hit" data-action="run-sb">[ SB ] 盗塁</button>
                    <button class="result-btn result-btn-out" data-action="run-cs">[ CS ] 盗塁死</button>
                    <button class="result-btn result-btn-out" data-action="run-other-out">[ OUT ] 走塁死</button>
                </div>
            </div>

            <div id="scorecard-log" class="p-2 md:p-4">
                <h4 class="font-bold mb-2 text-gray-700">簡易ログ</h4>
                <div id="scorecard-log-content" class="h-24 md:h-full w-full bg-gray-200 rounded p-2 text-xs overflow-y-auto font-mono">
                    (ここにプレーが記録されます)
                </div>
            </div>

        </div>

        <div class="flex-shrink-0 flex justify-between items-center border-t p-4 bg-gray-50 rounded-b-lg">
            <button id="scorecard-undo-btn" class="bg-yellow-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-yellow-600">
                1プレー戻す
            </button>
            <div>
                <button id="scorecard-save-btn" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 mr-4">
                    保存して閉じる
                </button>
                <button id="scorecard-close-btn" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-400">
                    キャンセル
                </button>
            </div>
        </div>
    </div>
</div>

<div id="pre-game-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden flex items-center justify-center z-[200]">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-2xl max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h3 id="pre-game-title" class="text-xl font-bold">試合前 応援コメント</h3>
                <button id="pre-game-modal-close" class="text-gray-400 hover:text-gray-600">&times;</button>
            </div>
            
            <div class="flex border-b mb-4">
                <button id="pre-game-tab-team1" class="pre-game-team-tab py-2 px-4 font-semibold text-gray-500 border-b-2 border-transparent" data-team-key="team1">
                    （チーム1）
                </button>
                <button id="pre-game-tab-team2" class="pre-game-team-tab py-2 px-4 font-semibold text-gray-500 border-b-2 border-transparent" data-team-key="team2">
                    （チーム2）
                </button>
            </div>
            <div id="pre-game-body" class="overflow-y-auto space-y-3 p-2 bg-gray-50 rounded min-h-[200px]">
                <p class="text-gray-500 text-center p-8">↑ 見たいチームの応援席タブをクリックしてください ↑</p>
            </div>
        </div>
    </div>

<div id="substitution-modal" class="fixed inset-0 bg-gray-900 bg-opacity-70 hidden items-center justify-center z-[150]">

    <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg">
        <h3 class="text-xl font-bold mb-4 border-b pb-3">守備交代</h3>
        <div class="space-y-4">
            <div>
                <label class="block text-sm font-medium text-gray-700">選手名</label>
                <input type="text" id="sub-modal-player-name" class="w-full bg-gray-100 p-2 border rounded" readonly>
            </div>
            
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label for="sub-modal-inning" class="block text-sm font-medium text-gray-700">イニング</label>
                    <input type="number" id="sub-modal-inning" value="1" min="1" max="20" class="w-full p-2 border rounded">
                </div>
                <div>
                    <label for="sub-modal-top-bottom" class="block text-sm font-medium text-gray-700">表 / 裏</label>
                    <select id="sub-modal-top-bottom" class="w-full p-2 border rounded bg-white">
                        <option value="表">表</option>
                        <option value="裏">裏</option>
                    </select>
                </div>
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-700">交代タイミング</label>
                <div class="flex gap-4 mt-1">
                    <label><input type="radio" name="sub-timing" id="sub-modal-timing-start" value="start" checked> イニング開始時</label>
                    <label><input type="radio" name="sub-timing" id="sub-modal-timing-mid" value="mid"> イニング途中</label>
                </div>
            </div>

            <div id="sub-modal-mid-inning-details" class="hidden space-y-3 p-3 bg-gray-50 rounded border">
                <div>
                    <label for="sub-modal-outs" class="block text-sm font-medium text-gray-700">アウトカウント</label>
                    <select id="sub-modal-outs" class="w-full p-2 border rounded bg-white">
                        <option value="0">0アウト</option>
                        <option value="1">1アウト</option>
                        <option value="2">2アウト</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">ランナー状況</label>
                    <div class="flex gap-4 mt-1">
                        <label><input type="checkbox" id="sub-modal-runner1"> 1塁</label>
                        <label><input type="checkbox" id="sub-modal-runner2"> 2塁</label>
                        <label><input type="checkbox" id="sub-modal-runner3"> 3塁</label>
                    </div>
                </div>
            </div>
            <div>
                <label for="sub-modal-new-pos" class="block text-sm font-medium text-gray-700">新しい守備位置</label>
                <select id="sub-modal-new-pos" class="w-full p-2 border rounded bg-white">
                    <option value="">- 選択 -</option>
                    <option value="投">投手 (投)</option>
                    <option value="捕">捕手 (捕)</option>
                    <option value="一">一塁手 (一)</option>
                    <option value="二">二塁手 (二)</option>
                    <option value="三">三塁手 (三)</option>
                    <option value="遊">遊撃手 (遊)</option>
                    <option value="左">左翼手 (左)</option>
                    <option value="中">中堅手 (中)</option>
                    <option value="右">右翼手 (右)</option>
                </select>
            </div>
        </div>

        <div class="mt-6 text-center border-t pt-4">
            <button id="sub-modal-save" class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 mr-4">
                交代を記録
            </button>
            <button id="sub-modal-cancel" class="bg-gray-300 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-400">
                キャンセル
            </button>
        </div>
    </div>
</div>


<div id="skip-newspaper-modal" class="newspaper-modal-backdrop hidden">
    <div class="skip-newspaper-container">
        <div class="skip-newspaper-header">
            <span class="skip-newspaper-logo">静岡 熱闘新聞</span>
            <h1 class="skip-newspaper-title" id="skip-newspaper-top-title">白熱の戦い、静岡を席巻</h1>
            <p id="skip-newspaper-date" class="skip-newspaper-date">2025年7月15日 発行</p>
        </div>
        
        <div id="skip-newspaper-body" class="skip-newspaper-body">
            <div class="skip-newspaper-main-headline">
                波乱続出
            </div>
            
            <div class="skip-newspaper-main-article">
                <div class="skip-newspaper-main-image">
                    写真：熱戦の瞬間
                </div>
                <p class="skip-newspaper-image-caption">激闘の末、勝利を掴んだ選手たちの雄姿</p>
                <div class="skip-newspaper-main-body">
                    <h4>激戦を制し、次なる舞台へ</h4>
                    <p>本日行われたラウンドでは、各地で手に汗握る激戦が繰り広げられた。強豪校が順当に勝ち上がる中、思わぬ番狂わせも発生。選手たちの熱い思いが詰まったプレーに、観衆は惜しみない拍手を送った。特に注目されたのは、優勝候補の一角が敗れる波乱の一戦。勝利したチームは、持ち前の粘り強さを発揮し、接戦をものにした。</p>
                    <p>この結果、次ラウンドへの進出を決めたチームは、さらなる高みを目指すことになる。敗れたチームもまた、その健闘を称えられ、来年への雪辱を誓った。夏の甲子園を目指す戦いは、ますます熱気を帯びてきている。</p>
                </div>
            </div>

            <div class="skip-newspaper-side-article right">
                <h3 class="skip-newspaper-side-headline">今日の注目選手</h3>
                <div class="skip-newspaper-main-image" style="height: 120px;">
                    写真：注目の投手
                </div>
                <p class="skip-newspaper-image-caption">躍動するエースの投球</p>
                <div class="skip-newspaper-side-body">
                    <p>〇〇高校のエース、田中選手は本日も圧巻のピッチングを披露。粘る相手打線を完璧に抑え込み、チームを勝利に導いた。</p>
                    <p>彼の今大会での活躍は目覚ましく、次戦での投球にも大きな期待が寄せられている。</p>
                </div>
            </div>

            <div class="skip-newspaper-side-article left">
                <h3 class="skip-newspaper-side-headline">波乱の舞台裏</h3>
                <div class="skip-newspaper-side-body">
                    <p>優勝候補の一角がまさかの敗退を喫した試合では、試合巧者の相手チームが見事な采配で勝利を手繰り寄せた。序盤からリードを許す苦しい展開ながら、中盤の集中打で逆転。守備陣も堅実なプレーで流れを渡さなかった。</p>
                    <p>この結果は、高校野球における「何が起こるかわからない」という醍醐味を改めて示すものとなった。</p>
                </div>
            </div>

            <div class="skip-newspaper-results-section">
                <h2 id="skip-newspaper-results-title">第〇回戦 全試合結果</h2>
                <div id="skip-newspaper-match-grid" class="skip-newspaper-match-grid">
                    </div>
            </div>
        </div>
        
        <div class="skip-newspaper-footer">
            <button id="skip-newspaper-close-btn" class="bg-gray-500 text-white font-bold py-1.5 px-5 rounded-md hover:bg-gray-600 text-sm">
                閉じる
            </button>
            <span class="ml-4">© 2025 静岡 熱闘新聞 全著作権所有</span>
        </div>
    </div>
</div>

    </body>
</html>